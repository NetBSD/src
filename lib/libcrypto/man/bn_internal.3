.rn '' }`
'''
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH bn_internal 3 "0.9.5a" "22/Jul/2000" "OpenSSL"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
bn_mul_words, bn_mul_add_words, bn_sqr_words, bn_div_words,
bn_add_words, bn_sub_words, bn_mul_comba4, bn_mul_comba8,
bn_sqr_comba4, bn_sqr_comba8, bn_cmp_words, bn_mul_normal,
bn_mul_low_normal, bn_mul_recursive, bn_mul_part_recursive,
bn_mul_low_recursive, bn_mul_high, bn_sqr_normal, bn_sqr_recursive,
bn_expand, bn_wexpand, bn_expand2, bn_fix_top, bn_check_top,
bn_print, bn_dump, bn_set_max, bn_set_high, bn_set_low \- BIGNUM
library internal functions
.SH "LIBRARY"
libcrypto, -lcrypto
.SH "SYNOPSIS"
.PP
.Vb 9
\& BN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w);
\& BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num,
\&   BN_ULONG w);
\& void     bn_sqr_words(BN_ULONG *rp, BN_ULONG *ap, int num);
\& BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d);
\& BN_ULONG bn_add_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
\&   int num);
\& BN_ULONG bn_sub_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
\&   int num);
.Ve
.Vb 4
\& void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
\& void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
\& void bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a);
\& void bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a);
.Ve
.Vb 1
\& int bn_cmp_words(BN_ULONG *a, BN_ULONG *b, int n);
.Ve
.Vb 11
\& void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b,
\&   int nb);
\& void bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n);
\& void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,
\&   BN_ULONG *tmp);
\& void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
\&   int tn, int n, BN_ULONG *tmp);
\& void bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
\&   int n2, BN_ULONG *tmp);
\& void bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l,
\&   int n2, BN_ULONG *tmp);
.Ve
.Vb 2
\& void bn_sqr_normal(BN_ULONG *r, BN_ULONG *a, int n, BN_ULONG *tmp);
\& void bn_sqr_recursive(BN_ULONG *r, BN_ULONG *a, int n2, BN_ULONG *tmp);
.Ve
.Vb 3
\& void mul(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
\& void mul_add(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
\& void sqr(BN_ULONG r0, BN_ULONG r1, BN_ULONG a);
.Ve
.Vb 4
\& BIGNUM *bn_expand(BIGNUM *a, int bits);
\& BIGNUM *bn_wexpand(BIGNUM *a, int n);
\& BIGNUM *bn_expand2(BIGNUM *a, int n);
\& void bn_fix_top(BIGNUM *a);
.Ve
.Vb 6
\& void bn_check_top(BIGNUM *a);
\& void bn_print(BIGNUM *a);
\& void bn_dump(BN_ULONG *d, int n);
\& void bn_set_max(BIGNUM *a);
\& void bn_set_high(BIGNUM *r, BIGNUM *a, int n);
\& void bn_set_low(BIGNUM *r, BIGNUM *a, int n);
.Ve
.SH "DESCRIPTION"
This page documents the internal functions used by the OpenSSL
\fBBIGNUM\fR implementation. They are described here to facilitate
debugging and extending the library. They are \fInot\fR to be used by
applications.
.Sh "The \s-1BIGNUM\s0 structure"
.PP
.Vb 7
\& typedef struct bignum_st
\&        {
\&        int top;      /* index of last used d (most significant word) */
\&        BN_ULONG *d;  /* pointer to an array of 'BITS2' bit chunks */
\&        int max;      /* size of the d array */
\&        int neg;      /* sign */
\&        } BIGNUM;
.Ve
The big number is stored in \fBd\fR, a \fImalloc()\fRed array of \fB\s-1BN_ULONG\s0\fRs,
least significant first. A \fB\s-1BN_ULONG\s0\fR can be either 16, 32 or 64 bits
in size (\fB\s-1BITS2\s0\fR), depending on the \*(L'number of bits\*(R' specified in
\f(CWopenssl/bn.h\fR.
.PP
\fBmax\fR is the size of the \fBd\fR array that has been allocated.  \fBtop\fR
is the \*(L'last\*(R' entry being used, so for a value of 4, bn.d[0]=4 and
bn.top=1.  \fBneg\fR is 1 if the number is negative.  When a \fB\s-1BIGNUM\s0\fR is
\fB0\fR, the \fBd\fR field can be \fB\s-1NULL\s0\fR and \fBtop\fR == \fB0\fR.
.PP
Various routines in this library require the use of temporary
\fB\s-1BIGNUM\s0\fR variables during their execution.  Since dynamic memory
allocation to create \fB\s-1BIGNUM\s0\fRs is rather expensive when used in
conjunction with repeated subroutine calls, the \fB\s-1BN_CTX\s0\fR structure is
used.  This structure contains \fB\s-1BN_CTX_NUM\s0\fR \fB\s-1BIGNUM\s0\fRs, see
the \fIBN_CTX_start(3)|BN_CTX_start(3)\fR manpage.
.Sh "Low-level arithmetic operations"
These functions are implemented in C and for several platforms in
assembly language:
.PP
\fIbn_mul_words\fR\|(\fBrp\fR, \fBap\fR, \fBnum\fR, \fBw\fR) operates on the \fBnum\fR word
arrays \fBrp\fR and \fBap\fR.  It computes \fBap\fR * \fBw\fR, places the result
in \fBrp\fR, and returns the high word (carry).
.PP
\fIbn_mul_add_words\fR\|(\fBrp\fR, \fBap\fR, \fBnum\fR, \fBw\fR) operates on the \fBnum\fR
word arrays \fBrp\fR and \fBap\fR.  It computes \fBap\fR * \fBw\fR + \fBrp\fR, places
the result in \fBrp\fR, and returns the high word (carry).
.PP
\fIbn_sqr_words\fR\|(\fBrp\fR, \fBap\fR, \fBn\fR) operates on the \fBnum\fR word array
\fBap\fR and the 2*\fBnum\fR word array \fBap\fR.  It computes \fBap\fR * \fBap\fR
word-wise, and places the low and high bytes of the result in \fBrp\fR.
.PP
\fIbn_div_words\fR\|(\fBh\fR, \fBl\fR, \fBd\fR) divides the two word number (\fBh\fR,\fBl\fR)
by \fBd\fR and returns the result.
.PP
\fIbn_add_words\fR\|(\fBrp\fR, \fBap\fR, \fBbp\fR, \fBnum\fR) operates on the \fBnum\fR word
arrays \fBap\fR, \fBbp\fR and \fBrp\fR.  It computes \fBap\fR + \fBbp\fR, places the
result in \fBrp\fR, and returns the high word (carry).
.PP
\fIbn_sub_words\fR\|(\fBrp\fR, \fBap\fR, \fBbp\fR, \fBnum\fR) operates on the \fBnum\fR word
arrays \fBap\fR, \fBbp\fR and \fBrp\fR.  It computes \fBap\fR \- \fBbp\fR, places the
result in \fBrp\fR, and returns the carry (1 if \fBbp\fR > \fBap\fR, 0
otherwise).
.PP
\fIbn_mul_comba4\fR\|(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 4 word arrays \fBa\fR and
\fBb\fR and the 8 word array \fBr\fR.  It computes \fBa\fR*\fBb\fR and places the
result in \fBr\fR.
.PP
\fIbn_mul_comba8\fR\|(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 8 word arrays \fBa\fR and
\fBb\fR and the 16 word array \fBr\fR.  It computes \fBa\fR*\fBb\fR and places the
result in \fBr\fR.
.PP
\fIbn_sqr_comba4\fR\|(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 4 word arrays \fBa\fR and
\fBb\fR and the 8 word array \fBr\fR.
.PP
\fIbn_sqr_comba8\fR\|(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 8 word arrays \fBa\fR and
\fBb\fR and the 16 word array \fBr\fR.
.PP
The following functions are implemented in C:
.PP
\fIbn_cmp_words\fR\|(\fBa\fR, \fBb\fR, \fBn\fR) operates on the \fBn\fR word arrays \fBa\fR
and \fBb\fR.  It returns 1, 0 and \-1 if \fBa\fR is greater than, equal and
less than \fBb\fR.
.PP
\fIbn_mul_normal\fR\|(\fBr\fR, \fBa\fR, \fBna\fR, \fBb\fR, \fBnb\fR) operates on the \fBna\fR
word array \fBa\fR, the \fBnb\fR word array \fBb\fR and the \fBna\fR+\fBnb\fR word
array \fBr\fR.  It computes \fBa\fR*\fBb\fR and places the result in \fBr\fR.
.PP
\fIbn_mul_low_normal\fR\|(\fBr\fR, \fBa\fR, \fBb\fR, \fBn\fR) operates on the \fBn\fR word
arrays \fBr\fR, \fBa\fR und \fBb\fR.  It computes the \fBn\fR low words of
\fBa\fR*\fBb\fR and places the result in \fBr\fR.
.PP
\fIbn_mul_recursive\fR\|(\fBr\fR, \fBa\fR, \fBb\fR, \fBn2\fR, \fBt\fR) operates on the \fBn2\fR
word arrays \fBa\fR and \fBb\fR and the 2*\fBn2\fR word arrays \fBr\fR and \fBt\fR.
\fBn2\fR must be a power of 2.  It computes \fBa\fR*\fBb\fR and places the
result in \fBr\fR.
.PP
\fIbn_mul_part_recursive\fR\|(\fBr\fR, \fBa\fR, \fBb\fR, \fBtn\fR, \fBn\fR, \fBtmp\fR) operates
on the \fBn\fR+\fBtn\fR word arrays \fBa\fR and \fBb\fR and the 4*\fBn\fR word arrays
\fBr\fR and \fBtmp\fR.
.PP
\fIbn_mul_low_recursive\fR\|(\fBr\fR, \fBa\fR, \fBb\fR, \fBn2\fR, \fBtmp\fR) operates on the
\fBn2\fR word arrays \fBr\fR and \fBtmp\fR and the \fBn2\fR/2 word arrays \fBa\fR
and \fBb\fR.
.PP
\fIbn_mul_high\fR\|(\fBr\fR, \fBa\fR, \fBb\fR, \fBl\fR, \fBn2\fR, \fBtmp\fR) operates on the
\fBn2\fR word arrays \fBr\fR, \fBa\fR, \fBb\fR and \fBl\fR (?) and the 3*\fBn2\fR word
array \fBtmp\fR.
.PP
\fIBN_mul()\fR calls \fIbn_mul_normal()\fR, or an optimized implementation if the
factors have the same size: \fIbn_mul_comba8()\fR is used if they are 8
words long, \fIbn_mul_recursive()\fR if they are larger than
\fB\s-1BN_MULL_SIZE_NORMAL\s0\fR and the size is an exact multiple of the word
size, and \fIbn_mul_part_recursive()\fR for others that are larger than
\fB\s-1BN_MULL_SIZE_NORMAL\s0\fR.
.PP
\fIbn_sqr_normal\fR\|(\fBr\fR, \fBa\fR, \fBn\fR, \fBtmp\fR) operates on the \fBn\fR word array
\fBa\fR and the 2*\fBn\fR word arrays \fBtmp\fR and \fBr\fR.
.PP
The implementations use the following macros which, depending on the
architecture, may use \*(L"long long\*(R" C operations or inline assembler.
They are defined in \f(CWbn_lcl.h\fR.
.PP
\fImul\fR\|(\fBr\fR, \fBa\fR, \fBw\fR, \fBc\fR) computes \fBw\fR*\fBa\fR+\fBc\fR and places the
low word of the result in \fBr\fR and the high word in \fBc\fR.
.PP
\fImul_add\fR\|(\fBr\fR, \fBa\fR, \fBw\fR, \fBc\fR) computes \fBw\fR*\fBa\fR+\fBr\fR+\fBc\fR and
places the low word of the result in \fBr\fR and the high word in \fBc\fR.
.PP
\fIsqr\fR\|(\fBr0\fR, \fBr1\fR, \fBa\fR) computes \fBa\fR*\fBa\fR and places the low word
of the result in \fBr0\fR and the high word in \fBr1\fR.
.Sh "Size changes"
\fIbn_expand()\fR ensures that \fBb\fR has enough space for a \fBbits\fR bit
number.  \fIbn_wexpand()\fR ensures that \fBb\fR has enough space for an
\fBn\fR word number.  If the number has to be expanded, both macros
call \fIbn_expand2()\fR, which allocates a new \fBd\fR array and copies the
data.  They return \fB\s-1NULL\s0\fR on error, \fBb\fR otherwise.
.PP
The \fIbn_fix_top()\fR macro reduces \fBa->top\fR to point to the most
significant non-zero word when \fBa\fR has shrunk.
.Sh "Debugging"
\fIbn_check_top()\fR verifies that \f(CW((a)->top >= 0 && (a)->top
<= (a)->max)\fR.  A violation will cause the program to abort.
.PP
\fIbn_print()\fR prints \fBa\fR to stderr. \fIbn_dump()\fR prints \fBn\fR words at \fBd\fR
(in reverse order, i.e. most significant word first) to stderr.
.PP
\fIbn_set_max()\fR makes \fBa\fR a static number with a \fBmax\fR of its current size.
This is used by \fIbn_set_low()\fR and \fIbn_set_high()\fR to make \fBr\fR a read-only
\fB\s-1BIGNUM\s0\fR that contains the \fBn\fR low or high words of \fBa\fR.
.PP
If \fB\s-1BN_DEBUG\s0\fR is not defined, \fIbn_check_top()\fR, \fIbn_print()\fR, \fIbn_dump()\fR
and \fIbn_set_max()\fR are defined as empty macros.
.SH "SEE ALSO"
the \fIbn(3)|bn(3)\fR manpage

.rn }` ''
.IX Title "bn_internal 3"
.IX Name "bn_mul_words, bn_mul_add_words, bn_sqr_words, bn_div_words,
bn_add_words, bn_sub_words, bn_mul_comba4, bn_mul_comba8,
bn_sqr_comba4, bn_sqr_comba8, bn_cmp_words, bn_mul_normal,
bn_mul_low_normal, bn_mul_recursive, bn_mul_part_recursive,
bn_mul_low_recursive, bn_mul_high, bn_sqr_normal, bn_sqr_recursive,
bn_expand, bn_wexpand, bn_expand2, bn_fix_top, bn_check_top,
bn_print, bn_dump, bn_set_max, bn_set_high, bn_set_low - BIGNUM
library internal functions"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Subsection "The \s-1BIGNUM\s0 structure"

.IX Subsection "Low-level arithmetic operations"

.IX Subsection "Size changes"

.IX Subsection "Debugging"

.IX Header "SEE ALSO"

