.rn '' }`
'''
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH ENC 1 "0.9.5a" "22/Jul/2000" "OpenSSL"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
enc \- symmetric cipher routines
.SH "SYNOPSIS"
\fBopenssl enc \-ciphername\fR
[\fB\-in filename\fR]
[\fB\-out filename\fR]
[\fB\-pass arg\fR]
[\fB\-e\fR]
[\fB\-d\fR]
[\fB\-a\fR]
[\fB\-A\fR]
[\fB\-k password\fR]
[\fB\-kfile filename\fR]
[\fB\-K key\fR]
[\fB\-iv IV\fR]
[\fB\-p\fR]
[\fB\-P\fR]
[\fB\-bufsize number\fR]
[\fB\-debug\fR]
.SH "DESCRIPTION"
The symmetric cipher commands allow data to be encrypted or decrypted
using various block and stream ciphers using keys based on passwords
or explicitly provided. Base64 encoding or decoding can also be performed
either by itself or in addition to the encryption or decryption.
.SH "OPTIONS"
.Ip "\fB\-in filename\fR" 4
the input filename, standard input by default.
.Ip "\fB\-out filename\fR" 4
the output filename, standard output by default.
.Ip "\fB\-pass arg\fR" 4
the password source. For more information about the format of \fBarg\fR
see the \fB\s-1PASS\s0 \s-1PHRASE\s0 \s-1ARGUMENTS\s0\fR section in the \fIopenssl(1)|openssl(1)\fR manpage.
.Ip "\fB\-salt\fR" 4
use a salt in the key derivation routines. This option should \fB\s-1ALWAYS\s0\fR
be used unless compatibility with previous versions of OpenSSL or SSLeay
is required. This option is only present on OpenSSL versions 0.9.5 or
above.
.Ip "\fB\-nosalt\fR" 4
don't use a salt in the key derivation routines. This is the default for
compatibility with previous versions of OpenSSL and SSLeay.
.Ip "\fB\-e\fR" 4
encrypt the input data: this is the default.
.Ip "\fB\-d\fR" 4
decrypt the input data.
.Ip "\fB\-a\fR" 4
base64 process the data. This means that if encryption is taking place
the data is base64 encoded after encryption. If decryption is set then
the input data is base64 decoded before being decrypted.
.Ip "\fB\-A\fR" 4
if the \fB\-a\fR option is set then base64 process the data on one line.
.Ip "\fB\-k password\fR" 4
the password to derive the key from. This is for compatibility with previous
versions of OpenSSL. Superseded by the \fB\-pass\fR argument.
.Ip "\fB\-kfile filename\fR" 4
read the password to derive the key from the first line of \fBfilename\fR.
This is for computability with previous versions of OpenSSL. Superseded by
the \fB\-pass\fR argument.
.Ip "\fB\-S salt\fR" 4
the actual salt to use: this must be represented as a string comprised only
of hex digits.
.Ip "\fB\-K key\fR" 4
the actual key to use: this must be represented as a string comprised only
of hex digits.
.Ip "\fB\-iv \s-1IV\s0\fR" 4
the actual \s-1IV\s0 to use: this must be represented as a string comprised only
of hex digits.
.Ip "\fB\-p\fR" 4
print out the key and \s-1IV\s0 used.
.Ip "\fB\-P\fR" 4
print out the key and \s-1IV\s0 used then immediately exit: don't do any encryption
or decryption.
.Ip "\fB\-bufsize number\fR" 4
set the buffer size for I/O
.Ip "\fB\-debug\fR" 4
debug the BIOs used for I/O.
.SH "NOTES"
The program can be called either as \fBopenssl ciphername\fR or
\fBopenssl enc \-ciphername\fR.
.PP
A password will be prompted for to derive the key and IV if necessary.
.PP
The \fB\-salt\fR option should \fBALWAYS\fR be used if the key is being derived
from a password unless you want compatibility with previous versions of
OpenSSL and SSLeay.
.PP
Without the \fB\-salt\fR option it is possible to perform efficient dictionary
attacks on the password and to attack stream cipher encrypted data. The reason
for this is that without the salt the same password always generates the same
encryption key. When the salt is being used the first eight bytes of the
encrypted data are reserved for the salt: it is generated at random when
encrypting a file and read from the encrypted file when it is decrypted.
.PP
Some of the ciphers do not have large keys and others have security
implications if not used correctly. A beginner is advised to just use
a strong block cipher in CBC mode such as bf or des3.
.PP
All the block ciphers use PKCS#5 padding also known as standard block
padding: this allows a rudimentary integrity or password check to be
performed. However since the chance of random data passing the test is
better than 1 in 256 it isn't a very good test.
.PP
All RC2 ciphers have the same key and effective key length.
.PP
Blowfish and RC5 algorithms use a 128 bit key.
.SH "SUPPORTED CIPHERS"
.PP
.Vb 1
\& base64             Base 64
.Ve
.Vb 5
\& bf-cbc             Blowfish in CBC mode
\& bf                 Alias for bf-cbc
\& bf-cfb             Blowfish in CFB mode
\& bf-ecb             Blowfish in ECB mode
\& bf-ofb             Blowfish in OFB mode
.Ve
.Vb 6
\& cast-cbc           CAST in CBC mode
\& cast               Alias for cast-cbc
\& cast5-cbc          CAST5 in CBC mode
\& cast5-cfb          CAST5 in CFB mode
\& cast5-ecb          CAST5 in ECB mode
\& cast5-ofb          CAST5 in OFB mode
.Ve
.Vb 5
\& des-cbc            DES in CBC mode
\& des                Alias for des-cbc
\& des-cfb            DES in CBC mode
\& des-ofb            DES in OFB mode
\& des-ecb            DES in ECB mode
.Ve
.Vb 4
\& des-ede-cbc        Two key triple DES EDE in CBC mode
\& des-ede            Alias for des-ede
\& des-ede-cfb        Two key triple DES EDE in CFB mode
\& des-ede-ofb        Two key triple DES EDE in OFB mode
.Ve
.Vb 5
\& des-ede3-cbc       Three key triple DES EDE in CBC mode
\& des-ede3           Alias for des-ede3-cbc
\& des3               Alias for des-ede3-cbc
\& des-ede3-cfb       Three key triple DES EDE CFB mode
\& des-ede3-ofb       Three key triple DES EDE in OFB mode
.Ve
.Vb 1
\& desx               DESX algorithm.
.Ve
.Vb 5
\& idea-cbc           IDEA algorithm in CBC mode
\& idea               same as idea-cbc
\& idea-cfb           IDEA in CFB mode
\& idea-ecb           IDEA in ECB mode
\& idea-ofb           IDEA in OFB mode
.Ve
.Vb 7
\& rc2-cbc            128 bit RC2 in CBC mode
\& rc2                Alias for rc2-cbc
\& rc2-cfb            128 bit RC2 in CBC mode
\& rc2-ecb            128 bit RC2 in CBC mode
\& rc2-ofb            128 bit RC2 in CBC mode
\& rc2-64-cbc         64 bit RC2 in CBC mode
\& rc2-40-cbc         40 bit RC2 in CBC mode
.Ve
.Vb 3
\& rc4                128 bit RC4
\& rc4-64             64 bit RC4
\& rc4-40             40 bit RC4
.Ve
.Vb 5
\& rc5-cbc            RC5 cipher in CBC mode
\& rc5                Alias for rc5-cbc
\& rc5-cfb            RC5 cipher in CBC mode
\& rc5-ecb            RC5 cipher in CBC mode
\& rc5-ofb            RC5 cipher in CBC mode
.Ve
.SH "EXAMPLES"
Just base64 encode a binary file:
.PP
.Vb 1
\& openssl base64 -in file.bin -out file.b64
.Ve
Decode the same file
.PP
.Vb 1
\& openssl base64 -d -in file.b64 -out file.bin 
.Ve
Encrypt a file using triple DES in CBC mode using a prompted password:
.PP
.Vb 1
\& openssl des3 -salt -in file.txt -out file.des3 
.Ve
Decrypt a file using a supplied password:
.PP
.Vb 1
\& openssl des3 -d -salt -in file.des3 -out file.txt -k mypassword
.Ve
Encrypt a file then base64 encode it (so it can be sent via mail for example)
using Blowfish in CBC mode:
.PP
.Vb 1
\& openssl bf -a -salt -in file.txt -out file.bf
.Ve
Base64 decode a file then decrypt it:
.PP
.Vb 1
\& openssl bf -d -salt -a -in file.bf -out file.txt
.Ve
Decrypt some data using a supplied 40 bit RC4 key:
.PP
.Vb 1
\& openssl rc4-40 -in file.rc4 -out file.txt -K 0102030405
.Ve
.SH "BUGS"
The \fB\-A\fR option when used with large files doesn't work properly.
.PP
There should be an option to allow an iteration count to be included.
.PP
Like the EVP library the \fBenc\fR program only supports a fixed number of
algorithms with certain parameters. So if, for example, you want to use RC2
with a 76 bit key or RC4 with an 84 bit key you can't use this program.

.rn }` ''
.IX Title "ENC 1"
.IX Name "enc - symmetric cipher routines"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "OPTIONS"

.IX Item "\fB\-in filename\fR"

.IX Item "\fB\-out filename\fR"

.IX Item "\fB\-pass arg\fR"

.IX Item "\fB\-salt\fR"

.IX Item "\fB\-nosalt\fR"

.IX Item "\fB\-e\fR"

.IX Item "\fB\-d\fR"

.IX Item "\fB\-a\fR"

.IX Item "\fB\-A\fR"

.IX Item "\fB\-k password\fR"

.IX Item "\fB\-kfile filename\fR"

.IX Item "\fB\-S salt\fR"

.IX Item "\fB\-K key\fR"

.IX Item "\fB\-iv \s-1IV\s0\fR"

.IX Item "\fB\-p\fR"

.IX Item "\fB\-P\fR"

.IX Item "\fB\-bufsize number\fR"

.IX Item "\fB\-debug\fR"

.IX Header "NOTES"

.IX Header "SUPPORTED CIPHERS"

.IX Header "EXAMPLES"

.IX Header "BUGS"

