.rn '' }`
'''
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH BN_add 3 "0.9.5a" "22/Jul/2000" "OpenSSL"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
BN_add, BN_sub, BN_mul, BN_div, BN_sqr, BN_mod, BN_mod_mul, BN_exp,
BN_mod_exp, BN_gcd \- arithmetic operations on BIGNUMs
.SH "LIBRARY"
libcrypto, -lcrypto
.SH "SYNOPSIS"
.PP
.Vb 1
\& #include <openssl/bn.h>
.Ve
.Vb 1
\& int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
.Ve
.Vb 1
\& int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
.Ve
.Vb 1
\& int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);
.Ve
.Vb 2
\& int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d,
\&         BN_CTX *ctx);
.Ve
.Vb 1
\& int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);
.Ve
.Vb 1
\& int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
.Ve
.Vb 2
\& int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
\&         BN_CTX *ctx);
.Ve
.Vb 1
\& int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);
.Ve
.Vb 2
\& int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
\&         const BIGNUM *m, BN_CTX *ctx);
.Ve
.Vb 1
\& int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);
.Ve
.SH "DESCRIPTION"
\fIBN_add()\fR adds \fBa\fR and \fBb\fR and places the result in \fBr\fR (\f(CWr=a+b\fR).
\fBr\fR may be the same \fBBIGNUM\fR as \fBa\fR or \fBb\fR.
.PP
\fIBN_sub()\fR subtracts \fBb\fR from \fBa\fR and places the result in \fBr\fR (\f(CWr=a-b\fR).
.PP
\fIBN_mul()\fR multiplies \fBa\fR and \fBb\fR and places the result in \fBr\fR (\f(CWr=a*b\fR).
\fBr\fR may be the same \fBBIGNUM\fR as \fBa\fR or \fBb\fR.
For multiplication by powers of 2, use the \fIBN_lshift(3)|BN_lshift(3)\fR manpage.
.PP
\fIBN_div()\fR divides \fBa\fR by \fBd\fR and places the result in \fBdv\fR and the
remainder in \fBrem\fR (\f(CWdv=a/d, rem=a%d\fR). Either of \fBdv\fR and \fBrem\fR may
be NULL, in which case the respective value is not returned.
For division by powers of 2, use \fIBN_rshift\fR\|(3).
.PP
\fIBN_sqr()\fR takes the square of \fBa\fR and places the result in \fBr\fR
(\f(CWr=a^2\fR). \fBr\fR and \fBa\fR may be the same \fBBIGNUM\fR.
This function is faster than \fIBN_mul\fR\|(r,a,a).
.PP
\fIBN_mod()\fR find the remainder of \fBa\fR divided by \fBm\fR and places it in
\fBrem\fR (\f(CWrem=a%m\fR).
.PP
\fIBN_mod_mul()\fR multiplies \fBa\fR by \fBb\fR and finds the remainder when
divided by \fBm\fR (\f(CWr=(a*b)%m\fR). \fBr\fR may be the same \fBBIGNUM\fR as \fBa\fR
or \fBb\fR. For a more efficient algorithm, see
the \fIBN_mod_mul_montgomery(3)|BN_mod_mul_montgomery(3)\fR manpage; for repeated
computations using the same modulus, see the \fIBN_mod_mul_reciprocal(3)|BN_mod_mul_reciprocal(3)\fR manpage.
.PP
\fIBN_exp()\fR raises \fBa\fR to the \fBp\fR\-th power and places the result in \fBr\fR
(\f(CWr=a^p\fR). This function is faster than repeated applications of
\fIBN_mul()\fR.
.PP
\fIBN_mod_exp()\fR computes \fBa\fR to the \fBp\fR\-th power modulo \fBm\fR (\f(CWr=a^p %
m\fR). This function uses less time and space than \fIBN_exp()\fR.
.PP
\fIBN_gcd()\fR computes the greatest common divisor of \fBa\fR and \fBb\fR and
places the result in \fBr\fR. \fBr\fR may be the same \fBBIGNUM\fR as \fBa\fR or
\fBb\fR.
.PP
For all functions, \fBctx\fR is a previously allocated \fBBN_CTX\fR used for
temporary variables; see the \fIBN_CTX_new(3)|BN_CTX_new(3)\fR manpage.
.PP
Unless noted otherwise, the result \fBBIGNUM\fR must be different from
the arguments.
.SH "RETURN VALUES"
For all functions, 1 is returned for success, 0 on error. The return
value should always be checked (e.g., \f(CWif (!BN_add(r,a,b)) goto err;\fR).
The error codes can be obtained by the \fIERR_get_error(3)|ERR_get_error(3)\fR manpage.
.SH "SEE ALSO"
the \fIbn(3)|bn(3)\fR manpage, the \fIerr(3)|err(3)\fR manpage, the \fIBN_CTX_new(3)|BN_CTX_new(3)\fR manpage,
the \fIBN_add_word(3)|BN_add_word(3)\fR manpage, the \fIBN_set_bit(3)|BN_set_bit(3)\fR manpage
.SH "HISTORY"
\fIBN_add()\fR, \fIBN_sub()\fR, \fIBN_div()\fR, \fIBN_sqr()\fR, \fIBN_mod()\fR, \fIBN_mod_mul()\fR,
\fIBN_mod_exp()\fR and \fIBN_gcd()\fR are available in all versions of SSLeay and
OpenSSL. The \fBctx\fR argument to \fIBN_mul()\fR was added in SSLeay
0.9.1b. \fIBN_exp()\fR appeared in SSLeay 0.9.0.

.rn }` ''
.IX Title "BN_add 3"
.IX Name "BN_add, BN_sub, BN_mul, BN_div, BN_sqr, BN_mod, BN_mod_mul, BN_exp,
BN_mod_exp, BN_gcd - arithmetic operations on BIGNUMs"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "RETURN VALUES"

.IX Header "SEE ALSO"

.IX Header "HISTORY"

