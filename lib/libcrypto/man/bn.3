.rn '' }`
'''
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH bn 3 "0.9.5a" "22/Jul/2000" "OpenSSL"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
bn \- multiprecision integer arithmetics
.SH "LIBRARY"
libcrypto, -lcrypto
.SH "SYNOPSIS"
.PP
.Vb 1
\& #include <openssl/bn.h>
.Ve
.Vb 5
\& BIGNUM *BN_new(void);
\& void BN_free(BIGNUM *a);
\& void BN_init(BIGNUM *);
\& void BN_clear(BIGNUM *a);
\& void BN_clear_free(BIGNUM *a);
.Ve
.Vb 3
\& BN_CTX *BN_CTX_new(void);
\& void BN_CTX_init(BN_CTX *c);
\& void BN_CTX_free(BN_CTX *c);
.Ve
.Vb 2
\& BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);
\& BIGNUM *BN_dup(const BIGNUM *a);
.Ve
.Vb 3
\& int BN_num_bytes(const BIGNUM *a);
\& int BN_num_bits(const BIGNUM *a);
\& int BN_num_bits_word(BN_ULONG w);
.Ve
.Vb 13
\& int BN_add(BIGNUM *r, BIGNUM *a, BIGNUM *b);
\& int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
\& int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);
\& int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d,
\&         BN_CTX *ctx);
\& int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);
\& int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
\& int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
\&         BN_CTX *ctx);
\& int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);
\& int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
\&         const BIGNUM *m, BN_CTX *ctx);
\& int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);
.Ve
.Vb 5
\& int BN_add_word(BIGNUM *a, BN_ULONG w);
\& int BN_sub_word(BIGNUM *a, BN_ULONG w);
\& int BN_mul_word(BIGNUM *a, BN_ULONG w);
\& BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w);
\& BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w);
.Ve
.Vb 6
\& int BN_cmp(BIGNUM *a, BIGNUM *b);
\& int BN_ucmp(BIGNUM *a, BIGNUM *b);
\& int BN_is_zero(BIGNUM *a);
\& int BN_is_one(BIGNUM *a);
\& int BN_is_word(BIGNUM *a, BN_ULONG w);
\& int BN_is_odd(BIGNUM *a);
.Ve
.Vb 5
\& int BN_zero(BIGNUM *a);
\& int BN_one(BIGNUM *a);
\& BIGNUM *BN_value_one(void);
\& int BN_set_word(BIGNUM *a, unsigned long w);
\& unsigned long BN_get_word(BIGNUM *a);
.Ve
.Vb 2
\& int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);
\& int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);
.Ve
.Vb 4
\& BIGNUM *BN_generate_prime(BIGNUM *ret, int bits,int safe, BIGNUM *add,
\&         BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);
\& int BN_is_prime(const BIGNUM *p, int nchecks,
\&         void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg);
.Ve
.Vb 8
\& int BN_set_bit(BIGNUM *a, int n);
\& int BN_clear_bit(BIGNUM *a, int n);
\& int BN_is_bit_set(const BIGNUM *a, int n);
\& int BN_mask_bits(BIGNUM *a, int n);
\& int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);
\& int BN_lshift1(BIGNUM *r, BIGNUM *a);
\& int BN_rshift(BIGNUM *r, BIGNUM *a, int n);
\& int BN_rshift1(BIGNUM *r, BIGNUM *a);
.Ve
.Vb 10
\& int BN_bn2bin(const BIGNUM *a, unsigned char *to);
\& BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);
\& char *BN_bn2hex(const BIGNUM *a);
\& char *BN_bn2dec(const BIGNUM *a);
\& int BN_hex2bn(BIGNUM **a, const char *str);
\& int BN_dec2bn(BIGNUM **a, const char *str);
\& int BN_print(BIO *fp, const BIGNUM *a);
\& int BN_print_fp(FILE *fp, const BIGNUM *a);
\& int BN_bn2mpi(const BIGNUM *a, unsigned char *to);
\& BIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret);
.Ve
.Vb 2
\& BIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n,
\&     BN_CTX *ctx);
.Ve
.Vb 6
\& BN_RECP_CTX *BN_RECP_CTX_new(void);
\& void BN_RECP_CTX_init(BN_RECP_CTX *recp);
\& void BN_RECP_CTX_free(BN_RECP_CTX *recp);
\& int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *m, BN_CTX *ctx);
\& int BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *a, BIGNUM *b,
\&        BN_RECP_CTX *recp, BN_CTX *ctx);
.Ve
.Vb 11
\& BN_MONT_CTX *BN_MONT_CTX_new(void);
\& void BN_MONT_CTX_init(BN_MONT_CTX *ctx);
\& void BN_MONT_CTX_free(BN_MONT_CTX *mont);
\& int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx);
\& BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from);
\& int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,
\&         BN_MONT_CTX *mont, BN_CTX *ctx);
\& int BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,
\&         BN_CTX *ctx);
\& int BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,
\&         BN_CTX *ctx);
.Ve
.SH "DESCRIPTION"
This library performs arithmetic operations on integers of arbitrary
size. It was written for use in public key cryptography, such as RSA
and Diffie-Hellman.
.PP
It uses dynamic memory allocation for storing its data structures.
That means that there is no limit on the size of the numbers
manipulated by these functions, but return values must always be
checked in case a memory allocation error has occurred.
.PP
The basic object in this library is a \fBBIGNUM\fR. It is used to hold a
single large integer. This type should be considered opaque and fields
should not be modified or accessed directly.
.PP
The creation of \fBBIGNUM\fR objects is described in the \fIBN_new(3)|BN_new(3)\fR manpage;
the \fIBN_add(3)|BN_add(3)\fR manpage describes most of the arithmetic operations.
Comparison is described in the \fIBN_cmp(3)|BN_cmp(3)\fR manpage; the \fIBN_zero(3)|BN_zero(3)\fR manpage
describes certain assignments, the \fIBN_rand(3)|BN_rand(3)\fR manpage the generation of
random numbers, the \fIBN_generate_prime(3)|BN_generate_prime(3)\fR manpage deals with prime
numbers and the \fIBN_set_bit(3)|BN_set_bit(3)\fR manpage with bit operations. The conversion
of \fBBIGNUM\fRs to external formats is described in the \fIBN_bn2bin(3)|BN_bn2bin(3)\fR manpage.
.SH "SEE ALSO"
the \fIbn_internal(3)|bn_internal(3)\fR manpage,
the \fIdh(3)|dh(3)\fR manpage, the \fIerr(3)|err(3)\fR manpage, the \fIrand(3)|rand(3)\fR manpage, the \fIrsa(3)|rsa(3)\fR manpage,
the \fIBN_new(3)|BN_new(3)\fR manpage, the \fIBN_CTX_new(3)|BN_CTX_new(3)\fR manpage,
the \fIBN_copy(3)|BN_copy(3)\fR manpage, the \fIBN_num_bytes(3)|BN_num_bytes(3)\fR manpage,
the \fIBN_add(3)|BN_add(3)\fR manpage, the \fIBN_add_word(3)|BN_add_word(3)\fR manpage,
the \fIBN_cmp(3)|BN_cmp(3)\fR manpage, the \fIBN_zero(3)|BN_zero(3)\fR manpage, the \fIBN_rand(3)|BN_rand(3)\fR manpage,
the \fIBN_generate_prime(3)|BN_generate_prime(3)\fR manpage, the \fIBN_set_bit(3)|BN_set_bit(3)\fR manpage,
the \fIBN_bn2bin(3)|BN_bn2bin(3)\fR manpage, the \fIBN_mod_inverse(3)|BN_mod_inverse(3)\fR manpage,
the \fIBN_mod_mul_reciprocal(3)|BN_mod_mul_reciprocal(3)\fR manpage,
the \fIBN_mod_mul_montgomery(3)|BN_mod_mul_montgomery(3)\fR manpage 

.rn }` ''
.IX Title "bn 3"
.IX Name "bn - multiprecision integer arithmetics"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "SEE ALSO"

