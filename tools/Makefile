#	$NetBSD: Makefile,v 1.70 2003/07/25 16:26:51 mrg Exp $

.include <bsd.own.mk>

.if ${TOOLCHAIN_MISSING} != "yes"
.  if ${USE_TOOLS_TOOLCHAIN} != "yes"
TOOLCHAIN_BITS= binutils .WAIT gcc
.  else
TOOLCHAIN_BITS= toolchain
.  endif
TOOLCHAIN_BITS+= .WAIT dbsym mdsetimage
# XXX Eventually, we want to be able to build dbsym and mdsetimage
# XXX if EXTERNAL_TOOLCHAIN is set.
.endif

# Dependencies in SUBDIR below ordered to maximize parallel ability.
.if !defined(NOSUBDIR)					# {

SUBDIR=	host-mkdep .WAIT compat .WAIT \
	binstall .WAIT mktemp .WAIT \
		cap_mkdb crunchgen ctags gencat hexdump lint lint2 lorder \
		m4 makewhatis mkdep mtree rpcgen tsort uudecode \
	texinfo .WAIT \
	yacc .WAIT \
	lex .WAIT \
	${TOOLCHAIN_BITS} \
		asn1_compile cat cksum compile_et config db file installboot \
		lint1 makefs menuc mklocale mkcsmapper mkesdb msgc pax \
		pwd_mkdb stat sunlabel zic

.if ${MKMAN} != "no"
SUBDIR+=	groff
.endif

.if ${MKMAINTAINERTOOLS:Uno} != "no"
SUBDIR+=	autoconf gettext
.endif

.if ${MACHINE} == prep
SUBDIR+=	prep-mkbootimage
.endif

.if (${MACHINE_ARCH} == "mipsel" || ${MACHINE_ARCH} == "mipseb")
SUBDIR+=	mips-elf2ecoff
.endif

.if (${MACHINE} == "sparc" || ${MACHINE} == "sparc64")
SUBDIR+=	fgen
.endif

.endif	# ! NOSUBDIR					# }

check_MKTOOLS: .PHONY .NOTMAIN
.if ${MKTOOLS:Uyes} == "no"
	@echo '*** WARNING: "MKTOOLS" is set to "no"; this will prevent building and'
	@echo '*** updating your host toolchain.  This should be used only as a'
	@echo '*** temporary workaround for toolchain problems, as it will result'
	@echo '*** in version skew and build errors over time!'
.endif

.if ${MKTOOLS:Uyes} == "no" || ${USETOOLS} != "yes"	# {
realall realdepend install: check_MKTOOLS

.for dir in ${SUBDIR:N.WAIT}
all-${dir} depend-${dir} dependall-${dir} install-${dir}:
	@true
.endfor
.endif							# }

.include <bsd.subdir.mk>
.include <bsd.obj.mk>

.if exists(PREVIOUSTOOLDIR)
PREVIOUSTOOLDIR!=	cat PREVIOUSTOOLDIR
.else
PREVIOUSTOOLDIR=	
.endif

CLEANFILES+=	PREVIOUSTOOLDIR

realall realdepend:
.if (${PREVIOUSTOOLDIR} != ${TOOLDIR})
	@echo "*** WARNING: TOOLDIR has moved?"
	@echo "*** PREVIOUSTOOLDIR '${PREVIOUSTOOLDIR}'"
	@echo "***     !=  TOOLDIR '${TOOLDIR}'"
	@echo "*** Cleaning mis-matched tools"
	rm -f PREVIOUSTOOLDIR
	${MAKE} cleandir
.endif
	echo ${TOOLDIR} > PREVIOUSTOOLDIR

# For each .WAIT point, make sure the immediately preceding target is
# installed before building anything after that point.
#
# We use the "internal" targets and dependencies generated by <bsd.subdir.mk>
# to achieve this. These targets look like:
#	subdir-all:	all-dir1     [.WAIT] all-dir2     etc..
#	subdir-install:	install-dir1 [.WAIT] install-dir2 etc..
# and so on for each element in ${TARGETS}, with .WAIT sources inserted at
# places corresponding to the .WAITs in our $SUBDIR variable.
#
# Also, since we're now mixing `install' with `all' and `depend' targets
# an order relationship between those in each individual subdirectory
# must be established.
#
_deps:=
_prev:=

.for d in ${SUBDIR}
_this:=		${d}

.if ${_this} == ".WAIT"

# setup dependency to apply to all/depend targets in the next group
_deps:=		${_deps} ${_prev:S/^/install-/}

# if we're building *only* individual targets (i.e. "dependall-yacc"),
# make sure prerequisite tools build before installing
.if !make(all) && !make(dependall)
install-${_prev}: dependall-${_prev}
.endif

.else

# order depend/all/install targets for ${d} subdir.  Note the additional
# .WAIT to achieve "closure" of the predecessor/successor relationships.
.ORDER: depend-${d} all-${d} dependall-${d} .WAIT install-${d}

# make all/depend-${d} dependent on list of install targets
depend-${d} all-${d} dependall-${d}: ${_deps}

.endif

# stash current name in case the next entry is .WAIT
_prev:=		${d}
.endfor

cleandir:
	rm -f ${CLEANFILES}
