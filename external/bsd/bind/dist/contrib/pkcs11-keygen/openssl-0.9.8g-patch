diff -r -u -N openssl-0.9.8g/Configure openssl/Configure
--- openssl-0.9.8g/Configure	2007-09-16 14:24:17.000000000 +0200
+++ openssl/Configure	2007-10-25 01:27:08.000000000 +0200
@@ -10,7 +10,7 @@
 
 # see INSTALL for instructions.
 
-my $usage="Usage: Configure [no-<cipher> ...] [enable-<cipher> ...] [-Dxxx] [-lxxx] [-Lxxx] [-fxxx] [-Kxxx] [no-hw-xxx|no-hw] [[no-]threads] [[no-]shared] [[no-]zlib|zlib-dynamic] [no-asm] [no-dso] [no-krb5] [386] [--prefix=DIR] [--openssldir=OPENSSLDIR] [--with-xxx[=vvv]] [--test-sanity] os/compiler[:flags]\n";
+my $usage="Usage: Configure  --pk11-libname=PK11_LIB_LOCATION [no-<cipher> ...] [enable-<cipher> ...] [-Dxxx] [-lxxx] [-Lxxx] [-fxxx] [-Kxxx] [no-hw-xxx|no-hw] [[no-]threads] [[no-]shared] [[no-]zlib|zlib-dynamic] [no-asm] [no-dso] [no-krb5] [386] [--prefix=DIR] [--openssldir=OPENSSLDIR] [--with-xxx[=vvv]] [--test-sanity] os/compiler[:flags]\n";
 
 # Options:
 #
@@ -19,6 +19,9 @@
 # --prefix      prefix for the OpenSSL include, lib and bin directories
 #               (Default: the OPENSSLDIR directory)
 #
+# --pk11_libname  PKCS#11 library name.
+#               (Default: none)
+#
 # --install_prefix  Additional prefix for package builders (empty by
 #               default).  This needn't be set in advance, you can
 #               just as well use "make INSTALL_PREFIX=/whatever install".
@@ -560,6 +563,8 @@
 my $idx_ranlib = $idx++;
 my $idx_arflags = $idx++;
 
+my $pk11_libname="";
+
 my $prefix="";
 my $openssldir="";
 my $exe_ext="";
@@ -738,6 +743,10 @@
 				{
 				$flags.=$_." ";
 				}
+                        elsif (/^--pk11-libname=(.*)$/)
+                                {
+                                $pk11_libname=$1;
+                                }
 			elsif (/^--prefix=(.*)$/)
 				{
 				$prefix=$1;
@@ -861,6 +870,13 @@
 	exit 0;
 }
 
+if (! $pk11_libname)
+        {
+        print STDERR "You must set --pk11-libname for PKCS#11 library.\n";
+        print STDERR "See README.pkcs11 for more information.\n";
+        exit 1;
+        }
+
 if ($target =~ m/^CygWin32(-.*)$/) {
 	$target = "Cygwin".$1;
 }
@@ -986,6 +1002,8 @@
 if ($flags ne "")	{ $cflags="$flags$cflags"; }
 else			{ $no_user_cflags=1;       }
 
+$cflags="-DPK11_LIB_LOCATION=\"$pk11_libname\" $cflags";
+
 # Kerberos settings.  The flavor must be provided from outside, either through
 # the script "config" or manually.
 if (!$no_krb5)
@@ -1319,6 +1337,7 @@
 	s/^VERSION=.*/VERSION=$version/;
 	s/^MAJOR=.*/MAJOR=$major/;
 	s/^MINOR=.*/MINOR=$minor/;
+	s/^PK11_LIB_LOCATION=.*/PK11_LIB_LOCATION=$pk11_libname/;
 	s/^SHLIB_VERSION_NUMBER=.*/SHLIB_VERSION_NUMBER=$shlib_version_number/;
 	s/^SHLIB_VERSION_HISTORY=.*/SHLIB_VERSION_HISTORY=$shlib_version_history/;
 	s/^SHLIB_MAJOR=.*/SHLIB_MAJOR=$shlib_major/;
diff -r -u -N openssl-0.9.8g/crypto/engine/cryptoki.h openssl/crypto/engine/cryptoki.h
--- openssl-0.9.8g/crypto/engine/cryptoki.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl/crypto/engine/cryptoki.h	2007-10-25 01:27:09.000000000 +0200
@@ -0,0 +1,103 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*
+ * Copyright 2003 Sun Microsystems, Inc.   All rights reserved.
+ * Use is subject to license terms.
+ */
+
+#ifndef	_CRYPTOKI_H
+#define	_CRYPTOKI_H
+
+#pragma ident	"@(#)cryptoki.h	1.2	05/06/08 SMI"
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#ifndef	CK_PTR
+#define	CK_PTR *
+#endif
+
+#ifndef CK_DEFINE_FUNCTION
+#define	CK_DEFINE_FUNCTION(returnType, name) returnType name
+#endif
+
+#ifndef CK_DECLARE_FUNCTION
+#define	CK_DECLARE_FUNCTION(returnType, name) returnType name
+#endif
+
+#ifndef CK_DECLARE_FUNCTION_POINTER
+#define	CK_DECLARE_FUNCTION_POINTER(returnType, name) returnType (* name)
+#endif
+
+#ifndef CK_CALLBACK_FUNCTION
+#define	CK_CALLBACK_FUNCTION(returnType, name) returnType (* name)
+#endif
+
+#ifndef NULL_PTR
+#include <unistd.h>	/* For NULL */
+#define	NULL_PTR NULL
+#endif
+
+/*
+ * pkcs11t.h defines TRUE and FALSE in a way that upsets lint
+ */
+#ifndef	CK_DISABLE_TRUE_FALSE
+#define	CK_DISABLE_TRUE_FALSE
+#ifndef	TRUE
+#define	TRUE	1
+#endif /* TRUE */
+#ifndef	FALSE
+#define	FALSE	0
+#endif /* FALSE */
+#endif /* CK_DISABLE_TRUE_FALSE */
+
+#undef CK_PKCS11_FUNCTION_INFO
+
+#include "pkcs11.h"
+
+/* Solaris specific functions */
+
+#include <stdlib.h>
+
+/*
+ * SUNW_C_GetMechSession will initialize the framework and do all
+ * the necessary PKCS#11 calls to create a session capable of
+ * providing operations on the requested mechanism
+ */
+CK_RV SUNW_C_GetMechSession(CK_MECHANISM_TYPE mech,
+    CK_SESSION_HANDLE_PTR hSession);
+
+/*
+ * SUNW_C_KeyToObject will create a secret key object for the given
+ * mechanism from the rawkey data.
+ */
+CK_RV SUNW_C_KeyToObject(CK_SESSION_HANDLE hSession,
+    CK_MECHANISM_TYPE mech, const void *rawkey, size_t rawkey_len,
+    CK_OBJECT_HANDLE_PTR obj);
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _CRYPTOKI_H */
diff -r -u -N openssl-0.9.8g/crypto/engine/eng_all.c openssl/crypto/engine/eng_all.c
--- openssl-0.9.8g/crypto/engine/eng_all.c	2007-01-04 23:55:25.000000000 +0100
+++ openssl/crypto/engine/eng_all.c	2007-10-25 01:27:09.000000000 +0200
@@ -107,6 +107,9 @@
 #if defined(__OpenBSD__) || defined(__FreeBSD__)
 	ENGINE_load_cryptodev();
 #endif
+#ifndef OPENSSL_NO_HW_PKCS11
+	ENGINE_load_pk11();
+#endif
 #endif
 	}
 
diff -r -u -N openssl-0.9.8g/crypto/engine/engine.h openssl/crypto/engine/engine.h
--- openssl-0.9.8g/crypto/engine/engine.h	2005-11-06 18:48:59.000000000 +0100
+++ openssl/crypto/engine/engine.h	2007-10-25 01:27:09.000000000 +0200
@@ -332,6 +332,7 @@
 void ENGINE_load_ubsec(void);
 #endif
 void ENGINE_load_cryptodev(void);
+void ENGINE_load_pk11(void);
 void ENGINE_load_padlock(void);
 void ENGINE_load_builtin_engines(void);
 
diff -r -u -N openssl-0.9.8g/crypto/engine/hw_pk11.c openssl/crypto/engine/hw_pk11.c
--- openssl-0.9.8g/crypto/engine/hw_pk11.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl/crypto/engine/hw_pk11.c	2007-10-29 23:31:11.000000000 +0100
@@ -0,0 +1,2153 @@
+/*
+ * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+
+#pragma ident	"@(#)hw_pk11.c	1.12	07/07/05 SMI"
+
+/* crypto/engine/hw_pk11.c */
+/* This product includes software developed by the OpenSSL Project for 
+ * use in the OpenSSL Toolkit (http://www.openssl.org/).
+ *
+ * This project also referenced hw_pkcs11-0.9.7b.patch written by 
+ * Afchine Madjlessi.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2001 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <openssl/e_os2.h>
+#include <openssl/engine.h>
+#include <openssl/dso.h>
+#include <openssl/err.h>
+#include <openssl/bn.h>
+#include <openssl/md5.h>
+#include <openssl/pem.h>
+#include <openssl/rsa.h>
+#include <openssl/rand.h>
+#include <openssl/objects.h>
+#include <openssl/x509.h>
+#include <cryptlib.h>
+
+#ifndef OPENSSL_NO_HW
+#ifndef OPENSSL_NO_HW_PK11
+
+#undef DEBUG_SLOT_SELECTION
+
+#include "cryptoki.h"
+#include "pkcs11.h"
+#include "hw_pk11_err.c"
+
+
+/* The head of the free PK11 session list */
+static struct PK11_SESSION_st *free_session = NULL;
+
+/* Create all secret key objects in a global session so that they are available
+ * to use for other sessions. These other sessions may be opened or closed
+ * without losing the secret key objects */
+static CK_SESSION_HANDLE	global_session = CK_INVALID_HANDLE;
+
+/* ENGINE level stuff */
+static int pk11_init(ENGINE *e);
+static int pk11_library_init(ENGINE *e);
+static int pk11_finish(ENGINE *e);
+static int pk11_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)());
+static int pk11_destroy(ENGINE *e);
+
+/* RAND stuff */
+static void pk11_rand_seed(const void *buf, int num);
+static void pk11_rand_add(const void *buf, int num, double add_entropy);
+static void pk11_rand_cleanup(void);
+static int pk11_rand_bytes(unsigned char *buf, int num);
+static int pk11_rand_status(void);
+
+/* These functions are also used in other files */
+PK11_SESSION *pk11_get_session();
+void pk11_return_session(PK11_SESSION *sp);
+int pk11_destroy_rsa_key_objects(PK11_SESSION *session);
+int pk11_destroy_dsa_key_objects(PK11_SESSION *session);
+int pk11_destroy_dh_key_objects(PK11_SESSION *session);
+
+/* Local helper functions */
+static int pk11_free_all_sessions();
+static int pk11_setup_session(PK11_SESSION *sp);
+static int pk11_destroy_cipher_key_objects(PK11_SESSION *session);
+static int pk11_destroy_object(CK_SESSION_HANDLE session, 
+	CK_OBJECT_HANDLE oh);
+static const char *get_PK11_LIBNAME(void);
+static void free_PK11_LIBNAME(void);
+static long set_PK11_LIBNAME(const char *name);
+
+/* Symmetric cipher and digest support functions */
+static int cipher_nid_to_pk11(int nid);
+static int pk11_usable_ciphers(const int **nids);
+static int pk11_usable_digests(const int **nids);
+static int pk11_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+	const unsigned char *iv, int enc);
+static int pk11_cipher_final(PK11_SESSION *sp);
+static int pk11_cipher_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+	const unsigned char *in, unsigned int inl);
+static int pk11_cipher_cleanup(EVP_CIPHER_CTX *ctx);
+static int pk11_engine_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
+	const int **nids, int nid);
+static int pk11_engine_digests(ENGINE *e, const EVP_MD **digest,
+	const int **nids, int nid);
+static CK_OBJECT_HANDLE pk11_get_cipher_key(EVP_CIPHER_CTX *ctx, 
+	const unsigned char *key, CK_KEY_TYPE key_type, PK11_SESSION *sp);
+static void check_new_cipher_key(PK11_SESSION *sp, const unsigned char *key);
+static int md_nid_to_pk11(int nid);
+static int pk11_digest_init(EVP_MD_CTX *ctx);
+static int pk11_digest_update(EVP_MD_CTX *ctx,const void *data,
+	size_t count);
+static int pk11_digest_final(EVP_MD_CTX *ctx,unsigned char *md);
+static int pk11_digest_copy(EVP_MD_CTX *to,const EVP_MD_CTX *from);
+static int pk11_digest_cleanup(EVP_MD_CTX *ctx);
+
+static int pk11_choose_slot();
+static int pk11_count_symmetric_cipher(int slot_id, CK_MECHANISM_TYPE mech,
+    int *current_slot_n_cipher, int *local_cipher_nids, int id);
+static int pk11_count_digest(int slot_id, CK_MECHANISM_TYPE mech,
+    int *current_slot_n_digest, int *local_digest_nids, int id);
+
+/* Index for the supported ciphers */
+#define PK11_DES_CBC		0
+#define PK11_DES3_CBC		1
+#define PK11_AES_CBC		2
+#define PK11_RC4		3
+
+/* Index for the supported digests */
+#define PK11_MD5		0
+#define PK11_SHA1		1
+
+#define PK11_CIPHER_MAX		4	/* Max num of ciphers supported */
+#define PK11_DIGEST_MAX		2	/* Max num of digests supported */
+
+#define PK11_KEY_LEN_MAX	24
+
+static int cipher_nids[PK11_CIPHER_MAX];
+static int digest_nids[PK11_DIGEST_MAX];
+static int cipher_count		= 0;
+static int digest_count		= 0;
+static CK_BBOOL pk11_have_rsa	= CK_FALSE;
+static CK_BBOOL pk11_have_dsa	= CK_FALSE;
+static CK_BBOOL pk11_have_dh	= CK_FALSE;
+static CK_BBOOL pk11_have_random = CK_FALSE;
+
+typedef struct PK11_CIPHER_st 
+	{
+	int		id;
+	int		nid;
+	int		ivmax;
+	int		key_len;
+	CK_KEY_TYPE	key_type;
+	CK_MECHANISM_TYPE	mech_type;
+	} PK11_CIPHER;
+
+static PK11_CIPHER ciphers[] = 
+	{
+	{PK11_DES_CBC,  NID_des_cbc,      8,  8,   CKK_DES,  CKM_DES_CBC, },
+	{PK11_DES3_CBC, NID_des_ede3_cbc, 8,  24,  CKK_DES3, CKM_DES3_CBC, },
+	{PK11_AES_CBC,  NID_aes_128_cbc,  16, 16,  CKK_AES,  CKM_AES_CBC, },
+	{PK11_RC4,      NID_rc4,          0,  16,  CKK_RC4,  CKM_RC4, },
+	};
+
+typedef struct PK11_DIGEST_st
+	{
+	int		id;
+	int		nid;
+	CK_MECHANISM_TYPE	mech_type;
+	} PK11_DIGEST;
+
+static PK11_DIGEST digests[] = 
+	{
+	{PK11_MD5,	NID_md5,	CKM_MD5, },
+	{PK11_SHA1,	NID_sha1,	CKM_SHA_1, },
+	{0,		NID_undef,	0xFFFF, },
+	};
+
+/* Structure to be used for the cipher_data/md_data in 
+ * EVP_CIPHER_CTX/EVP_MD_CTX structures in order to use the same 
+ * pk11 session in multiple cipher_update calls
+ */
+typedef struct PK11_CIPHER_STATE_st
+	{
+	PK11_SESSION	*sp;
+	} PK11_CIPHER_STATE;
+
+
+/* libcrypto EVP stuff - this is how we get wired to EVP so the engine
+ * gets called when libcrypto requests a cipher NID.
+ * Note how the PK11_CIPHER_STATE is used here.
+ */
+
+/* DES CBC EVP */
+static const EVP_CIPHER pk11_des_cbc = 
+	{
+	NID_des_cbc,
+	8, 8, 8,
+	EVP_CIPH_CBC_MODE,
+	pk11_cipher_init,
+	pk11_cipher_do_cipher,
+	pk11_cipher_cleanup,
+	sizeof(PK11_CIPHER_STATE),
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL
+	};
+
+/* 3DES CBC EVP */
+static const EVP_CIPHER pk11_3des_cbc = 
+	{
+	NID_des_ede3_cbc,
+	8, 24, 8,
+	EVP_CIPH_CBC_MODE,
+	pk11_cipher_init,
+	pk11_cipher_do_cipher,
+	pk11_cipher_cleanup,
+	sizeof(PK11_CIPHER_STATE),
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL
+	};
+
+static const EVP_CIPHER pk11_aes_cbc = 
+	{
+	NID_aes_128_cbc,
+	16, 16, 16,
+	EVP_CIPH_CBC_MODE,
+	pk11_cipher_init,
+	pk11_cipher_do_cipher,
+	pk11_cipher_cleanup,
+	sizeof(PK11_CIPHER_STATE),
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL
+	};
+
+static const EVP_CIPHER pk11_rc4 =
+	{
+	NID_rc4,
+	1,16,0,
+	EVP_CIPH_VARIABLE_LENGTH,
+	pk11_cipher_init,
+	pk11_cipher_do_cipher,
+	pk11_cipher_cleanup,
+	sizeof(PK11_CIPHER_STATE),
+	NULL,
+	NULL,
+	NULL
+	};
+
+static const EVP_MD pk11_md5 =
+	{
+	NID_md5,
+	NID_md5WithRSAEncryption,
+	MD5_DIGEST_LENGTH,
+	0,
+	pk11_digest_init,
+	pk11_digest_update,
+	pk11_digest_final,
+	pk11_digest_copy,
+	pk11_digest_cleanup,
+	EVP_PKEY_RSA_method,
+	MD5_CBLOCK,
+	sizeof(PK11_CIPHER_STATE),
+	};
+
+static const EVP_MD pk11_sha1 =
+	{
+	NID_sha1,
+	NID_sha1WithRSAEncryption,
+	SHA_DIGEST_LENGTH,
+	0,
+	pk11_digest_init,
+	pk11_digest_update,
+	pk11_digest_final,
+	pk11_digest_copy,
+	pk11_digest_cleanup,
+	EVP_PKEY_RSA_method,
+	SHA_CBLOCK,
+	sizeof(PK11_CIPHER_STATE),
+	};
+
+/* Initialization function. Sets up various pk11 library components.
+ */
+/* The definitions for control commands specific to this engine
+ */
+#define PK11_CMD_SO_PATH		ENGINE_CMD_BASE
+#define PK11_CMD_PIN			(ENGINE_CMD_BASE+1)
+#define PK11_CMD_SLOT			(ENGINE_CMD_BASE+2)
+static const ENGINE_CMD_DEFN pk11_cmd_defns[] =
+	{
+		{
+		PK11_CMD_SO_PATH,
+		"SO_PATH",
+		"Specifies the path to the 'pkcs#11' shared library",
+		ENGINE_CMD_FLAG_STRING
+		},
+		{
+		PK11_CMD_PIN,
+		"PIN",
+		"Specifies the pin code",
+		ENGINE_CMD_FLAG_STRING
+		},
+		{
+		PK11_CMD_SLOT,
+		"SLOT",
+		"Specifies the slot (default is auto select)",
+		ENGINE_CMD_FLAG_NUMERIC,
+		},
+		{0, NULL, NULL, 0}
+	};
+
+
+static RAND_METHOD pk11_random =
+	{
+	pk11_rand_seed,
+	pk11_rand_bytes,
+	pk11_rand_cleanup,
+	pk11_rand_add,
+	pk11_rand_bytes,
+	pk11_rand_status
+	};
+
+
+/* Constants used when creating the ENGINE
+ */
+static const char *engine_pk11_id = "pkcs11";
+static const char *engine_pk11_name = "PKCS #11 engine support";
+
+CK_FUNCTION_LIST_PTR pFuncList = NULL;
+static const char PK11_GET_FUNCTION_LIST[] = "C_GetFunctionList";
+
+/* Cryptoki library
+ */
+static const char def_PK11_LIBNAME[] = PK11_LIB_LOCATION;
+
+static CK_BBOOL true = TRUE;
+static CK_BBOOL false = FALSE;
+static CK_SLOT_ID SLOTID = 0;
+static int pk11_auto_slot = 1;
+char *pk11_pin;
+static int pk11_library_initialized = 0;
+
+static DSO *pk11_dso = NULL;
+
+/*
+ * This internal function is used by ENGINE_pk11() and "dynamic" ENGINE support.
+ */
+static int bind_pk11(ENGINE *e)
+	{
+	const RSA_METHOD *rsa = NULL;
+	RSA_METHOD *pk11_rsa = PK11_RSA();
+
+	if (!pk11_library_initialized)
+		pk11_library_init(e);
+
+	if(!ENGINE_set_id(e, engine_pk11_id) ||
+	   !ENGINE_set_name(e, engine_pk11_name) ||
+	   !ENGINE_set_ciphers(e, pk11_engine_ciphers) ||
+	   !ENGINE_set_digests(e, pk11_engine_digests))
+	   	return 0;
+#ifndef OPENSSL_NO_RSA
+	if(pk11_have_rsa == CK_TRUE)
+		{
+		if(!ENGINE_set_RSA(e, PK11_RSA()) ||
+	           !ENGINE_set_load_privkey_function(e, pk11_load_privkey) ||
+	           !ENGINE_set_load_pubkey_function(e, pk11_load_pubkey))
+			return 0;
+#ifdef DEBUG_SLOT_SELECTION
+		fprintf(stderr, "OPENSSL_PKCS#11_ENGINE: registered RSA\n");
+#endif /* DEBUG_SLOT_SELECTION */
+		}
+#endif
+#ifndef OPENSSL_NO_DSA
+	if(pk11_have_dsa == CK_TRUE)
+		{	
+	  	if (!ENGINE_set_DSA(e, PK11_DSA()))
+			return 0;
+#ifdef DEBUG_SLOT_SELECTION
+		fprintf(stderr, "OPENSSL_PKCS#11_ENGINE: registered DSA\n");
+#endif /* DEBUG_SLOT_SELECTION */
+	    	}
+#endif
+#ifndef OPENSSL_NO_DH
+	if(pk11_have_dh == CK_TRUE)
+		{
+	  	if (!ENGINE_set_DH(e, PK11_DH()))
+			return 0;
+#ifdef DEBUG_SLOT_SELECTION
+		fprintf(stderr, "OPENSSL_PKCS#11_ENGINE: registered DH\n");
+#endif /* DEBUG_SLOT_SELECTION */
+	    	}
+#endif
+	if(pk11_have_random)
+		{
+		if(!ENGINE_set_RAND(e, &pk11_random))
+			return 0;
+#ifdef DEBUG_SLOT_SELECTION
+		fprintf(stderr, "OPENSSL_PKCS#11_ENGINE: registered random\n");
+#endif /* DEBUG_SLOT_SELECTION */
+		}
+	if(!ENGINE_set_init_function(e, pk11_init) ||
+	   !ENGINE_set_destroy_function(e, pk11_destroy) ||
+	   !ENGINE_set_finish_function(e, pk11_finish) ||
+	   !ENGINE_set_ctrl_function(e, pk11_ctrl) ||
+	   !ENGINE_set_cmd_defns(e, pk11_cmd_defns))
+		return 0;
+
+/* Apache calls OpenSSL function RSA_blinding_on() once during startup
+ * which in turn calls bn_mod_exp. Since we do not implement bn_mod_exp
+ * here, we wire it back to the OpenSSL software implementation. 
+ * Since it is used only once, performance is not a concern. */
+#ifndef OPENSSL_NO_RSA
+        rsa = RSA_PKCS1_SSLeay();
+        pk11_rsa->rsa_mod_exp = rsa->rsa_mod_exp;
+        pk11_rsa->bn_mod_exp = rsa->bn_mod_exp;
+#endif
+
+	/* Ensure the pk11 error handling is set up */
+	ERR_load_pk11_strings();
+	
+	return 1;
+	}
+
+/* Dynamic engine support is disabled at a higher level for Solaris
+ */
+#ifdef ENGINE_DYNAMIC_SUPPORT
+static int bind_helper(ENGINE *e, const char *id)
+	{
+	if (id && (strcmp(id, engine_pk11_id) != 0))
+		return 0;
+
+	if (!bind_pk11(e))
+		return 0;
+
+	return 1;
+	}	   
+
+IMPLEMENT_DYNAMIC_CHECK_FN()
+IMPLEMENT_DYNAMIC_BIND_FN(bind_helper)
+
+#else
+static ENGINE *engine_pk11(void)
+	{
+	ENGINE *ret = ENGINE_new();
+
+	if (!ret)
+		return NULL;
+
+	if (!bind_pk11(ret))
+		{
+		ENGINE_free(ret);
+		return NULL;
+		}
+
+	return ret;
+	}
+
+void ENGINE_load_pk11(void)
+	{
+	ENGINE *e_pk11 = NULL;
+
+	/* Do not use dynamic PKCS#11 library on Solaris due to 
+	 * security reasons. We will link it in statically
+	 */
+	/* Attempt to load PKCS#11 library 
+	 */
+	if (!pk11_dso)
+		pk11_dso = DSO_load(NULL, get_PK11_LIBNAME(), NULL, 0);
+
+	if (pk11_dso == NULL)
+		{
+		PK11err(PK11_F_LOAD, PK11_R_DSO_FAILURE);
+		return;
+		}
+
+	e_pk11 = engine_pk11();
+	if (!e_pk11) 
+		{
+		DSO_free(pk11_dso);
+		pk11_dso = NULL;
+		return;
+		}
+
+	/* At this point, the pk11 shared library is either dynamically
+	 * loaded or statically linked in. So, initialize the pk11 
+	 * library before calling ENGINE_set_default since the latter 
+	 * needs cipher and digest algorithm information
+	 */
+	if (!pk11_library_init(e_pk11))
+		{
+		DSO_free(pk11_dso);
+		pk11_dso = NULL;
+		ENGINE_free(e_pk11);
+		return;
+		}
+
+	ENGINE_add(e_pk11);
+
+	ENGINE_free(e_pk11);
+	ERR_clear_error();
+	}
+#endif
+
+/* These are the static string constants for the DSO file name and 
+ * the function symbol names to bind to. 
+ */
+static const char *PK11_LIBNAME = NULL;
+
+static const char *get_PK11_LIBNAME(void)
+	{
+	if (PK11_LIBNAME)
+		return PK11_LIBNAME;
+
+	return def_PK11_LIBNAME;
+	}
+
+static void free_PK11_LIBNAME(void)
+	{
+	if (PK11_LIBNAME)
+		OPENSSL_free((void*)PK11_LIBNAME);
+
+	PK11_LIBNAME = NULL;
+	}
+
+static long set_PK11_LIBNAME(const char *name)
+	{
+	free_PK11_LIBNAME();
+
+	return ((PK11_LIBNAME = BUF_strdup(name)) != NULL ? 1 : 0);
+	}
+
+/* Initialization function for the pk11 engine */
+static int pk11_init(ENGINE *e)
+{
+	return pk11_library_init(e);
+}
+
+/* Initialization function. Sets up various pk11 library components.
+ * It selects a slot based on predefined critiera. In the process, it also
+ * count how many ciphers and digests to support. Since the cipher and
+ * digest information is needed when setting default engine, this function
+ * needs to be called before calling ENGINE_set_default.
+ */
+static int pk11_library_init(ENGINE *e)
+	{
+	CK_C_GetFunctionList p;
+	CK_RV rv = CKR_OK;
+	CK_INFO info;
+	CK_ULONG ul_state_len;
+	char tmp_buf[20];
+
+	if (pk11_library_initialized)
+		return 1;
+	
+	if (pk11_dso == NULL)
+		{
+		PK11err(PK11_F_LIBRARY_INIT, PK11_R_DSO_FAILURE);
+		goto err;
+		}
+
+	/* get the C_GetFunctionList function from the loaded library
+	 */
+	p = (CK_C_GetFunctionList)DSO_bind_func(pk11_dso, 
+		PK11_GET_FUNCTION_LIST);
+	if ( !p )
+		{
+		PK11err(PK11_F_LIBRARY_INIT, PK11_R_DSO_FAILURE);
+		goto err;
+		}
+ 
+	/* get the full function list from the loaded library 
+	 */
+	rv = p(&pFuncList);
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_LIBRARY_INIT, PK11_R_DSO_FAILURE);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+ 
+	rv = pFuncList->C_Initialize(NULL_PTR);
+	if ((rv != CKR_OK) && (rv != CKR_CRYPTOKI_ALREADY_INITIALIZED))
+		{
+		PK11err(PK11_F_LIBRARY_INIT, PK11_R_INITIALIZE);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	rv = pFuncList->C_GetInfo(&info);
+	if (rv != CKR_OK) 
+		{
+		PK11err(PK11_F_LIBRARY_INIT, PK11_R_GETINFO);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	if (pk11_choose_slot() == 0)
+		goto err;
+
+	if (global_session == CK_INVALID_HANDLE)
+		{
+		/* Open the global_session for the new process */
+		rv = pFuncList->C_OpenSession(SLOTID, CKF_SERIAL_SESSION,
+			NULL_PTR, NULL_PTR, &global_session);
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_LIBRARY_INIT, PK11_R_OPENSESSION);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+		}
+
+	/* Disable digest if C_GetOperationState is not supported since
+	 * this function is required by OpenSSL digest copy function */
+	if (pFuncList->C_GetOperationState(global_session, NULL, &ul_state_len)
+			== CKR_FUNCTION_NOT_SUPPORTED)
+		digest_count = 0;
+
+	pk11_library_initialized = 1;
+	return 1;
+
+err:
+
+	return 0;
+	}
+
+/* Destructor (complements the "ENGINE_pk11()" constructor)
+ */
+static int pk11_destroy(ENGINE *e)
+	{
+	free_PK11_LIBNAME();
+	ERR_unload_pk11_strings();
+	if (pk11_pin) {
+		memset(pk11_pin, 0, strlen(pk11_pin));
+		OPENSSL_free((void*)pk11_pin);
+	}
+	pk11_pin = NULL;
+	return 1;
+	}
+
+/* Termination function to clean up the session, the token, and 
+ * the pk11 library.
+ */
+static int pk11_finish(ENGINE *e)
+	{
+
+	if (pk11_pin) {
+		memset(pk11_pin, 0, strlen(pk11_pin));
+		OPENSSL_free((void*)pk11_pin);
+	}
+	pk11_pin = NULL;
+
+	if (pk11_dso == NULL)
+		{
+		PK11err(PK11_F_FINISH, PK11_R_NOT_LOADED);
+		goto err;
+		}
+
+	assert(pFuncList != NULL);
+
+	if (pk11_free_all_sessions() == 0)
+		goto err;
+
+	pFuncList->C_CloseSession(global_session);
+	
+	/* Since we are part of a library (libcrypto.so), calling this
+	 * function may have side-effects.
+	pFuncList->C_Finalize(NULL);
+	 */
+
+	if (!DSO_free(pk11_dso))
+		{
+		PK11err(PK11_F_FINISH, PK11_R_DSO_FAILURE);
+		goto err;
+		}
+	pk11_dso = NULL;
+	pFuncList = NULL;
+	pk11_library_initialized = 0;
+
+	return 1;
+
+err:
+	return 0;
+	}
+
+/* Standard engine interface function to set the dynamic library path */
+static int pk11_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)())
+	{
+	int initialized = ((pk11_dso == NULL) ? 0 : 1);
+
+	switch(cmd)
+		{
+	case PK11_CMD_SO_PATH:
+		if (p == NULL)
+			{
+			PK11err(PK11_F_CTRL, ERR_R_PASSED_NULL_PARAMETER);
+			return 0;
+			}
+
+		if (initialized)
+			{
+			PK11err(PK11_F_CTRL, PK11_R_ALREADY_LOADED);
+			return 0;
+			}
+
+		return set_PK11_LIBNAME((const char*)p);
+	case PK11_CMD_PIN:
+		if (pk11_pin) {
+			memset(pk11_pin, 0, strlen(pk11_pin));
+			OPENSSL_free((void*)pk11_pin);
+		}
+		pk11_pin = NULL;
+
+		if (p == NULL)
+			{
+			PK11err(PK11_F_CTRL, ERR_R_PASSED_NULL_PARAMETER);
+			return 0;
+			}
+
+		pk11_pin = BUF_strdup(p);
+		if (pk11_pin == NULL)
+			{
+			PK11err(PK11_F_GET_SESSION, PK11_R_MALLOC_FAILURE);
+			return 0;
+			}
+		return 1;
+	case PK11_CMD_SLOT:
+		SLOTID = (CK_SLOT_ID)i;
+#ifdef DEBUG_SLOT_SELECTION
+		fprintf(stderr, "OPENSSL_PKCS#11_ENGINE: slot set\n");
+#endif
+		return 1;
+	default:
+		break;
+		}
+
+	PK11err(PK11_F_CTRL,PK11_R_CTRL_COMMAND_NOT_IMPLEMENTED);
+
+	return 0;
+	}
+
+
+/* Required function by the engine random interface. It does nothing here
+ */
+static void pk11_rand_cleanup(void)
+	{
+	return;
+	}
+
+static void pk11_rand_add(const void *buf, int num, double add)
+	{
+	PK11_SESSION *sp;
+
+	if ((sp = pk11_get_session()) == NULL)
+		return;
+
+	/* Ignore any errors (e.g. CKR_RANDOM_SEED_NOT_SUPPORTED) since 
+	 * the calling functions do not care anyway
+	 */
+	pFuncList->C_SeedRandom(sp->session, (unsigned char *) buf, num);
+	pk11_return_session(sp);
+
+	return;
+	}
+
+static void pk11_rand_seed(const void *buf, int num)
+	{
+	pk11_rand_add(buf, num, 0);
+	}
+
+static int pk11_rand_bytes(unsigned char *buf, int num)
+	{
+	CK_RV rv;
+	PK11_SESSION *sp;
+	
+	if ((sp = pk11_get_session()) == NULL)
+		return 0;
+	
+	rv = pFuncList->C_GenerateRandom(sp->session, buf, num);
+	if (rv != CKR_OK)
+		{
+		char tmp_buf[20];
+		PK11err(PK11_F_RAND_BYTES, PK11_R_GENERATERANDOM);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		pk11_return_session(sp);
+		return 0;
+		}
+
+	pk11_return_session(sp);
+	return 1;
+	}
+
+
+/* Required function by the engine random interface. It does nothing here
+ */
+static int pk11_rand_status(void)
+	{
+	return 1;
+	}
+
+
+PK11_SESSION *pk11_get_session()
+	{
+	PK11_SESSION *sp, *sp1;
+	CK_RV rv;
+	char tmp_buf[20];
+
+	CRYPTO_w_lock(CRYPTO_LOCK_PK11_ENGINE);
+	if ((sp = free_session) == NULL)
+		{
+		if ((sp = OPENSSL_malloc(sizeof(PK11_SESSION))) == NULL)
+			{
+			PK11err(PK11_F_GET_SESSION, 
+				PK11_R_MALLOC_FAILURE);
+			goto err;
+			}
+		memset(sp, 0, sizeof(PK11_SESSION));
+		}
+	else
+		{
+		free_session = sp->next;
+		}
+
+	if (sp->pid != 0 && sp->pid != getpid())
+		{
+		/* We are a new process and thus need to free any inherated
+		 * PK11_SESSION objects.
+		 */
+		while ((sp1 = free_session) != NULL)
+			{
+			free_session = sp1->next;
+			OPENSSL_free(sp1);
+			}
+
+		/* Initialize the process */
+		rv = pFuncList->C_Initialize(NULL_PTR);
+		if ((rv != CKR_OK) && (rv != CKR_CRYPTOKI_ALREADY_INITIALIZED))
+			{
+			PK11err(PK11_F_GET_SESSION, PK11_R_INITIALIZE);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			OPENSSL_free(sp);
+			sp = NULL;
+			goto err;
+			}
+
+		/* Choose slot here since the slot table is different on 
+		 * this process.
+		 */
+		if (pk11_choose_slot() == 0)
+			goto err;
+
+		/* Open the global_session for the new process */
+		rv = pFuncList->C_OpenSession(SLOTID, CKF_SERIAL_SESSION,
+			NULL_PTR, NULL_PTR, &global_session);
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_GET_SESSION, PK11_R_OPENSESSION);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			OPENSSL_free(sp);
+			sp = NULL;
+			goto err;
+			}
+
+		/* It is an inherited session and needs re-initialization.
+		 */
+		if (pk11_setup_session(sp) == 0)
+			{
+			OPENSSL_free(sp);
+			sp = NULL;
+			}
+		}
+	else if (sp->pid == 0)
+		{
+		/* It is a new session and needs initialization.
+		 */
+		if (pk11_setup_session(sp) == 0)
+			{
+			OPENSSL_free(sp);
+			sp = NULL;
+			}
+		}
+
+err:
+	if (sp)
+		sp->next = NULL;
+
+	CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+
+	return sp;
+	}
+
+
+void pk11_return_session(PK11_SESSION *sp)
+	{
+	if (sp == NULL || sp->pid != getpid())
+		return;
+
+	
+	CRYPTO_w_lock(CRYPTO_LOCK_PK11_ENGINE);
+
+	sp->next = free_session;
+	free_session = sp;
+
+	CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+	}
+
+
+/* Destroy all objects. This function is called when the engine is finished
+ */
+static int pk11_free_all_sessions()
+	{
+	CK_RV rv;
+	PK11_SESSION *sp = NULL;
+	pid_t mypid = getpid();
+	int ret = 0;
+
+	pk11_destroy_rsa_key_objects(NULL);
+	pk11_destroy_dsa_key_objects(NULL);
+	pk11_destroy_dh_key_objects(NULL);
+	pk11_destroy_cipher_key_objects(NULL);
+	
+	CRYPTO_w_lock(CRYPTO_LOCK_PK11_ENGINE);
+	while ((sp = free_session) != NULL)
+		{
+		if (sp->session != CK_INVALID_HANDLE && sp->pid == mypid)
+			{
+			rv = pFuncList->C_CloseSession(sp->session);
+			if (rv != CKR_OK)
+				{
+				char tmp_buf[20];
+				PK11err(PK11_F_FREE_ALL_SESSIONS, 
+					PK11_R_CLOSESESSION);
+				snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+				ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+				}
+			}
+		if (sp->session_cipher != CK_INVALID_HANDLE && sp->pid == mypid)
+			{
+			rv = pFuncList->C_CloseSession(sp->session_cipher);
+			if (rv != CKR_OK)
+				{
+				char tmp_buf[20];
+				PK11err(PK11_F_FREE_ALL_SESSIONS, 
+					PK11_R_CLOSESESSION);
+				snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+				ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+				}
+			}
+		free_session = sp->next;
+		OPENSSL_free(sp);
+		}
+	ret = 1;
+err:
+	CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+
+	return ret;
+	}
+
+
+static int pk11_setup_session(PK11_SESSION *sp)
+	{
+	CK_RV rv;
+	sp->session = CK_INVALID_HANDLE;
+	rv = pFuncList->C_OpenSession(SLOTID, CKF_SERIAL_SESSION,
+		NULL_PTR, NULL_PTR, &sp->session);
+	if (rv == CKR_CRYPTOKI_NOT_INITIALIZED)
+		{
+		/*
+		 * We are probably a child process so force the
+		 * reinitialize of the session
+		 */
+		pk11_library_initialized = 0;
+		(void) pk11_library_init(NULL);
+		rv = pFuncList->C_OpenSession(SLOTID, CKF_SERIAL_SESSION,
+			NULL_PTR, NULL_PTR, &sp->session);
+		}
+	if (rv != CKR_OK)
+		{
+		char tmp_buf[20];
+		PK11err(PK11_F_SETUP_SESSION, PK11_R_OPENSESSION);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		return 0;
+		}
+
+	sp->session_cipher = CK_INVALID_HANDLE;
+	rv = pFuncList->C_OpenSession(SLOTID, CKF_SERIAL_SESSION,
+		NULL_PTR, NULL_PTR, &sp->session_cipher);
+	if (rv != CKR_OK)
+		{
+		char tmp_buf[20];
+
+		(void) pFuncList->C_CloseSession(sp->session);
+		sp->session = CK_INVALID_HANDLE;
+
+		PK11err(PK11_F_SETUP_SESSION, PK11_R_OPENSESSION);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		return 0;
+		}
+
+	sp->pid = getpid();
+	sp->rsa_pub_key = CK_INVALID_HANDLE;
+	sp->rsa_priv_key = CK_INVALID_HANDLE;
+	sp->dsa_pub_key = CK_INVALID_HANDLE;
+	sp->dsa_priv_key = CK_INVALID_HANDLE;
+	sp->dh_key = CK_INVALID_HANDLE;
+	sp->cipher_key = CK_INVALID_HANDLE;
+	sp->rsa = NULL;
+	sp->dsa = NULL;
+	sp->dh = NULL;
+	sp->encrypt = -1;
+
+	return 1;
+	}
+
+int pk11_destroy_rsa_key_objects(PK11_SESSION *session)
+	{
+	int ret = 0;
+	PK11_SESSION *sp = NULL;
+	PK11_SESSION *local_free_session;
+
+	CRYPTO_w_lock(CRYPTO_LOCK_PK11_ENGINE);
+	if (session)
+		local_free_session = session;
+	else
+		local_free_session = free_session;
+	while ((sp = local_free_session) != NULL)
+		{
+		local_free_session = sp->next;
+
+		if (sp->rsa_pub_key != CK_INVALID_HANDLE)
+			{
+			if (pk11_destroy_object(sp->session, 
+				sp->rsa_pub_key) == 0)
+				goto err;
+			sp->rsa_pub_key = CK_INVALID_HANDLE;
+			}
+
+		if (sp->rsa_priv_key != CK_INVALID_HANDLE)
+			{
+			if ((sp->rsa->flags & RSA_FLAG_EXT_PKEY) == 0 &&
+			    pk11_destroy_object(sp->session, 
+				sp->rsa_priv_key) == 0)
+				goto err;
+			sp->rsa_priv_key = CK_INVALID_HANDLE;
+			}
+
+		sp->rsa = NULL;
+		}
+	ret = 1;
+err:
+	CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+
+	return ret;
+	}
+
+int pk11_destroy_dsa_key_objects(PK11_SESSION *session)
+	{
+	int ret = 0;
+	PK11_SESSION *sp = NULL;
+	PK11_SESSION *local_free_session;
+
+	CRYPTO_w_lock(CRYPTO_LOCK_PK11_ENGINE);
+	if (session)
+		local_free_session = session;
+	else
+		local_free_session = free_session;
+	while ((sp = local_free_session) != NULL)
+		{
+		local_free_session = sp->next;
+
+		if (sp->dsa_pub_key != CK_INVALID_HANDLE)
+			{
+			if (pk11_destroy_object(sp->session, 
+				sp->dsa_pub_key) == 0)
+				goto err;
+			sp->dsa_pub_key = CK_INVALID_HANDLE;
+			}
+
+		if (sp->dsa_priv_key != CK_INVALID_HANDLE)
+			{
+			if (pk11_destroy_object(sp->session, 
+				sp->dsa_priv_key) == 0)
+				goto err;
+			sp->dsa_priv_key = CK_INVALID_HANDLE;
+			}
+
+		sp->dsa = NULL;
+		}
+	ret = 1;
+err:
+	CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+
+	return ret;
+	}
+
+int pk11_destroy_dh_key_objects(PK11_SESSION *session)
+	{
+	int ret = 0;
+	PK11_SESSION *sp = NULL;
+	PK11_SESSION *local_free_session;
+
+	CRYPTO_w_lock(CRYPTO_LOCK_PK11_ENGINE);
+	if (session)
+		local_free_session = session;
+	else
+		local_free_session = free_session;
+	while ((sp = local_free_session) != NULL)
+		{
+		local_free_session = sp->next;
+
+		if (sp->dh_key != CK_INVALID_HANDLE)
+			{
+			if (pk11_destroy_object(sp->session, 
+				sp->dh_key) == 0)
+				goto err;
+			sp->dh_key = CK_INVALID_HANDLE;
+			}
+
+		sp->dh = NULL;
+		}
+	ret = 1;
+err:
+	CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+
+	return ret;
+	}
+
+static int pk11_destroy_object(CK_SESSION_HANDLE session, CK_OBJECT_HANDLE oh)
+	{
+	CK_RV rv;
+	rv = pFuncList->C_DestroyObject(session, oh);
+	if (rv != CKR_OK)
+		{
+		char tmp_buf[20];
+		PK11err(PK11_F_DESTROY_OBJECT, PK11_R_DESTROYOBJECT);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", 
+			tmp_buf);
+		return 0;
+		}
+
+	return 1;
+	}
+
+
+/* Symmetric ciphers and digests support functions
+ */
+
+static int
+cipher_nid_to_pk11(int nid)
+	{
+	int i;
+
+	for (i = 0; i < PK11_CIPHER_MAX; i++)
+		if (ciphers[i].nid == nid)
+			return (ciphers[i].id);
+	return (-1);
+	}
+
+static int
+pk11_usable_ciphers(const int **nids)
+	{
+	if (cipher_count > 0)
+		*nids = cipher_nids;
+	else
+		*nids = NULL;
+	return (cipher_count);
+	}
+
+static int
+pk11_usable_digests(const int **nids)
+	{
+	if (digest_count > 0)
+		*nids = digest_nids;
+	else
+		*nids = NULL;
+	return (digest_count);
+	}
+
+static int
+pk11_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+    const unsigned char *iv, int enc)
+	{
+	CK_RV rv;
+	CK_MECHANISM mech;
+	int index;
+	PK11_CIPHER_STATE *state = (PK11_CIPHER_STATE *) ctx->cipher_data;
+	PK11_SESSION *sp;
+	PK11_CIPHER *pcp;
+	char tmp_buf[20];
+	
+	state->sp = NULL;
+
+	index = cipher_nid_to_pk11(ctx->cipher->nid);
+	if (index < 0 || index >= PK11_CIPHER_MAX)
+		return 0;
+
+	pcp = &ciphers[index];
+	if (ctx->cipher->iv_len > pcp->ivmax || ctx->key_len != pcp->key_len)
+		return 0;
+
+	if ((sp = pk11_get_session()) == NULL)
+		return 0;
+
+	/* if applicable, the mechanism parameter is used for IV */
+	mech.mechanism = pcp->mech_type;
+	mech.pParameter = NULL;
+	mech.ulParameterLen = 0;
+
+	/* The key object is destroyed here if it is not the current key
+	 */
+	check_new_cipher_key(sp, key);
+	
+	/* If the key is the same and the encryption is also the same,
+	 * then just reuse it
+	 */
+	if (sp->cipher_key != CK_INVALID_HANDLE && sp->encrypt == ctx->encrypt)
+		{
+		state->sp = sp;
+		return 1;
+		}
+
+	/* Check if the key has been invalidated. If so, a new key object
+	 * needs to be created.
+	 */
+	if (sp->cipher_key == CK_INVALID_HANDLE)
+		{
+		sp->cipher_key = pk11_get_cipher_key(
+			ctx, key, pcp->key_type, sp);
+		}
+
+	if (sp->encrypt != ctx->encrypt && sp->encrypt != -1)
+		{
+		/* The previous encryption/decryption
+		 * is different. Need to terminate the previous
+		 * active encryption/decryption here
+		 */
+		if (!pk11_cipher_final(sp))
+			{
+			pk11_return_session(sp);
+			return 0;
+			}
+		}
+
+	if (sp->cipher_key == CK_INVALID_HANDLE)
+		{
+		pk11_return_session(sp);
+		return 0;
+		}
+
+	if (ctx->cipher->iv_len > 0)
+		{
+		mech.pParameter = (void *) ctx->iv;
+		mech.ulParameterLen = ctx->cipher->iv_len;
+		}
+
+	/* If we get here, the encryption needs to be reinitialized */
+	if (ctx->encrypt)
+		{
+		rv = pFuncList->C_EncryptInit(sp->session_cipher, &mech, 
+			sp->cipher_key);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_CIPHER_INIT, PK11_R_ENCRYPTINIT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			pk11_return_session(sp);
+			return 0;
+			}
+		}
+	else
+		{
+		rv = pFuncList->C_DecryptInit(sp->session_cipher, &mech, 
+			sp->cipher_key);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_CIPHER_INIT, PK11_R_DECRYPTINIT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			pk11_return_session(sp);
+			return 0;
+			}
+		}
+
+	sp->encrypt = ctx->encrypt;
+	state->sp = sp;
+
+	return 1;
+	}
+
+/* When reusing the same key in an encryption/decryption session for a 
+ * decryption/encryption session, we need to close the active session
+ * and recreate a new one. Note that the key is in the global session so
+ * that it needs not be recreated.
+ *
+ * It is more appropriate to use C_En/DecryptFinish here. At the time of this
+ * development, these two functions in the PKCS#11 libraries used return
+ * unexpected errors when passing in 0 length output. It may be a good
+ * idea to try them again if performance is a problem here and fix
+ * C_En/DecryptFinial if there are bugs there causing the problem.
+ */
+static int
+pk11_cipher_final(PK11_SESSION *sp)
+	{
+	CK_RV rv;
+	char tmp_buf[20];
+
+	rv = pFuncList->C_CloseSession(sp->session_cipher);
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_CIPHER_FINAL, PK11_R_CLOSESESSION);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		return 0;
+		}
+
+	rv = pFuncList->C_OpenSession(SLOTID, CKF_SERIAL_SESSION,
+		NULL_PTR, NULL_PTR, &sp->session_cipher);
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_CIPHER_FINAL, PK11_R_OPENSESSION);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		return 0;
+		}
+
+	return 1;
+	}
+
+/* An engine interface function. The calling function allocates sufficient
+ * memory for the output buffer "out" to hold the results */
+static int
+pk11_cipher_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+	const unsigned char *in, unsigned int inl)
+	{
+	PK11_CIPHER_STATE *state = (PK11_CIPHER_STATE *) ctx->cipher_data;
+	PK11_SESSION *sp;
+	CK_RV rv;
+	unsigned long outl = inl;
+	char tmp_buf[20];
+
+	if (state == NULL || state->sp == NULL)
+		return 0;
+
+	sp = (PK11_SESSION *) state->sp;
+
+	if (!inl)
+		return 1;
+
+	/* RC4 is the only stream cipher we support */
+	if (ctx->cipher->nid != NID_rc4 && (inl % ctx->cipher->block_size) != 0)
+		return 0;
+
+	if (ctx->encrypt)
+		{
+		rv = pFuncList->C_EncryptUpdate(sp->session_cipher, 
+			(unsigned char *)in, inl, out, &outl);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_CIPHER_DO_CIPHER, 
+				PK11_R_ENCRYPTUPDATE);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			return 0;
+			}
+		}
+	else
+		{
+		rv = pFuncList->C_DecryptUpdate(sp->session_cipher, 
+			(unsigned char *)in, inl, out, &outl);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_CIPHER_DO_CIPHER, 
+				PK11_R_DECRYPTUPDATE);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			return 0;
+			}
+		}
+
+	/* for DES_CBC, DES3_CBC, AES_CBC, and RC4, the output size is always
+	 * the same size of input
+	 * The application has guaranteed to call the block ciphers with 
+	 * correctly aligned buffers.
+	 */
+	if (inl != outl)
+		return 0;
+
+	return 1;
+	}
+
+/* Return the session to the pool. The C_EncryptFinal and C_DecryptFinal are
+ * not used. Once a secret key is initialized, it is used until destroyed.
+ */
+static int
+pk11_cipher_cleanup(EVP_CIPHER_CTX *ctx)
+	{
+	PK11_CIPHER_STATE *state = ctx->cipher_data;
+
+	if (state != NULL && state->sp != NULL)
+		{
+		pk11_return_session(state->sp);
+		state->sp = NULL;
+		}
+
+	return 1;
+	}
+
+/* Registered by the ENGINE when used to find out how to deal with
+ * a particular NID in the ENGINE. This says what we'll do at the
+ * top level - note, that list is restricted by what we answer with
+ */
+static int
+pk11_engine_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
+	const int **nids, int nid)
+	{
+	if (!cipher)
+		return (pk11_usable_ciphers(nids));
+
+	switch (nid)
+		{
+		case NID_des_ede3_cbc:
+			*cipher = &pk11_3des_cbc;
+			break;
+		case NID_des_cbc:
+			*cipher = &pk11_des_cbc;
+			break;
+		case NID_aes_128_cbc:
+			*cipher = &pk11_aes_cbc;
+			break;
+		case NID_rc4:
+			*cipher = &pk11_rc4;
+			break;
+		default:
+			*cipher = NULL;
+			break;
+		}
+	return (*cipher != NULL);
+	}
+
+static int
+pk11_engine_digests(ENGINE *e, const EVP_MD **digest,
+	const int **nids, int nid)
+	{
+	if (!digest)
+		return (pk11_usable_digests(nids));
+
+	switch (nid)
+		{
+		case NID_md5:
+			*digest = &pk11_md5; 
+			break;
+		case NID_sha1:
+			*digest = &pk11_sha1; 
+			break;
+		default:
+			*digest = NULL;
+			break;
+		}
+	return (*digest != NULL);
+	}
+
+
+/* Create a secret key object in a PKCS#11 session
+ */
+static CK_OBJECT_HANDLE pk11_get_cipher_key(EVP_CIPHER_CTX *ctx, 
+	const unsigned char *key, CK_KEY_TYPE key_type, PK11_SESSION *sp)
+	{
+	CK_RV rv;
+	CK_OBJECT_HANDLE h_key = CK_INVALID_HANDLE;
+	CK_OBJECT_CLASS obj_key = CKO_SECRET_KEY;
+	CK_ULONG ul_key_attr_count = 6;
+	char tmp_buf[20];
+
+	CK_ATTRIBUTE  a_key_template[] =
+		{
+		{CKA_CLASS, (void*) NULL, sizeof(CK_OBJECT_CLASS)},
+		{CKA_KEY_TYPE, (void*) NULL, sizeof(CK_KEY_TYPE)},
+		{CKA_TOKEN, &false, sizeof(false)},
+		{CKA_ENCRYPT, &true, sizeof(true)},
+		{CKA_DECRYPT, &true, sizeof(true)},
+		{CKA_VALUE, (void*) NULL, 0},
+		};
+
+	/* Create secret key object in global_session. All other sessions
+	 * can use the key handles. Here is why:
+	 * OpenSSL will call EncryptInit and EncryptUpdate using a secret key.
+	 * It may then call DecryptInit and DecryptUpdate using the same key.
+	 * To use the same key object, we need to call EncryptFinal with
+	 * a 0 length message. Currently, this does not work for 3DES 
+	 * mechanism. To get around this problem, we close the session and
+	 * then create a new session to use the same key object. When a session
+	 * is closed, all the object handles will be invalid. Thus, create key 
+	 * objects in a global session, an individual session may be closed to
+	 * terminate the active operation.
+	 */
+	CK_SESSION_HANDLE session = global_session;
+	a_key_template[0].pValue = &obj_key;
+	a_key_template[1].pValue = &key_type;
+	a_key_template[5].pValue = (void *) key;
+	a_key_template[5].ulValueLen = (unsigned long) ctx->key_len;
+
+	rv = pFuncList->C_CreateObject(session, 
+		a_key_template, ul_key_attr_count, &h_key);
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_CIPHER_KEY, PK11_R_CREATEOBJECT);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	/* Save the key information used in this session.
+	 * The max can be saved is PK11_KEY_LEN_MAX.
+	 */
+	sp->key_len = ctx->key_len > PK11_KEY_LEN_MAX ? 
+		PK11_KEY_LEN_MAX : ctx->key_len;
+	memcpy(sp->key, key, sp->key_len);
+err:
+
+	return h_key;
+	}
+
+static int
+md_nid_to_pk11(int nid)
+	{
+	int i;
+
+	for (i = 0; i < PK11_DIGEST_MAX; i++)
+		if (digests[i].nid == nid)
+			return (digests[i].id);
+	return (-1);
+	}
+
+static int 
+pk11_digest_init(EVP_MD_CTX *ctx)
+        { 
+	CK_RV rv;
+	CK_MECHANISM mech;
+	int index;
+	PK11_SESSION *sp;
+	PK11_DIGEST *pdp;
+	PK11_CIPHER_STATE *state = (PK11_CIPHER_STATE *) ctx->md_data;
+	
+	state->sp = NULL;
+
+	index = md_nid_to_pk11(ctx->digest->type);
+	if (index < 0 || index >= PK11_DIGEST_MAX)
+		return 0;
+
+	pdp = &digests[index];
+	if ((sp = pk11_get_session()) == NULL)
+		return 0;
+
+	/* at present, no parameter is needed for supported digests */
+	mech.mechanism = pdp->mech_type;
+	mech.pParameter = NULL;
+	mech.ulParameterLen = 0;
+
+	rv = pFuncList->C_DigestInit(sp->session, &mech);
+
+	if (rv != CKR_OK)
+		{
+		char tmp_buf[20];
+		PK11err(PK11_F_DIGEST_INIT, PK11_R_DIGESTINIT);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		pk11_return_session(sp);
+		return 0;
+		}
+
+	state->sp = sp;
+
+	return 1;
+	}
+
+static int 
+pk11_digest_update(EVP_MD_CTX *ctx,const void *data,size_t count)
+        { 
+	CK_RV rv;
+	PK11_CIPHER_STATE *state = (PK11_CIPHER_STATE *) ctx->md_data;
+	
+	/* 0 length message will cause a failure in C_DigestFinal */
+	if (count == 0)
+		return 1;
+
+	if (state == NULL || state->sp == NULL)
+		return 0;
+
+	rv = pFuncList->C_DigestUpdate(state->sp->session, (CK_BYTE *) data,
+		count);
+
+	if (rv != CKR_OK)
+		{
+		char tmp_buf[20];
+		PK11err(PK11_F_DIGEST_UPDATE, PK11_R_DIGESTUPDATE);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		pk11_return_session(state->sp);
+		state->sp = NULL;
+		return 0;
+		}
+
+	return 1;
+	}
+
+static int 
+pk11_digest_final(EVP_MD_CTX *ctx,unsigned char *md)
+        { 
+	CK_RV rv;
+	unsigned long len;
+	PK11_CIPHER_STATE *state = (PK11_CIPHER_STATE *) ctx->md_data;
+	len = ctx->digest->md_size;
+	
+	if (state == NULL || state->sp == NULL)
+		return 0;
+
+	rv = pFuncList->C_DigestFinal(state->sp->session, md, &len);
+
+	if (rv != CKR_OK)
+		{
+		char tmp_buf[20];
+		PK11err(PK11_F_DIGEST_FINAL, PK11_R_DIGESTFINAL);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		pk11_return_session(state->sp);
+		state->sp = NULL;
+		return 0;
+		}
+
+	if (ctx->digest->md_size != len)
+		return 0;
+
+	/* Final is called and digest is returned, so return the session
+	 * to the pool
+	 */
+	pk11_return_session(state->sp);
+	state->sp = NULL;
+
+	return 1;
+	}
+
+static int 
+pk11_digest_copy(EVP_MD_CTX *to,const EVP_MD_CTX *from)
+        { 
+	CK_RV rv;
+	int ret = 0;
+	PK11_CIPHER_STATE *state, *state_to;
+	CK_BYTE_PTR pstate = NULL;
+	CK_ULONG ul_state_len;
+	char tmp_buf[20];
+	
+	/* The copy-from state */
+	state = (PK11_CIPHER_STATE *) from->md_data;
+	if (state == NULL || state->sp == NULL)
+		goto err;
+
+	/* Initialize the copy-to state */
+	if (!pk11_digest_init(to))
+		goto err;
+	state_to = (PK11_CIPHER_STATE *) to->md_data;
+
+	/* Get the size of the operation state of the copy-from session */
+	rv = pFuncList->C_GetOperationState(state->sp->session, NULL, 
+		&ul_state_len);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_DIGEST_COPY, PK11_R_GET_OPERATION_STATE);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+	if (ul_state_len == 0)
+		{
+		goto err;
+		}
+
+	pstate = OPENSSL_malloc(ul_state_len);
+	if (pstate == NULL)
+		{
+		RSAerr(PK11_F_DIGEST_COPY, PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	/* Get the operation state of the copy-from session */
+	rv = pFuncList->C_GetOperationState(state->sp->session, pstate, 
+		&ul_state_len);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_DIGEST_COPY, PK11_R_GET_OPERATION_STATE);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	/* Set the operation state of the copy-to session */
+	rv = pFuncList->C_SetOperationState(state_to->sp->session, pstate, 
+		ul_state_len, 0, 0);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_DIGEST_COPY, PK11_R_SET_OPERATION_STATE);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	ret = 1;
+err:
+	if (pstate != NULL)
+		OPENSSL_free(pstate);
+
+	return ret;
+	}
+
+/* Return any pending session state to the pool */
+static int
+pk11_digest_cleanup(EVP_MD_CTX *ctx)
+	{
+	PK11_CIPHER_STATE *state = ctx->md_data;
+	unsigned char buf[EVP_MAX_MD_SIZE];
+
+	if (state != NULL && state->sp != NULL)
+		{
+		/*
+		 * If state->sp is not NULL then pk11_digest_final() has not
+		 * been called yet. We must call it now to free any memory
+		 * that might have been allocated in the token when
+		 * pk11_digest_init() was called.
+		 */
+		pk11_digest_final(ctx,buf);
+		pk11_return_session(state->sp);
+		state->sp = NULL;
+		}
+
+	return 1;
+	}
+
+/* Check if the new key is the same as the key object in the session.
+ * If the key is the same, no need to create a new key object. Otherwise,
+ * the old key object needs to be destroyed and a new one will be created
+ */
+static void check_new_cipher_key(PK11_SESSION *sp, const unsigned char *key)
+	{
+	if (memcmp(sp->key, key, sp->key_len) != 0)
+		pk11_destroy_cipher_key_objects(sp);
+	}
+
+/* Destroy one or more secret key objects. 
+ */
+static int pk11_destroy_cipher_key_objects(PK11_SESSION *session)
+	{
+	int ret = 0;
+	PK11_SESSION *sp = NULL;
+	PK11_SESSION *local_free_session;
+
+	CRYPTO_w_lock(CRYPTO_LOCK_PK11_ENGINE);
+	if (session)
+		local_free_session = session;
+	else
+		local_free_session = free_session;
+	while ((sp = local_free_session) != NULL)
+		{
+		local_free_session = sp->next;
+
+		if (sp->cipher_key != CK_INVALID_HANDLE)
+			{
+			/* The secret key object is created in the 
+			 * global_session. See pk11_get_cipher_key
+			 */
+			if (pk11_destroy_object(global_session, 
+				sp->cipher_key) == 0)
+				goto err;
+			sp->cipher_key = CK_INVALID_HANDLE;
+			}
+		}
+	ret = 1;
+err:
+	CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+
+	return ret;
+	}
+
+
+/*
+ * Required mechanisms
+ *
+ * CKM_RSA_X_509
+ * CKM_RSA_PKCS
+ * CKM_DSA
+ *
+ * As long as these required mechanisms are met, it will return success. 
+ * Otherwise, it will return failure and the engine initialization will fail. 
+ * The application will then decide whether to use another engine or 
+ * no engine.
+ *
+ * Symmetric ciphers optionally supported
+ *
+ * CKM_DES3_CBC
+ * CKM_DES_CBC
+ * CKM_AES_CBC
+ * CKM_RC4
+ *
+ * Digests optionally supported
+ *
+ * CKM_MD5
+ * CKM_SHA_1
+ */
+
+static int 
+pk11_choose_slot()
+	{
+	CK_SLOT_ID_PTR pSlotList = NULL_PTR;
+	CK_ULONG ulSlotCount = 0;
+	CK_MECHANISM_INFO mech_info;
+	CK_TOKEN_INFO token_info;
+	int i;
+	CK_RV rv;
+	CK_SLOT_ID best_slot_sofar;
+	CK_BBOOL found_candidate_slot = CK_FALSE;
+	int slot_n_cipher = 0;
+	int slot_n_digest = 0;
+	CK_SLOT_ID current_slot = 0;
+	int current_slot_n_cipher = 0;
+	int current_slot_n_digest = 0;
+
+	int local_cipher_nids[PK11_CIPHER_MAX];
+	int local_digest_nids[PK11_DIGEST_MAX];
+	char tmp_buf[20];
+	int retval = 0;
+
+	if (!pk11_auto_slot)
+		return 1;
+
+	/* Get slot list for memory alloction */
+	rv = pFuncList->C_GetSlotList(0, NULL_PTR, &ulSlotCount);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_CHOOSE_SLOT, PK11_R_GETSLOTLIST);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		return retval;
+		}
+
+	if (ulSlotCount == 0) 
+		{
+		PK11err(PK11_F_CHOOSE_SLOT, PK11_R_GETSLOTLIST);
+		return retval;
+		}
+
+	pSlotList = OPENSSL_malloc(ulSlotCount * sizeof (CK_SLOT_ID));
+
+	if (pSlotList == NULL) 
+		{
+		RSAerr(PK11_F_CHOOSE_SLOT,PK11_R_MALLOC_FAILURE);
+		return retval;
+		}
+
+	/* Get the slot list for processing */
+	rv = pFuncList->C_GetSlotList(0, pSlotList, &ulSlotCount);
+	if (rv != CKR_OK) 
+		{
+		PK11err(PK11_F_CHOOSE_SLOT, PK11_R_GETSLOTLIST);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		OPENSSL_free(pSlotList);
+		return retval;
+		}
+
+	for (i = 0; i < ulSlotCount; i++) 
+		{
+		CK_BBOOL slot_has_rsa = CK_FALSE;
+		CK_BBOOL slot_has_dsa = CK_FALSE;
+		CK_BBOOL slot_has_dh = CK_FALSE;
+		current_slot = pSlotList[i];
+		current_slot_n_cipher = 0;
+		current_slot_n_digest = 0;
+		memset(local_cipher_nids, 0, sizeof(local_cipher_nids));
+		memset(local_digest_nids, 0, sizeof(local_digest_nids));
+
+#ifdef DEBUG_SLOT_SELECTION
+		fprintf(stderr, "OPENSSL_PKCS#11_ENGINE: checking slot: %d\n",
+		    current_slot);
+#endif
+		/* Check if slot has random support. */
+		rv = pFuncList->C_GetTokenInfo(current_slot, &token_info);
+		if (rv != CKR_OK)
+			continue;
+
+		if (token_info.flags & CKF_RNG)
+			pk11_have_random = CK_TRUE;
+
+		/*
+		 * Check if this slot is capable of signing and
+		 * verifying with CKM_RSA_PKCS.
+		 */
+		rv = pFuncList->C_GetMechanismInfo(current_slot, CKM_RSA_PKCS, 
+			&mech_info);
+
+		if (rv == CKR_OK && ((mech_info.flags & CKF_SIGN) &&
+				(mech_info.flags & CKF_VERIFY)))
+			{
+			/*
+			 * Check if this slot is capable of encryption,
+			 * decryption, sign, and verify with CKM_RSA_X_509.
+			 */
+			rv = pFuncList->C_GetMechanismInfo(current_slot,
+			  CKM_RSA_X_509, &mech_info);
+
+			if (rv == CKR_OK && ((mech_info.flags & CKF_SIGN) &&
+			    (mech_info.flags & CKF_VERIFY) &&
+			    (mech_info.flags & CKF_ENCRYPT) &&
+			    (mech_info.flags & CKF_VERIFY_RECOVER) &&
+			    (mech_info.flags & CKF_DECRYPT)))
+				slot_has_rsa = CK_TRUE;
+			}
+
+		/*
+		 * Check if this slot is capable of signing and
+		 * verifying with CKM_DSA.
+		 */
+		rv = pFuncList->C_GetMechanismInfo(current_slot, CKM_DSA, 
+			&mech_info);
+		if (rv == CKR_OK && ((mech_info.flags & CKF_SIGN) &&
+		    (mech_info.flags & CKF_VERIFY)))
+			slot_has_dsa = CK_TRUE;
+
+		/*
+		 * Check if this slot is capable of DH key generataion and
+		 * derivation.
+		 */
+		rv = pFuncList->C_GetMechanismInfo(current_slot,
+		  CKM_DH_PKCS_KEY_PAIR_GEN, &mech_info);
+
+		if (rv == CKR_OK && (mech_info.flags & CKF_GENERATE_KEY_PAIR))
+			{    
+			rv = pFuncList->C_GetMechanismInfo(current_slot,
+				CKM_DH_PKCS_DERIVE, &mech_info);
+			if (rv == CKR_OK && (mech_info.flags & CKF_DERIVE))
+				slot_has_dh = CK_TRUE;
+			}
+
+		if (!found_candidate_slot &&
+		    (slot_has_rsa || slot_has_dsa || slot_has_dh))
+			{
+#ifdef DEBUG_SLOT_SELECTION
+			fprintf(stderr,
+			    "OPENSSL_PKCS#11_ENGINE: potential slot: %d\n",
+			    current_slot);
+#endif
+			best_slot_sofar = current_slot;
+			pk11_have_rsa = slot_has_rsa;
+			pk11_have_dsa = slot_has_dsa;
+			pk11_have_dh = slot_has_dh;
+			found_candidate_slot = CK_TRUE;
+#ifdef DEBUG_SLOT_SELECTION
+			fprintf(stderr,
+		    	    "OPENSSL_PKCS#11_ENGINE: best so far slot: %d\n",
+		    	    best_slot_sofar);
+#endif
+			}
+
+		/* Count symmetric cipher support. */
+		if (!pk11_count_symmetric_cipher(current_slot, CKM_DES_CBC,
+				&current_slot_n_cipher, local_cipher_nids,
+				PK11_DES_CBC))
+			continue;
+		if (!pk11_count_symmetric_cipher(current_slot, CKM_DES3_CBC,
+				&current_slot_n_cipher, local_cipher_nids,
+				PK11_DES3_CBC))
+			continue;
+		if (!pk11_count_symmetric_cipher(current_slot, CKM_AES_CBC,
+				&current_slot_n_cipher, local_cipher_nids,
+				PK11_AES_CBC))
+			continue;
+		if (!pk11_count_symmetric_cipher(current_slot, CKM_RC4,
+				&current_slot_n_cipher, local_cipher_nids,
+				PK11_RC4))
+			continue;
+
+		/* Count digest support */
+		if (!pk11_count_digest(current_slot, CKM_MD5,
+				&current_slot_n_digest, local_digest_nids,
+				PK11_MD5))
+			continue;
+		if (!pk11_count_digest(current_slot, CKM_SHA_1,
+				&current_slot_n_digest, local_digest_nids,
+				PK11_SHA1))
+			continue;
+
+		/*
+		 * If the current slot supports more ciphers/digests than 
+		 * the previous best one we change the current best to this one.
+		 * otherwise leave it where it is.
+		 */
+		if (((current_slot_n_cipher > slot_n_cipher) &&
+		    (current_slot_n_digest > slot_n_digest)) &&
+		    ((slot_has_rsa == pk11_have_rsa) &&
+		     (slot_has_dsa == pk11_have_dsa) &&
+		     (slot_has_dh == pk11_have_dh)))
+			{
+			best_slot_sofar = current_slot;
+			slot_n_cipher = current_slot_n_cipher;
+			slot_n_digest = current_slot_n_digest;
+
+			memcpy(cipher_nids, local_cipher_nids, 
+				sizeof(local_cipher_nids));
+			memcpy(digest_nids, local_digest_nids, 
+				sizeof(local_digest_nids));
+			}
+
+		}
+
+	if (found_candidate_slot)
+		{
+		cipher_count = slot_n_cipher;
+		digest_count = slot_n_digest;
+		SLOTID = best_slot_sofar;
+		retval = 1;
+		}
+	else
+		{
+		cipher_count = 0;
+		digest_count = 0;
+		}
+
+#ifdef DEBUG_SLOT_SELECTION
+	fprintf(stderr,
+	  "OPENSSL_PKCS#11_ENGINE: choose slot: %d\n", SLOTID);
+	fprintf(stderr,
+	  "OPENSSL_PKCS#11_ENGINE: pk11_have_rsa %d\n", pk11_have_rsa);
+	fprintf(stderr,
+	  "OPENSSL_PKCS#11_ENGINE: pk11_have_dsa %d\n", pk11_have_dsa);
+	fprintf(stderr,
+	  "OPENSSL_PKCS#11_ENGINE: pk11_have_dh %d\n", pk11_have_dh);
+	fprintf(stderr,
+	  "OPENSSL_PKCS#11_ENGINE: pk11_have_random %d\n", pk11_have_random);
+#endif /* DEBUG_SLOT_SELECTION */
+		
+	if (pSlotList)
+		OPENSSL_free(pSlotList);
+
+	return retval;
+	}
+
+static int pk11_count_symmetric_cipher(int slot_id, CK_MECHANISM_TYPE mech,
+    int *current_slot_n_cipher, int *local_cipher_nids, int id)
+	{
+	CK_MECHANISM_INFO mech_info;
+	CK_RV rv;
+
+	rv = pFuncList->C_GetMechanismInfo(slot_id, mech, &mech_info);
+
+	if (rv != CKR_OK) 
+		return 0;
+
+	if ((mech_info.flags & CKF_ENCRYPT) &&
+			(mech_info.flags & CKF_DECRYPT))
+		{
+		local_cipher_nids[(*current_slot_n_cipher)++] = ciphers[id].nid;
+		}
+
+	return 1;
+	}
+
+
+static int pk11_count_digest(int slot_id, CK_MECHANISM_TYPE mech,
+    int *current_slot_n_digest, int *local_digest_nids, int id)
+	{
+	CK_MECHANISM_INFO mech_info;
+	CK_RV rv;
+
+	rv = pFuncList->C_GetMechanismInfo(slot_id, mech, &mech_info);
+
+	if (rv != CKR_OK) 
+		return 0;
+
+	if (mech_info.flags & CKF_DIGEST)
+		{
+		local_digest_nids[(*current_slot_n_digest)++] = digests[id].nid;
+		}
+
+	return 1;
+	}
+
+
+#endif
+#endif
+
diff -r -u -N openssl-0.9.8g/crypto/engine/hw_pk11_err.c openssl/crypto/engine/hw_pk11_err.c
--- openssl-0.9.8g/crypto/engine/hw_pk11_err.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl/crypto/engine/hw_pk11_err.c	2007-10-25 01:27:09.000000000 +0200
@@ -0,0 +1,233 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+#pragma ident	"@(#)hw_pk11_err.c	1.2	04/06/22 SMI"
+
+/* crypto/engine/hw_pk11_err.c */
+/* This product includes software developed by the OpenSSL Project for 
+ * use in the OpenSSL Toolkit (http://www.openssl.org/).
+ *
+ * This project also referenced hw_pkcs11-0.9.7b.patch written by 
+ * Afchine Madjlessi.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2001 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include "hw_pk11_err.h"
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+static ERR_STRING_DATA pk11_str_functs[]=
+{
+    {ERR_PACK(0,PK11_F_INIT,0),	            "PK11_INIT"},
+    {ERR_PACK(0,PK11_F_FINISH,0),	    "PK11_FINISH"},
+    {ERR_PACK(0,PK11_F_DESTROY,0),	    "PK11_DESTROY"},
+    {ERR_PACK(0,PK11_F_CTRL,0),	            "PK11_CTRL"},
+    {ERR_PACK(0,PK11_F_RSA_INIT,0),	    "PK11_RSA_INIT"},
+    {ERR_PACK(0,PK11_F_RSA_FINISH,0),	    "PK11_RSA_FINISH"},
+    {ERR_PACK(0,PK11_F_GET_PUB_RSA_KEY,0),  "PK11_GET_PUB_RSA_KEY"},
+    {ERR_PACK(0,PK11_F_GET_PRIV_RSA_KEY,0), "PK11_GET_PRIV_RSA_KEY"},
+    {ERR_PACK(0,PK11_F_RSA_GEN_KEY,0),      "PK11_RSA_GEN_KEY"},
+    {ERR_PACK(0,PK11_F_RSA_PUB_ENC,0),      "PK11_RSA_PUB_ENC"},
+    {ERR_PACK(0,PK11_F_RSA_PRIV_ENC,0),     "PK11_RSA_PRIV_ENC"},
+    {ERR_PACK(0,PK11_F_RSA_PUB_DEC,0),      "PK11_RSA_PUB_DEC"},
+    {ERR_PACK(0,PK11_F_RSA_PRIV_DEC,0),     "PK11_RSA_PRIV_DEC"},
+    {ERR_PACK(0,PK11_F_RSA_SIGN,0),	    "PK11_RSA_SIGN"},
+    {ERR_PACK(0,PK11_F_RSA_VERIFY,0),	    "PK11_RSA_VERIFY"},
+    {ERR_PACK(0,PK11_F_RAND_ADD,0),	    "PK11_RAND_ADD"},
+    {ERR_PACK(0,PK11_F_RAND_BYTES,0),	    "PK11_RAND_BYTES"},
+    {ERR_PACK(0,PK11_F_GET_SESSION,0),      "PK11_GET_SESSION"},
+    {ERR_PACK(0,PK11_F_FREE_SESSION,0),     "PK11_FREE_SESSION"},
+    {ERR_PACK(0,PK11_F_LOAD_PUBKEY,0),      "PK11_LOAD_PUBKEY"},
+    {ERR_PACK(0,PK11_F_LOAD_PRIVKEY,0),     "PK11_LOAD_PRIV_KEY"},
+    {ERR_PACK(0,PK11_F_RSA_PUB_ENC_LOW,0),  "PK11_RSA_PUB_ENC_LOW"},
+    {ERR_PACK(0,PK11_F_RSA_PRIV_ENC_LOW,0), "PK11_RSA_PRIV_ENC_LOW"},
+    {ERR_PACK(0,PK11_F_RSA_PUB_DEC_LOW,0),  "PK11_RSA_PUB_DEC_LOW"},
+    {ERR_PACK(0,PK11_F_RSA_PRIV_DEC_LOW,0), "PK11_RSA_PRIV_DEC_LOW"},
+    {ERR_PACK(0,PK11_F_DSA_SIGN,0),         "PK11_DSA_SIGN"},
+    {ERR_PACK(0,PK11_F_DSA_VERIFY,0),       "PK11_DSA_VERIFY"},
+    {ERR_PACK(0,PK11_F_DSA_INIT,0),         "PK11_DSA_INIT"},
+    {ERR_PACK(0,PK11_F_DSA_FINISH,0),       "PK11_DSA_FINISH"},
+    {ERR_PACK(0,PK11_F_GET_PUB_DSA_KEY,0),  "PK11_GET_PUB_DSA_KEY"},
+    {ERR_PACK(0,PK11_F_GET_PRIV_DSA_KEY,0), "PK11_GET_PRIV_DSA_KEY"},
+    {ERR_PACK(0,PK11_F_DH_INIT,0),          "PK11_DH_INIT"},
+    {ERR_PACK(0,PK11_F_DH_FINISH,0),        "PK11_DH_FINISH"},
+    {ERR_PACK(0,PK11_F_MOD_EXP_DH,0),       "PK11_MOD_EXP_DH"},
+    {ERR_PACK(0,PK11_F_GET_DH_KEY,0),       "PK11_GET_DH_KEY"},
+    {ERR_PACK(0,PK11_F_FREE_ALL_SESSIONS,0),"PK11_FREE_ALL_SESSIONS"},
+    {ERR_PACK(0,PK11_F_SETUP_SESSION,0),    "PK11_SETUP_SESSION"},
+    {ERR_PACK(0,PK11_F_DESTROY_OBJECT,0),   "PK11_DESTROY_OBJECT"},
+    {ERR_PACK(0,PK11_F_CIPHER_INIT,0),      "PK11_CIPHER_INIT"},
+    {ERR_PACK(0,PK11_F_CIPHER_DO_CIPHER,0), "PK11_CIPHER_DO_CIPHER"},
+    {ERR_PACK(0,PK11_F_GET_CIPHER_KEY,0),   "PK11_GET_CIPHER_KEY"},
+    {ERR_PACK(0,PK11_F_DIGEST_INIT,0),      "PK11_DIGEST_INIT"},
+    {ERR_PACK(0,PK11_F_DIGEST_UPDATE,0),    "PK11_DIGEST_UPDATE"},
+    {ERR_PACK(0,PK11_F_DIGEST_FINAL,0),     "PK11_DIGEST_FINAL"},
+    {ERR_PACK(0,PK11_F_CHOOSE_SLOT,0),      "PK11_CHOOSE_SLOT"},
+    {ERR_PACK(0,PK11_F_CIPHER_FINAL,0),     "PK11_CIPHER_FINAL"},
+    {ERR_PACK(0,PK11_F_LIBRARY_INIT,0),     "PK11_LIBRARY_INIT"},
+    {ERR_PACK(0,PK11_F_LOAD,0),             "ENGINE_LOAD_PK11"},
+    {ERR_PACK(0,PK11_F_DH_GEN_KEY,0),       "PK11_DH_GEN_KEY"},
+    {ERR_PACK(0,PK11_F_DH_COMP_KEY,0),      "PK11_DH_COMP_KEY"},
+    {ERR_PACK(0,PK11_F_DIGEST_COPY,0),      "PK11_DIGEST_COPY"},
+    {0,NULL}
+};
+
+static ERR_STRING_DATA pk11_str_reasons[]=
+{
+    {PK11_R_ALREADY_LOADED                 ,"PKCS#11 DSO already loaded"},
+    {PK11_R_DSO_FAILURE                    ,"unable to load PKCS#11 DSO"},
+    {PK11_R_NOT_LOADED                     ,"PKCS#11 DSO not loaded"},
+    {PK11_R_PASSED_NULL_PARAMETER          ,"null parameter passed"},
+    {PK11_R_COMMAND_NOT_IMPLEMENTED        ,"command not implemented"},
+    {PK11_R_INITIALIZE                     ,"C_Initialize failed"},
+    {PK11_R_FINALIZE                       ,"C_Finalize failed"},
+    {PK11_R_GETINFO                        ,"C_GetInfo faile"},
+    {PK11_R_GETSLOTLIST                    ,"C_GetSlotList failed"},
+    {PK11_R_NO_MODULUS_OR_NO_EXPONENT      ,"no modulus or no exponent"},
+    {PK11_R_ATTRIBUT_SENSITIVE_OR_INVALID  ,"attr sensitive or invalid"},
+    {PK11_R_GETATTRIBUTVALUE               ,"C_GetAttributeValue failed"},
+    {PK11_R_NO_MODULUS                     ,"no modulus"},
+    {PK11_R_NO_EXPONENT                    ,"no exponent"},
+    {PK11_R_FINDOBJECTSINIT                ,"C_FindObjectsInit failed"},
+    {PK11_R_FINDOBJECTS                    ,"C_FindObjects failed"},
+    {PK11_R_FINDOBJECTSFINAL               ,"C_FindObjectsFinal failed"},
+    {PK11_R_CREATEOBJECT                   ,"C_CreateObject failed"},
+    {PK11_R_DESTROYOBJECT                  ,"C_DestroyObject failed"},
+    {PK11_R_OPENSESSION                    ,"C_OpenSession failed"},
+    {PK11_R_CLOSESESSION                   ,"C_CloseSession failed"},
+    {PK11_R_ENCRYPTINIT                    ,"C_EncryptInit failed"},
+    {PK11_R_ENCRYPT                        ,"C_Encrypt failed"},
+    {PK11_R_SIGNINIT                       ,"C_SignInit failed"},
+    {PK11_R_SIGN                           ,"C_Sign failed"},
+    {PK11_R_DECRYPTINIT                    ,"C_DecryptInit failed"},
+    {PK11_R_DECRYPT                        ,"C_Decrypt failed"},
+    {PK11_R_VERIFYINIT                     ,"C_VerifyRecover failed"},
+    {PK11_R_VERIFY                         ,"C_Verify failed	"},
+    {PK11_R_VERIFYRECOVERINIT              ,"C_VerifyRecoverInit failed"},
+    {PK11_R_VERIFYRECOVER                  ,"C_VerifyRecover failed"},
+    {PK11_R_GEN_KEY                        ,"C_GenerateKeyPair failed"},
+    {PK11_R_SEEDRANDOM                     ,"C_SeedRandom failed"},
+    {PK11_R_GENERATERANDOM                 ,"C_GenerateRandom failed"},
+    {PK11_R_INVALID_MESSAGE_LENGTH         ,"invalid message length"},
+    {PK11_R_UNKNOWN_ALGORITHM_TYPE         ,"unknown algorithm type"},
+    {PK11_R_UNKNOWN_ASN1_OBJECT_ID         ,"unknown asn1 onject id"},
+    {PK11_R_UNKNOWN_PADDING_TYPE           ,"unknown padding type"},
+    {PK11_R_PADDING_CHECK_FAILED           ,"padding check failed"},
+    {PK11_R_DIGEST_TOO_BIG                 ,"digest too big"},
+    {PK11_R_MALLOC_FAILURE                 ,"malloc failure"},
+    {PK11_R_CTRL_COMMAND_NOT_IMPLEMENTED   ,"ctl command not implemented"},
+    {PK11_R_DATA_GREATER_THAN_MOD_LEN      ,"data is bigger than mod"},
+    {PK11_R_DATA_TOO_LARGE_FOR_MODULUS     ,"data is too larger for mod"},
+    {PK11_R_MISSING_KEY_COMPONENT          ,"a dsa component is missing"},
+    {PK11_R_INVALID_SIGNATURE_LENGTH       ,"invalid signature length"},
+    {PK11_R_INVALID_DSA_SIGNATURE_R        ,"missing r in dsa verify"},
+    {PK11_R_INVALID_DSA_SIGNATURE_S        ,"missing s in dsa verify"},
+    {PK11_R_INCONSISTENT_KEY               ,"inconsistent key type"},
+    {PK11_R_ENCRYPTUPDATE                  ,"C_EncryptUpdate failed"},
+    {PK11_R_DECRYPTUPDATE                  ,"C_DecryptUpdate failed"},
+    {PK11_R_DIGESTINIT                     ,"C_DigestInit failed"},
+    {PK11_R_DIGESTUPDATE                   ,"C_DigestUpdate failed"},
+    {PK11_R_DIGESTFINAL                    ,"C_DigestFinal failed"},
+    {PK11_R_ENCRYPTFINAL                   ,"C_EncryptFinal failed"},
+    {PK11_R_DECRYPTFINAL                   ,"C_DecryptFinal failed"},
+    {PK11_R_NO_PRNG_SUPPORT                ,"Slot does not support PRNG"},
+    {PK11_R_GETTOKENINFO                   ,"C_GetTokenInfo failed"},
+    {PK11_R_DERIVEKEY                      ,"C_DeriveKey failed"},
+    {PK11_R_GET_OPERATION_STATE            ,"C_GetOperationState failed"},
+    {PK11_R_SET_OPERATION_STATE            ,"C_SetOperationState failed"},
+    {0,NULL}
+};
+
+#endif	
+
+static int pk11_lib_error_code=0;
+static int pk11_error_init=1;
+
+static void ERR_load_pk11_strings(void)
+{
+    if (pk11_lib_error_code == 0)
+	pk11_lib_error_code = ERR_get_next_error_library();
+
+    if (pk11_error_init)
+    {
+	pk11_error_init=0;
+#ifndef OPENSSL_NO_ERR
+	ERR_load_strings(pk11_lib_error_code,pk11_str_functs);
+	ERR_load_strings(pk11_lib_error_code,pk11_str_reasons);
+#endif
+    }
+}
+
+static void ERR_unload_pk11_strings(void)
+{
+    if (pk11_error_init == 0)
+    {
+#ifndef OPENSSL_NO_ERR
+	ERR_unload_strings(pk11_lib_error_code,pk11_str_functs);
+	ERR_unload_strings(pk11_lib_error_code,pk11_str_reasons);
+#endif
+	pk11_error_init = 1;
+    }
+}
+
+static void ERR_pk11_error(int function, int reason, char *file, int line)
+{
+    if (pk11_lib_error_code == 0)
+	pk11_lib_error_code=ERR_get_next_error_library();
+    ERR_PUT_error(pk11_lib_error_code,function,reason,file,line);
+}
diff -r -u -N openssl-0.9.8g/crypto/engine/hw_pk11_err.h openssl/crypto/engine/hw_pk11_err.h
--- openssl-0.9.8g/crypto/engine/hw_pk11_err.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl/crypto/engine/hw_pk11_err.h	2008-01-31 16:14:07.000000000 +0100
@@ -0,0 +1,247 @@
+/*
+ * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+#pragma ident	"@(#)hw_pk11_err.h	1.2	04/06/22 SMI"
+
+/* crypto/engine/hw_pk11_err.h */
+/* This product includes software developed by the OpenSSL Project for 
+ * use in the OpenSSL Toolkit (http://www.openssl.org/).
+ *
+ * This project also referenced hw_pkcs11-0.9.7b.patch written by 
+ * Afchine Madjlessi.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2001 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#ifndef HW_PK11_ERR_H
+#define HW_PK11_ERR_H
+
+/* CRYPTO_LOCK_RSA is defined in OpenSSL for RSA method. Since this pk11
+ * engine replaces RSA method, we may reuse this lock here.
+ */
+#define CRYPTO_LOCK_PK11_ENGINE CRYPTO_LOCK_RSA
+
+static void ERR_load_pk11_strings(void);
+static void ERR_pk11_error(int function, int reason, char *file, int line);
+#define PK11err(f,r) ERR_pk11_error((f),(r),__FILE__,__LINE__)
+
+/* Error codes for the PK11 functions. */
+
+/* Function codes. */
+
+#define PK11_F_INIT 				100
+#define PK11_F_FINISH 				101
+#define PK11_F_DESTROY 				102
+#define PK11_F_CTRL 				103
+#define PK11_F_RSA_INIT 			104
+#define PK11_F_RSA_FINISH 			105
+#define PK11_F_GET_PUB_RSA_KEY 			106
+#define PK11_F_GET_PRIV_RSA_KEY 		107
+#define PK11_F_RSA_GEN_KEY 			108
+#define PK11_F_RSA_PUB_ENC 			109
+#define PK11_F_RSA_PRIV_ENC 			110
+#define PK11_F_RSA_PUB_DEC 			111
+#define PK11_F_RSA_PRIV_DEC 			112
+#define PK11_F_RSA_SIGN 			113
+#define PK11_F_RSA_VERIFY 			114
+#define PK11_F_RAND_ADD 			115
+#define PK11_F_RAND_BYTES 			116
+#define PK11_F_GET_SESSION 			117
+#define PK11_F_FREE_SESSION 			118
+#define PK11_F_LOAD_PUBKEY 			119
+#define PK11_F_LOAD_PRIVKEY 			120
+#define PK11_F_RSA_PUB_ENC_LOW 			121
+#define PK11_F_RSA_PRIV_ENC_LOW 		122
+#define PK11_F_RSA_PUB_DEC_LOW 			123
+#define PK11_F_RSA_PRIV_DEC_LOW 		124
+#define PK11_F_DSA_SIGN				125
+#define PK11_F_DSA_VERIFY			126
+#define PK11_F_DSA_INIT				127
+#define PK11_F_DSA_FINISH			128
+#define PK11_F_GET_PUB_DSA_KEY 			129
+#define PK11_F_GET_PRIV_DSA_KEY 		130
+#define PK11_F_DH_INIT 				131
+#define PK11_F_DH_FINISH 			132
+#define PK11_F_MOD_EXP_DH 			133
+#define PK11_F_GET_DH_KEY 			134
+#define PK11_F_FREE_ALL_SESSIONS		135
+#define PK11_F_SETUP_SESSION			136
+#define PK11_F_DESTROY_OBJECT			137
+#define PK11_F_CIPHER_INIT			138
+#define PK11_F_CIPHER_DO_CIPHER			139
+#define PK11_F_GET_CIPHER_KEY			140
+#define PK11_F_DIGEST_INIT			141
+#define PK11_F_DIGEST_UPDATE			142
+#define PK11_F_DIGEST_FINAL			143
+#define PK11_F_CHOOSE_SLOT			144
+#define PK11_F_CIPHER_FINAL			145
+#define PK11_F_LIBRARY_INIT 			146
+#define PK11_F_LOAD 				147
+#define PK11_F_DH_GEN_KEY			148
+#define PK11_F_DH_COMP_KEY 			149
+#define PK11_F_DIGEST_COPY 			150
+
+/* Reason codes. */
+#define PK11_R_ALREADY_LOADED 			100
+#define PK11_R_DSO_FAILURE 			101
+#define PK11_R_NOT_LOADED 			102
+#define PK11_R_PASSED_NULL_PARAMETER 		103
+#define PK11_R_COMMAND_NOT_IMPLEMENTED 		104
+#define PK11_R_INITIALIZE 			105
+#define PK11_R_FINALIZE 			106
+#define PK11_R_GETINFO 				107
+#define PK11_R_GETSLOTLIST 			108
+#define PK11_R_NO_MODULUS_OR_NO_EXPONENT 	109
+#define PK11_R_ATTRIBUT_SENSITIVE_OR_INVALID 	110
+#define PK11_R_GETATTRIBUTVALUE 		111
+#define PK11_R_NO_MODULUS 			112
+#define PK11_R_NO_EXPONENT 			113
+#define PK11_R_FINDOBJECTSINIT 			114
+#define PK11_R_FINDOBJECTS 			115
+#define PK11_R_FINDOBJECTSFINAL 		116
+#define PK11_R_CREATEOBJECT 			118
+#define PK11_R_DESTROYOBJECT 			119
+#define PK11_R_OPENSESSION 			120
+#define PK11_R_CLOSESESSION 			121
+#define PK11_R_ENCRYPTINIT 			122
+#define PK11_R_ENCRYPT 				123
+#define PK11_R_SIGNINIT 			124
+#define PK11_R_SIGN 				125
+#define PK11_R_DECRYPTINIT 			126
+#define PK11_R_DECRYPT 				127
+#define PK11_R_VERIFYINIT 			128
+#define PK11_R_VERIFY 				129
+#define PK11_R_VERIFYRECOVERINIT 		130
+#define PK11_R_VERIFYRECOVER 			131
+#define PK11_R_GEN_KEY 				132
+#define PK11_R_SEEDRANDOM 			133
+#define PK11_R_GENERATERANDOM 			134
+#define PK11_R_INVALID_MESSAGE_LENGTH 		135
+#define PK11_R_UNKNOWN_ALGORITHM_TYPE 		136
+#define PK11_R_UNKNOWN_ASN1_OBJECT_ID 		137
+#define PK11_R_UNKNOWN_PADDING_TYPE 		138
+#define PK11_R_PADDING_CHECK_FAILED 		139
+#define PK11_R_DIGEST_TOO_BIG 			140
+#define PK11_R_MALLOC_FAILURE 			141
+#define PK11_R_CTRL_COMMAND_NOT_IMPLEMENTED 	142
+#define PK11_R_DATA_GREATER_THAN_MOD_LEN 	143
+#define PK11_R_DATA_TOO_LARGE_FOR_MODULUS 	144
+#define PK11_R_MISSING_KEY_COMPONENT		145
+#define PK11_R_INVALID_SIGNATURE_LENGTH		146
+#define PK11_R_INVALID_DSA_SIGNATURE_R		147
+#define PK11_R_INVALID_DSA_SIGNATURE_S		148
+#define PK11_R_INCONSISTENT_KEY			149
+#define PK11_R_ENCRYPTUPDATE			150
+#define PK11_R_DECRYPTUPDATE			151
+#define PK11_R_DIGESTINIT			152
+#define PK11_R_DIGESTUPDATE			153
+#define PK11_R_DIGESTFINAL			154
+#define PK11_R_ENCRYPTFINAL			155
+#define PK11_R_DECRYPTFINAL			156
+#define PK11_R_NO_PRNG_SUPPORT			157
+#define PK11_R_GETTOKENINFO			158
+#define PK11_R_DERIVEKEY			159
+#define PK11_R_GET_OPERATION_STATE		160
+#define PK11_R_SET_OPERATION_STATE		161
+#define PK11_R_INVALID_PIN			162
+#define PK11_R_TOO_MANY_OBJECTS			163
+#define PK11_R_OBJECT_NOT_FOUND			164
+
+/* This structure encapsulates all reusable information for a PKCS#11
+ * session. A list of this object is created on behalf of the
+ * calling application using an on-demand method. When a new request
+ * comes in, an object will be taken from the list (if there is one)
+ * or a new one is created to handle the request. Note that not all
+ * fields are used for every application. For example, an RSA-only
+ * application only uses the RSA related fields */
+typedef struct PK11_SESSION_st
+        {
+        struct PK11_SESSION_st *next;
+        CK_SESSION_HANDLE       session;        /* PK11 session handle */
+        CK_SESSION_HANDLE       session_cipher; /* PK11 sess handle for ciph */
+        pid_t                   pid;            /* Current process ID */
+        CK_OBJECT_HANDLE        rsa_pub_key;    /* RSA key handle in the sess */
+	CK_OBJECT_HANDLE        rsa_priv_key;   /* RSA private key handle */
+        CK_OBJECT_HANDLE        dsa_pub_key;    /* DSA pub key handle */
+        CK_OBJECT_HANDLE        dsa_priv_key;   /* DSA priv key handle */
+        CK_OBJECT_HANDLE        dh_key;         /* RSA pub key handle for DH */
+        CK_OBJECT_HANDLE        cipher_key;     /* Cipher key handle */
+        RSA                     *rsa;   /* Address of the RSA struct */
+        void                    *dsa;   /* Address of the DSA structure */
+        void                    *dh;    /* Address of the DH */
+        unsigned char           key[24];/* Save the private key here */
+        int                     key_len;/* Saved private key length */
+        int                     encrypt;/* 1/0 for encrypt/decrypt */
+        } PK11_SESSION;
+
+extern PK11_SESSION *pk11_get_session();
+extern void pk11_return_session(PK11_SESSION *sp);
+
+extern int pk11_destroy_rsa_key_objects(PK11_SESSION *session);
+extern int pk11_destroy_dsa_key_objects(PK11_SESSION *session);
+extern int pk11_destroy_dh_key_objects(PK11_SESSION *session);
+
+extern RSA_METHOD *PK11_RSA(void);
+extern DSA_METHOD *PK11_DSA(void);
+extern DH_METHOD *PK11_DH(void);
+
+extern EVP_PKEY *pk11_load_privkey(ENGINE*, const char* pubkey_file,
+        UI_METHOD *ui_method, void *callback_data);
+extern EVP_PKEY *pk11_load_pubkey(ENGINE*, const char* pubkey_file,
+        UI_METHOD *ui_method, void *callback_data);
+
+extern CK_FUNCTION_LIST_PTR pFuncList;
+
+#endif /* HW_PK11_ERR_H */
diff -r -u -N openssl-0.9.8g/crypto/engine/hw_pk11_pub.c openssl/crypto/engine/hw_pk11_pub.c
--- openssl-0.9.8g/crypto/engine/hw_pk11_pub.c	1970-01-01 01:00:00.000000000 +0100
+++ openssl/crypto/engine/hw_pk11_pub.c	2008-03-17 15:15:49.000000000 +0100
@@ -0,0 +1,2616 @@
+/*
+ * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+#pragma ident	"@(#)hw_pk11_pub.c	1.4	07/05/10 SMI"
+
+/* crypto/engine/hw_pk11_pub.c */
+/* This product includes software developed by the OpenSSL Project for 
+ * use in the OpenSSL Toolkit (http://www.openssl.org/).
+ *
+ * This project also referenced hw_pkcs11-0.9.7b.patch written by 
+ * Afchine Madjlessi.
+ */
+/* ====================================================================
+ * Copyright (c) 2000-2001 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    licensing@OpenSSL.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+#include <stdio.h>
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <openssl/e_os2.h>
+#include <openssl/engine.h>
+#include <openssl/dso.h>
+#include <openssl/err.h>
+#include <openssl/bn.h>
+#include <openssl/pem.h>
+#include <openssl/rsa.h>
+#include <openssl/rand.h>
+#include <openssl/objects.h>
+#include <openssl/x509.h>
+#include <cryptlib.h>
+
+#ifndef OPENSSL_NO_HW
+#ifndef OPENSSL_NO_HW_PK11
+
+#include "cryptoki.h"
+#include "pkcs11.h"
+#include "hw_pk11_err.c"
+
+#ifndef OPENSSL_NO_RSA
+/* RSA stuff */
+static int pk11_RSA_public_encrypt(int flen, const unsigned char *from, 
+	unsigned char *to, RSA *rsa, int padding);
+static int pk11_RSA_private_encrypt(int flen, const unsigned char *from, 
+	unsigned char *to, RSA *rsa, int padding);
+static int pk11_RSA_public_decrypt(int flen, const unsigned char *from, 
+	unsigned char *to, RSA *rsa, int padding);
+static int pk11_RSA_private_decrypt(int flen, const unsigned char *from, 
+	unsigned char *to, RSA *rsa, int padding);
+static int pk11_RSA_init(RSA *rsa);
+static int pk11_RSA_finish(RSA *rsa);
+static int pk11_RSA_sign(int type, const unsigned char *m, unsigned int m_len,
+	unsigned char *sigret, unsigned int *siglen, const RSA *rsa);
+static int pk11_RSA_verify(int dtype, const unsigned char *m, 
+	unsigned int m_len, unsigned char *sigbuf, unsigned int siglen, 
+	const RSA *rsa);
+EVP_PKEY *pk11_load_privkey(ENGINE*, const char* pubkey_file,
+	UI_METHOD *ui_method, void *callback_data);
+EVP_PKEY *pk11_load_pubkey(ENGINE*, const char* pubkey_file,
+	UI_METHOD *ui_method, void *callback_data);
+
+static int pk11_RSA_public_encrypt_low(int flen, const unsigned char *from, 
+	unsigned char *to, RSA *rsa);
+static int pk11_RSA_private_encrypt_low(int flen, const unsigned char *from, 
+	unsigned char *to, RSA *rsa);
+static int pk11_RSA_public_decrypt_low(int flen, const unsigned char *from, 
+	unsigned char *to, RSA *rsa);
+static int pk11_RSA_private_decrypt_low(int flen, const unsigned char *from, 
+	unsigned char *to, RSA *rsa);
+
+static CK_OBJECT_HANDLE pk11_get_public_rsa_key(RSA* rsa, PK11_SESSION *sp);
+static CK_OBJECT_HANDLE pk11_get_private_rsa_key(RSA* rsa, 
+	PK11_SESSION *sp);
+#endif
+
+/* DSA stuff */
+#ifndef OPENSSL_NO_DSA
+static int pk11_DSA_init(DSA *dsa);
+static int pk11_DSA_finish(DSA *dsa);
+static DSA_SIG *pk11_dsa_do_sign(const unsigned char *dgst, int dlen, 
+	DSA *dsa);
+static int pk11_dsa_do_verify(const unsigned char *dgst, int dgst_len,
+	DSA_SIG *sig, DSA *dsa);
+
+static CK_OBJECT_HANDLE pk11_get_public_dsa_key(DSA* dsa,
+	PK11_SESSION *sp);
+static CK_OBJECT_HANDLE pk11_get_private_dsa_key(DSA* dsa, 
+	PK11_SESSION *sp);
+#endif
+
+/* DH stuff */
+#ifndef OPENSSL_NO_DH
+static int pk11_DH_init(DH *dh);
+static int pk11_DH_finish(DH *dh);
+static int pk11_DH_generate_key(DH *dh);
+static int pk11_DH_compute_key(unsigned char *key,
+	const BIGNUM *pub_key,DH *dh);
+
+static CK_OBJECT_HANDLE pk11_get_dh_key(DH* dh, PK11_SESSION *sp);
+#endif
+
+static int init_template_value(BIGNUM *bn, CK_VOID_PTR *pValue,
+        CK_ULONG *ulValueLen);
+static void check_new_rsa_key(PK11_SESSION *sp, void *rsa);
+static void check_new_dsa_key(PK11_SESSION *sp, void *dsa);
+static void check_new_dh_key(PK11_SESSION *sp, void *dh);
+static void attr_to_BN(CK_ATTRIBUTE_PTR attr, CK_BYTE attr_data[], BIGNUM **bn);
+
+
+#ifndef OPENSSL_NO_RSA
+/* Our internal RSA_METHOD that we provide pointers to */
+static RSA_METHOD pk11_rsa =
+	{
+	"PKCS#11 RSA method",
+	pk11_RSA_public_encrypt,		/* rsa_pub_encrypt */
+	pk11_RSA_public_decrypt,		/* rsa_pub_decrypt */
+	pk11_RSA_private_encrypt,		/* rsa_priv_encrypt */
+	pk11_RSA_private_decrypt,		/* rsa_priv_decrypt */
+	NULL,					/* rsa_mod_exp */
+	NULL,					/* bn_mod_exp */
+	pk11_RSA_init,				/* init */
+	pk11_RSA_finish,			/* finish */
+	RSA_FLAG_SIGN_VER,			/* flags */
+	NULL,					/* app_data */
+	pk11_RSA_sign,				/* rsa_sign */
+	pk11_RSA_verify/*,*/			/* rsa_verify */
+	};
+
+RSA_METHOD *PK11_RSA(void)
+	{
+	return(&pk11_rsa);
+	}
+#endif
+
+#ifndef OPENSSL_NO_DSA
+/* Our internal DSA_METHOD that we provide pointers to */
+static DSA_METHOD pk11_dsa =
+	{
+	"PKCS#11 DSA method",
+	pk11_dsa_do_sign, 	/* dsa_do_sign */
+	NULL, 			/* dsa_sign_setup */
+	pk11_dsa_do_verify, 	/* dsa_do_verify */
+	NULL,			/* dsa_mod_exp */
+	NULL, 			/* bn_mod_exp */
+	pk11_DSA_init, 		/* init */
+	pk11_DSA_finish, 	/* finish */
+	0, 			/* flags */
+	NULL 			/* app_data */
+	};
+
+DSA_METHOD *PK11_DSA(void)
+	{
+	return(&pk11_dsa);
+	}
+
+#endif
+
+
+#ifndef OPENSSL_NO_DH
+/* Our internal DH_METHOD that we provide pointers to */
+static DH_METHOD pk11_dh =
+	{
+	"PKCS#11 DH method",
+	pk11_DH_generate_key,	/* generate_key */
+	pk11_DH_compute_key,	/* compute_key */
+	NULL,			/* bn_mod_exp */
+	pk11_DH_init,		/* init */
+	pk11_DH_finish,		/* finish */
+	0,			/* flags */
+	NULL			/* app_data */
+	};
+
+DH_METHOD *PK11_DH(void)
+	{
+	return(&pk11_dh);
+	}
+#endif
+
+/* Size of an SSL signature: MD5+SHA1
+ */
+#define SSL_SIG_LENGTH          36
+
+/* Lengths of DSA data and signature
+ */
+#define DSA_DATA_LEN            20
+#define DSA_SIGNATURE_LEN       40
+
+static CK_BBOOL true = TRUE;
+static CK_BBOOL false = FALSE;
+
+#ifndef OPENSSL_NO_RSA
+
+/* Similiar to Openssl to take advantage of the paddings. The goal is to
+ * support all paddings in this engine although PK11 library does not 
+ * support all the paddings used in OpenSSL. 
+ * The input errors should have been checked in the padding functions
+ */
+static int pk11_RSA_public_encrypt(int flen, const unsigned char *from,
+		unsigned char *to, RSA *rsa, int padding)
+	{
+	int i,num=0,r= -1;
+	unsigned char *buf=NULL;
+
+	num=BN_num_bytes(rsa->n);
+	if ((buf=(unsigned char *)OPENSSL_malloc(num)) == NULL)
+		{
+		RSAerr(PK11_F_RSA_PUB_ENC,PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	switch (padding)
+		{
+	case RSA_PKCS1_PADDING:
+		i=RSA_padding_add_PKCS1_type_2(buf,num,from,flen);
+		break;
+#ifndef OPENSSL_NO_SHA
+	case RSA_PKCS1_OAEP_PADDING:
+		i=RSA_padding_add_PKCS1_OAEP(buf,num,from,flen,NULL,0);
+		break;
+#endif
+	case RSA_SSLV23_PADDING:
+		i=RSA_padding_add_SSLv23(buf,num,from,flen);
+		break;
+	case RSA_NO_PADDING:
+		i=RSA_padding_add_none(buf,num,from,flen);
+		break;
+	default:
+		RSAerr(PK11_F_RSA_PUB_ENC,PK11_R_UNKNOWN_PADDING_TYPE);
+		goto err;
+		}
+	if (i <= 0) goto err;
+
+	/* PK11 functions are called here */
+	r = pk11_RSA_public_encrypt_low(num, buf, to, rsa);
+err:
+	if (buf != NULL) 
+		{
+		OPENSSL_cleanse(buf,num);
+		OPENSSL_free(buf);
+		}
+	return(r);
+	}
+
+
+/* Similar to Openssl to take advantage of the paddings. The input errors
+ * should be catched in the padding functions
+ */
+static int pk11_RSA_private_encrypt(int flen, const unsigned char *from,
+	     unsigned char *to, RSA *rsa, int padding)
+	{
+	int i,num=0,r= -1;
+	unsigned char *buf=NULL;
+
+	num=BN_num_bytes(rsa->n);
+	if ((buf=(unsigned char *)OPENSSL_malloc(num)) == NULL)
+		{
+		RSAerr(PK11_F_RSA_PRIV_ENC,PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	switch (padding)
+		{
+	case RSA_PKCS1_PADDING:
+		i=RSA_padding_add_PKCS1_type_1(buf,num,from,flen);
+		break;
+	case RSA_NO_PADDING:
+		i=RSA_padding_add_none(buf,num,from,flen);
+		break;
+	case RSA_SSLV23_PADDING:
+	default:
+		RSAerr(PK11_F_RSA_PRIV_ENC,PK11_R_UNKNOWN_PADDING_TYPE);
+		goto err;
+		}
+	if (i <= 0) goto err;
+
+	/* PK11 functions are called here */
+	r=pk11_RSA_private_encrypt_low(num, buf, to, rsa);
+err:
+	if (buf != NULL)
+		{
+		OPENSSL_cleanse(buf,num);
+		OPENSSL_free(buf);
+		}
+	return(r);
+	}
+
+/* Similar to Openssl. Input errors are also checked here
+ */
+static int pk11_RSA_private_decrypt(int flen, const unsigned char *from,
+	     unsigned char *to, RSA *rsa, int padding)
+	{
+	BIGNUM f;
+	int j,num=0,r= -1;
+	unsigned char *p;
+	unsigned char *buf=NULL;
+
+	BN_init(&f);
+
+	num=BN_num_bytes(rsa->n);
+
+	if ((buf=(unsigned char *)OPENSSL_malloc(num)) == NULL)
+		{
+		RSAerr(PK11_F_RSA_PRIV_DEC,PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	/* This check was for equality but PGP does evil things
+	 * and chops off the top '0' bytes */
+	if (flen > num)
+		{
+		RSAerr(PK11_F_RSA_PRIV_DEC,
+			PK11_R_DATA_GREATER_THAN_MOD_LEN);
+		goto err;
+		}
+
+	/* make data into a big number */
+	if (BN_bin2bn(from,(int)flen,&f) == NULL) goto err;
+
+	if (BN_ucmp(&f, rsa->n) >= 0)
+		{
+		RSAerr(PK11_F_RSA_PRIV_DEC,
+			PK11_R_DATA_TOO_LARGE_FOR_MODULUS);
+		goto err;
+		}
+
+	/* PK11 functions are called here */
+	r = pk11_RSA_private_decrypt_low(flen, from, buf, rsa);
+
+	/* PK11 CKM_RSA_X_509 mechanism pads 0's at the beginning.
+	 * Needs to skip these 0's paddings here */
+	for (j = 0; j < r; j++)
+		if (buf[j] != 0)
+			break;
+
+	p = buf + j;
+	j = r - j;  /* j is only used with no-padding mode */
+
+	switch (padding)
+		{
+	case RSA_PKCS1_PADDING:
+		r=RSA_padding_check_PKCS1_type_2(to,num,p,j,num);
+		break;
+#ifndef OPENSSL_NO_SHA
+	case RSA_PKCS1_OAEP_PADDING:
+		r=RSA_padding_check_PKCS1_OAEP(to,num,p,j,num,NULL,0);
+		break;
+#endif
+ 	case RSA_SSLV23_PADDING:
+		r=RSA_padding_check_SSLv23(to,num,p,j,num);
+		break;
+	case RSA_NO_PADDING:
+		r=RSA_padding_check_none(to,num,p,j,num);
+		break;
+	default:
+		RSAerr(PK11_F_RSA_PRIV_DEC,PK11_R_UNKNOWN_PADDING_TYPE);
+		goto err;
+		}
+	if (r < 0)
+		RSAerr(PK11_F_RSA_PRIV_DEC,PK11_R_PADDING_CHECK_FAILED);
+
+err:
+	BN_clear_free(&f);
+	if (buf != NULL)
+		{
+		OPENSSL_cleanse(buf,num);
+		OPENSSL_free(buf);
+		}
+	return(r);
+	}
+
+/* Similar to Openssl. Input errors are also checked here
+ */
+static int pk11_RSA_public_decrypt(int flen, const unsigned char *from,
+	     unsigned char *to, RSA *rsa, int padding)
+	{
+	BIGNUM f;
+	int i,num=0,r= -1;
+	unsigned char *p;
+	unsigned char *buf=NULL;
+
+	BN_init(&f);
+	num=BN_num_bytes(rsa->n);
+	buf=(unsigned char *)OPENSSL_malloc(num);
+	if (buf == NULL)
+		{
+		RSAerr(PK11_F_RSA_PUB_DEC,PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	/* This check was for equality but PGP does evil things
+	 * and chops off the top '0' bytes */
+	if (flen > num)
+		{
+		RSAerr(PK11_F_RSA_PUB_DEC,PK11_R_DATA_GREATER_THAN_MOD_LEN);
+		goto err;
+		}
+
+	if (BN_bin2bn(from,flen,&f) == NULL) goto err;
+
+	if (BN_ucmp(&f, rsa->n) >= 0)
+		{
+		RSAerr(PK11_F_RSA_PUB_DEC,
+			PK11_R_DATA_TOO_LARGE_FOR_MODULUS);
+		goto err;
+		}
+
+	/* PK11 functions are called here */
+	r = pk11_RSA_public_decrypt_low(flen, from, buf, rsa);
+
+	/* PK11 CKM_RSA_X_509 mechanism pads 0's at the beginning.
+	 * Needs to skip these 0's here */
+	for (i = 0; i < r; i++)
+		if (buf[i] != 0)
+			break;
+
+	p = buf + i;
+	i = r - i;  /* i is only used with no-padding mode */
+
+	switch (padding)
+		{
+	case RSA_PKCS1_PADDING:
+		r=RSA_padding_check_PKCS1_type_1(to,num,p,i,num);
+		break;
+	case RSA_NO_PADDING:
+		r=RSA_padding_check_none(to,num,p,i,num);
+		break;
+	default:
+		RSAerr(PK11_F_RSA_PUB_DEC,PK11_R_UNKNOWN_PADDING_TYPE);
+		goto err;
+		}
+	if (r < 0)
+		RSAerr(PK11_F_RSA_PUB_DEC,PK11_R_PADDING_CHECK_FAILED);
+
+err:
+	BN_clear_free(&f);
+	if (buf != NULL)
+		{
+		OPENSSL_cleanse(buf,num);
+		OPENSSL_free(buf);
+		}
+	return(r);
+	}
+
+/* This function implements RSA public encryption using C_EncryptInit and
+ * C_Encrypt pk11 interfaces. Note that the CKM_RSA_X_509 is used here.
+ * The calling function allocated sufficient memory in "to" to store results.
+ */
+static int pk11_RSA_public_encrypt_low(int flen,
+	const unsigned char *from, unsigned char *to, RSA *rsa)
+	{
+	CK_ULONG bytes_encrypted=flen;
+	int retval = -1;
+	CK_RV rv;
+	CK_MECHANISM mech_rsa = {CKM_RSA_X_509, NULL, 0};
+	CK_MECHANISM *p_mech = &mech_rsa;
+	CK_OBJECT_HANDLE h_pub_key = CK_INVALID_HANDLE;
+	PK11_SESSION *sp;
+	char tmp_buf[20];
+	
+	if ((sp = pk11_get_session()) == NULL)
+		return -1;
+
+	check_new_rsa_key(sp, (void *) rsa);
+	
+	h_pub_key = sp->rsa_pub_key;
+	if (h_pub_key == CK_INVALID_HANDLE)
+		h_pub_key = sp->rsa_pub_key = 
+			pk11_get_public_rsa_key(rsa, sp);
+
+	if (h_pub_key != CK_INVALID_HANDLE)
+		{
+		rv = pFuncList->C_EncryptInit(sp->session, p_mech, 
+			h_pub_key);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_RSA_PUB_ENC_LOW, 
+				PK11_R_ENCRYPTINIT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			pk11_return_session(sp);
+			return -1;
+			}
+	
+		rv = pFuncList->C_Encrypt(sp->session, 
+			(unsigned char *)from, flen, to, &bytes_encrypted);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_RSA_PUB_ENC_LOW, PK11_R_ENCRYPT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			pk11_return_session(sp);
+			return -1;
+			}
+		retval = bytes_encrypted;
+		}
+	
+	pk11_return_session(sp);
+	return retval;
+	}
+
+
+/* This function implements RSA private encryption using C_SignInit and 
+ * C_Sign pk11 APIs. Note that CKM_RSA_X_509 is used here.
+ * The calling function allocated sufficient memory in "to" to store results.
+ */
+static int pk11_RSA_private_encrypt_low(int flen,
+	const unsigned char *from, unsigned char *to, RSA *rsa)
+	{
+	CK_ULONG ul_sig_len=flen;
+	int retval = -1;
+	CK_RV rv;
+	CK_MECHANISM mech_rsa = {CKM_RSA_X_509, NULL, 0};
+	CK_MECHANISM *p_mech = &mech_rsa;
+	CK_OBJECT_HANDLE h_priv_key= CK_INVALID_HANDLE;
+	PK11_SESSION *sp;
+	char tmp_buf[20];
+	
+	if ((sp = pk11_get_session()) == NULL)
+		return -1;
+	
+	check_new_rsa_key(sp, (void *) rsa);
+	
+	h_priv_key = sp->rsa_priv_key;
+	if (h_priv_key == CK_INVALID_HANDLE)
+		h_priv_key = sp->rsa_priv_key = 
+			pk11_get_private_rsa_key(rsa, sp);
+	
+	if (h_priv_key != CK_INVALID_HANDLE)
+		{
+		rv = pFuncList->C_SignInit(sp->session, p_mech, 
+			h_priv_key);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_RSA_PRIV_ENC_LOW, PK11_R_SIGNINIT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			pk11_return_session(sp);
+			return -1;
+			}
+	
+		rv = pFuncList->C_Sign(sp->session, 
+			(unsigned char *)from, flen, to, &ul_sig_len);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_RSA_PRIV_ENC_LOW, PK11_R_SIGN);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			pk11_return_session(sp);
+			return -1;
+			}
+
+		retval = ul_sig_len;
+		}
+	
+	pk11_return_session(sp);
+	return retval;
+	}
+
+
+/* This function implements RSA private decryption using C_DecryptInit and
+ * C_Decrypt pk11 APIs. Note that CKM_RSA_X_509 mechanism is used here.
+ * The calling function allocated sufficient memory in "to" to store results.
+ */
+static int pk11_RSA_private_decrypt_low(int flen,
+	const unsigned char *from, unsigned char *to, RSA *rsa)
+	{
+	CK_ULONG bytes_decrypted = flen;
+	int retval = -1;
+	CK_RV rv;
+	CK_MECHANISM mech_rsa = {CKM_RSA_X_509, NULL, 0};
+	CK_MECHANISM *p_mech = &mech_rsa;
+	CK_OBJECT_HANDLE h_priv_key;
+	PK11_SESSION *sp;
+	char tmp_buf[20];
+	
+	if ((sp = pk11_get_session()) == NULL)
+		return -1;
+	
+	check_new_rsa_key(sp, (void *) rsa);
+	
+	h_priv_key = sp->rsa_priv_key;
+	if (h_priv_key == CK_INVALID_HANDLE)
+		h_priv_key = sp->rsa_priv_key = 
+			pk11_get_private_rsa_key(rsa, sp);
+
+	if (h_priv_key != CK_INVALID_HANDLE)
+		{
+		rv = pFuncList->C_DecryptInit(sp->session, p_mech, 
+			h_priv_key);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_RSA_PRIV_DEC_LOW, 
+				PK11_R_DECRYPTINIT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			pk11_return_session(sp);
+			return -1;
+			}
+	
+		rv = pFuncList->C_Decrypt(sp->session, 
+			(unsigned char *)from, flen, to, &bytes_decrypted);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_RSA_PRIV_DEC_LOW, PK11_R_DECRYPT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			pk11_return_session(sp);
+			return -1;
+			}
+		retval = bytes_decrypted;
+		}
+
+	pk11_return_session(sp);
+	return retval;
+	}
+
+
+/* This function implements RSA public decryption using C_VerifyRecoverInit 
+ * and C_VerifyRecover pk11 APIs. Note that CKM_RSA_X_509 is used here.
+ * The calling function allocated sufficient memory in "to" to store results.
+ */
+static int pk11_RSA_public_decrypt_low(int flen,
+	const unsigned char *from, unsigned char *to, RSA *rsa)
+	{
+	CK_ULONG bytes_decrypted = flen;
+	int retval = -1;
+	CK_RV rv;
+	CK_MECHANISM mech_rsa = {CKM_RSA_X_509, NULL, 0};
+	CK_MECHANISM *p_mech = &mech_rsa;
+	CK_OBJECT_HANDLE h_pub_key = CK_INVALID_HANDLE;
+	PK11_SESSION *sp;
+	char tmp_buf[20];
+	
+	if ((sp = pk11_get_session()) == NULL)
+		return -1;
+	
+	check_new_rsa_key(sp, (void *) rsa);
+	
+	h_pub_key = sp->rsa_pub_key;
+	if (h_pub_key == CK_INVALID_HANDLE)
+		h_pub_key = sp->rsa_pub_key = 
+			pk11_get_public_rsa_key(rsa, sp);
+
+	if (h_pub_key != CK_INVALID_HANDLE)
+		{	
+		rv = pFuncList->C_VerifyRecoverInit(sp->session, 
+			p_mech, h_pub_key);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_RSA_PUB_DEC_LOW, 
+				PK11_R_VERIFYRECOVERINIT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			pk11_return_session(sp);
+			return -1;
+			}
+	
+		rv = pFuncList->C_VerifyRecover(sp->session, 
+			(unsigned char *)from, flen, to, &bytes_decrypted);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_RSA_PUB_DEC_LOW, 
+				PK11_R_VERIFYRECOVER);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			pk11_return_session(sp);
+			return -1;
+			}
+		retval = bytes_decrypted;
+		}
+
+	pk11_return_session(sp);
+	return retval;
+	}
+
+
+static int pk11_RSA_init(RSA *rsa)
+	{
+	/* This flag in the RSA_METHOD enables the new rsa_sign, 
+	 * rsa_verify functions. See rsa.h for details. */
+	rsa->flags |= RSA_FLAG_SIGN_VER;
+
+	return 1;
+	}
+
+
+static int pk11_RSA_finish(RSA *rsa)
+	{
+	if (rsa->_method_mod_n != NULL)
+		BN_MONT_CTX_free(rsa->_method_mod_n);
+	if (rsa->_method_mod_p != NULL)
+		BN_MONT_CTX_free(rsa->_method_mod_p);
+	if (rsa->_method_mod_q != NULL)
+		BN_MONT_CTX_free(rsa->_method_mod_q);
+	
+	return pk11_destroy_rsa_key_objects(NULL);
+	}
+
+
+/* Standard engine interface function. Majority codes here are from 
+ * rsa/rsa_sign.c. We replaced the decrypt function call by C_Sign of PKCS#11.
+ * See more details in rsa/rsa_sign.c */
+static int pk11_RSA_sign(int type, const unsigned char *m, unsigned int m_len,
+	unsigned char *sigret, unsigned int *siglen, const RSA *rsa)
+	{
+	X509_SIG sig;
+	ASN1_TYPE parameter;
+	int i,j;
+	unsigned char *p,*s = NULL;
+	X509_ALGOR algor;
+	ASN1_OCTET_STRING digest;
+	CK_RV rv;
+	CK_MECHANISM mech_rsa = {CKM_RSA_PKCS, NULL, 0};
+	CK_MECHANISM *p_mech = &mech_rsa;
+	CK_OBJECT_HANDLE h_priv_key;
+	PK11_SESSION *sp = NULL;
+	int ret = 0;
+	char tmp_buf[20];
+	unsigned long ulsiglen;
+
+	/* Encode the digest */
+	/* Special case: SSL signature, just check the length */
+	if (type == NID_md5_sha1)
+		{
+		if (m_len != SSL_SIG_LENGTH)
+			{
+			PK11err(PK11_F_RSA_SIGN, 
+				PK11_R_INVALID_MESSAGE_LENGTH);
+			goto err;
+			}
+		i = SSL_SIG_LENGTH;
+		s = (unsigned char *)m;
+		}
+	else
+		{
+		sig.algor= &algor;
+		sig.algor->algorithm=OBJ_nid2obj(type);
+		if (sig.algor->algorithm == NULL)
+			{
+			PK11err(PK11_F_RSA_SIGN, 
+				PK11_R_UNKNOWN_ALGORITHM_TYPE);
+			goto err;
+			}
+		if (sig.algor->algorithm->length == 0)
+			{
+			PK11err(PK11_F_RSA_SIGN, 
+				PK11_R_UNKNOWN_ASN1_OBJECT_ID);
+			goto err;
+			}
+		parameter.type=V_ASN1_NULL;
+		parameter.value.ptr=NULL;
+		sig.algor->parameter= &parameter;
+	
+		sig.digest= &digest;
+		sig.digest->data=(unsigned char *)m;
+		sig.digest->length=m_len;
+	
+		i=i2d_X509_SIG(&sig,NULL);
+		}
+	
+	j=RSA_size(rsa);
+	if ((i-RSA_PKCS1_PADDING) > j)
+		{
+		PK11err(PK11_F_RSA_SIGN, PK11_R_DIGEST_TOO_BIG);
+		goto err;
+		}
+	
+	if (type != NID_md5_sha1)
+		{
+		s=(unsigned char *)OPENSSL_malloc((unsigned int)j+1);
+		if (s == NULL)
+			{
+			PK11err(PK11_F_RSA_SIGN, PK11_R_MALLOC_FAILURE);
+			goto err;
+			}
+		p=s;
+		i2d_X509_SIG(&sig,&p);
+		}
+	
+	if ((sp = pk11_get_session()) == NULL)
+		goto err;
+
+	check_new_rsa_key(sp, (void *) rsa);
+	
+	h_priv_key = sp->rsa_priv_key;
+	if (h_priv_key == CK_INVALID_HANDLE)
+		h_priv_key = sp->rsa_priv_key = 
+			pk11_get_private_rsa_key((RSA *)rsa, sp);
+
+	if (h_priv_key != CK_INVALID_HANDLE)
+		{
+		rv = pFuncList->C_SignInit(sp->session, p_mech, h_priv_key);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_RSA_SIGN, PK11_R_SIGNINIT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+
+		ulsiglen = j;
+		rv = pFuncList->C_Sign(sp->session, s, i, sigret, 
+			(CK_ULONG_PTR) &ulsiglen);
+		*siglen = ulsiglen;
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_RSA_SIGN, PK11_R_SIGN);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+		ret = 1;
+		}
+
+err:
+	if (type != NID_md5_sha1)
+		{
+		memset(s,0,(unsigned int)j+1);
+		OPENSSL_free(s);
+		}
+	
+	pk11_return_session(sp);
+	return ret;
+	}
+
+static int pk11_RSA_verify(int type, const unsigned char *m,
+	unsigned int m_len, unsigned char *sigbuf, unsigned int siglen,
+	const RSA *rsa)
+	{
+	X509_SIG sig;
+	ASN1_TYPE parameter;
+	int i,j;
+	unsigned char *p,*s = NULL;
+	X509_ALGOR algor;
+	ASN1_OCTET_STRING digest;
+	CK_RV rv;
+	CK_MECHANISM mech_rsa = {CKM_RSA_PKCS, NULL, 0};
+	CK_MECHANISM *p_mech = &mech_rsa;
+	CK_OBJECT_HANDLE h_pub_key;
+	PK11_SESSION *sp = NULL;
+	int ret = 0;
+	char tmp_buf[20];
+
+	/* Encode the digest	*/
+	/* Special case: SSL signature, just check the length */
+	if (type == NID_md5_sha1)
+		{
+		if (m_len != SSL_SIG_LENGTH)
+			{
+			PK11err(PK11_F_RSA_VERIFY, 
+				PK11_R_INVALID_MESSAGE_LENGTH);
+			goto err;
+			}
+		i = SSL_SIG_LENGTH;
+		s = (unsigned char *)m;
+		}
+	else
+		{
+		sig.algor= &algor;
+		sig.algor->algorithm=OBJ_nid2obj(type);
+		if (sig.algor->algorithm == NULL)
+			{
+			PK11err(PK11_F_RSA_VERIFY, 
+				PK11_R_UNKNOWN_ALGORITHM_TYPE);
+			goto err;
+			}
+		if (sig.algor->algorithm->length == 0)
+			{
+			PK11err(PK11_F_RSA_VERIFY, 
+				PK11_R_UNKNOWN_ASN1_OBJECT_ID);
+			goto err;
+			}
+		parameter.type=V_ASN1_NULL;
+		parameter.value.ptr=NULL;
+		sig.algor->parameter= &parameter;
+		sig.digest= &digest;
+		sig.digest->data=(unsigned char *)m;
+		sig.digest->length=m_len;
+		i=i2d_X509_SIG(&sig,NULL);
+		}
+	
+	j=RSA_size(rsa);
+	if ((i-RSA_PKCS1_PADDING) > j)
+		{
+		PK11err(PK11_F_RSA_VERIFY, PK11_R_DIGEST_TOO_BIG);
+		goto err;
+		}
+	
+	if (type != NID_md5_sha1)
+		{
+		s=(unsigned char *)OPENSSL_malloc((unsigned int)j+1);
+		if (s == NULL)
+			{
+			PK11err(PK11_F_RSA_VERIFY, PK11_R_MALLOC_FAILURE);
+			goto err;
+			}
+		p=s;
+		i2d_X509_SIG(&sig,&p);
+		}
+	
+	if ((sp = pk11_get_session()) == NULL)
+		goto err;
+	
+	check_new_rsa_key(sp, (void *) rsa);
+	
+	h_pub_key = sp->rsa_pub_key;
+	if (h_pub_key == CK_INVALID_HANDLE)
+		h_pub_key = sp->rsa_pub_key = 
+			pk11_get_public_rsa_key((RSA *)rsa, sp);
+
+	if (h_pub_key != CK_INVALID_HANDLE)
+		{
+		rv = pFuncList->C_VerifyInit(sp->session, p_mech, 
+			h_pub_key);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_RSA_VERIFY, PK11_R_VERIFYINIT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+		rv = pFuncList->C_Verify(sp->session, s, i, sigbuf, 
+			(CK_ULONG)siglen);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_RSA_VERIFY, PK11_R_VERIFY);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+		ret = 1;
+		}
+
+err:
+	if (type != NID_md5_sha1)
+		{
+		memset(s,0,(unsigned int)siglen);
+		OPENSSL_free(s);
+		}
+
+	pk11_return_session(sp);
+	return ret;
+	}
+
+static int hndidx_rsa = -1;
+
+struct key_info {
+	CK_OBJECT_HANDLE handle;
+	CK_SESSION_HANDLE session;
+};
+
+/* Destroy the object when the last reference to it has gone.
+ */
+static void hndidx_free(void *obj, void *item, CRYPTO_EX_DATA *ad,
+			int ind, long argl, void *argp)
+{
+	struct key_info *key_info = item;
+	CK_RV rv;
+	char tmp_buf[20];
+
+	if (key_info != NULL)
+		{
+                rv = pFuncList->C_DestroyObject(key_info->session,
+						key_info->handle);
+                if (rv != CKR_OK)
+                        {
+                        PK11err(PK11_F_DESTROY_OBJECT, PK11_R_DESTROYOBJECT);
+                        snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+                        ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+                        }
+		free(item);
+		}
+}
+
+EVP_PKEY *pk11_load_privkey(ENGINE* e, const char* privkey_file,
+	UI_METHOD *ui_method, void *callback_data)
+	{
+	EVP_PKEY *pkey=NULL;
+	FILE *privkey;
+	CK_OBJECT_HANDLE  h_priv_key = CK_INVALID_HANDLE;
+	RSA *rsa;
+	PK11_SESSION *sp;
+	/* everything else below needed for key by reference extension */
+	char tmp_buf[20];
+	CK_RV rv;
+	CK_ULONG objcnt = 0;
+	CK_BBOOL is_token = TRUE;
+	CK_BYTE attr_data[2][1024];
+	CK_OBJECT_CLASS key_class = CKO_PRIVATE_KEY;
+	CK_OBJECT_HANDLE ks_key = CK_INVALID_HANDLE;	/* key in keystore */
+	struct key_info *key_info = NULL; 
+	extern char *pk11_pin;
+
+	/* we look for private keys only */
+	CK_ATTRIBUTE search_templ[] =
+		{
+		{CKA_TOKEN, &is_token, sizeof(is_token)},
+		{CKA_CLASS, &key_class, sizeof(key_class)},
+		{CKA_LABEL, NULL, 0}
+		};
+
+	/* these attributes are needed to initialize OpenSSL RSA structure */
+	CK_ATTRIBUTE get_templ[] =
+		{
+		{CKA_MODULUS, (void *)attr_data[0], 1024},	    /* n */
+		{CKA_PUBLIC_EXPONENT, (void *)attr_data[1], 1024},  /* e */
+		};
+
+	if ((sp = pk11_get_session()) == NULL)
+		return NULL;
+
+	/*
+	 * Use simple scheme "pkcs11:<KEY_LABEL>" for now.
+	 */
+	if (strstr(privkey_file, "pkcs11:") == privkey_file)
+		{
+		search_templ[2].pValue = strstr(privkey_file, ":") + 1;
+		search_templ[2].ulValueLen = strlen(search_templ[2].pValue);
+
+		if (pk11_pin == NULL)
+#ifndef OPENCRYPTOKI
+			pk11_pin = getpassphrase("Enter PIN: ");
+#else
+			pk11_pin = getpass("Enter PIN: ");
+#endif
+		if ((rv = pFuncList->C_Login(sp->session, CKU_USER, (CK_UTF8CHAR*)pk11_pin,
+		    strlen(pk11_pin))) != CKR_OK && rv != CKR_USER_ALREADY_LOGGED_IN)
+			{
+			fprintf(stderr, "C_Login -> %lx\n", rv);
+			PK11err(PK11_F_LOAD_PRIVKEY, PK11_R_INVALID_PIN);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+
+		CRYPTO_w_lock(CRYPTO_LOCK_PK11_ENGINE);
+		if ((rv = pFuncList->C_FindObjectsInit(sp->session,
+		    search_templ, 3)) != CKR_OK)
+			{
+			CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+			PK11err(PK11_F_LOAD_PRIVKEY, PK11_R_FINDOBJECTSINIT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+
+		rv = pFuncList->C_FindObjects(sp->session, &ks_key, 1, &objcnt);
+		if (rv != CKR_OK)
+			{
+			CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+			PK11err(PK11_F_LOAD_PRIVKEY, PK11_R_FINDOBJECTS);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+
+		if (objcnt > 1)
+			{
+			CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+			PK11err(PK11_F_LOAD_PRIVKEY, PK11_R_TOO_MANY_OBJECTS);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lu", objcnt);
+			ERR_add_error_data(2,
+				"PK11 too many objects:", tmp_buf);
+			goto err;
+			}
+
+		if (objcnt != 1)
+			{
+			CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+			PK11err(PK11_F_LOAD_PRIVKEY, PK11_R_OBJECT_NOT_FOUND);
+			ERR_add_error_data(1, "PK11 object not found");
+			goto err;
+			}
+
+		(void) pFuncList->C_FindObjectsFinal(sp->session);
+		CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+
+		if (hndidx_rsa == -1)
+			hndidx_rsa = RSA_get_ex_new_index(0,
+				        "pkcs11 RSA HSM key handle",
+					NULL, NULL, hndidx_free);
+
+		key_info = malloc(sizeof(struct key_info));
+		if (key_info == NULL)
+			goto err;
+
+		pkey = EVP_PKEY_new();
+		if (pkey == NULL)
+			goto err;
+
+		rsa = RSA_new();
+		if (rsa == NULL) {
+			EVP_PKEY_free(pkey);
+			pkey = NULL;
+			goto err;
+		}
+		EVP_PKEY_set1_RSA(pkey, rsa);
+
+		if ((rv = pFuncList->C_GetAttributeValue(sp->session, ks_key,
+		    get_templ, 2)) != CKR_OK)
+			{
+			PK11err(PK11_F_LOAD_PRIVKEY, PK11_R_GETATTRIBUTVALUE);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			EVP_PKEY_free(pkey);
+			pkey = NULL;
+			goto err;
+			}
+
+		/*
+		 * Now we have to initialize an OpenSSL RSA structure,
+		 * everything else is 0 or NULL.
+		 */
+		rsa->meth = &pk11_rsa;
+		rsa->engine = e;
+		rsa->references = 2;
+		rsa->flags = RSA_FLAG_SIGN_VER | RSA_FLAG_EXT_PKEY;
+		key_info->handle = ks_key;
+		key_info->session = sp->session;
+		RSA_set_ex_data(rsa, hndidx_rsa, key_info);
+		key_info = NULL;
+		sp->rsa = rsa;
+		sp->rsa_priv_key = ks_key;
+
+		attr_to_BN(&get_templ[0], attr_data[0], &rsa->n);
+#ifdef OPENCRYPTOKI
+		/* openCryptoki bug workaround */
+		if (get_templ[1].ulValueLen == 0) {
+			get_templ[1].ulValueLen = 1;
+			attr_data[1][0] = 3;
+		}
+#endif
+		attr_to_BN(&get_templ[1], attr_data[1], &rsa->e);
+		}
+	else if ((privkey=fopen(privkey_file,"r")) != NULL)
+		{
+		pkey = PEM_read_PrivateKey(privkey, NULL, NULL, NULL);
+		fclose(privkey);
+		if (pkey)
+			{
+			rsa = EVP_PKEY_get1_RSA(pkey);
+
+			if (rsa)
+				{
+				check_new_rsa_key(sp, (void *) rsa);
+	
+				h_priv_key = pk11_get_private_rsa_key(rsa,
+				sp);
+			if (h_priv_key == CK_INVALID_HANDLE)
+				{
+				EVP_PKEY_free(pkey);
+				pkey = NULL;
+				}
+			}
+		else
+			{
+			EVP_PKEY_free(pkey);
+			pkey = NULL;
+			}
+		}
+	}
+
+err:
+	if (key_info != NULL)
+		free(key_info);
+	pk11_return_session(sp);
+	return(pkey);
+	}
+
+EVP_PKEY *pk11_load_pubkey(ENGINE* e, const char* pubkey_file,
+	UI_METHOD *ui_method, void *callback_data)
+	{
+	EVP_PKEY *pkey=NULL;
+	FILE *pubkey;
+	CK_OBJECT_HANDLE  h_pub_key = CK_INVALID_HANDLE;
+	RSA *rsa;
+	PK11_SESSION *sp;
+	/* everything else below needed for key by reference extension */
+	char tmp_buf[20];
+	CK_RV rv;
+	CK_ULONG objcnt = 0;
+	CK_BBOOL is_token = TRUE;
+	CK_BYTE attr_data[2][1024];
+	CK_OBJECT_CLASS key_class = CKO_PUBLIC_KEY;
+	CK_OBJECT_HANDLE ks_key = CK_INVALID_HANDLE;	/* key in keystore */
+	extern char *pk11_pin;
+
+	/* we look for private keys only */
+	CK_ATTRIBUTE search_templ[] =
+		{
+		{CKA_TOKEN, &is_token, sizeof(is_token)},
+		{CKA_CLASS, &key_class, sizeof(key_class)},
+		{CKA_LABEL, NULL, 0}
+		};
+
+	/* these attributes are needed to initialize OpenSSL RSA structure */
+	CK_ATTRIBUTE get_templ[] =
+		{
+		{CKA_MODULUS, (void *)attr_data[0], 1024},	    /* n */
+		{CKA_PUBLIC_EXPONENT, (void *)attr_data[1], 1024},  /* e */
+		};
+
+	if ((sp = pk11_get_session()) == NULL)
+		return NULL;
+
+	/*
+	 * Use simple scheme "pkcs11:<KEY_LABEL>" for now.
+	 */
+	if (strstr(pubkey_file, "pkcs11:") == pubkey_file)
+		{
+		search_templ[2].pValue = strstr(pubkey_file, ":") + 1;
+		search_templ[2].ulValueLen = strlen(search_templ[2].pValue);
+
+#define ALLWAYS_LOGIN
+#ifdef ALLWAYS_LOGIN
+		if (pk11_pin == NULL)
+#ifndef OPENCRYPTOKI
+			pk11_pin = getpassphrase("Enter PIN: ");
+#else
+			pk11_pin = getpass("Enter PIN: ");
+#endif
+		if ((rv = pFuncList->C_Login(sp->session, CKU_USER, (CK_UTF8CHAR*)pk11_pin,
+		    strlen(pk11_pin))) != CKR_OK && rv != CKR_USER_ALREADY_LOGGED_IN)
+			{
+			fprintf(stderr, "C_Login -> %lx\n", rv);
+			PK11err(PK11_F_LOAD_PUBKEY, PK11_R_INVALID_PIN);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+#endif
+
+		CRYPTO_w_lock(CRYPTO_LOCK_PK11_ENGINE);
+		if (pFuncList->C_FindObjectsInit(sp->session, search_templ, 3) != CKR_OK)
+			{
+			CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+			PK11err(PK11_F_LOAD_PUBKEY, PK11_R_FINDOBJECTSINIT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+		rv = pFuncList->C_FindObjects(sp->session, &ks_key, 1, &objcnt);
+		if (rv != CKR_OK)
+			{
+			CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+			PK11err(PK11_F_LOAD_PUBKEY, PK11_R_FINDOBJECTS);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+
+		if (objcnt > 1)
+			{
+			CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+			PK11err(PK11_F_LOAD_PUBKEY, PK11_R_TOO_MANY_OBJECTS);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lu", objcnt);
+			ERR_add_error_data(2,
+				"PK11 too many objects:", tmp_buf);
+			goto err;
+			}
+
+		if (objcnt != 1)
+			{
+			CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+			PK11err(PK11_F_LOAD_PUBKEY, PK11_R_OBJECT_NOT_FOUND);
+			ERR_add_error_data(1, "PK11 object not found");
+			goto err;
+			}
+
+		(void) pFuncList->C_FindObjectsFinal(sp->session);
+		CRYPTO_w_unlock(CRYPTO_LOCK_PK11_ENGINE);
+
+		sp->rsa_pub_key = ks_key;
+		pkey = malloc(sizeof(EVP_PKEY));
+		bzero(pkey, sizeof(EVP_PKEY));
+		pkey->type = EVP_PKEY_RSA;
+		pkey->references = 1;
+
+		rsa = pkey->pkey.rsa = sp->rsa = malloc(sizeof(RSA));
+		bzero(rsa, sizeof(RSA));
+
+		if (pFuncList->C_GetAttributeValue(sp->session, ks_key,
+		    get_templ, 3) != CKR_OK)
+			{
+			PK11err(PK11_F_LOAD_PUBKEY, PK11_R_GETATTRIBUTVALUE);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+
+		/*
+		 * Now we have to initialize an OpenSSL RSA structure,
+		 * everything else is 0 or NULL.
+		 */
+		rsa->meth = &pk11_rsa;
+		rsa->engine = e;
+		rsa->references = 2;
+		rsa->flags = RSA_FLAG_SIGN_VER;
+
+		attr_to_BN(&get_templ[0], attr_data[0], &rsa->n);
+		attr_to_BN(&get_templ[1], attr_data[1], &rsa->e);
+		}
+	else if ((pubkey=fopen(pubkey_file,"r")) != NULL)
+		{
+		pkey = PEM_read_PUBKEY(pubkey, NULL, NULL, NULL);
+		fclose(pubkey);
+		if (pkey)
+			{
+			rsa = EVP_PKEY_get1_RSA(pkey);
+			if (rsa)
+				{
+				check_new_rsa_key(sp, (void *) rsa);
+	
+				h_pub_key = pk11_get_public_rsa_key(rsa, sp);
+				if (h_pub_key == CK_INVALID_HANDLE)
+					{
+					EVP_PKEY_free(pkey);
+					pkey = NULL;
+					}
+				}
+			else
+				{
+				EVP_PKEY_free(pkey);
+				pkey = NULL;
+				}
+			}
+		}
+
+err:
+	pk11_return_session(sp);
+	return(pkey);
+	}
+
+/* Create a public key object in a session from a given rsa structure.
+ */
+static CK_OBJECT_HANDLE pk11_get_public_rsa_key(RSA* rsa, PK11_SESSION *sp)
+	{
+	CK_RV rv;
+	CK_OBJECT_HANDLE h_key = CK_INVALID_HANDLE;
+	CK_ULONG found;
+	CK_OBJECT_CLASS o_key = CKO_PUBLIC_KEY;
+	CK_KEY_TYPE k_type = CKK_RSA;
+	CK_ULONG ul_key_attr_count = 7;
+	char tmp_buf[20];
+
+	CK_ATTRIBUTE  a_key_template[] =
+		{
+		{CKA_CLASS, (void *) NULL, sizeof(CK_OBJECT_CLASS)},
+		{CKA_KEY_TYPE, (void *) NULL, sizeof(CK_KEY_TYPE)},
+		{CKA_TOKEN, &false, sizeof(true)},
+		{CKA_ENCRYPT, &true, sizeof(true)},
+		{CKA_VERIFY_RECOVER, &true, sizeof(true)},
+		{CKA_MODULUS, (void *)NULL, 0},
+		{CKA_PUBLIC_EXPONENT, (void *)NULL, 0}
+		};
+
+	int i;
+	CK_SESSION_HANDLE session = sp->session;
+
+	a_key_template[0].pValue = &o_key;
+	a_key_template[1].pValue = &k_type;
+
+	a_key_template[5].ulValueLen = BN_num_bytes(rsa->n);
+	a_key_template[5].pValue = (CK_VOID_PTR)OPENSSL_malloc(
+		(size_t)a_key_template[5].ulValueLen);
+	if (a_key_template[5].pValue == NULL)
+		{
+		PK11err(PK11_F_GET_PUB_RSA_KEY, PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	BN_bn2bin(rsa->n, a_key_template[5].pValue);
+
+	a_key_template[6].ulValueLen = BN_num_bytes(rsa->e);
+	a_key_template[6].pValue = (CK_VOID_PTR)OPENSSL_malloc(
+		(size_t)a_key_template[6].ulValueLen);
+	if (a_key_template[6].pValue == NULL)
+		{
+		PK11err(PK11_F_GET_PUB_RSA_KEY, PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	BN_bn2bin(rsa->e, a_key_template[6].pValue);
+
+	rv = pFuncList->C_FindObjectsInit(session, a_key_template, 
+		ul_key_attr_count);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_PUB_RSA_KEY, PK11_R_FINDOBJECTSINIT);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjects(session, &h_key, 1, &found);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_PUB_RSA_KEY, PK11_R_FINDOBJECTS);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjectsFinal(session);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_PUB_RSA_KEY, PK11_R_FINDOBJECTSFINAL);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	if (found == 0)
+		{
+		rv = pFuncList->C_CreateObject(session, 
+			a_key_template, ul_key_attr_count, &h_key);
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_GET_PUB_RSA_KEY, 
+				PK11_R_CREATEOBJECT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+		}
+
+	sp->rsa = rsa;
+
+ err:
+	for (i = 5; i <= 6; i++)
+		{
+		if (a_key_template[i].pValue != NULL)
+			{
+			OPENSSL_free(a_key_template[i].pValue);
+			a_key_template[i].pValue = NULL;
+			}
+		}
+
+	return h_key;
+
+	}
+
+/* Create a private key object in the session from a given rsa structure
+ */
+static CK_OBJECT_HANDLE pk11_get_private_rsa_key(RSA* rsa, PK11_SESSION *sp)
+	{
+	CK_RV rv;
+	CK_OBJECT_HANDLE h_key = CK_INVALID_HANDLE;
+	int i;
+	CK_ULONG found;
+	CK_OBJECT_CLASS o_key = CKO_PRIVATE_KEY;
+	CK_KEY_TYPE k_type = CKK_RSA;
+	CK_ULONG ul_key_attr_count = 14;
+	char tmp_buf[20];
+
+	/* Both CKA_TOKEN and CKA_SENSITIVE have to be FALSE for session keys
+	 */
+	CK_ATTRIBUTE  a_key_template[] =
+		{
+		{CKA_CLASS, (void *) NULL, sizeof(CK_OBJECT_CLASS)},
+		{CKA_KEY_TYPE, (void *) NULL, sizeof(CK_KEY_TYPE)},
+		{CKA_TOKEN, &false, sizeof(true)},
+		{CKA_SENSITIVE, &false, sizeof(true)},
+		{CKA_DECRYPT, &true, sizeof(true)},
+		{CKA_SIGN, &true, sizeof(true)},
+		{CKA_MODULUS, (void *)NULL, 0},
+		{CKA_PUBLIC_EXPONENT, (void *)NULL, 0},
+		{CKA_PRIVATE_EXPONENT, (void *)NULL, 0},
+		{CKA_PRIME_1, (void *)NULL, 0},
+		{CKA_PRIME_2, (void *)NULL, 0},
+		{CKA_EXPONENT_1, (void *)NULL, 0},
+		{CKA_EXPONENT_2, (void *)NULL, 0},
+		{CKA_COEFFICIENT, (void *)NULL, 0}
+		};
+	CK_SESSION_HANDLE session = sp->session;
+
+	if ((rsa->flags & RSA_FLAG_EXT_PKEY) != 0) {
+		sp->rsa = rsa;
+		return (*(CK_OBJECT_HANDLE_PTR)RSA_get_ex_data(rsa, hndidx_rsa));
+	}
+	
+	a_key_template[0].pValue = &o_key;
+	a_key_template[1].pValue = &k_type;
+
+	/* Put the private key components into the template */
+	if (init_template_value(rsa->n, &a_key_template[6].pValue,
+		&a_key_template[6].ulValueLen) == 0 ||
+	    init_template_value(rsa->e, &a_key_template[7].pValue,
+		&a_key_template[7].ulValueLen) == 0 ||
+	    init_template_value(rsa->d, &a_key_template[8].pValue,
+		&a_key_template[8].ulValueLen) == 0 ||
+	    init_template_value(rsa->p, &a_key_template[9].pValue,
+		&a_key_template[9].ulValueLen) == 0 ||
+	    init_template_value(rsa->q, &a_key_template[10].pValue,
+		&a_key_template[10].ulValueLen) == 0 ||
+	    init_template_value(rsa->dmp1, &a_key_template[11].pValue,
+		&a_key_template[11].ulValueLen) == 0 ||
+	    init_template_value(rsa->dmq1, &a_key_template[12].pValue,
+		&a_key_template[12].ulValueLen) == 0 ||
+	    init_template_value(rsa->iqmp, &a_key_template[13].pValue,
+		&a_key_template[13].ulValueLen) == 0)
+		{
+		PK11err(PK11_F_GET_PRIV_RSA_KEY, PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjectsInit(session, a_key_template, 
+		ul_key_attr_count);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_PRIV_RSA_KEY, PK11_R_FINDOBJECTSINIT);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjects(session, &h_key, 1, &found);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_PRIV_RSA_KEY, PK11_R_FINDOBJECTS);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjectsFinal(session);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_PRIV_RSA_KEY, PK11_R_FINDOBJECTSFINAL);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	if (found == 0)
+		{
+		rv = pFuncList->C_CreateObject(session, 
+			a_key_template, ul_key_attr_count, &h_key);
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_GET_PRIV_RSA_KEY, 
+				PK11_R_CREATEOBJECT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+		}
+
+	sp->rsa = rsa;
+
+ err:
+	/* 6 to 13 entries in the key template are key components
+	 * They need to be freed apon exit or error.
+	 */
+	for (i = 6; i <= 13; i++)
+		{
+		if (a_key_template[i].pValue != NULL)
+			{
+			memset(a_key_template[i].pValue, 0, 
+				a_key_template[i].ulValueLen);
+			OPENSSL_free(a_key_template[i].pValue);
+			a_key_template[i].pValue = NULL;
+			}
+		}
+
+	return h_key;
+	}
+
+#endif
+
+
+#ifndef OPENSSL_NO_DSA
+/* The DSA function implementation
+ */
+static int pk11_DSA_init(DSA *dsa)
+	{
+	return 1;
+	}
+
+
+static int pk11_DSA_finish(DSA *dsa)
+	{
+	return pk11_destroy_dsa_key_objects(NULL);
+	}
+
+
+static DSA_SIG *
+pk11_dsa_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)
+	{
+	BIGNUM *r = NULL, *s = NULL;
+	int i;
+	DSA_SIG *dsa_sig = NULL;
+
+	CK_RV rv;
+	CK_MECHANISM Mechanism_dsa = {CKM_DSA, NULL, 0};
+	CK_MECHANISM *p_mech = &Mechanism_dsa;
+	CK_OBJECT_HANDLE h_priv_key;
+
+	/* The signature is the concatenation of r and s, 
+	 * each is 20 bytes long
+	 */
+	unsigned char sigret[DSA_SIGNATURE_LEN];
+	unsigned long siglen = DSA_SIGNATURE_LEN;
+	unsigned int siglen2 = DSA_SIGNATURE_LEN / 2;
+
+	PK11_SESSION *sp = NULL;
+	char tmp_buf[20];
+
+	if ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL)) 
+		{
+		PK11err(PK11_F_DSA_SIGN, PK11_R_MISSING_KEY_COMPONENT);
+		goto ret;
+		}
+
+	i=BN_num_bytes(dsa->q); /* should be 20 */
+	if (dlen > i)
+		{
+		PK11err(PK11_F_DSA_SIGN, PK11_R_INVALID_SIGNATURE_LENGTH);
+		goto ret;
+		}
+
+	if ((sp = pk11_get_session()) == NULL)
+		goto ret;
+
+	check_new_dsa_key(sp, (void *) dsa);
+
+	h_priv_key = sp->dsa_priv_key;
+	if (h_priv_key == CK_INVALID_HANDLE)
+		h_priv_key = sp->dsa_priv_key =
+			pk11_get_private_dsa_key((DSA *)dsa, sp);
+
+	if (h_priv_key != CK_INVALID_HANDLE)
+		{
+		rv = pFuncList->C_SignInit(sp->session, p_mech, h_priv_key);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_DSA_SIGN, PK11_R_SIGNINIT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto ret;
+			}
+
+		memset(sigret, 0, siglen);
+		rv = pFuncList->C_Sign(sp->session, 
+			(unsigned char*) dgst, dlen, sigret, 
+			(CK_ULONG_PTR) &siglen);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_DSA_SIGN, PK11_R_SIGN);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto ret;
+			}
+		}
+
+
+	if ((s = BN_new()) == NULL)
+		{
+		PK11err(PK11_F_DSA_SIGN, PK11_R_MALLOC_FAILURE);
+		goto ret;
+		}
+
+	if ((r = BN_new()) == NULL)
+		{
+		PK11err(PK11_F_DSA_SIGN, PK11_R_MALLOC_FAILURE);
+		goto ret;
+		}
+
+	if ((dsa_sig = DSA_SIG_new()) == NULL)
+		{
+		PK11err(PK11_F_DSA_SIGN, PK11_R_MALLOC_FAILURE);
+		goto ret;
+		}
+
+	BN_bin2bn(sigret, siglen2, r);
+	BN_bin2bn(&sigret[siglen2], siglen2, s);
+
+	dsa_sig->r = r;
+	dsa_sig->s = s;
+
+ret:
+	if (dsa_sig == NULL) 
+		{
+		if (r != NULL)
+			BN_free(r);
+		if (s != NULL)
+			BN_free(s);
+		}
+
+	pk11_return_session(sp);
+	return (dsa_sig);
+	}
+
+static int
+pk11_dsa_do_verify(const unsigned char *dgst, int dlen, DSA_SIG *sig,
+	DSA *dsa)
+	{
+	int i;
+	CK_RV rv;
+	int retval = 0;
+	CK_MECHANISM Mechanism_dsa = {CKM_DSA, NULL, 0};
+	CK_MECHANISM *p_mech = &Mechanism_dsa;
+	CK_OBJECT_HANDLE h_pub_key;
+
+	unsigned char sigbuf[DSA_SIGNATURE_LEN];
+	unsigned long siglen = DSA_SIGNATURE_LEN;
+	unsigned long siglen2 = DSA_SIGNATURE_LEN/2;
+
+	PK11_SESSION *sp = NULL;
+	char tmp_buf[20];
+
+	if (BN_is_zero(sig->r) || sig->r->neg || BN_ucmp(sig->r, dsa->q) >= 0)
+		{
+		PK11err(PK11_F_DSA_VERIFY, 
+			PK11_R_INVALID_DSA_SIGNATURE_R);
+		goto ret;
+		}
+
+	if (BN_is_zero(sig->s) || sig->s->neg || BN_ucmp(sig->s, dsa->q) >= 0) 
+		{
+		PK11err(PK11_F_DSA_VERIFY, 
+			PK11_R_INVALID_DSA_SIGNATURE_S);
+		goto ret;
+		}
+
+	i = BN_num_bytes(dsa->q); /* should be 20 */
+
+	if (dlen > i)
+		{
+		PK11err(PK11_F_DSA_VERIFY, 
+			PK11_R_INVALID_SIGNATURE_LENGTH);
+		goto ret;
+		}
+
+	if ((sp = pk11_get_session()) == NULL)
+		goto ret;
+	
+	check_new_dsa_key(sp, (void *) dsa);
+
+	h_pub_key = sp->dsa_pub_key;
+	if (h_pub_key == CK_INVALID_HANDLE)
+		h_pub_key = sp->dsa_pub_key = 
+			pk11_get_public_dsa_key((DSA *)dsa, sp);
+
+	if (h_pub_key != CK_INVALID_HANDLE)
+		{
+		rv = pFuncList->C_VerifyInit(sp->session, p_mech, 
+			h_pub_key);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_DSA_VERIFY, PK11_R_VERIFYINIT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto ret;
+			}
+
+		memset(sigbuf, 0, siglen);
+		BN_bn2bin(sig->r, sigbuf);
+		BN_bn2bin(sig->s, &sigbuf[siglen2]);
+		
+		rv = pFuncList->C_Verify(sp->session, 
+			(unsigned char *) dgst, dlen, sigbuf, (CK_ULONG)siglen);
+
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_DSA_VERIFY, PK11_R_VERIFY);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto ret;
+			}
+		}
+
+	retval = 1;
+ret:
+
+	pk11_return_session(sp);
+	return retval;
+	}
+
+
+/* Create a public key object in a session from a given dsa structure.
+ */
+static CK_OBJECT_HANDLE pk11_get_public_dsa_key(DSA* dsa, PK11_SESSION *sp)
+	{
+	CK_RV rv;
+	CK_OBJECT_CLASS o_key = CKO_PUBLIC_KEY;
+	CK_OBJECT_HANDLE h_key = CK_INVALID_HANDLE;
+	CK_ULONG found;
+	CK_KEY_TYPE k_type = CKK_DSA;
+	CK_ULONG ul_key_attr_count = 8;
+	int i;
+	char tmp_buf[20];
+
+	CK_ATTRIBUTE  a_key_template[] =
+		{
+		{CKA_CLASS, (void *) NULL, sizeof(CK_OBJECT_CLASS)},
+		{CKA_KEY_TYPE, (void *) NULL, sizeof(CK_KEY_TYPE)},
+		{CKA_TOKEN, &false, sizeof(true)},
+		{CKA_VERIFY, &true, sizeof(true)},
+		{CKA_PRIME, (void *)NULL, 0},		/* p */
+		{CKA_SUBPRIME, (void *)NULL, 0},	/* q */
+		{CKA_BASE, (void *)NULL, 0},		/* g */
+		{CKA_VALUE, (void *)NULL, 0}		/* pub_key - y */
+		};
+	CK_SESSION_HANDLE session = sp->session;
+
+	a_key_template[0].pValue = &o_key;
+	a_key_template[1].pValue = &k_type;
+
+	if (init_template_value(dsa->p, &a_key_template[4].pValue,
+		&a_key_template[4].ulValueLen) == 0 ||
+	    init_template_value(dsa->q, &a_key_template[5].pValue,
+		&a_key_template[5].ulValueLen) == 0 ||
+	    init_template_value(dsa->g, &a_key_template[6].pValue,
+		&a_key_template[6].ulValueLen) == 0 ||
+	    init_template_value(dsa->pub_key, &a_key_template[7].pValue,
+		&a_key_template[7].ulValueLen) == 0)
+		{
+		PK11err(PK11_F_GET_PUB_DSA_KEY, PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjectsInit(session, a_key_template, 
+		ul_key_attr_count);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_PUB_DSA_KEY, PK11_R_FINDOBJECTSINIT);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjects(session, &h_key, 1, &found);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_PUB_DSA_KEY, PK11_R_FINDOBJECTS);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjectsFinal(session);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_PUB_DSA_KEY, PK11_R_FINDOBJECTSFINAL);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	if (found == 0)
+		{
+		rv = pFuncList->C_CreateObject(session, 
+			a_key_template, ul_key_attr_count, &h_key);
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_GET_PUB_DSA_KEY, 
+				PK11_R_CREATEOBJECT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+		}
+
+	sp->dsa = dsa;
+
+ err:
+	for (i = 4; i <= 7; i++)
+		{
+		if (a_key_template[i].pValue != NULL)
+			{
+			OPENSSL_free(a_key_template[i].pValue);
+			a_key_template[i].pValue = NULL;
+			}
+		}
+
+	return h_key;
+
+	}
+
+/* Create a private key object in the session from a given dsa structure
+ */
+static CK_OBJECT_HANDLE pk11_get_private_dsa_key(DSA* dsa, PK11_SESSION *sp)
+	{
+	CK_RV rv;
+	CK_OBJECT_HANDLE h_key = CK_INVALID_HANDLE;
+	CK_OBJECT_CLASS o_key = CKO_PRIVATE_KEY;
+	int i;
+	char tmp_buf[20];
+	CK_ULONG found;
+	CK_KEY_TYPE k_type = CKK_DSA;
+	CK_ULONG ul_key_attr_count = 9;
+
+	/* Both CKA_TOKEN and CKA_SENSITIVE have to be FALSE for session keys
+	 */
+	CK_ATTRIBUTE  a_key_template[] =
+		{
+		{CKA_CLASS, (void *) NULL, sizeof(CK_OBJECT_CLASS)},
+		{CKA_KEY_TYPE, (void *) NULL, sizeof(CK_KEY_TYPE)},
+		{CKA_TOKEN, &false, sizeof(true)},
+		{CKA_SENSITIVE, &false, sizeof(true)},
+		{CKA_SIGN, &true, sizeof(true)},
+		{CKA_PRIME, (void *)NULL, 0},		/* p */
+		{CKA_SUBPRIME, (void *)NULL, 0},	/* q */
+		{CKA_BASE, (void *)NULL, 0},		/* g */
+		{CKA_VALUE, (void *)NULL, 0}		/* priv_key - x */
+		};
+	CK_SESSION_HANDLE session = sp->session;
+
+	a_key_template[0].pValue = &o_key;
+	a_key_template[1].pValue = &k_type;
+
+	/* Put the private key components into the template
+	 */
+	if (init_template_value(dsa->p, &a_key_template[5].pValue,
+		&a_key_template[5].ulValueLen) == 0 ||
+	    init_template_value(dsa->q, &a_key_template[6].pValue,
+		&a_key_template[6].ulValueLen) == 0 ||
+	    init_template_value(dsa->g, &a_key_template[7].pValue,
+		&a_key_template[7].ulValueLen) == 0 ||
+	    init_template_value(dsa->priv_key, &a_key_template[8].pValue,
+		&a_key_template[8].ulValueLen) == 0)
+		{
+		PK11err(PK11_F_GET_PRIV_DSA_KEY, PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjectsInit(session, a_key_template, 
+		ul_key_attr_count);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_PRIV_DSA_KEY, PK11_R_FINDOBJECTSINIT);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjects(session, &h_key, 1, &found);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_PRIV_DSA_KEY, PK11_R_FINDOBJECTS);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjectsFinal(session);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_PRIV_DSA_KEY, PK11_R_FINDOBJECTSFINAL);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	if (found == 0)
+		{
+		rv = pFuncList->C_CreateObject(session, 
+			a_key_template, ul_key_attr_count, &h_key);
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_GET_PRIV_DSA_KEY, 
+				PK11_R_CREATEOBJECT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+		}
+
+	sp->dsa = dsa;
+
+err:
+	/* 5 to 8 entries in the key template are key components
+	 * They need to be freed apon exit or error.
+	 */
+	for (i = 5; i <= 8; i++)
+		{
+		if (a_key_template[i].pValue != NULL)
+			{
+			memset(a_key_template[i].pValue, 0,
+				a_key_template[i].ulValueLen);
+			OPENSSL_free(a_key_template[i].pValue);
+			a_key_template[i].pValue = NULL;
+			}
+		}
+
+	return h_key;
+
+	}
+#endif
+
+
+#ifndef OPENSSL_NO_DH
+
+/* The DH function implementation
+ */
+static int pk11_DH_init(DH *dh)
+	{
+	return 1;
+	}
+
+
+static int pk11_DH_finish(DH *dh)
+	{
+	return pk11_destroy_dh_key_objects(NULL);
+	}
+
+static int pk11_DH_generate_key(DH *dh)
+	{
+	CK_ULONG i;
+	CK_RV rv, rv1;
+	int ret = 0;
+	PK11_SESSION *sp = NULL;
+	char tmp_buf[20];
+	CK_BYTE_PTR reuse_mem;
+
+	CK_MECHANISM mechanism = {CKM_DH_PKCS_KEY_PAIR_GEN, NULL_PTR, 0};
+	CK_OBJECT_HANDLE h_pub_key = CK_INVALID_HANDLE;
+	CK_OBJECT_HANDLE h_priv_key = CK_INVALID_HANDLE;
+
+	CK_ULONG ul_pub_key_attr_count = 3; 
+	CK_ATTRIBUTE pub_key_template[] =
+		{
+		{CKA_PRIVATE, &false, sizeof(false)},
+		{CKA_PRIME, (void *)NULL, 0},
+		{CKA_BASE, (void *)NULL, 0}
+		};
+
+	CK_ULONG ul_priv_key_attr_count = 3; 
+	CK_ATTRIBUTE priv_key_template[] =
+		{
+		{CKA_PRIVATE, &false, sizeof(false)},
+		{CKA_SENSITIVE, &false, sizeof(false)},
+		{CKA_DERIVE, &true, sizeof(true)}
+		};
+
+	CK_ULONG pub_key_attr_result_count = 1;
+	CK_ATTRIBUTE pub_key_result[] =
+		{
+		{CKA_VALUE, (void *)NULL, 0}
+		};
+
+	CK_ULONG priv_key_attr_result_count = 1;
+	CK_ATTRIBUTE priv_key_result[] =
+		{
+		{CKA_VALUE, (void *)NULL, 0}
+		};
+
+	pub_key_template[1].ulValueLen = BN_num_bytes(dh->p);
+	if (pub_key_template[1].ulValueLen > 0)
+		{
+		pub_key_template[1].pValue = 
+			OPENSSL_malloc(pub_key_template[1].ulValueLen);
+		if (pub_key_template[1].pValue == NULL)
+			{
+			PK11err(PK11_F_DH_GEN_KEY, PK11_R_MALLOC_FAILURE);
+			goto err;
+			}
+
+		i = BN_bn2bin(dh->p, pub_key_template[1].pValue);
+		}
+	else
+		goto err;
+
+	pub_key_template[2].ulValueLen = BN_num_bytes(dh->g);
+	if (pub_key_template[2].ulValueLen > 0)
+		{
+		pub_key_template[2].pValue = 
+			OPENSSL_malloc(pub_key_template[2].ulValueLen);
+		if (pub_key_template[2].pValue == NULL)
+			{
+			PK11err(PK11_F_DH_GEN_KEY, PK11_R_MALLOC_FAILURE);
+			goto err;
+			}
+
+		i = BN_bn2bin(dh->g, pub_key_template[2].pValue);
+		}
+	else
+		goto err;
+
+	if ((sp = pk11_get_session()) == NULL)
+		goto err;
+	
+	rv = pFuncList->C_GenerateKeyPair(sp->session,
+			   &mechanism,
+			   pub_key_template,
+			   ul_pub_key_attr_count,
+			   priv_key_template,
+			   ul_priv_key_attr_count,
+			   &h_pub_key,
+			   &h_priv_key);
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_DH_GEN_KEY, PK11_R_GEN_KEY);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	/* Reuse the larger memory allocated. We know the larger memory
+	 * is sufficient for reuse */
+	if (pub_key_template[1].ulValueLen > pub_key_template[2].ulValueLen)
+		reuse_mem = pub_key_template[1].pValue;
+	else
+		reuse_mem = pub_key_template[2].pValue;
+
+	rv = pFuncList->C_GetAttributeValue(sp->session, h_pub_key, 
+		pub_key_result, pub_key_attr_result_count);
+	rv1 = pFuncList->C_GetAttributeValue(sp->session, h_priv_key, 
+		priv_key_result, priv_key_attr_result_count);
+
+	if (rv != CKR_OK || rv1 != CKR_OK)
+		{
+		rv = (rv != CKR_OK) ? rv : rv1;
+		PK11err(PK11_F_DH_GEN_KEY, PK11_R_GETATTRIBUTVALUE);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	if (((CK_LONG) pub_key_result[0].ulValueLen) <= 0 ||
+		((CK_LONG) priv_key_result[0].ulValueLen) <= 0)
+		{
+		PK11err(PK11_F_DH_GEN_KEY, PK11_R_GETATTRIBUTVALUE);
+		goto err;
+		}
+	
+	/* Reuse the memory allocated */
+	pub_key_result[0].pValue = reuse_mem;
+
+	rv = pFuncList->C_GetAttributeValue(sp->session, h_pub_key, 
+		pub_key_result, pub_key_attr_result_count);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_DH_GEN_KEY, PK11_R_GETATTRIBUTVALUE);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	if (pub_key_result[0].type == CKA_VALUE)
+		{
+		if (dh->pub_key == NULL)
+			dh->pub_key = BN_new();
+		dh->pub_key = BN_bin2bn(pub_key_result[0].pValue, 
+			pub_key_result[0].ulValueLen, dh->pub_key);
+		}
+
+	/* Reuse the memory allocated */
+	priv_key_result[0].pValue = reuse_mem;
+
+	rv = pFuncList->C_GetAttributeValue(sp->session, h_priv_key, 
+		priv_key_result, priv_key_attr_result_count);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_DH_GEN_KEY, PK11_R_GETATTRIBUTVALUE);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	if (priv_key_result[0].type == CKA_VALUE)
+		{
+		if (dh->priv_key == NULL)
+			dh->priv_key = BN_new();
+		dh->priv_key = BN_bin2bn(priv_key_result[0].pValue, 
+			priv_key_result[0].ulValueLen, dh->priv_key);
+		}
+
+	ret = 1;
+
+err:
+	 
+	if (h_pub_key != CK_INVALID_HANDLE)
+		{
+		rv = pFuncList->C_DestroyObject(sp->session, h_pub_key);
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_DH_GEN_KEY, PK11_R_DESTROYOBJECT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			}
+		}
+
+	if (h_priv_key != CK_INVALID_HANDLE)
+		{
+		rv = pFuncList->C_DestroyObject(sp->session, h_priv_key);
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_DH_GEN_KEY, PK11_R_DESTROYOBJECT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			}
+		}
+
+	for (i = 1; i <= 2; i++)
+		{
+		if (pub_key_template[i].pValue != NULL)
+			{
+			OPENSSL_free(pub_key_template[i].pValue);
+			pub_key_template[i].pValue = NULL;
+			}
+		}
+
+	pk11_return_session(sp);
+	return ret;
+	}
+
+static int pk11_DH_compute_key(unsigned char *key,const BIGNUM *pub_key,DH *dh)
+	{
+	int i;
+	CK_MECHANISM mechanism = {CKM_DH_PKCS_DERIVE, NULL_PTR, 0};
+	CK_OBJECT_CLASS key_class = CKO_SECRET_KEY;
+	CK_KEY_TYPE key_type = CKK_GENERIC_SECRET;
+	CK_OBJECT_HANDLE h_derived_key = CK_INVALID_HANDLE;
+	CK_OBJECT_HANDLE h_key = CK_INVALID_HANDLE;
+
+	CK_ULONG ul_priv_key_attr_count = 2;
+	CK_ATTRIBUTE priv_key_template[] =
+		{
+		{CKA_CLASS, (void*) NULL, sizeof(key_class)},
+		{CKA_KEY_TYPE, (void*) NULL,  sizeof(key_type)},
+		};
+
+	CK_ULONG priv_key_attr_result_count = 1;
+	CK_ATTRIBUTE priv_key_result[] =
+		{
+		{CKA_VALUE, (void *)NULL, 0}
+		};
+
+	CK_RV rv;
+	int ret = 0;
+	PK11_SESSION *sp = NULL;
+	char tmp_buf[20];
+
+	priv_key_template[0].pValue = &key_class;
+	priv_key_template[1].pValue = &key_type;
+
+	if ((sp = pk11_get_session()) == NULL)
+		goto err;
+
+	mechanism.ulParameterLen = BN_num_bytes(pub_key);
+	mechanism.pParameter = OPENSSL_malloc(mechanism.ulParameterLen);
+	if (mechanism.pParameter == NULL)
+		{
+		PK11err(PK11_F_DH_COMP_KEY, PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+	BN_bn2bin(pub_key, mechanism.pParameter);
+
+	check_new_dh_key(sp, dh);
+
+	h_key = sp->dh_key;
+	if (h_key == CK_INVALID_HANDLE)
+		h_key = sp->dh_key = pk11_get_dh_key((DH*) dh, sp);
+
+	if (h_key == CK_INVALID_HANDLE)
+		{
+		PK11err(PK11_F_DH_COMP_KEY, PK11_R_CREATEOBJECT);
+		goto err;
+		}
+
+	rv = pFuncList->C_DeriveKey(sp->session,
+			   &mechanism,
+			   h_key,
+			   priv_key_template,
+			   ul_priv_key_attr_count,
+			   &h_derived_key);
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_DH_COMP_KEY, PK11_R_DERIVEKEY);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	rv = pFuncList->C_GetAttributeValue(sp->session, h_derived_key, 
+		priv_key_result, priv_key_attr_result_count);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_DH_COMP_KEY, PK11_R_GETATTRIBUTVALUE);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	if (((CK_LONG) priv_key_result[0].ulValueLen) <= 0)
+		{
+		PK11err(PK11_F_DH_COMP_KEY, PK11_R_GETATTRIBUTVALUE);
+		goto err;
+		}
+	priv_key_result[0].pValue = 
+		OPENSSL_malloc(priv_key_result[0].ulValueLen);
+	if (!priv_key_result[0].pValue)
+		{
+		PK11err(PK11_F_DH_COMP_KEY, PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	rv = pFuncList->C_GetAttributeValue(sp->session, h_derived_key, 
+		priv_key_result, priv_key_attr_result_count);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_DH_COMP_KEY, PK11_R_GETATTRIBUTVALUE);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	/* OpenSSL allocates the output buffer 'key' which is the same
+	 * length of the public key. It is long enough for the derived key */
+	if (priv_key_result[0].type == CKA_VALUE)
+		{
+		/* CKM_DH_PKCS_DERIVE mechanism is not supposed to strip
+		 * leading zeros from a computed shared secret. However,
+		 * OpenSSL always did it so we must do the same here. The
+		 * vagueness of the spec regarding leading zero bytes was
+		 * finally cleared with TLS 1.1 (RFC 4346) saying that leading
+		 * zeros are stripped before the computed data is used as the
+		 * pre-master secret.
+		 */
+		for (i = 0; i < priv_key_result[0].ulValueLen; ++i)
+			{
+			if (((char *) priv_key_result[0].pValue)[i] != 0)
+				break;
+			}
+
+		memcpy(key, ((char *) priv_key_result[0].pValue) + i, 
+			priv_key_result[0].ulValueLen - i);
+		ret = priv_key_result[0].ulValueLen - i;
+		}
+
+err:
+
+	if (h_derived_key != CK_INVALID_HANDLE)
+		{
+		rv = pFuncList->C_DestroyObject(sp->session, h_derived_key);
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_DH_COMP_KEY, PK11_R_DESTROYOBJECT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			}
+		}
+	if (priv_key_result[0].pValue)
+		{ 
+		OPENSSL_free(priv_key_result[0].pValue);
+		priv_key_result[0].pValue = NULL;
+		}
+
+	if (mechanism.pParameter)
+		{
+		OPENSSL_free(mechanism.pParameter);
+		mechanism.pParameter = NULL;
+		}
+
+	pk11_return_session(sp);
+	return ret;
+	}
+
+
+static CK_OBJECT_HANDLE pk11_get_dh_key(DH* dh, PK11_SESSION *sp)
+	{
+	CK_RV rv;
+	CK_OBJECT_HANDLE h_key = CK_INVALID_HANDLE;
+	CK_OBJECT_CLASS class = CKO_PRIVATE_KEY;
+	CK_KEY_TYPE key_type = CKK_DH;
+	CK_ULONG found;
+	int i;
+	char tmp_buf[20];
+
+	CK_ULONG ul_key_attr_count = 7;
+	CK_ATTRIBUTE key_template[] =
+		{
+		{CKA_CLASS, (void*) NULL, sizeof(class)},
+		{CKA_KEY_TYPE, (void*) NULL, sizeof(key_type)},
+		{CKA_DERIVE, &true, sizeof(true)},
+		{CKA_PRIVATE, &false, sizeof(false)},
+		{CKA_PRIME, (void *) NULL, 0},
+		{CKA_BASE, (void *) NULL, 0},
+		{CKA_VALUE, (void *) NULL, 0},
+		};
+
+	CK_SESSION_HANDLE session = sp->session;
+
+	key_template[0].pValue = &class;
+	key_template[1].pValue = &key_type;
+
+	key_template[4].ulValueLen = BN_num_bytes(dh->p);
+	key_template[4].pValue = (CK_VOID_PTR)OPENSSL_malloc(
+		(size_t)key_template[4].ulValueLen);
+	if (key_template[4].pValue == NULL)
+		{
+		PK11err(PK11_F_GET_DH_KEY, PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	BN_bn2bin(dh->p, key_template[4].pValue);
+
+	key_template[5].ulValueLen = BN_num_bytes(dh->g);
+	key_template[5].pValue = (CK_VOID_PTR)OPENSSL_malloc(
+		(size_t)key_template[5].ulValueLen);
+	if (key_template[5].pValue == NULL)
+		{
+		PK11err(PK11_F_GET_DH_KEY, PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	BN_bn2bin(dh->g, key_template[5].pValue);
+
+	key_template[6].ulValueLen = BN_num_bytes(dh->priv_key);
+	key_template[6].pValue = (CK_VOID_PTR)OPENSSL_malloc(
+		(size_t)key_template[6].ulValueLen);
+	if (key_template[6].pValue == NULL)
+		{
+		PK11err(PK11_F_GET_DH_KEY, PK11_R_MALLOC_FAILURE);
+		goto err;
+		}
+
+	BN_bn2bin(dh->priv_key, key_template[6].pValue);
+
+	rv = pFuncList->C_FindObjectsInit(session, key_template, 
+		ul_key_attr_count);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_DH_KEY, PK11_R_FINDOBJECTSINIT);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjects(session, &h_key, 1, &found);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_DH_KEY, PK11_R_FINDOBJECTS);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	rv = pFuncList->C_FindObjectsFinal(session);
+
+	if (rv != CKR_OK)
+		{
+		PK11err(PK11_F_GET_DH_KEY, PK11_R_FINDOBJECTSFINAL);
+		snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+		ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+		goto err;
+		}
+
+	if (found == 0)
+		{
+		rv = pFuncList->C_CreateObject(session, 
+			key_template, ul_key_attr_count, &h_key);
+		if (rv != CKR_OK)
+			{
+			PK11err(PK11_F_GET_DH_KEY, PK11_R_CREATEOBJECT);
+			snprintf(tmp_buf, sizeof (tmp_buf), "%lx", rv);
+			ERR_add_error_data(2, "PK11 CK_RV=0X", tmp_buf);
+			goto err;
+			}
+		}
+
+	sp->dh = dh;
+
+ err:
+	for (i = 4; i <= 6; i++)
+		{
+		if (key_template[i].pValue != NULL)
+			{
+			OPENSSL_free(key_template[i].pValue);
+			key_template[i].pValue = NULL;
+			}
+		}
+
+	return h_key;
+	}
+
+#endif
+
+/* Local function to simplify key template population
+ * Return 0 -- error, 1 -- no error
+ */
+static int init_template_value(BIGNUM *bn, CK_VOID_PTR *p_value, 
+	CK_ULONG *ul_value_len)
+	{
+	CK_ULONG len = BN_num_bytes(bn);
+	if (len == 0)
+		return 1;
+
+	*ul_value_len = len;
+	*p_value = (CK_VOID_PTR)OPENSSL_malloc((size_t) *ul_value_len);
+	if (*p_value == NULL)
+		return 0;
+
+	BN_bn2bin(bn, *p_value);
+
+	return 1;
+	}
+
+static void attr_to_BN(CK_ATTRIBUTE_PTR attr, CK_BYTE attr_data[], BIGNUM **bn)
+	{
+		if (attr->ulValueLen > 0)
+			{
+			*bn = BN_bin2bn(attr_data, attr->ulValueLen, NULL);
+			}
+	}
+
+static void check_new_rsa_key(PK11_SESSION *sp, void *rsa)
+	{
+	if (sp->rsa != rsa)
+		pk11_destroy_rsa_key_objects(sp);
+	}
+
+static void check_new_dsa_key(PK11_SESSION *sp, void *dsa)
+	{
+	if (sp->dsa != dsa)
+		pk11_destroy_dsa_key_objects(sp);
+	}
+
+static void check_new_dh_key(PK11_SESSION *sp, void *dh)
+	{
+	if (sp->dh != dh)
+		pk11_destroy_dh_key_objects(sp);
+	}
+
+
+#endif
+#endif
diff -r -u -N openssl-0.9.8g/crypto/engine/Makefile openssl/crypto/engine/Makefile
--- openssl-0.9.8g/crypto/engine/Makefile	2005-07-16 13:13:05.000000000 +0200
+++ openssl/crypto/engine/Makefile	2007-10-25 01:27:09.000000000 +0200
@@ -21,12 +21,14 @@
 	eng_table.c eng_pkey.c eng_fat.c eng_all.c \
 	tb_rsa.c tb_dsa.c tb_ecdsa.c tb_dh.c tb_ecdh.c tb_rand.c tb_store.c \
 	tb_cipher.c tb_digest.c \
-	eng_openssl.c eng_cnf.c eng_dyn.c eng_cryptodev.c eng_padlock.c
+	eng_openssl.c eng_cnf.c eng_dyn.c eng_cryptodev.c eng_padlock.c \
+	hw_pk11.c hw_pk11_pub.c
 LIBOBJ= eng_err.o eng_lib.o eng_list.o eng_init.o eng_ctrl.o \
 	eng_table.o eng_pkey.o eng_fat.o eng_all.o \
 	tb_rsa.o tb_dsa.o tb_ecdsa.o tb_dh.o tb_ecdh.o tb_rand.o tb_store.o \
 	tb_cipher.o tb_digest.o \
-	eng_openssl.o eng_cnf.o eng_dyn.o eng_cryptodev.o eng_padlock.o
+	eng_openssl.o eng_cnf.o eng_dyn.o eng_cryptodev.o eng_padlock.o \
+	hw_pk11.o hw_pk11_pub.o
 
 SRC= $(LIBSRC)
 
@@ -212,6 +214,54 @@
 eng_table.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
 eng_table.o: ../../include/openssl/symhacks.h ../cryptlib.h eng_int.h
 eng_table.o: eng_table.c
+hw_pk11.o: ../../include/openssl/e_os2.h ../../include/openssl/opensslconf.h
+hw_pk11.o: ../../include/openssl/engine.h ../../include/openssl/ossl_typ.h
+hw_pk11.o: ../../include/openssl/bn.h ../../include/openssl/rsa.h
+hw_pk11.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+hw_pk11.o: ../../include/openssl/crypto.h ../../include/openssl/stack.h
+hw_pk11.o: ../../include/openssl/safestack.h ../../include/openssl/opensslv.h
+hw_pk11.o: ../../include/openssl/symhacks.h ../../include/openssl/dsa.h
+hw_pk11.o: ../../include/openssl/dh.h ../../include/openssl/rand.h
+hw_pk11.o: ../../include/openssl/ui.h ../../include/openssl/err.h
+hw_pk11.o: ../../include/openssl/lhash.h ../../include/openssl/dso.h
+hw_pk11.o: ../../include/openssl/pem.h ../../include/openssl/evp.h
+hw_pk11.o: ../../include/openssl/md2.h ../../include/openssl/md4.h
+hw_pk11.o: ../../include/openssl/md5.h ../../include/openssl/sha.h
+hw_pk11.o: ../../include/openssl/ripemd.h ../../include/openssl/des.h
+hw_pk11.o: ../../include/openssl/des_old.h ../../include/openssl/ui_compat.h
+hw_pk11.o: ../../include/openssl/rc4.h ../../include/openssl/rc2.h
+hw_pk11.o: ../../crypto/rc5/rc5.h ../../include/openssl/blowfish.h
+hw_pk11.o: ../../include/openssl/cast.h ../../include/openssl/idea.h
+hw_pk11.o: ../../crypto/mdc2/mdc2.h ../../include/openssl/aes.h
+hw_pk11.o: ../../include/openssl/objects.h ../../include/openssl/obj_mac.h
+hw_pk11.o: ../../include/openssl/x509.h ../../include/openssl/buffer.h
+hw_pk11.o: ../../include/openssl/x509_vfy.h ../../include/openssl/pkcs7.h
+hw_pk11.o: ../../include/openssl/pem2.h ../cryptlib.h
+hw_pk11.o: ../../e_os.h hw_pk11_err.c hw_pk11_err.h hw_pk11.c
+hw_pk11_pub.o: ../../include/openssl/e_os2.h ../../include/openssl/opensslconf.h
+hw_pk11_pub.o: ../../include/openssl/engine.h ../../include/openssl/ossl_typ.h
+hw_pk11_pub.o: ../../include/openssl/bn.h ../../include/openssl/rsa.h
+hw_pk11_pub.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
+hw_pk11_pub.o: ../../include/openssl/crypto.h ../../include/openssl/stack.h
+hw_pk11_pub.o: ../../include/openssl/safestack.h ../../include/openssl/opensslv.h
+hw_pk11_pub.o: ../../include/openssl/symhacks.h ../../include/openssl/dsa.h
+hw_pk11_pub.o: ../../include/openssl/dh.h ../../include/openssl/rand.h
+hw_pk11_pub.o: ../../include/openssl/ui.h ../../include/openssl/err.h
+hw_pk11_pub.o: ../../include/openssl/lhash.h ../../include/openssl/dso.h
+hw_pk11_pub.o: ../../include/openssl/pem.h ../../include/openssl/evp.h
+hw_pk11_pub.o: ../../include/openssl/md2.h ../../include/openssl/md4.h
+hw_pk11_pub.o: ../../include/openssl/md5.h ../../include/openssl/sha.h
+hw_pk11_pub.o: ../../include/openssl/ripemd.h ../../include/openssl/des.h
+hw_pk11_pub.o: ../../include/openssl/des_old.h ../../include/openssl/ui_compat.h
+hw_pk11_pub.o: ../../include/openssl/rc4.h ../../include/openssl/rc2.h
+hw_pk11_pub.o: ../../crypto/rc5/rc5.h ../../include/openssl/blowfish.h
+hw_pk11_pub.o: ../../include/openssl/cast.h ../../include/openssl/idea.h
+hw_pk11_pub.o: ../../crypto/mdc2/mdc2.h ../../include/openssl/aes.h
+hw_pk11_pub.o: ../../include/openssl/objects.h ../../include/openssl/obj_mac.h
+hw_pk11_pub.o: ../../include/openssl/x509.h ../../include/openssl/buffer.h
+hw_pk11_pub.o: ../../include/openssl/x509_vfy.h ../../include/openssl/pkcs7.h
+hw_pk11_pub.o: ../../include/openssl/pem2.h ../cryptlib.h
+hw_pk11_pub.o: ../../e_os.h hw_pk11_err.c hw_pk11_err.h hw_pk11_pub.c
 tb_cipher.o: ../../e_os.h ../../include/openssl/bio.h
 tb_cipher.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
 tb_cipher.o: ../../include/openssl/e_os2.h ../../include/openssl/engine.h
diff -r -u -N openssl-0.9.8g/crypto/engine/pkcs11f.h openssl/crypto/engine/pkcs11f.h
--- openssl-0.9.8g/crypto/engine/pkcs11f.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl/crypto/engine/pkcs11f.h	2007-10-25 01:27:09.000000000 +0200
@@ -0,0 +1,912 @@
+/* pkcs11f.h include file for PKCS #11. */
+/* Revision: 1.2 */
+
+/* License to copy and use this software is granted provided that it is
+ * identified as "RSA Security Inc. PKCS #11 Cryptographic Token Interface
+ * (Cryptoki)" in all material mentioning or referencing this software.
+
+ * License is also granted to make and use derivative works provided that
+ * such works are identified as "derived from the RSA Security Inc. PKCS #11
+ * Cryptographic Token Interface (Cryptoki)" in all material mentioning or 
+ * referencing the derived work.
+
+ * RSA Security Inc. makes no representations concerning either the 
+ * merchantability of this software or the suitability of this software for
+ * any particular purpose. It is provided "as is" without express or implied
+ * warranty of any kind.
+ */
+
+/* This header file contains pretty much everything about all the */
+/* Cryptoki function prototypes.  Because this information is */
+/* used for more than just declaring function prototypes, the */
+/* order of the functions appearing herein is important, and */
+/* should not be altered. */
+
+/* General-purpose */
+
+/* C_Initialize initializes the Cryptoki library. */
+CK_PKCS11_FUNCTION_INFO(C_Initialize)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_VOID_PTR   pInitArgs  /* if this is not NULL_PTR, it gets
+                            * cast to CK_C_INITIALIZE_ARGS_PTR
+                            * and dereferenced */
+);
+#endif
+
+
+/* C_Finalize indicates that an application is done with the
+ * Cryptoki library. */
+CK_PKCS11_FUNCTION_INFO(C_Finalize)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_VOID_PTR   pReserved  /* reserved.  Should be NULL_PTR */
+);
+#endif
+
+
+/* C_GetInfo returns general information about Cryptoki. */
+CK_PKCS11_FUNCTION_INFO(C_GetInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_INFO_PTR   pInfo  /* location that receives information */
+);
+#endif
+
+
+/* C_GetFunctionList returns the function list. */
+CK_PKCS11_FUNCTION_INFO(C_GetFunctionList)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_FUNCTION_LIST_PTR_PTR ppFunctionList  /* receives pointer to
+                                            * function list */
+);
+#endif
+
+
+
+/* Slot and token management */
+
+/* C_GetSlotList obtains a list of slots in the system. */
+CK_PKCS11_FUNCTION_INFO(C_GetSlotList)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_BBOOL       tokenPresent,  /* only slots with tokens? */
+  CK_SLOT_ID_PTR pSlotList,     /* receives array of slot IDs */
+  CK_ULONG_PTR   pulCount       /* receives number of slots */
+);
+#endif
+
+
+/* C_GetSlotInfo obtains information about a particular slot in
+ * the system. */
+CK_PKCS11_FUNCTION_INFO(C_GetSlotInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID       slotID,  /* the ID of the slot */
+  CK_SLOT_INFO_PTR pInfo    /* receives the slot information */
+);
+#endif
+
+
+/* C_GetTokenInfo obtains information about a particular token
+ * in the system. */
+CK_PKCS11_FUNCTION_INFO(C_GetTokenInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID        slotID,  /* ID of the token's slot */
+  CK_TOKEN_INFO_PTR pInfo    /* receives the token information */
+);
+#endif
+
+
+/* C_GetMechanismList obtains a list of mechanism types
+ * supported by a token. */
+CK_PKCS11_FUNCTION_INFO(C_GetMechanismList)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID            slotID,          /* ID of token's slot */
+  CK_MECHANISM_TYPE_PTR pMechanismList,  /* gets mech. array */
+  CK_ULONG_PTR          pulCount         /* gets # of mechs. */
+);
+#endif
+
+
+/* C_GetMechanismInfo obtains information about a particular
+ * mechanism possibly supported by a token. */
+CK_PKCS11_FUNCTION_INFO(C_GetMechanismInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID            slotID,  /* ID of the token's slot */
+  CK_MECHANISM_TYPE     type,    /* type of mechanism */
+  CK_MECHANISM_INFO_PTR pInfo    /* receives mechanism info */
+);
+#endif
+
+
+/* C_InitToken initializes a token. */
+CK_PKCS11_FUNCTION_INFO(C_InitToken)
+#ifdef CK_NEED_ARG_LIST
+/* pLabel changed from CK_CHAR_PTR to CK_UTF8CHAR_PTR for v2.10 */
+(
+  CK_SLOT_ID      slotID,    /* ID of the token's slot */
+  CK_UTF8CHAR_PTR pPin,      /* the SO's initial PIN */
+  CK_ULONG        ulPinLen,  /* length in bytes of the PIN */
+  CK_UTF8CHAR_PTR pLabel     /* 32-byte token label (blank padded) */
+);
+#endif
+
+
+/* C_InitPIN initializes the normal user's PIN. */
+CK_PKCS11_FUNCTION_INFO(C_InitPIN)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_UTF8CHAR_PTR   pPin,      /* the normal user's PIN */
+  CK_ULONG          ulPinLen   /* length in bytes of the PIN */
+);
+#endif
+
+
+/* C_SetPIN modifies the PIN of the user who is logged in. */
+CK_PKCS11_FUNCTION_INFO(C_SetPIN)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_UTF8CHAR_PTR   pOldPin,   /* the old PIN */
+  CK_ULONG          ulOldLen,  /* length of the old PIN */
+  CK_UTF8CHAR_PTR   pNewPin,   /* the new PIN */
+  CK_ULONG          ulNewLen   /* length of the new PIN */
+);
+#endif
+
+
+
+/* Session management */
+
+/* C_OpenSession opens a session between an application and a
+ * token. */
+CK_PKCS11_FUNCTION_INFO(C_OpenSession)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID            slotID,        /* the slot's ID */
+  CK_FLAGS              flags,         /* from CK_SESSION_INFO */
+  CK_VOID_PTR           pApplication,  /* passed to callback */
+  CK_NOTIFY             Notify,        /* callback function */
+  CK_SESSION_HANDLE_PTR phSession      /* gets session handle */
+);
+#endif
+
+
+/* C_CloseSession closes a session between an application and a
+ * token. */
+CK_PKCS11_FUNCTION_INFO(C_CloseSession)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+/* C_CloseAllSessions closes all sessions with a token. */
+CK_PKCS11_FUNCTION_INFO(C_CloseAllSessions)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID     slotID  /* the token's slot */
+);
+#endif
+
+
+/* C_GetSessionInfo obtains information about the session. */
+CK_PKCS11_FUNCTION_INFO(C_GetSessionInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE   hSession,  /* the session's handle */
+  CK_SESSION_INFO_PTR pInfo      /* receives session info */
+);
+#endif
+
+
+/* C_GetOperationState obtains the state of the cryptographic operation
+ * in a session. */
+CK_PKCS11_FUNCTION_INFO(C_GetOperationState)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,             /* session's handle */
+  CK_BYTE_PTR       pOperationState,      /* gets state */
+  CK_ULONG_PTR      pulOperationStateLen  /* gets state length */
+);
+#endif
+
+
+/* C_SetOperationState restores the state of the cryptographic
+ * operation in a session. */
+CK_PKCS11_FUNCTION_INFO(C_SetOperationState)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR      pOperationState,      /* holds state */
+  CK_ULONG         ulOperationStateLen,  /* holds state length */
+  CK_OBJECT_HANDLE hEncryptionKey,       /* en/decryption key */
+  CK_OBJECT_HANDLE hAuthenticationKey    /* sign/verify key */
+);
+#endif
+
+
+/* C_Login logs a user into a token. */
+CK_PKCS11_FUNCTION_INFO(C_Login)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_USER_TYPE      userType,  /* the user type */
+  CK_UTF8CHAR_PTR   pPin,      /* the user's PIN */
+  CK_ULONG          ulPinLen   /* the length of the PIN */
+);
+#endif
+
+
+/* C_Logout logs a user out from a token. */
+CK_PKCS11_FUNCTION_INFO(C_Logout)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+
+/* Object management */
+
+/* C_CreateObject creates a new object. */
+CK_PKCS11_FUNCTION_INFO(C_CreateObject)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_ATTRIBUTE_PTR  pTemplate,   /* the object's template */
+  CK_ULONG          ulCount,     /* attributes in template */
+  CK_OBJECT_HANDLE_PTR phObject  /* gets new object's handle. */
+);
+#endif
+
+
+/* C_CopyObject copies an object, creating a new object for the
+ * copy. */
+CK_PKCS11_FUNCTION_INFO(C_CopyObject)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,    /* the session's handle */
+  CK_OBJECT_HANDLE     hObject,     /* the object's handle */
+  CK_ATTRIBUTE_PTR     pTemplate,   /* template for new object */
+  CK_ULONG             ulCount,     /* attributes in template */
+  CK_OBJECT_HANDLE_PTR phNewObject  /* receives handle of copy */
+);
+#endif
+
+
+/* C_DestroyObject destroys an object. */
+CK_PKCS11_FUNCTION_INFO(C_DestroyObject)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_OBJECT_HANDLE  hObject    /* the object's handle */
+);
+#endif
+
+
+/* C_GetObjectSize gets the size of an object in bytes. */
+CK_PKCS11_FUNCTION_INFO(C_GetObjectSize)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_OBJECT_HANDLE  hObject,   /* the object's handle */
+  CK_ULONG_PTR      pulSize    /* receives size of object */
+);
+#endif
+
+
+/* C_GetAttributeValue obtains the value of one or more object
+ * attributes. */
+CK_PKCS11_FUNCTION_INFO(C_GetAttributeValue)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_OBJECT_HANDLE  hObject,    /* the object's handle */
+  CK_ATTRIBUTE_PTR  pTemplate,  /* specifies attrs; gets vals */
+  CK_ULONG          ulCount     /* attributes in template */
+);
+#endif
+
+
+/* C_SetAttributeValue modifies the value of one or more object
+ * attributes */
+CK_PKCS11_FUNCTION_INFO(C_SetAttributeValue)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_OBJECT_HANDLE  hObject,    /* the object's handle */
+  CK_ATTRIBUTE_PTR  pTemplate,  /* specifies attrs and values */
+  CK_ULONG          ulCount     /* attributes in template */
+);
+#endif
+
+
+/* C_FindObjectsInit initializes a search for token and session
+ * objects that match a template. */
+CK_PKCS11_FUNCTION_INFO(C_FindObjectsInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_ATTRIBUTE_PTR  pTemplate,  /* attribute values to match */
+  CK_ULONG          ulCount     /* attrs in search template */
+);
+#endif
+
+
+/* C_FindObjects continues a search for token and session
+ * objects that match a template, obtaining additional object
+ * handles. */
+CK_PKCS11_FUNCTION_INFO(C_FindObjects)
+#ifdef CK_NEED_ARG_LIST
+(
+ CK_SESSION_HANDLE    hSession,          /* session's handle */
+ CK_OBJECT_HANDLE_PTR phObject,          /* gets obj. handles */
+ CK_ULONG             ulMaxObjectCount,  /* max handles to get */
+ CK_ULONG_PTR         pulObjectCount     /* actual # returned */
+);
+#endif
+
+
+/* C_FindObjectsFinal finishes a search for token and session
+ * objects. */
+CK_PKCS11_FUNCTION_INFO(C_FindObjectsFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+
+/* Encryption and decryption */
+
+/* C_EncryptInit initializes an encryption operation. */
+CK_PKCS11_FUNCTION_INFO(C_EncryptInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the encryption mechanism */
+  CK_OBJECT_HANDLE  hKey         /* handle of encryption key */
+);
+#endif
+
+
+/* C_Encrypt encrypts single-part data. */
+CK_PKCS11_FUNCTION_INFO(C_Encrypt)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pData,               /* the plaintext data */
+  CK_ULONG          ulDataLen,           /* bytes of plaintext */
+  CK_BYTE_PTR       pEncryptedData,      /* gets ciphertext */
+  CK_ULONG_PTR      pulEncryptedDataLen  /* gets c-text size */
+);
+#endif
+
+
+/* C_EncryptUpdate continues a multiple-part encryption
+ * operation. */
+CK_PKCS11_FUNCTION_INFO(C_EncryptUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,           /* session's handle */
+  CK_BYTE_PTR       pPart,              /* the plaintext data */
+  CK_ULONG          ulPartLen,          /* plaintext data len */
+  CK_BYTE_PTR       pEncryptedPart,     /* gets ciphertext */
+  CK_ULONG_PTR      pulEncryptedPartLen /* gets c-text size */
+);
+#endif
+
+
+/* C_EncryptFinal finishes a multiple-part encryption
+ * operation. */
+CK_PKCS11_FUNCTION_INFO(C_EncryptFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,                /* session handle */
+  CK_BYTE_PTR       pLastEncryptedPart,      /* last c-text */
+  CK_ULONG_PTR      pulLastEncryptedPartLen  /* gets last size */
+);
+#endif
+
+
+/* C_DecryptInit initializes a decryption operation. */
+CK_PKCS11_FUNCTION_INFO(C_DecryptInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the decryption mechanism */
+  CK_OBJECT_HANDLE  hKey         /* handle of decryption key */
+);
+#endif
+
+
+/* C_Decrypt decrypts encrypted data in a single part. */
+CK_PKCS11_FUNCTION_INFO(C_Decrypt)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,           /* session's handle */
+  CK_BYTE_PTR       pEncryptedData,     /* ciphertext */
+  CK_ULONG          ulEncryptedDataLen, /* ciphertext length */
+  CK_BYTE_PTR       pData,              /* gets plaintext */
+  CK_ULONG_PTR      pulDataLen          /* gets p-text size */
+);
+#endif
+
+
+/* C_DecryptUpdate continues a multiple-part decryption
+ * operation. */
+CK_PKCS11_FUNCTION_INFO(C_DecryptUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pEncryptedPart,      /* encrypted data */
+  CK_ULONG          ulEncryptedPartLen,  /* input length */
+  CK_BYTE_PTR       pPart,               /* gets plaintext */
+  CK_ULONG_PTR      pulPartLen           /* p-text size */
+);
+#endif
+
+
+/* C_DecryptFinal finishes a multiple-part decryption
+ * operation. */
+CK_PKCS11_FUNCTION_INFO(C_DecryptFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,       /* the session's handle */
+  CK_BYTE_PTR       pLastPart,      /* gets plaintext */
+  CK_ULONG_PTR      pulLastPartLen  /* p-text size */
+);
+#endif
+
+
+
+/* Message digesting */
+
+/* C_DigestInit initializes a message-digesting operation. */
+CK_PKCS11_FUNCTION_INFO(C_DigestInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism  /* the digesting mechanism */
+);
+#endif
+
+
+/* C_Digest digests data in a single part. */
+CK_PKCS11_FUNCTION_INFO(C_Digest)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,     /* the session's handle */
+  CK_BYTE_PTR       pData,        /* data to be digested */
+  CK_ULONG          ulDataLen,    /* bytes of data to digest */
+  CK_BYTE_PTR       pDigest,      /* gets the message digest */
+  CK_ULONG_PTR      pulDigestLen  /* gets digest length */
+);
+#endif
+
+
+/* C_DigestUpdate continues a multiple-part message-digesting
+ * operation. */
+CK_PKCS11_FUNCTION_INFO(C_DigestUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_BYTE_PTR       pPart,     /* data to be digested */
+  CK_ULONG          ulPartLen  /* bytes of data to be digested */
+);
+#endif
+
+
+/* C_DigestKey continues a multi-part message-digesting
+ * operation, by digesting the value of a secret key as part of
+ * the data already digested. */
+CK_PKCS11_FUNCTION_INFO(C_DigestKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_OBJECT_HANDLE  hKey       /* secret key to digest */
+);
+#endif
+
+
+/* C_DigestFinal finishes a multiple-part message-digesting
+ * operation. */
+CK_PKCS11_FUNCTION_INFO(C_DigestFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,     /* the session's handle */
+  CK_BYTE_PTR       pDigest,      /* gets the message digest */
+  CK_ULONG_PTR      pulDigestLen  /* gets byte count of digest */
+);
+#endif
+
+
+
+/* Signing and MACing */
+
+/* C_SignInit initializes a signature (private key encryption)
+ * operation, where the signature is (will be) an appendix to
+ * the data, and plaintext cannot be recovered from the
+ *signature. */
+CK_PKCS11_FUNCTION_INFO(C_SignInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the signature mechanism */
+  CK_OBJECT_HANDLE  hKey         /* handle of signature key */
+);
+#endif
+
+
+/* C_Sign signs (encrypts with private key) data in a single
+ * part, where the signature is (will be) an appendix to the
+ * data, and plaintext cannot be recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_Sign)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_BYTE_PTR       pData,           /* the data to sign */
+  CK_ULONG          ulDataLen,       /* count of bytes to sign */
+  CK_BYTE_PTR       pSignature,      /* gets the signature */
+  CK_ULONG_PTR      pulSignatureLen  /* gets signature length */
+);
+#endif
+
+
+/* C_SignUpdate continues a multiple-part signature operation,
+ * where the signature is (will be) an appendix to the data, 
+ * and plaintext cannot be recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_SignUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_BYTE_PTR       pPart,     /* the data to sign */
+  CK_ULONG          ulPartLen  /* count of bytes to sign */
+);
+#endif
+
+
+/* C_SignFinal finishes a multiple-part signature operation, 
+ * returning the signature. */
+CK_PKCS11_FUNCTION_INFO(C_SignFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_BYTE_PTR       pSignature,      /* gets the signature */
+  CK_ULONG_PTR      pulSignatureLen  /* gets signature length */
+);
+#endif
+
+
+/* C_SignRecoverInit initializes a signature operation, where
+ * the data can be recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_SignRecoverInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism, /* the signature mechanism */
+  CK_OBJECT_HANDLE  hKey        /* handle of the signature key */
+);
+#endif
+
+
+/* C_SignRecover signs data in a single operation, where the
+ * data can be recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_SignRecover)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_BYTE_PTR       pData,           /* the data to sign */
+  CK_ULONG          ulDataLen,       /* count of bytes to sign */
+  CK_BYTE_PTR       pSignature,      /* gets the signature */
+  CK_ULONG_PTR      pulSignatureLen  /* gets signature length */
+);
+#endif
+
+
+
+/* Verifying signatures and MACs */
+
+/* C_VerifyInit initializes a verification operation, where the
+ * signature is an appendix to the data, and plaintext cannot
+ *  cannot be recovered from the signature (e.g. DSA). */
+CK_PKCS11_FUNCTION_INFO(C_VerifyInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the verification mechanism */
+  CK_OBJECT_HANDLE  hKey         /* verification key */ 
+);
+#endif
+
+
+/* C_Verify verifies a signature in a single-part operation, 
+ * where the signature is an appendix to the data, and plaintext
+ * cannot be recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_Verify)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,       /* the session's handle */
+  CK_BYTE_PTR       pData,          /* signed data */
+  CK_ULONG          ulDataLen,      /* length of signed data */
+  CK_BYTE_PTR       pSignature,     /* signature */
+  CK_ULONG          ulSignatureLen  /* signature length*/
+);
+#endif
+
+
+/* C_VerifyUpdate continues a multiple-part verification
+ * operation, where the signature is an appendix to the data, 
+ * and plaintext cannot be recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_VerifyUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_BYTE_PTR       pPart,     /* signed data */
+  CK_ULONG          ulPartLen  /* length of signed data */
+);
+#endif
+
+
+/* C_VerifyFinal finishes a multiple-part verification
+ * operation, checking the signature. */
+CK_PKCS11_FUNCTION_INFO(C_VerifyFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,       /* the session's handle */
+  CK_BYTE_PTR       pSignature,     /* signature to verify */
+  CK_ULONG          ulSignatureLen  /* signature length */
+);
+#endif
+
+
+/* C_VerifyRecoverInit initializes a signature verification
+ * operation, where the data is recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_VerifyRecoverInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the verification mechanism */
+  CK_OBJECT_HANDLE  hKey         /* verification key */
+);
+#endif
+
+
+/* C_VerifyRecover verifies a signature in a single-part
+ * operation, where the data is recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_VerifyRecover)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_BYTE_PTR       pSignature,      /* signature to verify */
+  CK_ULONG          ulSignatureLen,  /* signature length */
+  CK_BYTE_PTR       pData,           /* gets signed data */
+  CK_ULONG_PTR      pulDataLen       /* gets signed data len */
+);
+#endif
+
+
+
+/* Dual-function cryptographic operations */
+
+/* C_DigestEncryptUpdate continues a multiple-part digesting
+ * and encryption operation. */
+CK_PKCS11_FUNCTION_INFO(C_DigestEncryptUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pPart,               /* the plaintext data */
+  CK_ULONG          ulPartLen,           /* plaintext length */
+  CK_BYTE_PTR       pEncryptedPart,      /* gets ciphertext */
+  CK_ULONG_PTR      pulEncryptedPartLen  /* gets c-text length */
+);
+#endif
+
+
+/* C_DecryptDigestUpdate continues a multiple-part decryption and
+ * digesting operation. */
+CK_PKCS11_FUNCTION_INFO(C_DecryptDigestUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pEncryptedPart,      /* ciphertext */
+  CK_ULONG          ulEncryptedPartLen,  /* ciphertext length */
+  CK_BYTE_PTR       pPart,               /* gets plaintext */
+  CK_ULONG_PTR      pulPartLen           /* gets plaintext len */
+);
+#endif
+
+
+/* C_SignEncryptUpdate continues a multiple-part signing and
+ * encryption operation. */
+CK_PKCS11_FUNCTION_INFO(C_SignEncryptUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pPart,               /* the plaintext data */
+  CK_ULONG          ulPartLen,           /* plaintext length */
+  CK_BYTE_PTR       pEncryptedPart,      /* gets ciphertext */
+  CK_ULONG_PTR      pulEncryptedPartLen  /* gets c-text length */
+);
+#endif
+
+
+/* C_DecryptVerifyUpdate continues a multiple-part decryption and
+ * verify operation. */
+CK_PKCS11_FUNCTION_INFO(C_DecryptVerifyUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pEncryptedPart,      /* ciphertext */
+  CK_ULONG          ulEncryptedPartLen,  /* ciphertext length */
+  CK_BYTE_PTR       pPart,               /* gets plaintext */
+  CK_ULONG_PTR      pulPartLen           /* gets p-text length */
+);
+#endif
+
+
+
+/* Key management */
+
+/* C_GenerateKey generates a secret key, creating a new key
+ * object. */
+CK_PKCS11_FUNCTION_INFO(C_GenerateKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,    /* the session's handle */
+  CK_MECHANISM_PTR     pMechanism,  /* key generation mech. */
+  CK_ATTRIBUTE_PTR     pTemplate,   /* template for new key */
+  CK_ULONG             ulCount,     /* # of attrs in template */
+  CK_OBJECT_HANDLE_PTR phKey        /* gets handle of new key */
+);
+#endif
+
+
+/* C_GenerateKeyPair generates a public-key/private-key pair, 
+ * creating new key objects. */
+CK_PKCS11_FUNCTION_INFO(C_GenerateKeyPair)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,                    /* session
+                                                     * handle */
+  CK_MECHANISM_PTR     pMechanism,                  /* key-gen
+                                                     * mech. */
+  CK_ATTRIBUTE_PTR     pPublicKeyTemplate,          /* template
+                                                     * for pub.
+                                                     * key */
+  CK_ULONG             ulPublicKeyAttributeCount,   /* # pub.
+                                                     * attrs. */
+  CK_ATTRIBUTE_PTR     pPrivateKeyTemplate,         /* template
+                                                     * for priv.
+                                                     * key */
+  CK_ULONG             ulPrivateKeyAttributeCount,  /* # priv.
+                                                     * attrs. */
+  CK_OBJECT_HANDLE_PTR phPublicKey,                 /* gets pub.
+                                                     * key
+                                                     * handle */
+  CK_OBJECT_HANDLE_PTR phPrivateKey                 /* gets
+                                                     * priv. key
+                                                     * handle */
+);
+#endif
+
+
+/* C_WrapKey wraps (i.e., encrypts) a key. */
+CK_PKCS11_FUNCTION_INFO(C_WrapKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,      /* the wrapping mechanism */
+  CK_OBJECT_HANDLE  hWrappingKey,    /* wrapping key */
+  CK_OBJECT_HANDLE  hKey,            /* key to be wrapped */
+  CK_BYTE_PTR       pWrappedKey,     /* gets wrapped key */
+  CK_ULONG_PTR      pulWrappedKeyLen /* gets wrapped key size */
+);
+#endif
+
+
+/* C_UnwrapKey unwraps (decrypts) a wrapped key, creating a new
+ * key object. */
+CK_PKCS11_FUNCTION_INFO(C_UnwrapKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,          /* session's handle */
+  CK_MECHANISM_PTR     pMechanism,        /* unwrapping mech. */
+  CK_OBJECT_HANDLE     hUnwrappingKey,    /* unwrapping key */
+  CK_BYTE_PTR          pWrappedKey,       /* the wrapped key */
+  CK_ULONG             ulWrappedKeyLen,   /* wrapped key len */
+  CK_ATTRIBUTE_PTR     pTemplate,         /* new key template */
+  CK_ULONG             ulAttributeCount,  /* template length */
+  CK_OBJECT_HANDLE_PTR phKey              /* gets new handle */
+);
+#endif
+
+
+/* C_DeriveKey derives a key from a base key, creating a new key
+ * object. */
+CK_PKCS11_FUNCTION_INFO(C_DeriveKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,          /* session's handle */
+  CK_MECHANISM_PTR     pMechanism,        /* key deriv. mech. */
+  CK_OBJECT_HANDLE     hBaseKey,          /* base key */
+  CK_ATTRIBUTE_PTR     pTemplate,         /* new key template */
+  CK_ULONG             ulAttributeCount,  /* template length */
+  CK_OBJECT_HANDLE_PTR phKey              /* gets new handle */
+);
+#endif
+
+
+
+/* Random number generation */
+
+/* C_SeedRandom mixes additional seed material into the token's
+ * random number generator. */
+CK_PKCS11_FUNCTION_INFO(C_SeedRandom)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_BYTE_PTR       pSeed,     /* the seed material */
+  CK_ULONG          ulSeedLen  /* length of seed material */
+);
+#endif
+
+
+/* C_GenerateRandom generates random data. */
+CK_PKCS11_FUNCTION_INFO(C_GenerateRandom)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_BYTE_PTR       RandomData,  /* receives the random data */
+  CK_ULONG          ulRandomLen  /* # of bytes to generate */
+);
+#endif
+
+
+
+/* Parallel function management */
+
+/* C_GetFunctionStatus is a legacy function; it obtains an
+ * updated status of a function running in parallel with an
+ * application. */
+CK_PKCS11_FUNCTION_INFO(C_GetFunctionStatus)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+/* C_CancelFunction is a legacy function; it cancels a function
+ * running in parallel. */
+CK_PKCS11_FUNCTION_INFO(C_CancelFunction)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+
+/* Functions added in for Cryptoki Version 2.01 or later */
+
+/* C_WaitForSlotEvent waits for a slot event (token insertion,
+ * removal, etc.) to occur. */
+CK_PKCS11_FUNCTION_INFO(C_WaitForSlotEvent)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_FLAGS flags,        /* blocking/nonblocking flag */
+  CK_SLOT_ID_PTR pSlot,  /* location that receives the slot ID */
+  CK_VOID_PTR pRserved   /* reserved.  Should be NULL_PTR */
+);
+#endif
diff -r -u -N openssl-0.9.8g/crypto/engine/pkcs11.h openssl/crypto/engine/pkcs11.h
--- openssl-0.9.8g/crypto/engine/pkcs11.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl/crypto/engine/pkcs11.h	2007-10-25 01:27:09.000000000 +0200
@@ -0,0 +1,299 @@
+/* pkcs11.h include file for PKCS #11. */
+/* Revision: 1.2 */
+
+/* License to copy and use this software is granted provided that it is
+ * identified as "RSA Security Inc. PKCS #11 Cryptographic Token Interface
+ * (Cryptoki)" in all material mentioning or referencing this software.
+
+ * License is also granted to make and use derivative works provided that
+ * such works are identified as "derived from the RSA Security Inc. PKCS #11
+ * Cryptographic Token Interface (Cryptoki)" in all material mentioning or 
+ * referencing the derived work.
+
+ * RSA Security Inc. makes no representations concerning either the 
+ * merchantability of this software or the suitability of this software for
+ * any particular purpose. It is provided "as is" without express or implied
+ * warranty of any kind.
+ */
+
+#ifndef _PKCS11_H_
+#define _PKCS11_H_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Before including this file (pkcs11.h) (or pkcs11t.h by
+ * itself), 6 platform-specific macros must be defined.  These
+ * macros are described below, and typical definitions for them
+ * are also given.  Be advised that these definitions can depend
+ * on both the platform and the compiler used (and possibly also
+ * on whether a Cryptoki library is linked statically or
+ * dynamically).
+ *
+ * In addition to defining these 6 macros, the packing convention
+ * for Cryptoki structures should be set.  The Cryptoki
+ * convention on packing is that structures should be 1-byte
+ * aligned.
+ *
+ * If you're using Microsoft Developer Studio 5.0 to produce
+ * Win32 stuff, this might be done by using the following
+ * preprocessor directive before including pkcs11.h or pkcs11t.h:
+ *
+ * #pragma pack(push, cryptoki, 1)
+ *
+ * and using the following preprocessor directive after including
+ * pkcs11.h or pkcs11t.h:
+ *
+ * #pragma pack(pop, cryptoki)
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to produce Win16 stuff, this might be done by using
+ * the following preprocessor directive before including
+ * pkcs11.h or pkcs11t.h:
+ *
+ * #pragma pack(1)
+ *
+ * In a UNIX environment, you're on your own for this.  You might
+ * not need to do (or be able to do!) anything.
+ *
+ *
+ * Now for the macros:
+ *
+ *
+ * 1. CK_PTR: The indirection string for making a pointer to an
+ * object.  It can be used like this:
+ *
+ * typedef CK_BYTE CK_PTR CK_BYTE_PTR;
+ *
+ * If you're using Microsoft Developer Studio 5.0 to produce
+ * Win32 stuff, it might be defined by:
+ *
+ * #define CK_PTR *
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to produce Win16 stuff, it might be defined by:
+ *
+ * #define CK_PTR far *
+ *
+ * In a typical UNIX environment, it might be defined by:
+ *
+ * #define CK_PTR *
+ *
+ *
+ * 2. CK_DEFINE_FUNCTION(returnType, name): A macro which makes
+ * an exportable Cryptoki library function definition out of a
+ * return type and a function name.  It should be used in the
+ * following fashion to define the exposed Cryptoki functions in
+ * a Cryptoki library:
+ *
+ * CK_DEFINE_FUNCTION(CK_RV, C_Initialize)(
+ *   CK_VOID_PTR pReserved
+ * )
+ * {
+ *   ...
+ * }
+ *
+ * If you're using Microsoft Developer Studio 5.0 to define a
+ * function in a Win32 Cryptoki .dll, it might be defined by:
+ *
+ * #define CK_DEFINE_FUNCTION(returnType, name) \
+ *   returnType __declspec(dllexport) name
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to define a function in a Win16 Cryptoki .dll, it
+ * might be defined by:
+ *
+ * #define CK_DEFINE_FUNCTION(returnType, name) \
+ *   returnType __export _far _pascal name
+ *
+ * In a UNIX environment, it might be defined by:
+ *
+ * #define CK_DEFINE_FUNCTION(returnType, name) \
+ *   returnType name
+ *
+ *
+ * 3. CK_DECLARE_FUNCTION(returnType, name): A macro which makes
+ * an importable Cryptoki library function declaration out of a
+ * return type and a function name.  It should be used in the
+ * following fashion:
+ *
+ * extern CK_DECLARE_FUNCTION(CK_RV, C_Initialize)(
+ *   CK_VOID_PTR pReserved
+ * );
+ *
+ * If you're using Microsoft Developer Studio 5.0 to declare a
+ * function in a Win32 Cryptoki .dll, it might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION(returnType, name) \
+ *   returnType __declspec(dllimport) name
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to declare a function in a Win16 Cryptoki .dll, it
+ * might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION(returnType, name) \
+ *   returnType __export _far _pascal name
+ *
+ * In a UNIX environment, it might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION(returnType, name) \
+ *   returnType name
+ *
+ *
+ * 4. CK_DECLARE_FUNCTION_POINTER(returnType, name): A macro
+ * which makes a Cryptoki API function pointer declaration or
+ * function pointer type declaration out of a return type and a
+ * function name.  It should be used in the following fashion:
+ *
+ * // Define funcPtr to be a pointer to a Cryptoki API function
+ * // taking arguments args and returning CK_RV.
+ * CK_DECLARE_FUNCTION_POINTER(CK_RV, funcPtr)(args);
+ *
+ * or
+ *
+ * // Define funcPtrType to be the type of a pointer to a
+ * // Cryptoki API function taking arguments args and returning
+ * // CK_RV, and then define funcPtr to be a variable of type
+ * // funcPtrType.
+ * typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, funcPtrType)(args);
+ * funcPtrType funcPtr;
+ *
+ * If you're using Microsoft Developer Studio 5.0 to access
+ * functions in a Win32 Cryptoki .dll, in might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
+ *   returnType __declspec(dllimport) (* name)
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to access functions in a Win16 Cryptoki .dll, it might
+ * be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
+ *   returnType __export _far _pascal (* name)
+ *
+ * In a UNIX environment, it might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
+ *   returnType (* name)
+ *
+ *
+ * 5. CK_CALLBACK_FUNCTION(returnType, name): A macro which makes
+ * a function pointer type for an application callback out of
+ * a return type for the callback and a name for the callback.
+ * It should be used in the following fashion:
+ *
+ * CK_CALLBACK_FUNCTION(CK_RV, myCallback)(args);
+ *
+ * to declare a function pointer, myCallback, to a callback
+ * which takes arguments args and returns a CK_RV.  It can also
+ * be used like this:
+ *
+ * typedef CK_CALLBACK_FUNCTION(CK_RV, myCallbackType)(args);
+ * myCallbackType myCallback;
+ *
+ * If you're using Microsoft Developer Studio 5.0 to do Win32
+ * Cryptoki development, it might be defined by:
+ *
+ * #define CK_CALLBACK_FUNCTION(returnType, name) \
+ *   returnType (* name)
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to do Win16 development, it might be defined by:
+ *
+ * #define CK_CALLBACK_FUNCTION(returnType, name) \
+ *   returnType _far _pascal (* name)
+ *
+ * In a UNIX environment, it might be defined by:
+ *
+ * #define CK_CALLBACK_FUNCTION(returnType, name) \
+ *   returnType (* name)
+ *
+ *
+ * 6. NULL_PTR: This macro is the value of a NULL pointer.
+ *
+ * In any ANSI/ISO C environment (and in many others as well),
+ * this should best be defined by
+ *
+ * #ifndef NULL_PTR
+ * #define NULL_PTR 0
+ * #endif
+ */
+
+
+/* All the various Cryptoki types and #define'd values are in the
+ * file pkcs11t.h. */
+#include "pkcs11t.h"
+
+#define __PASTE(x,y)      x##y
+
+
+/* ==============================================================
+ * Define the "extern" form of all the entry points.
+ * ==============================================================
+ */
+
+#define CK_NEED_ARG_LIST  1
+#define CK_PKCS11_FUNCTION_INFO(name) \
+  extern CK_DECLARE_FUNCTION(CK_RV, name)
+
+/* pkcs11f.h has all the information about the Cryptoki
+ * function prototypes. */
+#include "pkcs11f.h"
+
+#undef CK_NEED_ARG_LIST
+#undef CK_PKCS11_FUNCTION_INFO
+
+
+/* ==============================================================
+ * Define the typedef form of all the entry points.  That is, for
+ * each Cryptoki function C_XXX, define a type CK_C_XXX which is
+ * a pointer to that kind of function.
+ * ==============================================================
+ */
+
+#define CK_NEED_ARG_LIST  1
+#define CK_PKCS11_FUNCTION_INFO(name) \
+  typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, __PASTE(CK_,name))
+
+/* pkcs11f.h has all the information about the Cryptoki
+ * function prototypes. */
+#include "pkcs11f.h"
+
+#undef CK_NEED_ARG_LIST
+#undef CK_PKCS11_FUNCTION_INFO
+
+
+/* ==============================================================
+ * Define structed vector of entry points.  A CK_FUNCTION_LIST
+ * contains a CK_VERSION indicating a library's Cryptoki version
+ * and then a whole slew of function pointers to the routines in
+ * the library.  This type was declared, but not defined, in
+ * pkcs11t.h.
+ * ==============================================================
+ */
+
+#define CK_PKCS11_FUNCTION_INFO(name) \
+  __PASTE(CK_,name) name;
+  
+struct CK_FUNCTION_LIST {
+
+  CK_VERSION    version;  /* Cryptoki version */
+
+/* Pile all the function pointers into the CK_FUNCTION_LIST. */
+/* pkcs11f.h has all the information about the Cryptoki
+ * function prototypes. */
+#include "pkcs11f.h"
+
+};
+
+#undef CK_PKCS11_FUNCTION_INFO
+
+
+#undef __PASTE
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -r -u -N openssl-0.9.8g/crypto/engine/pkcs11t.h openssl/crypto/engine/pkcs11t.h
--- openssl-0.9.8g/crypto/engine/pkcs11t.h	1970-01-01 01:00:00.000000000 +0100
+++ openssl/crypto/engine/pkcs11t.h	2007-10-25 01:27:09.000000000 +0200
@@ -0,0 +1,1685 @@
+/* pkcs11t.h include file for PKCS #11. */
+/* Revision: 1.2 */
+
+/* License to copy and use this software is granted provided that it is
+ * identified as "RSA Security Inc. PKCS #11 Cryptographic Token Interface
+ * (Cryptoki)" in all material mentioning or referencing this software.
+
+ * License is also granted to make and use derivative works provided that
+ * such works are identified as "derived from the RSA Security Inc. PKCS #11
+ * Cryptographic Token Interface (Cryptoki)" in all material mentioning or
+ * referencing the derived work.
+
+ * RSA Security Inc. makes no representations concerning either the
+ * merchantability of this software or the suitability of this software for
+ * any particular purpose. It is provided "as is" without express or implied
+ * warranty of any kind.
+ */
+
+/* See top of pkcs11.h for information about the macros that
+ * must be defined and the structure-packing conventions that
+ * must be set before including this file. */
+
+#ifndef _PKCS11T_H_
+#define _PKCS11T_H_ 1
+
+#define CK_TRUE 1
+#define CK_FALSE 0
+
+#ifndef CK_DISABLE_TRUE_FALSE
+#ifndef FALSE
+#define FALSE CK_FALSE
+#endif
+
+#ifndef TRUE
+#define TRUE CK_TRUE
+#endif
+#endif
+
+/* an unsigned 8-bit value */
+typedef unsigned char     CK_BYTE;
+
+/* an unsigned 8-bit character */
+typedef CK_BYTE           CK_CHAR;
+
+/* an 8-bit UTF-8 character */
+typedef CK_BYTE           CK_UTF8CHAR;
+
+/* a BYTE-sized Boolean flag */
+typedef CK_BYTE           CK_BBOOL;
+
+/* an unsigned value, at least 32 bits long */
+typedef unsigned long int CK_ULONG;
+
+/* a signed value, the same size as a CK_ULONG */
+/* CK_LONG is new for v2.0 */
+typedef long int          CK_LONG;
+
+/* at least 32 bits; each bit is a Boolean flag */
+typedef CK_ULONG          CK_FLAGS;
+
+
+/* some special values for certain CK_ULONG variables */
+#define CK_UNAVAILABLE_INFORMATION (~0UL)
+#define CK_EFFECTIVELY_INFINITE    0
+
+
+typedef CK_BYTE     CK_PTR   CK_BYTE_PTR;
+typedef CK_CHAR     CK_PTR   CK_CHAR_PTR;
+typedef CK_UTF8CHAR CK_PTR   CK_UTF8CHAR_PTR;
+typedef CK_ULONG    CK_PTR   CK_ULONG_PTR;
+typedef void        CK_PTR   CK_VOID_PTR;
+
+/* Pointer to a CK_VOID_PTR-- i.e., pointer to pointer to void */
+typedef CK_VOID_PTR CK_PTR CK_VOID_PTR_PTR;
+
+
+/* The following value is always invalid if used as a session */
+/* handle or object handle */
+#define CK_INVALID_HANDLE 0
+
+
+typedef struct CK_VERSION {
+  CK_BYTE       major;  /* integer portion of version number */
+  CK_BYTE       minor;  /* 1/100ths portion of version number */
+} CK_VERSION;
+
+typedef CK_VERSION CK_PTR CK_VERSION_PTR;
+
+
+typedef struct CK_INFO {
+  /* manufacturerID and libraryDecription have been changed from
+   * CK_CHAR to CK_UTF8CHAR for v2.10 */
+  CK_VERSION    cryptokiVersion;     /* Cryptoki interface ver */
+  CK_UTF8CHAR   manufacturerID[32];  /* blank padded */
+  CK_FLAGS      flags;               /* must be zero */
+
+  /* libraryDescription and libraryVersion are new for v2.0 */
+  CK_UTF8CHAR   libraryDescription[32];  /* blank padded */
+  CK_VERSION    libraryVersion;          /* version of library */
+} CK_INFO;
+
+typedef CK_INFO CK_PTR    CK_INFO_PTR;
+
+
+/* CK_NOTIFICATION enumerates the types of notifications that
+ * Cryptoki provides to an application */
+/* CK_NOTIFICATION has been changed from an enum to a CK_ULONG
+ * for v2.0 */
+typedef CK_ULONG CK_NOTIFICATION;
+#define CKN_SURRENDER       0
+
+
+typedef CK_ULONG          CK_SLOT_ID;
+
+typedef CK_SLOT_ID CK_PTR CK_SLOT_ID_PTR;
+
+
+/* CK_SLOT_INFO provides information about a slot */
+typedef struct CK_SLOT_INFO {
+  /* slotDescription and manufacturerID have been changed from
+   * CK_CHAR to CK_UTF8CHAR for v2.10 */
+  CK_UTF8CHAR   slotDescription[64];  /* blank padded */
+  CK_UTF8CHAR   manufacturerID[32];   /* blank padded */
+  CK_FLAGS      flags;
+
+  /* hardwareVersion and firmwareVersion are new for v2.0 */
+  CK_VERSION    hardwareVersion;  /* version of hardware */
+  CK_VERSION    firmwareVersion;  /* version of firmware */
+} CK_SLOT_INFO;
+
+/* flags: bit flags that provide capabilities of the slot
+ *      Bit Flag              Mask        Meaning
+ */
+#define CKF_TOKEN_PRESENT     0x00000001  /* a token is there */
+#define CKF_REMOVABLE_DEVICE  0x00000002  /* removable devices*/
+#define CKF_HW_SLOT           0x00000004  /* hardware slot */
+
+typedef CK_SLOT_INFO CK_PTR CK_SLOT_INFO_PTR;
+
+
+/* CK_TOKEN_INFO provides information about a token */
+typedef struct CK_TOKEN_INFO {
+  /* label, manufacturerID, and model have been changed from
+   * CK_CHAR to CK_UTF8CHAR for v2.10 */
+  CK_UTF8CHAR   label[32];           /* blank padded */
+  CK_UTF8CHAR   manufacturerID[32];  /* blank padded */
+  CK_UTF8CHAR   model[16];           /* blank padded */
+  CK_CHAR       serialNumber[16];    /* blank padded */
+  CK_FLAGS      flags;               /* see below */
+
+  /* ulMaxSessionCount, ulSessionCount, ulMaxRwSessionCount,
+   * ulRwSessionCount, ulMaxPinLen, and ulMinPinLen have all been
+   * changed from CK_USHORT to CK_ULONG for v2.0 */
+  CK_ULONG      ulMaxSessionCount;     /* max open sessions */
+  CK_ULONG      ulSessionCount;        /* sess. now open */
+  CK_ULONG      ulMaxRwSessionCount;   /* max R/W sessions */
+  CK_ULONG      ulRwSessionCount;      /* R/W sess. now open */
+  CK_ULONG      ulMaxPinLen;           /* in bytes */
+  CK_ULONG      ulMinPinLen;           /* in bytes */
+  CK_ULONG      ulTotalPublicMemory;   /* in bytes */
+  CK_ULONG      ulFreePublicMemory;    /* in bytes */
+  CK_ULONG      ulTotalPrivateMemory;  /* in bytes */
+  CK_ULONG      ulFreePrivateMemory;   /* in bytes */
+
+  /* hardwareVersion, firmwareVersion, and time are new for
+   * v2.0 */
+  CK_VERSION    hardwareVersion;       /* version of hardware */
+  CK_VERSION    firmwareVersion;       /* version of firmware */
+  CK_CHAR       utcTime[16];           /* time */
+} CK_TOKEN_INFO;
+
+/* The flags parameter is defined as follows:
+ *      Bit Flag                    Mask        Meaning
+ */
+#define CKF_RNG                     0x00000001  /* has random #
+                                                 * generator */
+#define CKF_WRITE_PROTECTED         0x00000002  /* token is
+                                                 * write-
+                                                 * protected */
+#define CKF_LOGIN_REQUIRED          0x00000004  /* user must
+                                                 * login */
+#define CKF_USER_PIN_INITIALIZED    0x00000008  /* normal user's
+                                                 * PIN is set */
+
+/* CKF_RESTORE_KEY_NOT_NEEDED is new for v2.0.  If it is set,
+ * that means that *every* time the state of cryptographic
+ * operations of a session is successfully saved, all keys
+ * needed to continue those operations are stored in the state */
+#define CKF_RESTORE_KEY_NOT_NEEDED  0x00000020
+
+/* CKF_CLOCK_ON_TOKEN is new for v2.0.  If it is set, that means
+ * that the token has some sort of clock.  The time on that
+ * clock is returned in the token info structure */
+#define CKF_CLOCK_ON_TOKEN          0x00000040
+
+/* CKF_PROTECTED_AUTHENTICATION_PATH is new for v2.0.  If it is
+ * set, that means that there is some way for the user to login
+ * without sending a PIN through the Cryptoki library itself */
+#define CKF_PROTECTED_AUTHENTICATION_PATH 0x00000100
+
+/* CKF_DUAL_CRYPTO_OPERATIONS is new for v2.0.  If it is true,
+ * that means that a single session with the token can perform
+ * dual simultaneous cryptographic operations (digest and
+ * encrypt; decrypt and digest; sign and encrypt; and decrypt
+ * and sign) */
+#define CKF_DUAL_CRYPTO_OPERATIONS  0x00000200
+
+/* CKF_TOKEN_INITIALIZED if new for v2.10. If it is true, the
+ * token has been initialized using C_InitializeToken or an
+ * equivalent mechanism outside the scope of PKCS #11.
+ * Calling C_InitializeToken when this flag is set will cause
+ * the token to be reinitialized. */
+#define CKF_TOKEN_INITIALIZED       0x00000400
+
+/* CKF_SECONDARY_AUTHENTICATION if new for v2.10. If it is
+ * true, the token supports secondary authentication for
+ * private key objects. This flag is deprecated in v2.11 and
+   onwards. */
+#define CKF_SECONDARY_AUTHENTICATION  0x00000800
+
+/* CKF_USER_PIN_COUNT_LOW if new for v2.10. If it is true, an
+ * incorrect user login PIN has been entered at least once
+ * since the last successful authentication. */
+#define CKF_USER_PIN_COUNT_LOW       0x00010000
+
+/* CKF_USER_PIN_FINAL_TRY if new for v2.10. If it is true,
+ * supplying an incorrect user PIN will it to become locked. */
+#define CKF_USER_PIN_FINAL_TRY       0x00020000
+
+/* CKF_USER_PIN_LOCKED if new for v2.10. If it is true, the
+ * user PIN has been locked. User login to the token is not
+ * possible. */
+#define CKF_USER_PIN_LOCKED          0x00040000
+
+/* CKF_USER_PIN_TO_BE_CHANGED if new for v2.10. If it is true,
+ * the user PIN value is the default value set by token
+ * initialization or manufacturing, or the PIN has been
+ * expired by the card. */
+#define CKF_USER_PIN_TO_BE_CHANGED   0x00080000
+
+/* CKF_SO_PIN_COUNT_LOW if new for v2.10. If it is true, an
+ * incorrect SO login PIN has been entered at least once since
+ * the last successful authentication. */
+#define CKF_SO_PIN_COUNT_LOW         0x00100000
+
+/* CKF_SO_PIN_FINAL_TRY if new for v2.10. If it is true,
+ * supplying an incorrect SO PIN will it to become locked. */
+#define CKF_SO_PIN_FINAL_TRY         0x00200000
+
+/* CKF_SO_PIN_LOCKED if new for v2.10. If it is true, the SO
+ * PIN has been locked. SO login to the token is not possible.
+ */
+#define CKF_SO_PIN_LOCKED            0x00400000
+
+/* CKF_SO_PIN_TO_BE_CHANGED if new for v2.10. If it is true,
+ * the SO PIN value is the default value set by token
+ * initialization or manufacturing, or the PIN has been
+ * expired by the card. */
+#define CKF_SO_PIN_TO_BE_CHANGED     0x00800000
+
+typedef CK_TOKEN_INFO CK_PTR CK_TOKEN_INFO_PTR;
+
+
+/* CK_SESSION_HANDLE is a Cryptoki-assigned value that
+ * identifies a session */
+typedef CK_ULONG          CK_SESSION_HANDLE;
+
+typedef CK_SESSION_HANDLE CK_PTR CK_SESSION_HANDLE_PTR;
+
+
+/* CK_USER_TYPE enumerates the types of Cryptoki users */
+/* CK_USER_TYPE has been changed from an enum to a CK_ULONG for
+ * v2.0 */
+typedef CK_ULONG          CK_USER_TYPE;
+/* Security Officer */
+#define CKU_SO    0
+/* Normal user */
+#define CKU_USER  1
+/* Context specific (added in v2.20) */
+#define CKU_CONTEXT_SPECIFIC   2
+
+/* CK_STATE enumerates the session states */
+/* CK_STATE has been changed from an enum to a CK_ULONG for
+ * v2.0 */
+typedef CK_ULONG          CK_STATE;
+#define CKS_RO_PUBLIC_SESSION  0
+#define CKS_RO_USER_FUNCTIONS  1
+#define CKS_RW_PUBLIC_SESSION  2
+#define CKS_RW_USER_FUNCTIONS  3
+#define CKS_RW_SO_FUNCTIONS    4
+
+
+/* CK_SESSION_INFO provides information about a session */
+typedef struct CK_SESSION_INFO {
+  CK_SLOT_ID    slotID;
+  CK_STATE      state;
+  CK_FLAGS      flags;          /* see below */
+
+  /* ulDeviceError was changed from CK_USHORT to CK_ULONG for
+   * v2.0 */
+  CK_ULONG      ulDeviceError;  /* device-dependent error code */
+} CK_SESSION_INFO;
+
+/* The flags are defined in the following table:
+ *      Bit Flag                Mask        Meaning
+ */
+#define CKF_RW_SESSION          0x00000002  /* session is r/w */
+#define CKF_SERIAL_SESSION      0x00000004  /* no parallel */
+
+typedef CK_SESSION_INFO CK_PTR CK_SESSION_INFO_PTR;
+
+
+/* CK_OBJECT_HANDLE is a token-specific identifier for an
+ * object  */
+typedef CK_ULONG          CK_OBJECT_HANDLE;
+
+typedef CK_OBJECT_HANDLE CK_PTR CK_OBJECT_HANDLE_PTR;
+
+
+/* CK_OBJECT_CLASS is a value that identifies the classes (or
+ * types) of objects that Cryptoki recognizes.  It is defined
+ * as follows: */
+/* CK_OBJECT_CLASS was changed from CK_USHORT to CK_ULONG for
+ * v2.0 */
+typedef CK_ULONG          CK_OBJECT_CLASS;
+
+/* The following classes of objects are defined: */
+/* CKO_HW_FEATURE is new for v2.10 */
+/* CKO_DOMAIN_PARAMETERS is new for v2.11 */
+/* CKO_MECHANISM is new for v2.20 */
+#define CKO_DATA              0x00000000
+#define CKO_CERTIFICATE       0x00000001
+#define CKO_PUBLIC_KEY        0x00000002
+#define CKO_PRIVATE_KEY       0x00000003
+#define CKO_SECRET_KEY        0x00000004
+#define CKO_HW_FEATURE        0x00000005
+#define CKO_DOMAIN_PARAMETERS 0x00000006
+#define CKO_MECHANISM         0x00000007
+#define CKO_VENDOR_DEFINED    0x80000000
+
+typedef CK_OBJECT_CLASS CK_PTR CK_OBJECT_CLASS_PTR;
+
+/* CK_HW_FEATURE_TYPE is new for v2.10. CK_HW_FEATURE_TYPE is a
+ * value that identifies the hardware feature type of an object
+ * with CK_OBJECT_CLASS equal to CKO_HW_FEATURE. */
+typedef CK_ULONG          CK_HW_FEATURE_TYPE;
+
+/* The following hardware feature types are defined */
+/* CKH_USER_INTERFACE is new for v2.20 */
+#define CKH_MONOTONIC_COUNTER  0x00000001
+#define CKH_CLOCK           0x00000002
+#define CKH_USER_INTERFACE  0x00000003
+#define CKH_VENDOR_DEFINED  0x80000000
+
+/* CK_KEY_TYPE is a value that identifies a key type */
+/* CK_KEY_TYPE was changed from CK_USHORT to CK_ULONG for v2.0 */
+typedef CK_ULONG          CK_KEY_TYPE;
+
+/* the following key types are defined: */
+#define CKK_RSA             0x00000000
+#define CKK_DSA             0x00000001
+#define CKK_DH              0x00000002
+
+/* CKK_ECDSA and CKK_KEA are new for v2.0 */
+/* CKK_ECDSA is deprecated in v2.11, CKK_EC is preferred. */
+#define CKK_ECDSA           0x00000003
+#define CKK_EC              0x00000003
+#define CKK_X9_42_DH        0x00000004
+#define CKK_KEA             0x00000005
+
+#define CKK_GENERIC_SECRET  0x00000010
+#define CKK_RC2             0x00000011
+#define CKK_RC4             0x00000012
+#define CKK_DES             0x00000013
+#define CKK_DES2            0x00000014
+#define CKK_DES3            0x00000015
+
+/* all these key types are new for v2.0 */
+#define CKK_CAST            0x00000016
+#define CKK_CAST3           0x00000017
+/* CKK_CAST5 is deprecated in v2.11, CKK_CAST128 is preferred. */
+#define CKK_CAST5           0x00000018
+#define CKK_CAST128         0x00000018
+#define CKK_RC5             0x00000019
+#define CKK_IDEA            0x0000001A
+#define CKK_SKIPJACK        0x0000001B
+#define CKK_BATON           0x0000001C
+#define CKK_JUNIPER         0x0000001D
+#define CKK_CDMF            0x0000001E
+#define CKK_AES             0x0000001F
+
+/* BlowFish and TwoFish are new for v2.20 */
+#define CKK_BLOWFISH        0x00000020
+#define CKK_TWOFISH         0x00000021
+
+#define CKK_VENDOR_DEFINED  0x80000000
+
+
+/* CK_CERTIFICATE_TYPE is a value that identifies a certificate
+ * type */
+/* CK_CERTIFICATE_TYPE was changed from CK_USHORT to CK_ULONG
+ * for v2.0 */
+typedef CK_ULONG          CK_CERTIFICATE_TYPE;
+
+/* The following certificate types are defined: */
+/* CKC_X_509_ATTR_CERT is new for v2.10 */
+/* CKC_WTLS is new for v2.20 */
+#define CKC_X_509           0x00000000
+#define CKC_X_509_ATTR_CERT 0x00000001
+#define CKC_WTLS            0x00000002
+#define CKC_VENDOR_DEFINED  0x80000000
+
+
+/* CK_ATTRIBUTE_TYPE is a value that identifies an attribute
+ * type */
+/* CK_ATTRIBUTE_TYPE was changed from CK_USHORT to CK_ULONG for
+ * v2.0 */
+typedef CK_ULONG          CK_ATTRIBUTE_TYPE;
+
+/* The CKF_ARRAY_ATTRIBUTE flag identifies an attribute which
+   consists of an array of values. */
+#define CKF_ARRAY_ATTRIBUTE    0x40000000
+
+/* The following attribute types are defined: */
+#define CKA_CLASS              0x00000000
+#define CKA_TOKEN              0x00000001
+#define CKA_PRIVATE            0x00000002
+#define CKA_LABEL              0x00000003
+#define CKA_APPLICATION        0x00000010
+#define CKA_VALUE              0x00000011
+
+/* CKA_OBJECT_ID is new for v2.10 */
+#define CKA_OBJECT_ID          0x00000012
+
+#define CKA_CERTIFICATE_TYPE   0x00000080
+#define CKA_ISSUER             0x00000081
+#define CKA_SERIAL_NUMBER      0x00000082
+
+/* CKA_AC_ISSUER, CKA_OWNER, and CKA_ATTR_TYPES are new
+ * for v2.10 */
+#define CKA_AC_ISSUER          0x00000083
+#define CKA_OWNER              0x00000084
+#define CKA_ATTR_TYPES         0x00000085
+
+/* CKA_TRUSTED is new for v2.11 */
+#define CKA_TRUSTED            0x00000086
+
+/* CKA_CERTIFICATE_CATEGORY ...
+ * CKA_CHECK_VALUE are new for v2.20 */
+#define CKA_CERTIFICATE_CATEGORY        0x00000087
+#define CKA_JAVA_MIDP_SECURITY_DOMAIN   0x00000088
+#define CKA_URL                         0x00000089
+#define CKA_HASH_OF_SUBJECT_PUBLIC_KEY  0x0000008A
+#define CKA_HASH_OF_ISSUER_PUBLIC_KEY   0x0000008B
+#define CKA_CHECK_VALUE                 0x00000090
+
+#define CKA_KEY_TYPE           0x00000100
+#define CKA_SUBJECT            0x00000101
+#define CKA_ID                 0x00000102
+#define CKA_SENSITIVE          0x00000103
+#define CKA_ENCRYPT            0x00000104
+#define CKA_DECRYPT            0x00000105
+#define CKA_WRAP               0x00000106
+#define CKA_UNWRAP             0x00000107
+#define CKA_SIGN               0x00000108
+#define CKA_SIGN_RECOVER       0x00000109
+#define CKA_VERIFY             0x0000010A
+#define CKA_VERIFY_RECOVER     0x0000010B
+#define CKA_DERIVE             0x0000010C
+#define CKA_START_DATE         0x00000110
+#define CKA_END_DATE           0x00000111
+#define CKA_MODULUS            0x00000120
+#define CKA_MODULUS_BITS       0x00000121
+#define CKA_PUBLIC_EXPONENT    0x00000122
+#define CKA_PRIVATE_EXPONENT   0x00000123
+#define CKA_PRIME_1            0x00000124
+#define CKA_PRIME_2            0x00000125
+#define CKA_EXPONENT_1         0x00000126
+#define CKA_EXPONENT_2         0x00000127
+#define CKA_COEFFICIENT        0x00000128
+#define CKA_PRIME              0x00000130
+#define CKA_SUBPRIME           0x00000131
+#define CKA_BASE               0x00000132
+
+/* CKA_PRIME_BITS and CKA_SUB_PRIME_BITS are new for v2.11 */
+#define CKA_PRIME_BITS         0x00000133
+#define CKA_SUBPRIME_BITS      0x00000134
+#define CKA_SUB_PRIME_BITS     CKA_SUBPRIME_BITS
+/* (To retain backwards-compatibility) */
+
+#define CKA_VALUE_BITS         0x00000160
+#define CKA_VALUE_LEN          0x00000161
+
+/* CKA_EXTRACTABLE, CKA_LOCAL, CKA_NEVER_EXTRACTABLE,
+ * CKA_ALWAYS_SENSITIVE, CKA_MODIFIABLE, CKA_ECDSA_PARAMS,
+ * and CKA_EC_POINT are new for v2.0 */
+#define CKA_EXTRACTABLE        0x00000162
+#define CKA_LOCAL              0x00000163
+#define CKA_NEVER_EXTRACTABLE  0x00000164
+#define CKA_ALWAYS_SENSITIVE   0x00000165
+
+/* CKA_KEY_GEN_MECHANISM is new for v2.11 */
+#define CKA_KEY_GEN_MECHANISM  0x00000166
+
+#define CKA_MODIFIABLE         0x00000170
+
+/* CKA_ECDSA_PARAMS is deprecated in v2.11,
+ * CKA_EC_PARAMS is preferred. */
+#define CKA_ECDSA_PARAMS       0x00000180
+#define CKA_EC_PARAMS          0x00000180
+
+#define CKA_EC_POINT           0x00000181
+
+/* CKA_SECONDARY_AUTH, CKA_AUTH_PIN_FLAGS,
+ * are new for v2.10. Deprecated in v2.11 and onwards. */
+#define CKA_SECONDARY_AUTH     0x00000200
+#define CKA_AUTH_PIN_FLAGS     0x00000201
+
+/* CKA_ALWAYS_AUTHENTICATE ...
+ * CKA_UNWRAP_TEMPLATE are new for v2.20 */
+#define CKA_ALWAYS_AUTHENTICATE  0x00000202
+
+#define CKA_WRAP_WITH_TRUSTED    0x00000210
+#define CKA_WRAP_TEMPLATE        (CKF_ARRAY_ATTRIBUTE|0x00000211)
+#define CKA_UNWRAP_TEMPLATE      (CKF_ARRAY_ATTRIBUTE|0x00000212)
+
+/* CKA_HW_FEATURE_TYPE, CKA_RESET_ON_INIT, and CKA_HAS_RESET
+ * are new for v2.10 */
+#define CKA_HW_FEATURE_TYPE    0x00000300
+#define CKA_RESET_ON_INIT      0x00000301
+#define CKA_HAS_RESET          0x00000302
+
+/* The following attributes are new for v2.20 */
+#define CKA_PIXEL_X                     0x00000400
+#define CKA_PIXEL_Y                     0x00000401
+#define CKA_RESOLUTION                  0x00000402
+#define CKA_CHAR_ROWS                   0x00000403
+#define CKA_CHAR_COLUMNS                0x00000404
+#define CKA_COLOR                       0x00000405
+#define CKA_BITS_PER_PIXEL              0x00000406
+#define CKA_CHAR_SETS                   0x00000480
+#define CKA_ENCODING_METHODS            0x00000481
+#define CKA_MIME_TYPES                  0x00000482
+#define CKA_MECHANISM_TYPE              0x00000500
+#define CKA_REQUIRED_CMS_ATTRIBUTES     0x00000501
+#define CKA_DEFAULT_CMS_ATTRIBUTES      0x00000502
+#define CKA_SUPPORTED_CMS_ATTRIBUTES    0x00000503
+#define CKA_ALLOWED_MECHANISMS          (CKF_ARRAY_ATTRIBUTE|0x00000600)
+
+#define CKA_VENDOR_DEFINED     0x80000000
+
+
+/* CK_ATTRIBUTE is a structure that includes the type, length
+ * and value of an attribute */
+typedef struct CK_ATTRIBUTE {
+  CK_ATTRIBUTE_TYPE type;
+  CK_VOID_PTR       pValue;
+
+  /* ulValueLen went from CK_USHORT to CK_ULONG for v2.0 */
+  CK_ULONG          ulValueLen;  /* in bytes */
+} CK_ATTRIBUTE;
+
+typedef CK_ATTRIBUTE CK_PTR CK_ATTRIBUTE_PTR;
+
+
+/* CK_DATE is a structure that defines a date */
+typedef struct CK_DATE{
+  CK_CHAR       year[4];   /* the year ("1900" - "9999") */
+  CK_CHAR       month[2];  /* the month ("01" - "12") */
+  CK_CHAR       day[2];    /* the day   ("01" - "31") */
+} CK_DATE;
+
+
+/* CK_MECHANISM_TYPE is a value that identifies a mechanism
+ * type */
+/* CK_MECHANISM_TYPE was changed from CK_USHORT to CK_ULONG for
+ * v2.0 */
+typedef CK_ULONG          CK_MECHANISM_TYPE;
+
+/* the following mechanism types are defined: */
+#define CKM_RSA_PKCS_KEY_PAIR_GEN      0x00000000
+#define CKM_RSA_PKCS                   0x00000001
+#define CKM_RSA_9796                   0x00000002
+#define CKM_RSA_X_509                  0x00000003
+
+/* CKM_MD2_RSA_PKCS, CKM_MD5_RSA_PKCS, and CKM_SHA1_RSA_PKCS
+ * are new for v2.0.  They are mechanisms which hash and sign */
+#define CKM_MD2_RSA_PKCS               0x00000004
+#define CKM_MD5_RSA_PKCS               0x00000005
+#define CKM_SHA1_RSA_PKCS              0x00000006
+
+/* CKM_RIPEMD128_RSA_PKCS, CKM_RIPEMD160_RSA_PKCS, and
+ * CKM_RSA_PKCS_OAEP are new for v2.10 */
+#define CKM_RIPEMD128_RSA_PKCS         0x00000007
+#define CKM_RIPEMD160_RSA_PKCS         0x00000008
+#define CKM_RSA_PKCS_OAEP              0x00000009
+
+/* CKM_RSA_X9_31_KEY_PAIR_GEN, CKM_RSA_X9_31, CKM_SHA1_RSA_X9_31,
+ * CKM_RSA_PKCS_PSS, and CKM_SHA1_RSA_PKCS_PSS are new for v2.11 */
+#define CKM_RSA_X9_31_KEY_PAIR_GEN     0x0000000A
+#define CKM_RSA_X9_31                  0x0000000B
+#define CKM_SHA1_RSA_X9_31             0x0000000C
+#define CKM_RSA_PKCS_PSS               0x0000000D
+#define CKM_SHA1_RSA_PKCS_PSS          0x0000000E
+
+#define CKM_DSA_KEY_PAIR_GEN           0x00000010
+#define CKM_DSA                        0x00000011
+#define CKM_DSA_SHA1                   0x00000012
+#define CKM_DH_PKCS_KEY_PAIR_GEN       0x00000020
+#define CKM_DH_PKCS_DERIVE             0x00000021
+
+/* CKM_X9_42_DH_KEY_PAIR_GEN, CKM_X9_42_DH_DERIVE,
+ * CKM_X9_42_DH_HYBRID_DERIVE, and CKM_X9_42_MQV_DERIVE are new for
+ * v2.11 */
+#define CKM_X9_42_DH_KEY_PAIR_GEN      0x00000030
+#define CKM_X9_42_DH_DERIVE            0x00000031
+#define CKM_X9_42_DH_HYBRID_DERIVE     0x00000032
+#define CKM_X9_42_MQV_DERIVE           0x00000033
+
+/* CKM_SHA256/384/512 are new for v2.20 */
+#define CKM_SHA256_RSA_PKCS            0x00000040
+#define CKM_SHA384_RSA_PKCS            0x00000041
+#define CKM_SHA512_RSA_PKCS            0x00000042
+#define CKM_SHA256_RSA_PKCS_PSS        0x00000043
+#define CKM_SHA384_RSA_PKCS_PSS        0x00000044
+#define CKM_SHA512_RSA_PKCS_PSS        0x00000045
+
+#define CKM_RC2_KEY_GEN                0x00000100
+#define CKM_RC2_ECB                    0x00000101
+#define CKM_RC2_CBC                    0x00000102
+#define CKM_RC2_MAC                    0x00000103
+
+/* CKM_RC2_MAC_GENERAL and CKM_RC2_CBC_PAD are new for v2.0 */
+#define CKM_RC2_MAC_GENERAL            0x00000104
+#define CKM_RC2_CBC_PAD                0x00000105
+
+#define CKM_RC4_KEY_GEN                0x00000110
+#define CKM_RC4                        0x00000111
+#define CKM_DES_KEY_GEN                0x00000120
+#define CKM_DES_ECB                    0x00000121
+#define CKM_DES_CBC                    0x00000122
+#define CKM_DES_MAC                    0x00000123
+
+/* CKM_DES_MAC_GENERAL and CKM_DES_CBC_PAD are new for v2.0 */
+#define CKM_DES_MAC_GENERAL            0x00000124
+#define CKM_DES_CBC_PAD                0x00000125
+
+#define CKM_DES2_KEY_GEN               0x00000130
+#define CKM_DES3_KEY_GEN               0x00000131
+#define CKM_DES3_ECB                   0x00000132
+#define CKM_DES3_CBC                   0x00000133
+#define CKM_DES3_MAC                   0x00000134
+
+/* CKM_DES3_MAC_GENERAL, CKM_DES3_CBC_PAD, CKM_CDMF_KEY_GEN,
+ * CKM_CDMF_ECB, CKM_CDMF_CBC, CKM_CDMF_MAC,
+ * CKM_CDMF_MAC_GENERAL, and CKM_CDMF_CBC_PAD are new for v2.0 */
+#define CKM_DES3_MAC_GENERAL           0x00000135
+#define CKM_DES3_CBC_PAD               0x00000136
+#define CKM_CDMF_KEY_GEN               0x00000140
+#define CKM_CDMF_ECB                   0x00000141
+#define CKM_CDMF_CBC                   0x00000142
+#define CKM_CDMF_MAC                   0x00000143
+#define CKM_CDMF_MAC_GENERAL           0x00000144
+#define CKM_CDMF_CBC_PAD               0x00000145
+
+/* the following four DES mechanisms are new for v2.20 */
+#define CKM_DES_OFB64                  0x00000150
+#define CKM_DES_OFB8                   0x00000151
+#define CKM_DES_CFB64                  0x00000152
+#define CKM_DES_CFB8                   0x00000153
+
+#define CKM_MD2                        0x00000200
+
+/* CKM_MD2_HMAC and CKM_MD2_HMAC_GENERAL are new for v2.0 */
+#define CKM_MD2_HMAC                   0x00000201
+#define CKM_MD2_HMAC_GENERAL           0x00000202
+
+#define CKM_MD5                        0x00000210
+
+/* CKM_MD5_HMAC and CKM_MD5_HMAC_GENERAL are new for v2.0 */
+#define CKM_MD5_HMAC                   0x00000211
+#define CKM_MD5_HMAC_GENERAL           0x00000212
+
+#define CKM_SHA_1                      0x00000220
+
+/* CKM_SHA_1_HMAC and CKM_SHA_1_HMAC_GENERAL are new for v2.0 */
+#define CKM_SHA_1_HMAC                 0x00000221
+#define CKM_SHA_1_HMAC_GENERAL         0x00000222
+
+/* CKM_RIPEMD128, CKM_RIPEMD128_HMAC,
+ * CKM_RIPEMD128_HMAC_GENERAL, CKM_RIPEMD160, CKM_RIPEMD160_HMAC,
+ * and CKM_RIPEMD160_HMAC_GENERAL are new for v2.10 */
+#define CKM_RIPEMD128                  0x00000230
+#define CKM_RIPEMD128_HMAC             0x00000231
+#define CKM_RIPEMD128_HMAC_GENERAL     0x00000232
+#define CKM_RIPEMD160                  0x00000240
+#define CKM_RIPEMD160_HMAC             0x00000241
+#define CKM_RIPEMD160_HMAC_GENERAL     0x00000242
+
+/* CKM_SHA256/384/512 are new for v2.20 */
+#define CKM_SHA256                     0x00000250
+#define CKM_SHA256_HMAC                0x00000251
+#define CKM_SHA256_HMAC_GENERAL        0x00000252
+#define CKM_SHA384                     0x00000260
+#define CKM_SHA384_HMAC                0x00000261
+#define CKM_SHA384_HMAC_GENERAL        0x00000262
+#define CKM_SHA512                     0x00000270
+#define CKM_SHA512_HMAC                0x00000271
+#define CKM_SHA512_HMAC_GENERAL        0x00000272
+
+/* All of the following mechanisms are new for v2.0 */
+/* Note that CAST128 and CAST5 are the same algorithm */
+#define CKM_CAST_KEY_GEN               0x00000300
+#define CKM_CAST_ECB                   0x00000301
+#define CKM_CAST_CBC                   0x00000302
+#define CKM_CAST_MAC                   0x00000303
+#define CKM_CAST_MAC_GENERAL           0x00000304
+#define CKM_CAST_CBC_PAD               0x00000305
+#define CKM_CAST3_KEY_GEN              0x00000310
+#define CKM_CAST3_ECB                  0x00000311
+#define CKM_CAST3_CBC                  0x00000312
+#define CKM_CAST3_MAC                  0x00000313
+#define CKM_CAST3_MAC_GENERAL          0x00000314
+#define CKM_CAST3_CBC_PAD              0x00000315
+#define CKM_CAST5_KEY_GEN              0x00000320
+#define CKM_CAST128_KEY_GEN            0x00000320
+#define CKM_CAST5_ECB                  0x00000321
+#define CKM_CAST128_ECB                0x00000321
+#define CKM_CAST5_CBC                  0x00000322
+#define CKM_CAST128_CBC                0x00000322
+#define CKM_CAST5_MAC                  0x00000323
+#define CKM_CAST128_MAC                0x00000323
+#define CKM_CAST5_MAC_GENERAL          0x00000324
+#define CKM_CAST128_MAC_GENERAL        0x00000324
+#define CKM_CAST5_CBC_PAD              0x00000325
+#define CKM_CAST128_CBC_PAD            0x00000325
+#define CKM_RC5_KEY_GEN                0x00000330
+#define CKM_RC5_ECB                    0x00000331
+#define CKM_RC5_CBC                    0x00000332
+#define CKM_RC5_MAC                    0x00000333
+#define CKM_RC5_MAC_GENERAL            0x00000334
+#define CKM_RC5_CBC_PAD                0x00000335
+#define CKM_IDEA_KEY_GEN               0x00000340
+#define CKM_IDEA_ECB                   0x00000341
+#define CKM_IDEA_CBC                   0x00000342
+#define CKM_IDEA_MAC                   0x00000343
+#define CKM_IDEA_MAC_GENERAL           0x00000344
+#define CKM_IDEA_CBC_PAD               0x00000345
+#define CKM_GENERIC_SECRET_KEY_GEN     0x00000350
+#define CKM_CONCATENATE_BASE_AND_KEY   0x00000360
+#define CKM_CONCATENATE_BASE_AND_DATA  0x00000362
+#define CKM_CONCATENATE_DATA_AND_BASE  0x00000363
+#define CKM_XOR_BASE_AND_DATA          0x00000364
+#define CKM_EXTRACT_KEY_FROM_KEY       0x00000365
+#define CKM_SSL3_PRE_MASTER_KEY_GEN    0x00000370
+#define CKM_SSL3_MASTER_KEY_DERIVE     0x00000371
+#define CKM_SSL3_KEY_AND_MAC_DERIVE    0x00000372
+
+/* CKM_SSL3_MASTER_KEY_DERIVE_DH, CKM_TLS_PRE_MASTER_KEY_GEN,
+ * CKM_TLS_MASTER_KEY_DERIVE, CKM_TLS_KEY_AND_MAC_DERIVE, and
+ * CKM_TLS_MASTER_KEY_DERIVE_DH are new for v2.11 */
+#define CKM_SSL3_MASTER_KEY_DERIVE_DH  0x00000373
+#define CKM_TLS_PRE_MASTER_KEY_GEN     0x00000374
+#define CKM_TLS_MASTER_KEY_DERIVE      0x00000375
+#define CKM_TLS_KEY_AND_MAC_DERIVE     0x00000376
+#define CKM_TLS_MASTER_KEY_DERIVE_DH   0x00000377
+
+/* CKM_TLS_PRF is new for v2.20 */
+#define CKM_TLS_PRF                    0x00000378
+
+#define CKM_SSL3_MD5_MAC               0x00000380
+#define CKM_SSL3_SHA1_MAC              0x00000381
+#define CKM_MD5_KEY_DERIVATION         0x00000390
+#define CKM_MD2_KEY_DERIVATION         0x00000391
+#define CKM_SHA1_KEY_DERIVATION        0x00000392
+
+/* CKM_SHA256/384/512 are new for v2.20 */
+#define CKM_SHA256_KEY_DERIVATION      0x00000393
+#define CKM_SHA384_KEY_DERIVATION      0x00000394
+#define CKM_SHA512_KEY_DERIVATION      0x00000395
+
+#define CKM_PBE_MD2_DES_CBC            0x000003A0
+#define CKM_PBE_MD5_DES_CBC            0x000003A1
+#define CKM_PBE_MD5_CAST_CBC           0x000003A2
+#define CKM_PBE_MD5_CAST3_CBC          0x000003A3
+#define CKM_PBE_MD5_CAST5_CBC          0x000003A4
+#define CKM_PBE_MD5_CAST128_CBC        0x000003A4
+#define CKM_PBE_SHA1_CAST5_CBC         0x000003A5
+#define CKM_PBE_SHA1_CAST128_CBC       0x000003A5
+#define CKM_PBE_SHA1_RC4_128           0x000003A6
+#define CKM_PBE_SHA1_RC4_40            0x000003A7
+#define CKM_PBE_SHA1_DES3_EDE_CBC      0x000003A8
+#define CKM_PBE_SHA1_DES2_EDE_CBC      0x000003A9
+#define CKM_PBE_SHA1_RC2_128_CBC       0x000003AA
+#define CKM_PBE_SHA1_RC2_40_CBC        0x000003AB
+
+/* CKM_PKCS5_PBKD2 is new for v2.10 */
+#define CKM_PKCS5_PBKD2                0x000003B0
+
+#define CKM_PBA_SHA1_WITH_SHA1_HMAC    0x000003C0
+
+/* WTLS mechanisms are new for v2.20 */
+#define CKM_WTLS_PRE_MASTER_KEY_GEN         0x000003D0
+#define CKM_WTLS_MASTER_KEY_DERIVE          0x000003D1
+#define CKM_WTLS_MASTER_KEY_DERIVE_DH_ECC   0x000003D2
+#define CKM_WTLS_PRF                        0x000003D3
+#define CKM_WTLS_SERVER_KEY_AND_MAC_DERIVE  0x000003D4
+#define CKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE  0x000003D5
+
+#define CKM_KEY_WRAP_LYNKS             0x00000400
+#define CKM_KEY_WRAP_SET_OAEP          0x00000401
+
+/* CKM_CMS_SIG is new for v2.20 */
+#define CKM_CMS_SIG                    0x00000500
+
+/* Fortezza mechanisms */
+#define CKM_SKIPJACK_KEY_GEN           0x00001000
+#define CKM_SKIPJACK_ECB64             0x00001001
+#define CKM_SKIPJACK_CBC64             0x00001002
+#define CKM_SKIPJACK_OFB64             0x00001003
+#define CKM_SKIPJACK_CFB64             0x00001004
+#define CKM_SKIPJACK_CFB32             0x00001005
+#define CKM_SKIPJACK_CFB16             0x00001006
+#define CKM_SKIPJACK_CFB8              0x00001007
+#define CKM_SKIPJACK_WRAP              0x00001008
+#define CKM_SKIPJACK_PRIVATE_WRAP      0x00001009
+#define CKM_SKIPJACK_RELAYX            0x0000100a
+#define CKM_KEA_KEY_PAIR_GEN           0x00001010
+#define CKM_KEA_KEY_DERIVE             0x00001011
+#define CKM_FORTEZZA_TIMESTAMP         0x00001020
+#define CKM_BATON_KEY_GEN              0x00001030
+#define CKM_BATON_ECB128               0x00001031
+#define CKM_BATON_ECB96                0x00001032
+#define CKM_BATON_CBC128               0x00001033
+#define CKM_BATON_COUNTER              0x00001034
+#define CKM_BATON_SHUFFLE              0x00001035
+#define CKM_BATON_WRAP                 0x00001036
+
+/* CKM_ECDSA_KEY_PAIR_GEN is deprecated in v2.11,
+ * CKM_EC_KEY_PAIR_GEN is preferred */
+#define CKM_ECDSA_KEY_PAIR_GEN         0x00001040
+#define CKM_EC_KEY_PAIR_GEN            0x00001040
+
+#define CKM_ECDSA                      0x00001041
+#define CKM_ECDSA_SHA1                 0x00001042
+
+/* CKM_ECDH1_DERIVE, CKM_ECDH1_COFACTOR_DERIVE, and CKM_ECMQV_DERIVE
+ * are new for v2.11 */
+#define CKM_ECDH1_DERIVE               0x00001050
+#define CKM_ECDH1_COFACTOR_DERIVE      0x00001051
+#define CKM_ECMQV_DERIVE               0x00001052
+
+#define CKM_JUNIPER_KEY_GEN            0x00001060
+#define CKM_JUNIPER_ECB128             0x00001061
+#define CKM_JUNIPER_CBC128             0x00001062
+#define CKM_JUNIPER_COUNTER            0x00001063
+#define CKM_JUNIPER_SHUFFLE            0x00001064
+#define CKM_JUNIPER_WRAP               0x00001065
+#define CKM_FASTHASH                   0x00001070
+
+/* CKM_AES_KEY_GEN, CKM_AES_ECB, CKM_AES_CBC, CKM_AES_MAC,
+ * CKM_AES_MAC_GENERAL, CKM_AES_CBC_PAD, CKM_DSA_PARAMETER_GEN,
+ * CKM_DH_PKCS_PARAMETER_GEN, and CKM_X9_42_DH_PARAMETER_GEN are
+ * new for v2.11 */
+#define CKM_AES_KEY_GEN                0x00001080
+#define CKM_AES_ECB                    0x00001081
+#define CKM_AES_CBC                    0x00001082
+#define CKM_AES_MAC                    0x00001083
+#define CKM_AES_MAC_GENERAL            0x00001084
+#define CKM_AES_CBC_PAD                0x00001085
+
+/* BlowFish and TwoFish are new for v2.20 */
+#define CKM_BLOWFISH_KEY_GEN           0x00001090
+#define CKM_BLOWFISH_CBC               0x00001091
+#define CKM_TWOFISH_KEY_GEN            0x00001092
+#define CKM_TWOFISH_CBC                0x00001093
+
+
+/* CKM_xxx_ENCRYPT_DATA mechanisms are new for v2.20 */
+#define CKM_DES_ECB_ENCRYPT_DATA       0x00001100
+#define CKM_DES_CBC_ENCRYPT_DATA       0x00001101
+#define CKM_DES3_ECB_ENCRYPT_DATA      0x00001102
+#define CKM_DES3_CBC_ENCRYPT_DATA      0x00001103
+#define CKM_AES_ECB_ENCRYPT_DATA       0x00001104
+#define CKM_AES_CBC_ENCRYPT_DATA       0x00001105
+
+#define CKM_DSA_PARAMETER_GEN          0x00002000
+#define CKM_DH_PKCS_PARAMETER_GEN      0x00002001
+#define CKM_X9_42_DH_PARAMETER_GEN     0x00002002
+
+#define CKM_VENDOR_DEFINED             0x80000000
+
+typedef CK_MECHANISM_TYPE CK_PTR CK_MECHANISM_TYPE_PTR;
+
+
+/* CK_MECHANISM is a structure that specifies a particular
+ * mechanism  */
+typedef struct CK_MECHANISM {
+  CK_MECHANISM_TYPE mechanism;
+  CK_VOID_PTR       pParameter;
+
+  /* ulParameterLen was changed from CK_USHORT to CK_ULONG for
+   * v2.0 */
+  CK_ULONG          ulParameterLen;  /* in bytes */
+} CK_MECHANISM;
+
+typedef CK_MECHANISM CK_PTR CK_MECHANISM_PTR;
+
+
+/* CK_MECHANISM_INFO provides information about a particular
+ * mechanism */
+typedef struct CK_MECHANISM_INFO {
+    CK_ULONG    ulMinKeySize;
+    CK_ULONG    ulMaxKeySize;
+    CK_FLAGS    flags;
+} CK_MECHANISM_INFO;
+
+/* The flags are defined as follows:
+ *      Bit Flag               Mask        Meaning */
+#define CKF_HW                 0x00000001  /* performed by HW */
+
+/* The flags CKF_ENCRYPT, CKF_DECRYPT, CKF_DIGEST, CKF_SIGN,
+ * CKG_SIGN_RECOVER, CKF_VERIFY, CKF_VERIFY_RECOVER,
+ * CKF_GENERATE, CKF_GENERATE_KEY_PAIR, CKF_WRAP, CKF_UNWRAP,
+ * and CKF_DERIVE are new for v2.0.  They specify whether or not
+ * a mechanism can be used for a particular task */
+#define CKF_ENCRYPT            0x00000100
+#define CKF_DECRYPT            0x00000200
+#define CKF_DIGEST             0x00000400
+#define CKF_SIGN               0x00000800
+#define CKF_SIGN_RECOVER       0x00001000
+#define CKF_VERIFY             0x00002000
+#define CKF_VERIFY_RECOVER     0x00004000
+#define CKF_GENERATE           0x00008000
+#define CKF_GENERATE_KEY_PAIR  0x00010000
+#define CKF_WRAP               0x00020000
+#define CKF_UNWRAP             0x00040000
+#define CKF_DERIVE             0x00080000
+
+/* CKF_EC_F_P, CKF_EC_F_2M, CKF_EC_ECPARAMETERS, CKF_EC_NAMEDCURVE,
+ * CKF_EC_UNCOMPRESS, and CKF_EC_COMPRESS are new for v2.11. They
+ * describe a token's EC capabilities not available in mechanism
+ * information. */
+#define CKF_EC_F_P             0x00100000
+#define CKF_EC_F_2M            0x00200000
+#define CKF_EC_ECPARAMETERS    0x00400000
+#define CKF_EC_NAMEDCURVE      0x00800000
+#define CKF_EC_UNCOMPRESS      0x01000000
+#define CKF_EC_COMPRESS        0x02000000
+
+#define CKF_EXTENSION          0x80000000 /* FALSE for this version */
+
+typedef CK_MECHANISM_INFO CK_PTR CK_MECHANISM_INFO_PTR;
+
+
+/* CK_RV is a value that identifies the return value of a
+ * Cryptoki function */
+/* CK_RV was changed from CK_USHORT to CK_ULONG for v2.0 */
+typedef CK_ULONG          CK_RV;
+
+#define CKR_OK                                0x00000000
+#define CKR_CANCEL                            0x00000001
+#define CKR_HOST_MEMORY                       0x00000002
+#define CKR_SLOT_ID_INVALID                   0x00000003
+
+/* CKR_FLAGS_INVALID was removed for v2.0 */
+
+/* CKR_GENERAL_ERROR and CKR_FUNCTION_FAILED are new for v2.0 */
+#define CKR_GENERAL_ERROR                     0x00000005
+#define CKR_FUNCTION_FAILED                   0x00000006
+
+/* CKR_ARGUMENTS_BAD, CKR_NO_EVENT, CKR_NEED_TO_CREATE_THREADS,
+ * and CKR_CANT_LOCK are new for v2.01 */
+#define CKR_ARGUMENTS_BAD                     0x00000007
+#define CKR_NO_EVENT                          0x00000008
+#define CKR_NEED_TO_CREATE_THREADS            0x00000009
+#define CKR_CANT_LOCK                         0x0000000A
+
+#define CKR_ATTRIBUTE_READ_ONLY               0x00000010
+#define CKR_ATTRIBUTE_SENSITIVE               0x00000011
+#define CKR_ATTRIBUTE_TYPE_INVALID            0x00000012
+#define CKR_ATTRIBUTE_VALUE_INVALID           0x00000013
+#define CKR_DATA_INVALID                      0x00000020
+#define CKR_DATA_LEN_RANGE                    0x00000021
+#define CKR_DEVICE_ERROR                      0x00000030
+#define CKR_DEVICE_MEMORY                     0x00000031
+#define CKR_DEVICE_REMOVED                    0x00000032
+#define CKR_ENCRYPTED_DATA_INVALID            0x00000040
+#define CKR_ENCRYPTED_DATA_LEN_RANGE          0x00000041
+#define CKR_FUNCTION_CANCELED                 0x00000050
+#define CKR_FUNCTION_NOT_PARALLEL             0x00000051
+
+/* CKR_FUNCTION_NOT_SUPPORTED is new for v2.0 */
+#define CKR_FUNCTION_NOT_SUPPORTED            0x00000054
+
+#define CKR_KEY_HANDLE_INVALID                0x00000060
+
+/* CKR_KEY_SENSITIVE was removed for v2.0 */
+
+#define CKR_KEY_SIZE_RANGE                    0x00000062
+#define CKR_KEY_TYPE_INCONSISTENT             0x00000063
+
+/* CKR_KEY_NOT_NEEDED, CKR_KEY_CHANGED, CKR_KEY_NEEDED,
+ * CKR_KEY_INDIGESTIBLE, CKR_KEY_FUNCTION_NOT_PERMITTED,
+ * CKR_KEY_NOT_WRAPPABLE, and CKR_KEY_UNEXTRACTABLE are new for
+ * v2.0 */
+#define CKR_KEY_NOT_NEEDED                    0x00000064
+#define CKR_KEY_CHANGED                       0x00000065
+#define CKR_KEY_NEEDED                        0x00000066
+#define CKR_KEY_INDIGESTIBLE                  0x00000067
+#define CKR_KEY_FUNCTION_NOT_PERMITTED        0x00000068
+#define CKR_KEY_NOT_WRAPPABLE                 0x00000069
+#define CKR_KEY_UNEXTRACTABLE                 0x0000006A
+
+#define CKR_MECHANISM_INVALID                 0x00000070
+#define CKR_MECHANISM_PARAM_INVALID           0x00000071
+
+/* CKR_OBJECT_CLASS_INCONSISTENT and CKR_OBJECT_CLASS_INVALID
+ * were removed for v2.0 */
+#define CKR_OBJECT_HANDLE_INVALID             0x00000082
+#define CKR_OPERATION_ACTIVE                  0x00000090
+#define CKR_OPERATION_NOT_INITIALIZED         0x00000091
+#define CKR_PIN_INCORRECT                     0x000000A0
+#define CKR_PIN_INVALID                       0x000000A1
+#define CKR_PIN_LEN_RANGE                     0x000000A2
+
+/* CKR_PIN_EXPIRED and CKR_PIN_LOCKED are new for v2.0 */
+#define CKR_PIN_EXPIRED                       0x000000A3
+#define CKR_PIN_LOCKED                        0x000000A4
+
+#define CKR_SESSION_CLOSED                    0x000000B0
+#define CKR_SESSION_COUNT                     0x000000B1
+#define CKR_SESSION_HANDLE_INVALID            0x000000B3
+#define CKR_SESSION_PARALLEL_NOT_SUPPORTED    0x000000B4
+#define CKR_SESSION_READ_ONLY                 0x000000B5
+#define CKR_SESSION_EXISTS                    0x000000B6
+
+/* CKR_SESSION_READ_ONLY_EXISTS and
+ * CKR_SESSION_READ_WRITE_SO_EXISTS are new for v2.0 */
+#define CKR_SESSION_READ_ONLY_EXISTS          0x000000B7
+#define CKR_SESSION_READ_WRITE_SO_EXISTS      0x000000B8
+
+#define CKR_SIGNATURE_INVALID                 0x000000C0
+#define CKR_SIGNATURE_LEN_RANGE               0x000000C1
+#define CKR_TEMPLATE_INCOMPLETE               0x000000D0
+#define CKR_TEMPLATE_INCONSISTENT             0x000000D1
+#define CKR_TOKEN_NOT_PRESENT                 0x000000E0
+#define CKR_TOKEN_NOT_RECOGNIZED              0x000000E1
+#define CKR_TOKEN_WRITE_PROTECTED             0x000000E2
+#define CKR_UNWRAPPING_KEY_HANDLE_INVALID     0x000000F0
+#define CKR_UNWRAPPING_KEY_SIZE_RANGE         0x000000F1
+#define CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT  0x000000F2
+#define CKR_USER_ALREADY_LOGGED_IN            0x00000100
+#define CKR_USER_NOT_LOGGED_IN                0x00000101
+#define CKR_USER_PIN_NOT_INITIALIZED          0x00000102
+#define CKR_USER_TYPE_INVALID                 0x00000103
+
+/* CKR_USER_ANOTHER_ALREADY_LOGGED_IN and CKR_USER_TOO_MANY_TYPES
+ * are new to v2.01 */
+#define CKR_USER_ANOTHER_ALREADY_LOGGED_IN    0x00000104
+#define CKR_USER_TOO_MANY_TYPES               0x00000105
+
+#define CKR_WRAPPED_KEY_INVALID               0x00000110
+#define CKR_WRAPPED_KEY_LEN_RANGE             0x00000112
+#define CKR_WRAPPING_KEY_HANDLE_INVALID       0x00000113
+#define CKR_WRAPPING_KEY_SIZE_RANGE           0x00000114
+#define CKR_WRAPPING_KEY_TYPE_INCONSISTENT    0x00000115
+#define CKR_RANDOM_SEED_NOT_SUPPORTED         0x00000120
+
+/* These are new to v2.0 */
+#define CKR_RANDOM_NO_RNG                     0x00000121
+
+/* These are new to v2.11 */
+#define CKR_DOMAIN_PARAMS_INVALID             0x00000130
+
+/* These are new to v2.0 */
+#define CKR_BUFFER_TOO_SMALL                  0x00000150
+#define CKR_SAVED_STATE_INVALID               0x00000160
+#define CKR_INFORMATION_SENSITIVE             0x00000170
+#define CKR_STATE_UNSAVEABLE                  0x00000180
+
+/* These are new to v2.01 */
+#define CKR_CRYPTOKI_NOT_INITIALIZED          0x00000190
+#define CKR_CRYPTOKI_ALREADY_INITIALIZED      0x00000191
+#define CKR_MUTEX_BAD                         0x000001A0
+#define CKR_MUTEX_NOT_LOCKED                  0x000001A1
+
+/* This is new to v2.20 */
+#define CKR_FUNCTION_REJECTED                 0x00000200
+
+#define CKR_VENDOR_DEFINED                    0x80000000
+
+
+/* CK_NOTIFY is an application callback that processes events */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_NOTIFY)(
+  CK_SESSION_HANDLE hSession,     /* the session's handle */
+  CK_NOTIFICATION   event,
+  CK_VOID_PTR       pApplication  /* passed to C_OpenSession */
+);
+
+
+/* CK_FUNCTION_LIST is a structure holding a Cryptoki spec
+ * version and pointers of appropriate types to all the
+ * Cryptoki functions */
+/* CK_FUNCTION_LIST is new for v2.0 */
+typedef struct CK_FUNCTION_LIST CK_FUNCTION_LIST;
+
+typedef CK_FUNCTION_LIST CK_PTR CK_FUNCTION_LIST_PTR;
+
+typedef CK_FUNCTION_LIST_PTR CK_PTR CK_FUNCTION_LIST_PTR_PTR;
+
+
+/* CK_CREATEMUTEX is an application callback for creating a
+ * mutex object */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_CREATEMUTEX)(
+  CK_VOID_PTR_PTR ppMutex  /* location to receive ptr to mutex */
+);
+
+
+/* CK_DESTROYMUTEX is an application callback for destroying a
+ * mutex object */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_DESTROYMUTEX)(
+  CK_VOID_PTR pMutex  /* pointer to mutex */
+);
+
+
+/* CK_LOCKMUTEX is an application callback for locking a mutex */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_LOCKMUTEX)(
+  CK_VOID_PTR pMutex  /* pointer to mutex */
+);
+
+
+/* CK_UNLOCKMUTEX is an application callback for unlocking a
+ * mutex */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_UNLOCKMUTEX)(
+  CK_VOID_PTR pMutex  /* pointer to mutex */
+);
+
+
+/* CK_C_INITIALIZE_ARGS provides the optional arguments to
+ * C_Initialize */
+typedef struct CK_C_INITIALIZE_ARGS {
+  CK_CREATEMUTEX CreateMutex;
+  CK_DESTROYMUTEX DestroyMutex;
+  CK_LOCKMUTEX LockMutex;
+  CK_UNLOCKMUTEX UnlockMutex;
+  CK_FLAGS flags;
+  CK_VOID_PTR pReserved;
+} CK_C_INITIALIZE_ARGS;
+
+/* flags: bit flags that provide capabilities of the slot
+ *      Bit Flag                           Mask       Meaning
+ */
+#define CKF_LIBRARY_CANT_CREATE_OS_THREADS 0x00000001
+#define CKF_OS_LOCKING_OK                  0x00000002
+
+typedef CK_C_INITIALIZE_ARGS CK_PTR CK_C_INITIALIZE_ARGS_PTR;
+
+
+/* additional flags for parameters to functions */
+
+/* CKF_DONT_BLOCK is for the function C_WaitForSlotEvent */
+#define CKF_DONT_BLOCK     1
+
+/* CK_RSA_PKCS_OAEP_MGF_TYPE is new for v2.10.
+ * CK_RSA_PKCS_OAEP_MGF_TYPE  is used to indicate the Message
+ * Generation Function (MGF) applied to a message block when
+ * formatting a message block for the PKCS #1 OAEP encryption
+ * scheme. */
+typedef CK_ULONG CK_RSA_PKCS_MGF_TYPE;
+
+typedef CK_RSA_PKCS_MGF_TYPE CK_PTR CK_RSA_PKCS_MGF_TYPE_PTR;
+
+/* The following MGFs are defined */
+/* CKG_MGF1_SHA256, CKG_MGF1_SHA384, and CKG_MGF1_SHA512
+ * are new for v2.20 */
+#define CKG_MGF1_SHA1         0x00000001
+#define CKG_MGF1_SHA256       0x00000002
+#define CKG_MGF1_SHA384       0x00000003
+#define CKG_MGF1_SHA512       0x00000004
+
+/* CK_RSA_PKCS_OAEP_SOURCE_TYPE is new for v2.10.
+ * CK_RSA_PKCS_OAEP_SOURCE_TYPE  is used to indicate the source
+ * of the encoding parameter when formatting a message block
+ * for the PKCS #1 OAEP encryption scheme. */
+typedef CK_ULONG CK_RSA_PKCS_OAEP_SOURCE_TYPE;
+
+typedef CK_RSA_PKCS_OAEP_SOURCE_TYPE CK_PTR CK_RSA_PKCS_OAEP_SOURCE_TYPE_PTR;
+
+/* The following encoding parameter sources are defined */
+#define CKZ_DATA_SPECIFIED    0x00000001
+
+/* CK_RSA_PKCS_OAEP_PARAMS is new for v2.10.
+ * CK_RSA_PKCS_OAEP_PARAMS provides the parameters to the
+ * CKM_RSA_PKCS_OAEP mechanism. */
+typedef struct CK_RSA_PKCS_OAEP_PARAMS {
+        CK_MECHANISM_TYPE hashAlg;
+        CK_RSA_PKCS_MGF_TYPE mgf;
+        CK_RSA_PKCS_OAEP_SOURCE_TYPE source;
+        CK_VOID_PTR pSourceData;
+        CK_ULONG ulSourceDataLen;
+} CK_RSA_PKCS_OAEP_PARAMS;
+
+typedef CK_RSA_PKCS_OAEP_PARAMS CK_PTR CK_RSA_PKCS_OAEP_PARAMS_PTR;
+
+/* CK_RSA_PKCS_PSS_PARAMS is new for v2.11.
+ * CK_RSA_PKCS_PSS_PARAMS provides the parameters to the
+ * CKM_RSA_PKCS_PSS mechanism(s). */
+typedef struct CK_RSA_PKCS_PSS_PARAMS {
+        CK_MECHANISM_TYPE    hashAlg;
+        CK_RSA_PKCS_MGF_TYPE mgf;
+        CK_ULONG             sLen;
+} CK_RSA_PKCS_PSS_PARAMS;
+
+typedef CK_RSA_PKCS_PSS_PARAMS CK_PTR CK_RSA_PKCS_PSS_PARAMS_PTR;
+
+/* CK_EC_KDF_TYPE is new for v2.11. */
+typedef CK_ULONG CK_EC_KDF_TYPE;
+
+/* The following EC Key Derivation Functions are defined */
+#define CKD_NULL                 0x00000001
+#define CKD_SHA1_KDF             0x00000002
+
+/* CK_ECDH1_DERIVE_PARAMS is new for v2.11.
+ * CK_ECDH1_DERIVE_PARAMS provides the parameters to the
+ * CKM_ECDH1_DERIVE and CKM_ECDH1_COFACTOR_DERIVE mechanisms,
+ * where each party contributes one key pair.
+ */
+typedef struct CK_ECDH1_DERIVE_PARAMS {
+  CK_EC_KDF_TYPE kdf;
+  CK_ULONG ulSharedDataLen;
+  CK_BYTE_PTR pSharedData;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+} CK_ECDH1_DERIVE_PARAMS;
+
+typedef CK_ECDH1_DERIVE_PARAMS CK_PTR CK_ECDH1_DERIVE_PARAMS_PTR;
+
+
+/* CK_ECDH2_DERIVE_PARAMS is new for v2.11.
+ * CK_ECDH2_DERIVE_PARAMS provides the parameters to the
+ * CKM_ECMQV_DERIVE mechanism, where each party contributes two key pairs. */
+typedef struct CK_ECDH2_DERIVE_PARAMS {
+  CK_EC_KDF_TYPE kdf;
+  CK_ULONG ulSharedDataLen;
+  CK_BYTE_PTR pSharedData;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+  CK_ULONG ulPrivateDataLen;
+  CK_OBJECT_HANDLE hPrivateData;
+  CK_ULONG ulPublicDataLen2;
+  CK_BYTE_PTR pPublicData2;
+} CK_ECDH2_DERIVE_PARAMS;
+
+typedef CK_ECDH2_DERIVE_PARAMS CK_PTR CK_ECDH2_DERIVE_PARAMS_PTR;
+
+typedef struct CK_ECMQV_DERIVE_PARAMS {
+  CK_EC_KDF_TYPE kdf;
+  CK_ULONG ulSharedDataLen;
+  CK_BYTE_PTR pSharedData;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+  CK_ULONG ulPrivateDataLen;
+  CK_OBJECT_HANDLE hPrivateData;
+  CK_ULONG ulPublicDataLen2;
+  CK_BYTE_PTR pPublicData2;
+  CK_OBJECT_HANDLE publicKey;
+} CK_ECMQV_DERIVE_PARAMS;
+
+typedef CK_ECMQV_DERIVE_PARAMS CK_PTR CK_ECMQV_DERIVE_PARAMS_PTR;
+
+/* Typedefs and defines for the CKM_X9_42_DH_KEY_PAIR_GEN and the
+ * CKM_X9_42_DH_PARAMETER_GEN mechanisms (new for PKCS #11 v2.11) */
+typedef CK_ULONG CK_X9_42_DH_KDF_TYPE;
+typedef CK_X9_42_DH_KDF_TYPE CK_PTR CK_X9_42_DH_KDF_TYPE_PTR;
+
+/* The following X9.42 DH key derivation functions are defined
+   (besides CKD_NULL already defined : */
+#define CKD_SHA1_KDF_ASN1        0x00000003
+#define CKD_SHA1_KDF_CONCATENATE 0x00000004
+
+/* CK_X9_42_DH1_DERIVE_PARAMS is new for v2.11.
+ * CK_X9_42_DH1_DERIVE_PARAMS provides the parameters to the
+ * CKM_X9_42_DH_DERIVE key derivation mechanism, where each party
+ * contributes one key pair */
+typedef struct CK_X9_42_DH1_DERIVE_PARAMS {
+  CK_X9_42_DH_KDF_TYPE kdf;
+  CK_ULONG ulOtherInfoLen;
+  CK_BYTE_PTR pOtherInfo;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+} CK_X9_42_DH1_DERIVE_PARAMS;
+
+typedef struct CK_X9_42_DH1_DERIVE_PARAMS CK_PTR CK_X9_42_DH1_DERIVE_PARAMS_PTR;
+
+/* CK_X9_42_DH2_DERIVE_PARAMS is new for v2.11.
+ * CK_X9_42_DH2_DERIVE_PARAMS provides the parameters to the
+ * CKM_X9_42_DH_HYBRID_DERIVE and CKM_X9_42_MQV_DERIVE key derivation
+ * mechanisms, where each party contributes two key pairs */
+typedef struct CK_X9_42_DH2_DERIVE_PARAMS {
+  CK_X9_42_DH_KDF_TYPE kdf;
+  CK_ULONG ulOtherInfoLen;
+  CK_BYTE_PTR pOtherInfo;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+  CK_ULONG ulPrivateDataLen;
+  CK_OBJECT_HANDLE hPrivateData;
+  CK_ULONG ulPublicDataLen2;
+  CK_BYTE_PTR pPublicData2;
+} CK_X9_42_DH2_DERIVE_PARAMS;
+
+typedef CK_X9_42_DH2_DERIVE_PARAMS CK_PTR CK_X9_42_DH2_DERIVE_PARAMS_PTR;
+
+typedef struct CK_X9_42_MQV_DERIVE_PARAMS {
+  CK_X9_42_DH_KDF_TYPE kdf;
+  CK_ULONG ulOtherInfoLen;
+  CK_BYTE_PTR pOtherInfo;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+  CK_ULONG ulPrivateDataLen;
+  CK_OBJECT_HANDLE hPrivateData;
+  CK_ULONG ulPublicDataLen2;
+  CK_BYTE_PTR pPublicData2;
+  CK_OBJECT_HANDLE publicKey;
+} CK_X9_42_MQV_DERIVE_PARAMS;
+
+typedef CK_X9_42_MQV_DERIVE_PARAMS CK_PTR CK_X9_42_MQV_DERIVE_PARAMS_PTR;
+
+/* CK_KEA_DERIVE_PARAMS provides the parameters to the
+ * CKM_KEA_DERIVE mechanism */
+/* CK_KEA_DERIVE_PARAMS is new for v2.0 */
+typedef struct CK_KEA_DERIVE_PARAMS {
+  CK_BBOOL      isSender;
+  CK_ULONG      ulRandomLen;
+  CK_BYTE_PTR   pRandomA;
+  CK_BYTE_PTR   pRandomB;
+  CK_ULONG      ulPublicDataLen;
+  CK_BYTE_PTR   pPublicData;
+} CK_KEA_DERIVE_PARAMS;
+
+typedef CK_KEA_DERIVE_PARAMS CK_PTR CK_KEA_DERIVE_PARAMS_PTR;
+
+
+/* CK_RC2_PARAMS provides the parameters to the CKM_RC2_ECB and
+ * CKM_RC2_MAC mechanisms.  An instance of CK_RC2_PARAMS just
+ * holds the effective keysize */
+typedef CK_ULONG          CK_RC2_PARAMS;
+
+typedef CK_RC2_PARAMS CK_PTR CK_RC2_PARAMS_PTR;
+
+
+/* CK_RC2_CBC_PARAMS provides the parameters to the CKM_RC2_CBC
+ * mechanism */
+typedef struct CK_RC2_CBC_PARAMS {
+  /* ulEffectiveBits was changed from CK_USHORT to CK_ULONG for
+   * v2.0 */
+  CK_ULONG      ulEffectiveBits;  /* effective bits (1-1024) */
+
+  CK_BYTE       iv[8];            /* IV for CBC mode */
+} CK_RC2_CBC_PARAMS;
+
+typedef CK_RC2_CBC_PARAMS CK_PTR CK_RC2_CBC_PARAMS_PTR;
+
+
+/* CK_RC2_MAC_GENERAL_PARAMS provides the parameters for the
+ * CKM_RC2_MAC_GENERAL mechanism */
+/* CK_RC2_MAC_GENERAL_PARAMS is new for v2.0 */
+typedef struct CK_RC2_MAC_GENERAL_PARAMS {
+  CK_ULONG      ulEffectiveBits;  /* effective bits (1-1024) */
+  CK_ULONG      ulMacLength;      /* Length of MAC in bytes */
+} CK_RC2_MAC_GENERAL_PARAMS;
+
+typedef CK_RC2_MAC_GENERAL_PARAMS CK_PTR \
+  CK_RC2_MAC_GENERAL_PARAMS_PTR;
+
+
+/* CK_RC5_PARAMS provides the parameters to the CKM_RC5_ECB and
+ * CKM_RC5_MAC mechanisms */
+/* CK_RC5_PARAMS is new for v2.0 */
+typedef struct CK_RC5_PARAMS {
+  CK_ULONG      ulWordsize;  /* wordsize in bits */
+  CK_ULONG      ulRounds;    /* number of rounds */
+} CK_RC5_PARAMS;
+
+typedef CK_RC5_PARAMS CK_PTR CK_RC5_PARAMS_PTR;
+
+
+/* CK_RC5_CBC_PARAMS provides the parameters to the CKM_RC5_CBC
+ * mechanism */
+/* CK_RC5_CBC_PARAMS is new for v2.0 */
+typedef struct CK_RC5_CBC_PARAMS {
+  CK_ULONG      ulWordsize;  /* wordsize in bits */
+  CK_ULONG      ulRounds;    /* number of rounds */
+  CK_BYTE_PTR   pIv;         /* pointer to IV */
+  CK_ULONG      ulIvLen;     /* length of IV in bytes */
+} CK_RC5_CBC_PARAMS;
+
+typedef CK_RC5_CBC_PARAMS CK_PTR CK_RC5_CBC_PARAMS_PTR;
+
+
+/* CK_RC5_MAC_GENERAL_PARAMS provides the parameters for the
+ * CKM_RC5_MAC_GENERAL mechanism */
+/* CK_RC5_MAC_GENERAL_PARAMS is new for v2.0 */
+typedef struct CK_RC5_MAC_GENERAL_PARAMS {
+  CK_ULONG      ulWordsize;   /* wordsize in bits */
+  CK_ULONG      ulRounds;     /* number of rounds */
+  CK_ULONG      ulMacLength;  /* Length of MAC in bytes */
+} CK_RC5_MAC_GENERAL_PARAMS;
+
+typedef CK_RC5_MAC_GENERAL_PARAMS CK_PTR \
+  CK_RC5_MAC_GENERAL_PARAMS_PTR;
+
+
+/* CK_MAC_GENERAL_PARAMS provides the parameters to most block
+ * ciphers' MAC_GENERAL mechanisms.  Its value is the length of
+ * the MAC */
+/* CK_MAC_GENERAL_PARAMS is new for v2.0 */
+typedef CK_ULONG          CK_MAC_GENERAL_PARAMS;
+
+typedef CK_MAC_GENERAL_PARAMS CK_PTR CK_MAC_GENERAL_PARAMS_PTR;
+
+/* CK_DES/AES_ECB/CBC_ENCRYPT_DATA_PARAMS are new for v2.20 */
+typedef struct CK_DES_CBC_ENCRYPT_DATA_PARAMS {
+  CK_BYTE      iv[8];
+  CK_BYTE_PTR  pData;
+  CK_ULONG     length;
+} CK_DES_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_DES_CBC_ENCRYPT_DATA_PARAMS CK_PTR CK_DES_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+typedef struct CK_AES_CBC_ENCRYPT_DATA_PARAMS {
+  CK_BYTE      iv[16];
+  CK_BYTE_PTR  pData;
+  CK_ULONG     length;
+} CK_AES_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_AES_CBC_ENCRYPT_DATA_PARAMS CK_PTR CK_AES_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+/* CK_SKIPJACK_PRIVATE_WRAP_PARAMS provides the parameters to the
+ * CKM_SKIPJACK_PRIVATE_WRAP mechanism */
+/* CK_SKIPJACK_PRIVATE_WRAP_PARAMS is new for v2.0 */
+typedef struct CK_SKIPJACK_PRIVATE_WRAP_PARAMS {
+  CK_ULONG      ulPasswordLen;
+  CK_BYTE_PTR   pPassword;
+  CK_ULONG      ulPublicDataLen;
+  CK_BYTE_PTR   pPublicData;
+  CK_ULONG      ulPAndGLen;
+  CK_ULONG      ulQLen;
+  CK_ULONG      ulRandomLen;
+  CK_BYTE_PTR   pRandomA;
+  CK_BYTE_PTR   pPrimeP;
+  CK_BYTE_PTR   pBaseG;
+  CK_BYTE_PTR   pSubprimeQ;
+} CK_SKIPJACK_PRIVATE_WRAP_PARAMS;
+
+typedef CK_SKIPJACK_PRIVATE_WRAP_PARAMS CK_PTR \
+  CK_SKIPJACK_PRIVATE_WRAP_PTR;
+
+
+/* CK_SKIPJACK_RELAYX_PARAMS provides the parameters to the
+ * CKM_SKIPJACK_RELAYX mechanism */
+/* CK_SKIPJACK_RELAYX_PARAMS is new for v2.0 */
+typedef struct CK_SKIPJACK_RELAYX_PARAMS {
+  CK_ULONG      ulOldWrappedXLen;
+  CK_BYTE_PTR   pOldWrappedX;
+  CK_ULONG      ulOldPasswordLen;
+  CK_BYTE_PTR   pOldPassword;
+  CK_ULONG      ulOldPublicDataLen;
+  CK_BYTE_PTR   pOldPublicData;
+  CK_ULONG      ulOldRandomLen;
+  CK_BYTE_PTR   pOldRandomA;
+  CK_ULONG      ulNewPasswordLen;
+  CK_BYTE_PTR   pNewPassword;
+  CK_ULONG      ulNewPublicDataLen;
+  CK_BYTE_PTR   pNewPublicData;
+  CK_ULONG      ulNewRandomLen;
+  CK_BYTE_PTR   pNewRandomA;
+} CK_SKIPJACK_RELAYX_PARAMS;
+
+typedef CK_SKIPJACK_RELAYX_PARAMS CK_PTR \
+  CK_SKIPJACK_RELAYX_PARAMS_PTR;
+
+
+typedef struct CK_PBE_PARAMS {
+  CK_BYTE_PTR      pInitVector;
+  CK_UTF8CHAR_PTR  pPassword;
+  CK_ULONG         ulPasswordLen;
+  CK_BYTE_PTR      pSalt;
+  CK_ULONG         ulSaltLen;
+  CK_ULONG         ulIteration;
+} CK_PBE_PARAMS;
+
+typedef CK_PBE_PARAMS CK_PTR CK_PBE_PARAMS_PTR;
+
+
+/* CK_KEY_WRAP_SET_OAEP_PARAMS provides the parameters to the
+ * CKM_KEY_WRAP_SET_OAEP mechanism */
+/* CK_KEY_WRAP_SET_OAEP_PARAMS is new for v2.0 */
+typedef struct CK_KEY_WRAP_SET_OAEP_PARAMS {
+  CK_BYTE       bBC;     /* block contents byte */
+  CK_BYTE_PTR   pX;      /* extra data */
+  CK_ULONG      ulXLen;  /* length of extra data in bytes */
+} CK_KEY_WRAP_SET_OAEP_PARAMS;
+
+typedef CK_KEY_WRAP_SET_OAEP_PARAMS CK_PTR \
+  CK_KEY_WRAP_SET_OAEP_PARAMS_PTR;
+
+
+typedef struct CK_SSL3_RANDOM_DATA {
+  CK_BYTE_PTR  pClientRandom;
+  CK_ULONG     ulClientRandomLen;
+  CK_BYTE_PTR  pServerRandom;
+  CK_ULONG     ulServerRandomLen;
+} CK_SSL3_RANDOM_DATA;
+
+
+typedef struct CK_SSL3_MASTER_KEY_DERIVE_PARAMS {
+  CK_SSL3_RANDOM_DATA RandomInfo;
+  CK_VERSION_PTR pVersion;
+} CK_SSL3_MASTER_KEY_DERIVE_PARAMS;
+
+typedef struct CK_SSL3_MASTER_KEY_DERIVE_PARAMS CK_PTR \
+  CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR;
+
+
+typedef struct CK_SSL3_KEY_MAT_OUT {
+  CK_OBJECT_HANDLE hClientMacSecret;
+  CK_OBJECT_HANDLE hServerMacSecret;
+  CK_OBJECT_HANDLE hClientKey;
+  CK_OBJECT_HANDLE hServerKey;
+  CK_BYTE_PTR      pIVClient;
+  CK_BYTE_PTR      pIVServer;
+} CK_SSL3_KEY_MAT_OUT;
+
+typedef CK_SSL3_KEY_MAT_OUT CK_PTR CK_SSL3_KEY_MAT_OUT_PTR;
+
+
+typedef struct CK_SSL3_KEY_MAT_PARAMS {
+  CK_ULONG                ulMacSizeInBits;
+  CK_ULONG                ulKeySizeInBits;
+  CK_ULONG                ulIVSizeInBits;
+  CK_BBOOL                bIsExport;
+  CK_SSL3_RANDOM_DATA     RandomInfo;
+  CK_SSL3_KEY_MAT_OUT_PTR pReturnedKeyMaterial;
+} CK_SSL3_KEY_MAT_PARAMS;
+
+typedef CK_SSL3_KEY_MAT_PARAMS CK_PTR CK_SSL3_KEY_MAT_PARAMS_PTR;
+
+/* CK_TLS_PRF_PARAMS is new for version 2.20 */
+typedef struct CK_TLS_PRF_PARAMS {
+  CK_BYTE_PTR  pSeed;
+  CK_ULONG     ulSeedLen;
+  CK_BYTE_PTR  pLabel;
+  CK_ULONG     ulLabelLen;
+  CK_BYTE_PTR  pOutput;
+  CK_ULONG_PTR pulOutputLen;
+} CK_TLS_PRF_PARAMS;
+
+typedef CK_TLS_PRF_PARAMS CK_PTR CK_TLS_PRF_PARAMS_PTR;
+
+/* WTLS is new for version 2.20 */
+typedef struct CK_WTLS_RANDOM_DATA {
+  CK_BYTE_PTR pClientRandom;
+  CK_ULONG    ulClientRandomLen;
+  CK_BYTE_PTR pServerRandom;
+  CK_ULONG    ulServerRandomLen;
+} CK_WTLS_RANDOM_DATA;
+
+typedef CK_WTLS_RANDOM_DATA CK_PTR CK_WTLS_RANDOM_DATA_PTR;
+
+typedef struct CK_WTLS_MASTER_KEY_DERIVE_PARAMS {
+  CK_MECHANISM_TYPE   DigestMechanism;
+  CK_WTLS_RANDOM_DATA RandomInfo;
+  CK_BYTE_PTR         pVersion;
+} CK_WTLS_MASTER_KEY_DERIVE_PARAMS;
+
+typedef CK_WTLS_MASTER_KEY_DERIVE_PARAMS CK_PTR \
+  CK_WTLS_MASTER_KEY_DERIVE_PARAMS_PTR;
+
+typedef struct CK_WTLS_PRF_PARAMS {
+  CK_MECHANISM_TYPE DigestMechanism;
+  CK_BYTE_PTR       pSeed;
+  CK_ULONG          ulSeedLen;
+  CK_BYTE_PTR       pLabel;
+  CK_ULONG          ulLabelLen;
+  CK_BYTE_PTR       pOutput;
+  CK_ULONG_PTR      pulOutputLen;
+} CK_WTLS_PRF_PARAMS;
+
+typedef CK_WTLS_PRF_PARAMS CK_PTR CK_WTLS_PRF_PARAMS_PTR;
+
+typedef struct CK_WTLS_KEY_MAT_OUT {
+  CK_OBJECT_HANDLE hMacSecret;
+  CK_OBJECT_HANDLE hKey;
+  CK_BYTE_PTR      pIV;
+} CK_WTLS_KEY_MAT_OUT;
+
+typedef CK_WTLS_KEY_MAT_OUT CK_PTR CK_WTLS_KEY_MAT_OUT_PTR;
+
+typedef struct CK_WTLS_KEY_MAT_PARAMS {
+  CK_MECHANISM_TYPE       DigestMechanism;
+  CK_ULONG                ulMacSizeInBits;
+  CK_ULONG                ulKeySizeInBits;
+  CK_ULONG                ulIVSizeInBits;
+  CK_ULONG                ulSequenceNumber;
+  CK_BBOOL                bIsExport;
+  CK_WTLS_RANDOM_DATA     RandomInfo;
+  CK_WTLS_KEY_MAT_OUT_PTR pReturnedKeyMaterial;
+} CK_WTLS_KEY_MAT_PARAMS;
+
+typedef CK_WTLS_KEY_MAT_PARAMS CK_PTR CK_WTLS_KEY_MAT_PARAMS_PTR;
+
+/* CMS is new for version 2.20 */
+typedef struct CK_CMS_SIG_PARAMS {
+  CK_OBJECT_HANDLE      certificateHandle;
+  CK_MECHANISM_PTR      pSigningMechanism;
+  CK_MECHANISM_PTR      pDigestMechanism;
+  CK_UTF8CHAR_PTR       pContentType;
+  CK_BYTE_PTR           pRequestedAttributes;
+  CK_ULONG              ulRequestedAttributesLen;
+  CK_BYTE_PTR           pRequiredAttributes;
+  CK_ULONG              ulRequiredAttributesLen;
+} CK_CMS_SIG_PARAMS;
+
+typedef CK_CMS_SIG_PARAMS CK_PTR CK_CMS_SIG_PARAMS_PTR;
+
+typedef struct CK_KEY_DERIVATION_STRING_DATA {
+  CK_BYTE_PTR pData;
+  CK_ULONG    ulLen;
+} CK_KEY_DERIVATION_STRING_DATA;
+
+typedef CK_KEY_DERIVATION_STRING_DATA CK_PTR \
+  CK_KEY_DERIVATION_STRING_DATA_PTR;
+
+
+/* The CK_EXTRACT_PARAMS is used for the
+ * CKM_EXTRACT_KEY_FROM_KEY mechanism.  It specifies which bit
+ * of the base key should be used as the first bit of the
+ * derived key */
+/* CK_EXTRACT_PARAMS is new for v2.0 */
+typedef CK_ULONG CK_EXTRACT_PARAMS;
+
+typedef CK_EXTRACT_PARAMS CK_PTR CK_EXTRACT_PARAMS_PTR;
+
+/* CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE is new for v2.10.
+ * CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE is used to
+ * indicate the Pseudo-Random Function (PRF) used to generate
+ * key bits using PKCS #5 PBKDF2. */
+typedef CK_ULONG CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE;
+
+typedef CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE CK_PTR CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE_PTR;
+
+/* The following PRFs are defined in PKCS #5 v2.0. */
+#define CKP_PKCS5_PBKD2_HMAC_SHA1 0x00000001
+
+
+/* CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE is new for v2.10.
+ * CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE is used to indicate the
+ * source of the salt value when deriving a key using PKCS #5
+ * PBKDF2. */
+typedef CK_ULONG CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE;
+
+typedef CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE CK_PTR CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE_PTR;
+
+/* The following salt value sources are defined in PKCS #5 v2.0. */
+#define CKZ_SALT_SPECIFIED        0x00000001
+
+/* CK_PKCS5_PBKD2_PARAMS is new for v2.10.
+ * CK_PKCS5_PBKD2_PARAMS is a structure that provides the
+ * parameters to the CKM_PKCS5_PBKD2 mechanism. */
+typedef struct CK_PKCS5_PBKD2_PARAMS {
+        CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE           saltSource;
+        CK_VOID_PTR                                pSaltSourceData;
+        CK_ULONG                                   ulSaltSourceDataLen;
+        CK_ULONG                                   iterations;
+        CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE prf;
+        CK_VOID_PTR                                pPrfData;
+        CK_ULONG                                   ulPrfDataLen;
+        CK_UTF8CHAR_PTR                            pPassword;
+        CK_ULONG_PTR                               ulPasswordLen;
+} CK_PKCS5_PBKD2_PARAMS;
+
+typedef CK_PKCS5_PBKD2_PARAMS CK_PTR CK_PKCS5_PBKD2_PARAMS_PTR;
+
+#endif
diff -r -u -N openssl-0.9.8g/demos/easy_tls/cacerts.pem openssl/demos/easy_tls/cacerts.pem
--- openssl-0.9.8g/demos/easy_tls/cacerts.pem	2001-09-17 21:06:57.000000000 +0200
+++ openssl/demos/easy_tls/cacerts.pem	2007-10-25 01:27:09.000000000 +0200
@@ -1,4 +1,4 @@
-Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp
+Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp
 
 issuer= /C=AU/ST=Queensland/O=CryptSoft Pty Ltd/CN=Test PCA (1024 bit)
 subject=/C=AU/ST=Queensland/O=CryptSoft Pty Ltd/CN=Test CA (1024 bit)
diff -r -u -N openssl-0.9.8g/demos/easy_tls/cert.pem openssl/demos/easy_tls/cert.pem
--- openssl-0.9.8g/demos/easy_tls/cert.pem	2001-09-17 21:06:57.000000000 +0200
+++ openssl/demos/easy_tls/cert.pem	2007-10-25 01:27:09.000000000 +0200
@@ -1,4 +1,4 @@
-Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp
+Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp
 
 Example certificate and key.
 
diff -r -u -N openssl-0.9.8g/demos/easy_tls/easy-tls.c openssl/demos/easy_tls/easy-tls.c
--- openssl-0.9.8g/demos/easy_tls/easy-tls.c	2002-03-05 10:07:16.000000000 +0100
+++ openssl/demos/easy_tls/easy-tls.c	2007-10-25 01:27:09.000000000 +0200
@@ -1,7 +1,7 @@
 /* -*- Mode: C; c-file-style: "bsd" -*- */
 /*
  * easy-tls.c -- generic TLS proxy.
- * Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp
+ * Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp
  */
 /*
  (c) Copyright 1999 Bodo Moeller.  All rights reserved.
@@ -73,7 +73,7 @@
  */
 
 static char const rcsid[] =
-"Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp";
+"Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp";
 
 #include <assert.h>
 #include <errno.h>
diff -r -u -N openssl-0.9.8g/demos/easy_tls/easy-tls.h openssl/demos/easy_tls/easy-tls.h
--- openssl-0.9.8g/demos/easy_tls/easy-tls.h	2001-09-17 21:06:59.000000000 +0200
+++ openssl/demos/easy_tls/easy-tls.h	2007-10-25 01:27:09.000000000 +0200
@@ -1,7 +1,7 @@
 /* -*- Mode: C; c-file-style: "bsd" -*- */
 /*
  * easy-tls.h -- generic TLS proxy.
- * Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp
+ * Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp
  */
 /*
  * (c) Copyright 1999 Bodo Moeller.  All rights reserved.
diff -r -u -N openssl-0.9.8g/demos/easy_tls/Makefile openssl/demos/easy_tls/Makefile
--- openssl-0.9.8g/demos/easy_tls/Makefile	2001-09-18 11:15:40.000000000 +0200
+++ openssl/demos/easy_tls/Makefile	2007-10-25 01:27:09.000000000 +0200
@@ -1,5 +1,5 @@
 # Makefile for easy-tls example application (rudimentary client and server)
-# Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp
+# Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp
 
 SOLARIS_CFLAGS=-Wall -pedantic -g -O2
 SOLARIS_LIBS=-lxnet
diff -r -u -N openssl-0.9.8g/demos/easy_tls/test.c openssl/demos/easy_tls/test.c
--- openssl-0.9.8g/demos/easy_tls/test.c	2001-09-17 21:06:59.000000000 +0200
+++ openssl/demos/easy_tls/test.c	2007-10-25 01:27:09.000000000 +0200
@@ -1,5 +1,5 @@
 /* test.c */
-/* Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp */
+/* Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp */
 
 #define L_PORT 9999
 #define C_PORT 443
diff -r -u -N openssl-0.9.8g/demos/easy_tls/test.h openssl/demos/easy_tls/test.h
--- openssl-0.9.8g/demos/easy_tls/test.h	2001-09-17 21:07:00.000000000 +0200
+++ openssl/demos/easy_tls/test.h	2007-10-25 01:27:09.000000000 +0200
@@ -1,5 +1,5 @@
 /* test.h */
-/* Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp */
+/* Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp */
 
 
 void test_process_init(int fd, int client_p, void *apparg);
diff -r -u -N openssl-0.9.8g/engines/vendor_defns/hwcryptohook.h openssl/engines/vendor_defns/hwcryptohook.h
--- openssl-0.9.8g/engines/vendor_defns/hwcryptohook.h	2002-10-11 19:10:59.000000000 +0200
+++ openssl/engines/vendor_defns/hwcryptohook.h	2007-10-25 01:27:09.000000000 +0200
@@ -65,7 +65,7 @@
  * please contact nCipher.
  *
  *
- * Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp
+ * Id: openssl-0.9.8g-patch,v 1.2 2008/03/31 14:42:50 fdupont Exp
  */
 
 #ifndef HWCRYPTOHOOK_H
diff -r -u -N openssl-0.9.8g/Makefile.org openssl/Makefile.org
--- openssl-0.9.8g/Makefile.org	2007-04-24 01:49:54.000000000 +0200
+++ openssl/Makefile.org	2007-10-25 01:27:08.000000000 +0200
@@ -26,6 +26,9 @@
 INSTALL_PREFIX=
 INSTALLTOP=/usr/local/ssl
 
+# You must set this through --pk11-libname configure option.
+PK11_LIB_LOCATION=
+
 # Do not edit this manually. Use Configure --openssldir=DIR do change this!
 OPENSSLDIR=/usr/local/ssl
 
diff -r -u -N openssl-0.9.8g/README.pkcs11 openssl/README.pkcs11
--- openssl-0.9.8g/README.pkcs11	1970-01-01 01:00:00.000000000 +0100
+++ openssl/README.pkcs11	2008-01-31 15:24:32.000000000 +0100
@@ -0,0 +1,153 @@
+PKCS#11 engine support for OpenSSL 0.9.8g
+=========================================
+
+[Nov 21, 2007]
+
+This patch containing code available in OpenSolaris adds support for PKCS#11
+engine into OpenSSL and implements PKCS#11 v2.20. It is to be applied against
+OpenSSL 0.9.8g. Your system must provide PKCS#11 backend otherwise the patch
+is useless.
+
+Patch can be applied like this:
+
+	tar xfzv openssl-0.9.8g.tar.gz
+	cd openssl-0.9.8g
+	patch -p1 < ../pkcs11_engine-0.9.8g.patch.2007-11-21
+
+It is designed to support pure acceleration for RSA, DSA, DH and all the
+symetric ciphers and message digest algorithms that PKCS#11 and OpenSSL share
+except for missing support for patented algorithms MDC2, RC3, RC5 and IDEA.
+
+It also contains experimental code for accessing RSA keys stored in pkcs#11 key
+stores by reference. See below for more information.
+
+You must provide the location of PKCS#11 library in your system to the
+configure script, eg. if you use libraries from openCryptoki project on Linux
+AMD64 box, run configure like this:
+
+	./config --pk11-libname=/usr/lib64/pkcs11/PKCS11_API.so
+
+To check whether newly built openssl really supports PKCS#11 it's enough to
+run "apps/openssl engine" and look for "(pkcs11) PKCS #11 engine support" in
+the output.
+
+This patch was tested on Solaris against PKCS#11 engine available from Solaris
+Cryptographic Framework (Solaris 10 and OpenSolaris) and also on Linux using
+PKCS#11 libraries from openCryptoki project (see openCryptoki website
+http://sourceforge.net/projects/opencryptoki for more information). Some Linux
+distributions even ship those libraries with the system. The patch should work
+on any system that is supported by OpenSSL itself and has functional PKCS#11
+library.
+
+The patch contains "RSA Security Inc. PKCS #11 Cryptographic Token Interface
+(Cryptoki)" - files cryptoki.h, pkcs11.h, pkcs11f.h and pkcs11t.h which are
+copyrighted by RSA Security Inc., see pkcs11.h for more information.
+
+Other added/modified code in this patch is copyrighted by Sun Microsystems,
+Inc. and is released under the OpenSSL license (see LICENSE file for more
+information).
+
+Revisions of patch for 0.9.8 branch
+===================================
+
+2007-11-21
+- update for 0.9.8g version 
+- fixes in the draft code for "6607670 teach pkcs#11 engine how to use keys
+  be reference" so that it doesn't coredump when the referenced key is not
+  present
+
+2007-10-15
+- update for 0.9.8f version 
+- update for "6607670 teach pkcs#11 engine how to use keys be reference"
+
+2007-10-02
+- draft for "6607670 teach pkcs#11 engine how to use keys be reference"
+- draft for "6607307 pkcs#11 engine can't read RSA private keys"
+
+2007-09-26
+- 6375348 Using pkcs11 as the SSLCryptoDevice with Apache/OpenSSL causes
+	  significant performance drop
+- 6573196 memory is leaked when OpenSSL is used with PKCS#11 engine
+
+2007-05-25
+- 6558630 race in OpenSSL pkcs11 engine when using symetric block ciphers
+
+2007-05-19
+- initial patch for 0.9.8e using latest OpenSolaris code
+
+Notes
+=====
+
+This patch version contains not very well tested code for referencing RSA keys
+in keystores by labels. That code might and might not end up in OpenSolaris
+code base in the future. If you use this particular functionality with this
+patch I would be very grateful to get any feedback from you (please see my
+contact in the bottom).
+
+Issues
+------
+- can't reference public keys inside of certificates using certificate label
+- can't reference symetric keys
+- simple references in form of "pkcs11:LABEL" only are supported now. This is
+  supposed to be changed according to discussion on pkcs11 mailing list; comma
+  separated list of attributes is planned to be used.
+- getpassphrase(3c) is used for entering the PIN. This should be changed to a
+  more general approach; to check if the process has allocated tty and use
+  other means of entering the PIN if not.
+
+Usage
+-----
+See examples below using Solaris's pktool(1):
+
+# list private keys (note "mycert" label. Basically, we can't generate a
+# pub/priv key pair with pktool(1) without creating a certificate. This should
+# be changed in the future).
+$ pktool list objtype=private
+Enter PIN for Sun Software PKCS#11 softtoken  : 
+Found 1 keys.
+Key #1 - RSA private key:  mycert
+
+# this file is going to be signed
+$ cat test
+hello
+
+# sign it, note "pkcs11:mycert" private key's label
+$ openssl rsautl -inkey pkcs11:mycert -out test2 -in test -sign -keyform e -engine pkcs11
+engine "pkcs11" set.
+Enter PIN:
+
+# export the certificate out of the keyring
+$ pktool export keystore=pkcs11 label=mycert outfile=mycert.cert outformat=pem
+Warning: file "mycert.cert" exists, will be overwritten.
+Continue with export? y
+
+# verify using OpenSSL without pkcs#11 engine and with the certificate in the
+# file. This is proof of concept that a file signed with key by reference is
+# successfully verified when stock OpenSSL is used (I didn't have public key
+# in the keystore, only the certificate. There is no way to reference a public
+# key inside of the certificate).
+$ openssl rsautl -verify -inkey mycert.cert -certin -in test2
+hello
+
+API
+---
+You can use ENGINE_load_public_key() and ENGINE_load_private_key() functions
+only. The 2nd parameter of those calls is the one to use for "pkcs11:LABEL"
+filename overloading. If used that way, both functions will look for the key
+in the available keystores. Only one such key must be present. The private key
+is never extracted from the keystore. See OpenSSL's engine(3) or header file
+openssl/engine.h for more information.
+
+Note that those functions return a pointer to EVP_PKEY structure that contains
+all necessary information for accesing the key by label then. The pointer can be
+used in other functions that work with RSA keys - X509_sign() for example. See
+source code in apps/ subdirectory for reference.
+
+Feedback
+========
+
+Please send feedback to security-discuss@opensolaris.org. The patch was
+created by Jan.Pechanec@Sun.COM from code available in OpenSolaris.
+
+Latest version should be always available on http://blogs.sun.com/janp.
+
