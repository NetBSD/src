# Support routines for LD testsuite.
#   Copyright (C) 1994-2015 Free Software Foundation, Inc.
#
# This file is part of the GNU Binutils.
#
# This file is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
# MA 02110-1301, USA.

proc load_common_lib { name } {
    global srcdir
    load_file $srcdir/../../binutils/testsuite/lib/$name
}

load_common_lib binutils-common.exp

# Returns 1 if the gcc for the target is at least version MAJOR.MINOR
# Returns 0 otherwise.
#
proc at_least_gcc_version { major minor } {

    if {![info exists CC]} {
	set CC [find_gcc]
    }
    if { $CC == "" } {
      return 0
    }
    set state [remote_exec host $CC --version]
    set tmp "[lindex $state 1]\n"
    # Look for (eg) 4.6.1 in the version output.
    set ver_re "\[^\\.0-9\]+(\[1-9\]\[0-9\]*)\\.(\[0-9\]+)(?:\\.\[0-9\]+)?"
    regexp $ver_re $tmp fred maj min
    verbose "gcc version: $tmp"
    if { ![info exists maj] || ![info exists min] } then {
	perror "can't decipher gcc version number, fix the framework!"
	return 0
    }
    verbose "major gcc version is $maj, want at least $major"
    if { $maj == $major } then {
	verbose "minor gcc version is $min, want at least $minor"
	return [expr $min >= $minor]
    } else {
	return [expr $maj > $major]
    }
}

# Extract and print the version number of ld.
#
proc default_ld_version { ld } {
    global host_triplet

    if { ![is_remote host] && [which $ld] == 0 } then {
	perror "$ld does not exist"
	exit 1
    }

    remote_exec host "$ld --version" "" "/dev/null" "ld.version"
    remote_upload host "ld.version"
    set tmp [prune_warnings [file_contents "ld.version"]]
    remote_file build delete "ld.version"
    remote_file host delete "ld.version"

    regexp "\[^\n\]* (cygnus-|)(\[-0-9.a-zA-Z-\]+)\[\r\n\].*" $tmp version cyg number
    if [info exists number] then {
	clone_output "$ld $number\n"
    }
}

proc run_host_cmd { prog command } {
    global link_output
    global gcc_B_opt
    global ld_L_opt

    if { ![is_remote host] && [which "$prog"] == 0 } then {
	perror "$prog does not exist"
	return 0
    }

    # If we are compiling with gcc, we want to add gcc_B_opt and
    # ld_L_opt to flags.  However, if $prog already has -B options,
    # which might be the case when running gcc out of a build
    # directory, we want our -B options to come first.
    set gccexe $prog
    set gccparm [string first " " $gccexe]
    set gccflags ""
    if { $gccparm > 0 } then {
	set gccflags [string range $gccexe $gccparm end]
	set gccexe [string range $gccexe 0 $gccparm]
	set prog $gccexe
    }
    set gccexe [string replace $gccexe 0 [string last "/" $gccexe] ""]
    if {[string match "*cc*" $gccexe] || [string match "*++*" $gccexe]} then {
	set gccflags "$gcc_B_opt $gccflags $ld_L_opt"
    }

    verbose -log "$prog $gccflags $command"
    set status [remote_exec host [concat sh -c [list "$prog $gccflags $command 2>&1"]] "" "/dev/null" "ld.tmp"]
    remote_upload host "ld.tmp"
    set link_output [file_contents "ld.tmp"]
    regsub "\n$" $link_output "" link_output
    if { [lindex $status 0] != 0 && [string match "" $link_output] } then {
	append link_output "child process exited abnormally"
    }
    remote_file build delete ld.tmp
    remote_file host delete ld.tmp

    if [string match "" $link_output] then {
	return ""
    }

    verbose -log "$link_output"
    return "$link_output"
}

proc run_host_cmd_yesno { prog command } {
    global exec_output
    global errcnt warncnt

    set exec_output [prune_warnings [run_host_cmd "$prog" "$command"]]
    # Ignore error and warning.
    set errcnt 0
    set warncnt 0
    if [string match "" $exec_output] then {
	return 1;
    }
    return 0;
}

# Link an object using relocation.
#
proc default_ld_relocate { ld target objects } {
    global HOSTING_EMU

    remote_file host delete $target
    return [run_host_cmd_yesno "$ld" "$HOSTING_EMU -o $target -r $objects"]
}

# Check to see if ld is being invoked with a non-endian output format
#
proc is_endian_output_format { object_flags } {

    if {[string match "*-oformat binary*" $object_flags] ||      \
        [string match "*-oformat ieee*" $object_flags] ||        \
	[string match "*-oformat ihex*" $object_flags] ||        \
	[string match "*-oformat netbsd-core*" $object_flags] || \
	[string match "*-oformat srec*" $object_flags] ||        \
	[string match "*-oformat tekhex*" $object_flags] ||      \
	[string match "*-oformat trad-core*" $object_flags] } then {
        return 0
    } else {
	return 1
    }
}

# Look for big-endian or little-endian switches in the multlib
# options and translate these into a -EB or -EL switch.  Note
# we cannot rely upon proc process_multilib_options to do this
# for us because for some targets the compiler does not support
# -EB/-EL but it does support -mbig-endian/-mlittle-endian, and
# the site.exp file will include the switch "-mbig-endian"
# (rather than "big-endian") which is not detected by proc
# process_multilib_options.
#
proc big_or_little_endian {} {

    if [board_info [target_info name] exists multilib_flags] {
	set tmp_flags " [board_info [target_info name] multilib_flags]"

	foreach x $tmp_flags {
	    case $x in {
		{*big*endian eb EB -eb -EB -mb -meb} {
		    set flags " -EB"
		    return $flags
		}
		{*little*endian el EL -el -EL -ml -mel} {
		    set flags " -EL"
		    return $flags
		}
	    }
	}
    }

    set flags ""
    return $flags
}

# Link a program using ld.
#
proc default_ld_link { ld target objects } {
    global HOSTING_EMU
    global HOSTING_CRT0
    global HOSTING_SCRT0
    global HOSTING_LIBS
    global HOSTING_SLIBS
    global LIBS
    global host_triplet
    global link_output
    global exec_output

    if { [ string match "* -pie *" $objects ] } {
	set objs "$HOSTING_SCRT0 $objects"
	set libs "$LIBS $HOSTING_SLIBS"
    } else {
	set objs "$HOSTING_CRT0 $objects"
	set libs "$LIBS $HOSTING_LIBS"
    }

    if [is_endian_output_format $objects] then {
	set flags [big_or_little_endian]
    } else {
	set flags ""
    }

    remote_file host delete $target

    return [run_host_cmd_yesno "$ld" "$HOSTING_EMU $flags -o $target $objs $libs"]
}

# Link a program using ld, without including any libraries.
#
proc default_ld_simple_link { ld target objects } {
    global host_triplet
    global exec_output

    set flags ""
    if [is_endian_output_format $objects] then {
	set flags [big_or_little_endian]
    }

    remote_file host delete $target
    set exec_output [run_host_cmd "$ld" "$flags -o $target $objects"]
    set exec_output [prune_warnings $exec_output]

    # We don't care if we get a warning about a non-existent start
    # symbol, since the default linker script might use ENTRY.
    regsub -all "(^|\n)(\[^\n\]*: warning: cannot find entry symbol\[^\n\]*\n?)" $exec_output "\\1" exec_output

    return [string match "" $exec_output]
}

# Compile an object using cc.
#
proc default_ld_compile { cc source object } {
    global CFLAGS
    global CXXFLAGS
    global srcdir
    global subdir
    global host_triplet
    global gcc_B_opt

    set cc_prog $cc
    if {[llength $cc_prog] > 1} then {
	set cc_prog [lindex $cc_prog 0]
    }
    if {![is_remote host] && [which $cc_prog] == 0} then {
	perror "$cc_prog does not exist"
	return 0
    }

    remote_file build delete "$object"
    remote_file host delete "$object"

    set flags "$gcc_B_opt -I$srcdir/$subdir"

    # If we are compiling with gcc, we want to add gcc_B_opt to flags.
    # However, if $prog already has -B options, which might be the
    # case when running gcc out of a build directory, we want our -B
    # options to come first.
    set ccexe $cc
    set ccparm [string first " " $cc]
    set ccflags ""
    if { $ccparm > 0 } then {
	set ccflags [string range $cc $ccparm end]
	set ccexe [string range $cc 0 $ccparm]
	set cc $ccexe
    }

    set ccexe [string replace $ccexe 0 [string last "/" $ccexe] ""]
    if {[string match "*++*" $ccexe]} {
	append flags " $CXXFLAGS"
    } else {
	append flags " $CFLAGS"
    }

    if [board_info [target_info name] exists cflags] {
        append flags " [board_info [target_info name] cflags]"
    }

    if [board_info [target_info name] exists multilib_flags] {
	append flags " [board_info [target_info name] multilib_flags]"
    }

    set cmd "$cc $flags $ccflags -c $source -o $object"
    verbose -log "$cmd"

    set status [remote_exec host [concat sh -c [list "$cmd 2>&1"]] "" "/dev/null" "ld.tmp"]
    remote_upload host "ld.tmp"
    set exec_output [file_contents "ld.tmp"]
    remote_file build delete "ld.tmp"
    remote_file host delete "ld.tmp"
    set exec_output [prune_warnings $exec_output]
    if [string match "" $exec_output] then {
	if {![file exists $object]} then {
	    regexp ".*/(\[^/\]*)$" $source all dobj
	    regsub "\\.c" $dobj ".o" realobj
	    verbose "looking for $realobj"
	    if {[remote_file host exists $realobj]} then {
		verbose -log "mv $realobj $object"
		remote_upload "$realobj" "$object"
	    } else {
		perror "$object not found after compilation"
		return 0
	    }
	}
	return 1
    } else {
	verbose -log "$exec_output"
	perror "$source: compilation failed"
	return 0
    }
}

# Assemble a file.
#
proc default_ld_assemble { as in_flags source object } {
    global ASFLAGS
    global host_triplet
    global srcdir
    global subdir

    if ![info exists ASFLAGS] { set ASFLAGS "" }

    set flags "[big_or_little_endian] -I$srcdir/$subdir"
    set exec_output [run_host_cmd "$as" "$flags $in_flags $ASFLAGS -o $object $source"]
    set exec_output [prune_warnings $exec_output]
    if [string match "" $exec_output] then {
	return 1
    } else {
	perror "$source: assembly failed"
	return 0
    }
}

# Run nm on a file, putting the result in the array nm_output.
#
proc default_ld_nm { nm nmflags object } {
    global NMFLAGS
    global nm_output
    global host_triplet

    if {[info exists nm_output]} {
      unset nm_output
    }

    if ![info exists NMFLAGS] { set NMFLAGS "" }

    # Ensure consistent sorting of symbols
    if {[info exists env(LC_ALL)]} {
	set old_lc_all $env(LC_ALL)
    }
    set env(LC_ALL) "C"

    verbose -log "$nm $NMFLAGS $nmflags $object >tmpdir/nm.out"

    set status [remote_exec host [concat sh -c [list "$nm $NMFLAGS $nmflags $object 2>ld.stderr"]] "" "/dev/null" "tmpdir/nm.out"]
    if {[info exists old_lc_all]} {
	set env(LC_ALL) $old_lc_all
    } else {
	unset env(LC_ALL)
    }
    remote_upload host "ld.stderr"
    remote_upload host "tmpdir/nm.out" "tmpdir/nm.out"
    set exec_output [prune_warnings [file_contents "ld.stderr"]]
    remote_file host delete "ld.stderr"
    remote_file build delete "ld.stderr"
    if [string match "" $exec_output] then {
	set file [open tmpdir/nm.out r]
	while { [gets $file line] != -1 } {
	    verbose "$line" 2
	    if [regexp "^(\[0-9a-fA-F\]+) \[a-zA-Z0-9\] \\.*(.+)$" $line whole value name] {
                set name [string trimleft $name "_"]
		verbose "Setting nm_output($name) to 0x$value" 2
		set nm_output($name) 0x$value
	    }
	}
	close $file
	return 1
    } else {
	verbose -log "$exec_output"
	perror "$object: nm failed"
	return 0
    }
}

# Define various symbols needed when not linking against all
# target libs.
proc ld_simple_link_defsyms {} {

    set flags "--defsym __stack_chk_fail=0"

    # ARM targets call __gccmain
    if {[istarget arm*-*-*]} {
        append flags " --defsym __gccmain=0"
    }

    # Windows targets need __main, some prefixed with underscore.
    if {[istarget *-*-cygwin* ] || [istarget *-*-mingw*]} {
        append flags " --defsym __main=0 --defsym ___main=0"
    }

    # PowerPC EABI code calls __eabi.
    if {[istarget powerpc*-*-eabi*] || [istarget powerpc*-*-rtems*]} {
	append flags " --defsym __eabi=0"
    }

    # mn10200 code calls __truncsipsi2_d0_d2.
    if {[istarget mn10200*-*-*]} then {
	append flags " --defsym __truncsipsi2_d0_d2=0"
    }

    # m6811/m6812 code has references to soft registers.
    if {[istarget m6811-*-*] || [istarget m6812-*-*] || [istarget m68hc1*-*-*]} {
	append flags " --defsym _.frame=0 --defsym _.d1=0 --defsym _.d2=0"
	append flags " --defsym _.d3=0 --defsym _.d4=0"
	append flags " --defsym _.tmp=0 --defsym _.xy=0 --defsym _.z=0"
    }

    # Some OpenBSD targets have ProPolice and reference __guard and
    # __stack_smash_handler.
    if [istarget *-*-openbsd*] {
	append flags " --defsym __guard=0"
	append flags " --defsym __stack_smash_handler=0"
    }

    return $flags
}

# run_dump_test FILE (optional:) EXTRA_OPTIONS
# Copied from gas testsuite, tweaked and further extended.
#
# Assemble a .s file, then run some utility on it and check the output.
#
# There should be an assembly language file named FILE.s in the test
# suite directory, and a pattern file called FILE.d.  `run_dump_test'
# will assemble FILE.s, run some tool like `objdump', `objcopy', or
# `nm' on the .o file to produce textual output, and then analyze that
# with regexps.  The FILE.d file specifies what program to run, and
# what to expect in its output.
#
# The FILE.d file begins with zero or more option lines, which specify
# flags to pass to the assembler, the program to run to dump the
# assembler's output, and the options it wants.  The option lines have
# the syntax:
#
#         # OPTION: VALUE
#
# OPTION is the name of some option, like "name" or "objdump", and
# VALUE is OPTION's value.  The valid options are described below.
# Whitespace is ignored everywhere, except within VALUE.  The option
# list ends with the first line that doesn't match the above syntax
# (hmm, not great for error detection).
#
# The optional EXTRA_OPTIONS argument to `run_dump_test' is a list of
# two-element lists.  The first element of each is an option name, and
# the second additional arguments to be added on to the end of the
# option list as given in FILE.d.  (If omitted, no additional options
# are added.)
#
# The interesting options are:
#
#   name: TEST-NAME
#	The name of this test, passed to DejaGNU's `pass' and `fail'
#       commands.  If omitted, this defaults to FILE, the root of the
#       .s and .d files' names.
#
#   as: FLAGS
#	When assembling, pass FLAGS to the assembler.
#       If assembling several files, you can pass different assembler
#       options in the "source" directives.  See below.
#
#   ld: FLAGS
#       Link assembled files using FLAGS, in the order of the "source"
#       directives, when using multiple files.
#
#   ld_after_inputfiles: FLAGS
#       Similar to "ld", but put after all input files.
#
#   objcopy_objects: FLAGS
#	Run objcopy with the specified flags after assembling any source
#	that has the special marker RUN_OBJCOPY in the source specific
#	flags.
#
#   objcopy_linked_file: FLAGS
#	Run objcopy on the linked file with the specified flags.
#	This lets you transform the linked file using objcopy, before the
#	result is analyzed by an analyzer program specified below (which
#	may in turn *also* be objcopy).
#
#   PROG: PROGRAM-NAME
#       The name of the program to run to analyze the .o file produced
#       by the assembler or the linker output.  This can be omitted;
#       run_dump_test will guess which program to run by seeing which of
#       the flags options below is present.
#
#   readelf: FLAGS
#   objdump: FLAGS
#   nm: FLAGS
#   objcopy: FLAGS
#	Use the specified program to analyze the assembler or linker
#       output file, and pass it FLAGS, in addition to the output name.
#	Note that they are run with LC_ALL=C in the environment to give
#	consistent sorting of symbols.
#
#   source: SOURCE [FLAGS]
#	Assemble the file SOURCE.s using the flags in the "as" directive
#       and the (optional) FLAGS.  If omitted, the source defaults to
#       FILE.s.
#       This is useful if several .d files want to share a .s file.
#       More than one "source" directive can be given, which is useful
#       when testing linking.
#
#   dump: DUMP
#	Match against DUMP.d.  If omitted, this defaults to FILE.d.  This
#	is useful if several .d files differ by options only.  Options are
#	always read from FILE.d.
#
#   xfail: TARGET
#       The test is expected to fail on TARGET.  This may occur more than
#       once.
#
#   target: TARGET
#       Only run the test for TARGET.  This may occur more than once; the
#       target being tested must match at least one.  You may provide target
#       name "cfi" for any target supporting the CFI statements.
#
#   notarget: TARGET
#       Do not run the test for TARGET.  This may occur more than once;
#       the target being tested must not match any of them.
#
#   error: REGEX
#	An error with message matching REGEX must be emitted for the test
#	to pass.  The PROG, readelf, objdump, nm and objcopy options have
#	no meaning and need not be supplied if this is present.  Multiple
#	"error" directives append to the expected linker error message.
#
#   error_output: FILE
#       Means the same as 'error', except the regular expression lines
#       are contains in FILE.
#
#   warning: REGEX
#	Expect a linker warning matching REGEX.  It is an error to issue
#	both "error" and "warning".  Multiple "warning" directives
#	append to the expected linker warning message.
#
#   warning_output: FILE
#       Means the same as 'warning', except the regular expression
#       lines are contains in FILE.
#
#   map: FILE
#       Adding this option will cause the linker to generate a linker
#       map file, using the -Map=MAPFILE command line option.  If
#       there is no -Map=MAPFILE in the 'ld: FLAGS' then one will be
#       added to the linker command line.  The contents of the
#       generated MAPFILE are then compared against the regexp lines
#       in FILE using `regexp_diff' (see below for details).
#
# Each option may occur at most once unless otherwise mentioned.
#
# After the option lines come regexp lines.  `run_dump_test' calls
# `regexp_diff' to compare the output of the dumping tool against the
# regexps in FILE.d.  `regexp_diff' is defined in binutils-common.exp;
# see further comments there.
#
proc run_dump_test { name {extra_options {}} } {
    global subdir srcdir
    global OBJDUMP NM AS OBJCOPY READELF LD
    global OBJDUMPFLAGS NMFLAGS ASFLAGS OBJCOPYFLAGS READELFFLAGS LDFLAGS
    global host_triplet runtests
    global env verbose

    if [string match "*/*" $name] {
	set file $name
	set name [file tail $name]
    } else {
	set file "$srcdir/$subdir/$name"
    }

    if ![runtest_file_p $runtests $name] then {
	return
    }

    set opt_array [slurp_options "${file}.d"]
    if { $opt_array == -1 } {
	perror "error reading options from $file.d"
	unresolved $subdir/$name
	return
    }
    set dumpfile tmpdir/dump.out
    set run_ld 0
    set run_objcopy 0
    set opts(as) {}
    set opts(ld) {}
    set opts(ld_after_inputfiles) {}
    set opts(xfail) {}
    set opts(target) {}
    set opts(notarget) {}
    set opts(objdump) {}
    set opts(nm) {}
    set opts(objcopy) {}
    set opts(readelf) {}
    set opts(name) {}
    set opts(PROG) {}
    set opts(source) {}
    set opts(dump) {}
    set opts(error) {}
    set opts(warning) {}
    set opts(error_output) {}
    set opts(warning_output) {}
    set opts(objcopy_linked_file) {}
    set opts(objcopy_objects) {}
    set opts(map) {}

    foreach i $opt_array {
	set opt_name [lindex $i 0]
	set opt_val [lindex $i 1]
	if ![info exists opts($opt_name)] {
	    perror "unknown option $opt_name in file $file.d"
	    unresolved $subdir/$name
	    return
	}

	switch -- $opt_name {
	    xfail {}
	    target {}
	    notarget {}
	    warning {}
	    error {}
	    source {
		# Move any source-specific as-flags to a separate list to
		# simplify processing.
		if { [llength $opt_val] > 1 } {
		    lappend asflags [lrange $opt_val 1 end]
		    set opt_val [lindex $opt_val 0]
		} else {
		    lappend asflags {}
		}
	    }
	    default {
		if [string length $opts($opt_name)] {
		    perror "option $opt_name multiply set in $file.d"
		    unresolved $subdir/$name
		    return
		}

		# A single "# ld:" with no options should do the right thing.
		if { $opt_name == "ld" } {
		    set run_ld 1
		}
		# Likewise objcopy_linked_file.
		if { $opt_name == "objcopy_linked_file" } {
		    set run_objcopy 1
		}
	    }
	}
	if { $opt_name == "as" || $opt_name == "ld" } {
	    set opt_val [subst $opt_val]
	}

	# Append differently whether it's a message (without space) or
	# an option or list (with space).
	switch -- $opt_name {
	    warning -
	    error {
		append opts($opt_name) $opt_val
	    }
	    default {
		set opts($opt_name) [concat $opts($opt_name) $opt_val]
	    }
	}
    }

    foreach i $extra_options {
	set opt_name [lindex $i 0]
	set opt_val [lindex $i 1]
	if ![info exists opts($opt_name)] {
	    perror "unknown option $opt_name given in extra_opts"
	    unresolved $subdir/$name
	    return
	}
	# Add extra option to end of existing option, adding space
	# if necessary.
	if { ![regexp "warning|error" $opt_name]
	     && [string length $opts($opt_name)] } {
	    append opts($opt_name) " "
	}
	append opts($opt_name) $opt_val
    }

    foreach opt { as ld } {
	regsub {\[big_or_little_endian\]} $opts($opt) \
	    [big_or_little_endian] opts($opt)
    }

    # Decide early whether we should run the test for this target.
    if { [llength $opts(target)] > 0 } {
	set targmatch 0
	foreach targ $opts(target) {
	    if [istarget $targ] {
		set targmatch 1
		break
	    }
	}
	if { $targmatch == 0 } {
	    return
	}
    }
    foreach targ $opts(notarget) {
	if [istarget $targ] {
	    return
	}
    }

    set program ""
    # It's meaningless to require an output-testing method when we
    # expect an error.
    if { $opts(error) == "" && $opts(error_output) == "" } {
	if {$opts(PROG) != ""} {
	    switch -- $opts(PROG) {
		objdump	{ set program objdump }
		nm	{ set program nm }
		objcopy	{ set program objcopy }
		readelf	{ set program readelf }
		default
		{ perror "unrecognized program option $opts(PROG) in $file.d"
		  unresolved $subdir/$name
		  return }
	    }
	} else {
	# Guess which program to run, by seeing which option was specified.
	    foreach p {objdump objcopy nm readelf} {
		if {$opts($p) != ""} {
		    if {$program != ""} {
			perror "ambiguous dump program in $file.d"
			unresolved $subdir/$name
			return
		    } else {
			set program $p
		    }
		}
	    }
	}
	if { $program == "" \
                 && $opts(map) == "" \
                 && $opts(warning) == "" \
                 && $opts(warning_output) == "" \
                 && $opts(error) == "" \
                 && $opts(error_output) == "" } {
	    perror "dump program unspecified in $file.d"
	    unresolved $subdir/$name
	    return
	}
    }

    if { $opts(name) == "" } {
	set testname "$subdir/$name"
    } else {
	set testname $opts(name)
    }

    if { $opts(source) == "" } {
	set sourcefiles [list ${file}.s]
	set asflags [list ""]
    } else {
	set sourcefiles {}
	foreach sf $opts(source) {
	    if { [string match "/*" $sf] } {
		lappend sourcefiles "$sf"
	    } else {
		lappend sourcefiles "$srcdir/$subdir/$sf"
	    }
	}
    }

    if { $opts(dump) == "" } {
	set dfile ${file}.d
    } else {
	set dfile $srcdir/$subdir/$opts(dump)
    }

    # Time to setup xfailures.
    foreach targ $opts(xfail) {
	setup_xfail $targ
    }

    # Assemble each file.
    set objfiles {}
    for { set i 0 } { $i < [llength $sourcefiles] } { incr i } {
	set sourcefile [lindex $sourcefiles $i]
	set sourceasflags [lindex $asflags $i]
	set run_objcopy_objects 0

	if { [string match "*RUN_OBJCOPY*" $sourceasflags] } {
	    set run_objcopy_objects 1
	}
	regsub "RUN_OBJCOPY" $sourceasflags "" sourceasflags

	set objfile "tmpdir/dump$i.o"
	catch "exec rm -f $objfile" exec_output
	lappend objfiles $objfile
	set cmd "$AS $ASFLAGS $opts(as) $sourceasflags -o $objfile $sourcefile"

	send_log "$cmd\n"
	set cmdret [remote_exec host [concat sh -c [list "$cmd 2>&1"]] "" "/dev/null" "ld.tmp"]
	remote_upload host "ld.tmp"
	set comp_output [prune_warnings [file_contents "ld.tmp"]]
	remote_file host delete "ld.tmp"
	remote_file build delete "ld.tmp"

	if { [lindex $cmdret 0] != 0 || ![string match "" $comp_output] } then {
	    send_log "$comp_output\n"
	    verbose "$comp_output" 3

	    set exitstat "succeeded"
	    if { $cmdret != 0 } { set exitstat "failed" }
	    verbose -log "$exitstat with: <$comp_output>"
	    fail $testname
	    return
	}

	if { $run_objcopy_objects } {
	    set cmd "$OBJCOPY $opts(objcopy_objects) $objfile"

	    send_log "$cmd\n"
	    set cmdret [remote_exec host [concat sh -c [list "$cmd 2>&1"]] \
			"" "/dev/null" "objcopy.tmp"]
	    remote_upload host "objcopy.tmp"
	    set comp_output [prune_warnings [file_contents "objcopy.tmp"]]
	    remote_file host delete "objcopy.tmp"
	    remote_file build delete "objcopy.tmp"

	    if { [lindex $cmdret 0] != 0 \
		  || ![string match "" $comp_output] } {
		send_log "$comp_output\n"
		verbose "$comp_output" 3

		set exitstat "succeeded"
		if { $cmdret != 0 } { set exitstat "failed" }
		verbose -log "$exitstat with: <$comp_output>"
		fail $testname
		return
	    }
	}
    }

    if { (($opts(warning) != "") && ($opts(error) != "")) \
	 || (($opts(warning) != "") && ($opts(error_output) != "")) \
	 || (($opts(warning) != "") && ($opts(warning_output) != "")) \
	 || (($opts(error) != "") && ($opts(warning_output) != "")) \
	 || (($opts(error) != "") && ($opts(error_output) != "")) \
	 || (($opts(warning_output) != "") && ($opts(error_output) != "")) } {
	perror "$testname: bad mix of warning, error, warning_output, and error_output test-directives"
	unresolved $testname
	return
    }

    set check_ld(source) ""
    if { $opts(error) != "" \
         || $opts(warning) != "" \
         || $opts(error_output) != "" \
         || $opts(warning_output) != "" } {

        if { $opts(error) != "" || $opts(error_output) != "" } {
            set check_ld(terminal) 1
        } else {
            set check_ld(terminal) 0
        }

        if { $opts(error) != "" || $opts(warning) != "" } {
            set check_ld(source) "regex"
            if { $opts(error) != "" } {
                set check_ld(regex) $opts(error)
            } else {
                set check_ld(regex) $opts(warning)
            }
        } else {
            set check_ld(source) "file"
            if { $opts(error_output) != "" } {
                set check_ld(file) $opts(error_output)
            } else {
                set check_ld(file) $opts(warning_output)
            }
        }
    }

    # Perhaps link the file(s).
    if { $run_ld } {
	set objfile "tmpdir/dump"
	catch "exec rm -f $objfile" exec_output

	# Add -L$srcdir/$subdir so that the linker command can use
	# linker scripts in the source directory.
	set cmd "$LD $LDFLAGS -L$srcdir/$subdir \
		   $opts(ld) -o $objfile $objfiles $opts(ld_after_inputfiles)"

        # If needed then check for, or add a -Map option.
        set mapfile ""
        if { $opts(map) != "" } then {
            if { [regexp -- "-Map=(\[^ \]+)" $cmd all mapfile] } then {
                # Found existing mapfile option
                verbose -log "Existing mapfile '$mapfile' found"
            } else {
                # No mapfile option.
                set mapfile "tmpdir/dump.map"
                verbose -log "Adding mapfile '$mapfile'"
                set cmd "$cmd -Map=$mapfile"
            }
        }

	send_log "$cmd\n"
	set cmdret [remote_exec host [concat sh -c [list "$cmd 2>&1"]] "" "/dev/null" "ld.tmp"]
	remote_upload host "ld.tmp"
	set comp_output [file_contents "ld.tmp"]
	remote_file host delete "ld.tmp"
	remote_file build delete "ld.tmp"
	set cmdret [lindex $cmdret 0]

	if { $cmdret == 0 && $run_objcopy } {
	    set infile $objfile
	    set objfile "tmpdir/dump1"
	    remote_file host delete $objfile

	    # Note that we don't use OBJCOPYFLAGS here; any flags must be
	    # explicitly specified.
	    set cmd "$OBJCOPY $opts(objcopy_linked_file) $infile $objfile"

	    send_log "$cmd\n"
	    set cmdret [remote_exec host [concat sh -c [list "$cmd 2>&1"]] "" "/dev/null" "ld.tmp"]
	    remote_upload host "ld.tmp"
	    append comp_output [file_contents "ld.tmp"]
	    remote_file host delete "ld.tmp"
	    remote_file build delete "ld.tmp"
	    set cmdret [lindex $cmdret 0]
	}

	regsub "\n$" $comp_output "" comp_output
	if { $cmdret != 0 || $comp_output != "" || $check_ld(source) != "" } then {
	    set exitstat "succeeded"
	    if { $cmdret != 0 } { set exitstat "failed" }

            if { $check_ld(source) == "regexp" } {
                verbose -log "$exitstat with: <$comp_output>, expected: <$check_ld(regex)>"
            } elseif { $check_ld(source) == "file" } {
                verbose -log "$exitstat with: <$comp_output>, expected in file $check_ld(file)"
                set_file_contents "tmpdir/ld.messages" "$comp_output"
            } else {
                verbose -log "$exitstat with: <$comp_output>, no expected output"
            }
	    send_log "$comp_output\n"
	    verbose "$comp_output" 3

	    if { (($check_ld(source) == "") == ($comp_output == "")) \
                 && (($cmdret == 0) == ($check_ld(terminal) == 0)) \
                 && ((($check_ld(source) == "regex") \
                      && ($check_ld(regex) == "") == ($comp_output == "") \
                      && [regexp $check_ld(regex) $comp_output]) \
                     || (($check_ld(source) == "file") \
                         && ([regexp_diff "tmpdir/ld.messages" "$srcdir/$subdir/$check_ld(file)"]))) } {
                # We have the expected output from ld.
		if { $check_ld(terminal) || $program == "" } {
		    pass $testname
		    return
		}
	    } else {
		fail $testname
		return
	    }
	}

        if { $opts(map) != "" } then {
            # Check the map file matches.
            set map_pattern_file $srcdir/$subdir/$opts(map)
            verbose -log "Compare '$mapfile' against '$map_pattern_file'"
            if { [regexp_diff $mapfile $map_pattern_file] } then {
                fail "$testname (map file check)"
            } else {
                pass "$testname (map file check)"
            }

            if { $program == "" } then {
                return
            }
        }
    } else {
	set objfile "tmpdir/dump0.o"
    }

    # We must not have expected failure if we get here.
    if { $opts(error) != "" } {
	fail $testname
	return
    }

    set progopts1 $opts($program)
    eval set progopts \$[string toupper $program]FLAGS
    eval set binary \$[string toupper $program]

    if { ![is_remote host] && [which $binary] == 0 } {
	untested $testname
	return
    }

    if { $progopts1 == "" } { set $progopts1 "-r" }
    verbose "running $binary $progopts $progopts1" 3

    # Objcopy, unlike the other two, won't send its output to stdout,
    # so we have to run it specially.
    set cmd "$binary $progopts $progopts1 $objfile > $dumpfile"
    if { $program == "objcopy" } {
	set cmd "$binary $progopts $progopts1 $objfile $dumpfile"
    }

    # Ensure consistent sorting of symbols
    if {[info exists env(LC_ALL)]} {
	set old_lc_all $env(LC_ALL)
    }
    set env(LC_ALL) "C"
    send_log "$cmd\n"
    set cmdret [remote_exec host [concat sh -c [list "$cmd 2>ld.tmp"]] "" "/dev/null"]
    set cmdret [lindex $cmdret 0]
    remote_upload host "ld.tmp"
    set comp_output [prune_warnings [file_contents "ld.tmp"]]
    remote_file host delete "ld.tmp"
    remote_file build delete "ld.tmp"
    if {[info exists old_lc_all]} {
	set env(LC_ALL) $old_lc_all
    } else {
	unset env(LC_ALL)
    }
    if { $cmdret != 0 || $comp_output != "" } {
	send_log "exited abnormally with $cmdret, output:$comp_output\n"
	fail $testname
	return
    }

    if { $verbose > 2 } then { verbose "output is [file_contents $dumpfile]" 3 }
    if { [regexp_diff $dumpfile "${dfile}"] } then {
	fail $testname
	if { $verbose == 2 } then { verbose "output is [file_contents $dumpfile]" 2 }
	return
    }

    pass $testname
}

proc slurp_options { file } {
    # If options_regsub(foo) is set to {a b}, then the contents of a
    # "#foo:" line will have regsub -all applied to replace a with b.
    global options_regsub

    if [catch { set f [open $file r] } x] {
	#perror "couldn't open `$file': $x"
	perror "$x"
	return -1
    }
    set opt_array {}
    # whitespace expression
    set ws  {[ 	]*}
    set nws {[^ 	]*}
    # whitespace is ignored anywhere except within the options list;
    # option names are alphabetic plus underscore only.
    set pat "^#${ws}(\[a-zA-Z_\]*)$ws:${ws}(.*)$ws\$"
    while { [gets $f line] != -1 } {
	set line [string trim $line]
	# Whitespace here is space-tab.
	if [regexp $pat $line xxx opt_name opt_val] {
	    # match!
	    if [info exists options_regsub($opt_name)] {
		set subst $options_regsub($opt_name)
		regsub -all -- [lindex $subst 0] $opt_val [lindex $subst 1] \
		    opt_val
	    }
	    lappend opt_array [list $opt_name $opt_val]
	} else {
	    break
	}
    }
    close $f
    return $opt_array
}

proc file_contents { filename } {
    set file [open $filename r]
    set contents [read $file]
    close $file
    return $contents
}

proc set_file_contents { filename contents } {
    set file [open $filename w]
    puts $file "$contents"
    close $file
}

# Create an archive using ar
#
proc ar_simple_create { ar aropts target objects } {
    remote_file host delete $target

    set exec_output [run_host_cmd "$ar" "-rc $aropts $target $objects"]
    set exec_output [prune_warnings $exec_output]

    if [string match "" $exec_output] then {
	send_log "$exec_output\n"
	return 1
    } else {
	return 0
    }
}

# List contains test-items with 3 items followed by 2 lists, one item and
# one optional item:
#  0:name
#  1:ld/ar leading options, placed before object files
#  2:ld/ar trailing options, placed after object files
#  3:assembler options
#  4:filenames of assembler files
#  5:list of actions, options and expected outputs.
#  6:name of output file
#  7:compiler flags (optional)
#
# Actions: { command command-line-options file-containg-expected-output-regexps }
# Commands:
#   objdump: Apply objdump options on result.
#   nm: Apply nm options on result.
#   readelf: Apply readelf options on result.
#   ld: Don't apply anything on result.  Compare output during linking with
#     the file containing regexps (which is the second arg, not the third).
#     Note that this *must* be the first action if it is to be used at all;
#     in all other cases, any output from the linker during linking is
#     treated as a sign of an error and FAILs the test.
#
proc run_ld_link_tests { ldtests } {
    global ld
    global as
    global nm
    global ar
    global objdump
    global READELF
    global srcdir
    global subdir
    global env
    global CC
    global CFLAGS
    global runtests
    global exec_output

    foreach testitem $ldtests {
	set testname [lindex $testitem 0]

	if ![runtest_file_p $runtests $testname] then {
	    continue
	}

	set ld_options [lindex $testitem 1]
	set ld_after [lindex $testitem 2]
	set as_options [lindex $testitem 3]
	set src_files  [lindex $testitem 4]
	set actions [lindex $testitem 5]
	set binfile tmpdir/[lindex $testitem 6]
	set cflags [lindex $testitem 7]
	set objfiles {}
	set is_unresolved 0
	set failed 0
	set maybe_failed 0
	set ld_output ""

#	verbose -log "Testname is $testname"
#	verbose -log "ld_options is $ld_options"
#	verbose -log "ld_after is $ld_after"
#	verbose -log "as_options is $as_options"
#	verbose -log "src_files is $src_files"
#	verbose -log "actions is $actions"
#	verbose -log "binfile is $binfile"

	# Assemble each file in the test.
	foreach src_file $src_files {
	    set fileroot "[file rootname [file tail $src_file]]"
	    set objfile "tmpdir/$fileroot.o"
	    lappend objfiles $objfile

	    if { [file extension $src_file] == ".c" } {
		set as_file "tmpdir/$fileroot.s"
		if ![ld_compile "$CC -S $CFLAGS $cflags" $srcdir/$subdir/$src_file $as_file] {
		    set is_unresolved 1
		    break
		}
	    } else {
		set as_file "$srcdir/$subdir/$src_file"
	    }
	    if ![ld_assemble $as "$as_options $as_file" $objfile] {
		set is_unresolved 1
		break
	    }
	}

	# Catch assembler errors.
	if { $is_unresolved } {
	    unresolved $testname
	    continue
	}

	if { $binfile eq "tmpdir/" } {
	    # compile only
	} elseif { [regexp ".*\\.a$" $binfile] } {
	    if { ![ar_simple_create $ar $ld_options $binfile "$objfiles $ld_after"] } {
		set failed 1
	    }
	} elseif { ![ld_simple_link $ld $binfile "-L$srcdir/$subdir $ld_options $objfiles $ld_after"] } {
	    set maybe_failed 1
	    set ld_output "$exec_output"
	}

	if { !$failed } {
	    foreach actionlist $actions {
		set action [lindex $actionlist 0]
		set progopts [lindex $actionlist 1]

		# There are actions where we run regexp_diff on the
		# output, and there are other actions (presumably).
		# Handling of the former look the same.
		set dump_prog ""
		switch -- $action {
		    objdump
		        { set dump_prog $objdump }
		    nm
		        { set dump_prog $nm }
		    readelf
		        { set dump_prog $READELF }
		    ld
		        { set dump_prog "ld" }
		    default
			{
			    perror "Unrecognized action $action"
			    set is_unresolved 1
			    break
			}
		    }

		if { $action == "ld" } {
		    set regexpfile $progopts
		    verbose "regexpfile is $srcdir/$subdir/$regexpfile"
		    set_file_contents "tmpdir/ld.messages" "$ld_output"
		    verbose "ld.messages has '[file_contents tmpdir/ld.messages]'"
		    if { [regexp_diff "tmpdir/ld.messages" "$srcdir/$subdir/$regexpfile"] } then {
			verbose "output is $ld_output" 2
			set failed 1
			break
		    }
		    set maybe_failed 0
		} elseif { !$maybe_failed && $dump_prog != "" } {
		    set dumpfile [lindex $actionlist 2]
		    set binary $dump_prog

		    # Ensure consistent sorting of symbols
		    if {[info exists env(LC_ALL)]} {
			set old_lc_all $env(LC_ALL)
		    }
		    set env(LC_ALL) "C"
		    set cmd "$binary $progopts $binfile"
    		    set status [remote_exec host [concat sh -c [list "$cmd >dump.out 2>ld.stderr"]] "" "/dev/null"]
		    send_log "$cmd\n"
    		    remote_upload host "ld.stderr"
    		    set comp_output [prune_warnings [file_contents "ld.stderr"]]
    		    remote_file host delete "ld.stderr"
    		    remote_file build delete "ld.stderr"

		    if {[info exists old_lc_all]} {
			set env(LC_ALL) $old_lc_all
		    } else {
			unset env(LC_ALL)
		    }

		    if ![string match "" $comp_output] then {
			send_log "$comp_output\n"
			set failed 1
			break
		    }

		    remote_upload host "dump.out"

		    if { [regexp_diff "dump.out" "$srcdir/$subdir/$dumpfile"] } then {
			verbose "output is [file_contents "dump.out"]" 2
			set failed 1
		   	remote_file build delete "dump.out"
		   	remote_file host delete "dump.out"
			break
		    }
		    remote_file build delete "dump.out"
		    remote_file host delete "dump.out"
		}
	    }
	}

	if { $is_unresolved } {
	    unresolved $testname
	} elseif { $maybe_failed || $failed } {
	    fail $testname
	} else {
	    pass $testname
	}
    }
}

# This definition is taken from an unreleased version of DejaGnu.  Once
# that version gets released, and has been out in the world for a few
# months at least, it may be safe to delete this copy.
if ![string length [info proc prune_warnings]] {
    #
    # prune_warnings -- delete various system verbosities from TEXT
    #
    # An example is:
    # ld.so: warning: /usr/lib/libc.so.1.8.1 has older revision than expected 9
    #
    # Sites with particular verbose os's may wish to override this in site.exp.
    #
    proc prune_warnings { text } {
	# This is from sun4's.  Do it for all machines for now.
	# The "\\1" is to try to preserve a "\n" but only if necessary.
	regsub -all "(^|\n)(ld.so: warning:\[^\n\]*\n?)+" $text "\\1" text

	# It might be tempting to get carried away and delete blank lines, etc.
	# Just delete *exactly* what we're ask to, and that's it.
	return $text
    }
}

# targets_to_xfail is a list of target triplets to be xfailed.
# ldtests contains test-items with 3 items followed by 1 lists, 2 items
# and 3 optional items:
#   0:name
#   1:ld options
#   2:assembler options
#   3:filenames of source files
#   4:name of output file
#   5:expected output
#   6:compiler flags (optional)
#   7:language (optional)
#   8:linker warning (optional)

proc run_ld_link_exec_tests { targets_to_xfail ldtests } {
    global ld
    global as
    global srcdir
    global subdir
    global env
    global CC
    global CXX
    global CFLAGS
    global CXXFLAGS
    global errcnt
    global exec_output

    foreach testitem $ldtests {
	foreach target $targets_to_xfail {
	    setup_xfail $target
	}
	set testname [lindex $testitem 0]
	set ld_options [lindex $testitem 1]
	set as_options [lindex $testitem 2]
	set src_files  [lindex $testitem 3]
	set binfile tmpdir/[lindex $testitem 4]
	set expfile [lindex $testitem 5]
	set cflags [lindex $testitem 6]
	set lang [lindex $testitem 7]
	set warning [lindex $testitem 8]
	set objfiles {}
	set failed 0

#	verbose -log "Testname is $testname"
#	verbose -log "ld_options is $ld_options"
#	verbose -log "as_options is $as_options"
#	verbose -log "src_files is $src_files"
#	verbose -log "binfile is $binfile"

	# Assemble each file in the test.
	foreach src_file $src_files {
	    set fileroot "[file rootname [file tail $src_file]]"
	    set objfile "tmpdir/$fileroot.o"
	    lappend objfiles $objfile

	    # We ignore warnings since some compilers may generate
	    # incorrect section attributes and the assembler will warn
	    # them.
	    if { [ string match "c++" $lang ] } {
		ld_compile "$CXX -c $CXXFLAGS $cflags" $srcdir/$subdir/$src_file $objfile
	    } else {
		ld_compile "$CC -c $CFLAGS $cflags" $srcdir/$subdir/$src_file $objfile
	    }
	}

	# We have to use $CC to build PIE and shared library.
	if { [ string match "c" $lang ] } {
	    set link_proc ld_simple_link
	    set link_cmd $CC
	} elseif { [ string match "c++" $lang ] } {
	    set link_proc ld_simple_link
	    set link_cmd $CXX
	} elseif { [ string match "-shared" $ld_options ] \
		   || [ string match "-pie" $ld_options ] } {
	    set link_proc ld_simple_link
	    set link_cmd $CC
	} else {
	    set link_proc ld_link
	    set link_cmd $ld
	}

	if { $binfile eq "tmpdir/" } {
	    # compile only
	    pass $testname
	    continue;
	} elseif ![$link_proc $link_cmd $binfile "-L$srcdir/$subdir $ld_options $objfiles"] {
	    set failed 1
	}

	# Check if exec_output is expected.
	if { $warning != "" } then {
	    verbose -log "returned with: <$exec_output>, expected: <$warning>"
	    if { [regexp $warning $exec_output] } then {
		set failed 0
	    } else {
		set failed 1
	    }
	}

	if { $failed == 0 } {
	    send_log "Running: $binfile > $binfile.out\n"
	    verbose "Running: $binfile > $binfile.out"
	    catch "exec $binfile > $binfile.out" exec_output

	    if ![string match "" $exec_output] then {
		send_log "$exec_output\n"
		verbose "$exec_output" 1
		set failed 1
	    } else {
		send_log "diff $binfile.out $srcdir/$subdir/$expfile\n"
		verbose "diff $binfile.out $srcdir/$subdir/$expfile"
		catch "exec diff $binfile.out $srcdir/$subdir/$expfile" exec_output
		set exec_output [prune_warnings $exec_output]

		if ![string match "" $exec_output] then {
		    send_log "$exec_output\n"
		    verbose "$exec_output" 1
		    set failed 1
		}
	    }
	}

	if { $failed != 0 } {
	    fail $testname
	} else {
	    set errcnt 0
	    pass $testname
	}
    }
}

# List contains test-items with 3 items followed by 2 lists, one item and
# one optional item:
#  0:name
#  1:ld or ar options
#  2:compile options
#  3:filenames of source files
#  4:action and options.
#  5:name of output file
#  6:language (optional)
#  7:linker warnings (optional)
#
# Actions:
# objdump: Apply objdump options on result.  Compare with regex (last arg).
# nm: Apply nm options on result.  Compare with regex (last arg).
# readelf: Apply readelf options on result.  Compare with regex (last arg).
#
proc run_cc_link_tests { ldtests } {
    global nm
    global objdump
    global READELF
    global srcdir
    global subdir
    global env
    global CC
    global CXX
    global CFLAGS
    global CXXFLAGS
    global ar
    global exec_output
    global board_cflags

    if [board_info [target_info name] exists cflags] {
        set board_cflags " [board_info [target_info name] cflags]"
    } else {
	set board_cflags ""
    }

    foreach testitem $ldtests {
	set testname [lindex $testitem 0]
	set ldflags [lindex $testitem 1]
	set cflags [lindex $testitem 2]
	set src_files  [lindex $testitem 3]
	set actions [lindex $testitem 4]
	set binfile tmpdir/[lindex $testitem 5]
	set lang [lindex $testitem 6]
	set warnings [lindex $testitem 7]
	set objfiles {}
	set is_unresolved 0
	set failed 0

	#verbose -log "testname  is $testname"
	#verbose -log "ldflags   is $ldflags"
	#verbose -log "cflags    is $cflags"
	#verbose -log "src_files is $src_files"
	#verbose -log "actions   is $actions"
	#verbose -log "binfile   is $binfile"
	#verbose -log "lang      is $lang"
	#verbose -log "warnings  is $warnings"

	# Compile each file in the test.
	foreach src_file $src_files {
	    set fileroot "[file rootname [file tail $src_file]]"
	    set objfile "tmpdir/$fileroot.o"
	    lappend objfiles $objfile

	    # We ignore warnings since some compilers may generate
	    # incorrect section attributes and the assembler will warn
	    # them.
	    if { [ string match "c++" $lang ] } {
		ld_compile "$CXX -c $CXXFLAGS $cflags" $srcdir/$subdir/$src_file $objfile
	    } else {
		ld_compile "$CC -c $CFLAGS $cflags" $srcdir/$subdir/$src_file $objfile
	    }
	}

	# Clear error and warning counts.
	reset_vars

	if { [ string match "c++" $lang ] } {
	    set cc_cmd $CXX
	} else {
	    set cc_cmd $CC
	}

	if { $binfile eq "tmpdir/" } {
	    # compile only
	} elseif { [regexp ".*\\.a$" $binfile] } {
	    if { ![ar_simple_create $ar $ldflags $binfile "$objfiles"] } {
		fail $testname
		set failed 1
	    }
	} else {
	    if { ![ld_simple_link $cc_cmd $binfile "$board_cflags -L$srcdir/$subdir $ldflags $objfiles"] } {
		set failed 1
	    }

	    # Check if exec_output is expected.
	    if { $warnings != "" } then {
		verbose -log "returned with: <$exec_output>, expected: <$warnings>"
		if { [regexp $warnings $exec_output] } then {
		    set failed 0
		} else {
		    set failed 1
		}
	    }

	    if { $failed == 1 } {
		fail $testname
	    }
	}

	if { $failed == 0 } {
	    foreach actionlist $actions {
		set action [lindex $actionlist 0]
		set progopts [lindex $actionlist 1]

		# There are actions where we run regexp_diff on the
		# output, and there are other actions (presumably).
		# Handling of the former look the same.
		set dump_prog ""
		switch -- $action {
		    objdump
		        { set dump_prog $objdump }
		    nm
		        { set dump_prog $nm }
		    readelf
		        { set dump_prog $READELF }
		    default
			{
			    perror "Unrecognized action $action"
			    set is_unresolved 1
			    break
			}
		    }

		if { $dump_prog != "" } {
		    set dumpfile [lindex $actionlist 2]
		    set binary $dump_prog

		    # Ensure consistent sorting of symbols
		    if {[info exists env(LC_ALL)]} {
			set old_lc_all $env(LC_ALL)
		    }
		    set env(LC_ALL) "C"
		    set cmd "$binary $progopts $binfile > dump.out"
		    send_log "$cmd\n"
		    catch "exec $cmd" comp_output
		    if {[info exists old_lc_all]} {
			set env(LC_ALL) $old_lc_all
		    } else {
			unset env(LC_ALL)
		    }
		    set comp_output [prune_warnings $comp_output]

		    if ![string match "" $comp_output] then {
			send_log "$comp_output\n"
			set failed 1
			break
		    }

		    if { [regexp_diff "dump.out" "$srcdir/$subdir/$dumpfile"] } then {
			verbose "output is [file_contents "dump.out"]" 2
			set failed 1
			break
		    }
		}
	    }
	}

	if { $failed != 0 } {
	    fail $testname
	} elseif { $is_unresolved == 0 } {
	    pass $testname
	} else {
	    unresolved $testname
	    continue
	}
    }
}

# Returns true if --gc-sections is supported on the target.

proc check_gc_sections_available { } {
    global gc_sections_available_saved
    global ld

    if {![info exists gc_sections_available_saved]} {
	# Some targets don't support gc-sections despite whatever's
	# advertised by ld's options.
	if {   [istarget arc-*-*]
	    || [istarget d30v-*-*]
	    || [istarget dlx-*-*]
	    || [istarget i960-*-*]
	    || [istarget pj*-*-*]
	    || [istarget alpha-*-*]
	    || [istarget hppa*64-*-*]
	    || [istarget i370-*-*]
	    || [istarget i860-*-*]
	    || [istarget ia64-*-*]
	    || [istarget mep-*-*]
	    || [istarget mn10200-*-*] } {
	    set gc_sections_available_saved 0
	    return 0
	}

	# elf2flt uses -q (--emit-relocs), which is incompatible with
	# --gc-sections.
	if { [board_info target exists ldflags]
	     && [regexp " -elf2flt\[ =\]" " [board_info target ldflags] "] } {
	    set gc_sections_available_saved 0
	    return 0
	}

	# Check if the ld used by gcc supports --gc-sections.
	# FIXME: this test is useless since ld --help always says
	# --gc-sections is available
	set ld_output [remote_exec host $ld "--help"]
	if { [ string first "--gc-sections" $ld_output ] >= 0 } {
	    set gc_sections_available_saved 1
	} else {
	    set gc_sections_available_saved 0
	}
    }
    return $gc_sections_available_saved
}

# Returns true if -shared is supported on the target
# Only used and accurate for ELF targets at the moment

proc check_shared_lib_support { } {
    if {![istarget aarch64*-*-elf]
	 && ![istarget arc-*-*]
	 && ![istarget arm*-*-elf]
	 && ![istarget avr-*-*]
	 && ![istarget cr16-*-*]
	 && ![istarget cris*-*-elf]
	 && ![istarget crx-*-*]
	 && ![istarget d10v-*-*]
	 && ![istarget d30v-*-*]
	 && ![istarget dlx-*-*]
	 && ![istarget epiphany-*-*]
	 && ![istarget fr30-*-*]
	 && ![istarget frv-*-*]
	 && ![istarget h8300-*-*]
	 && ![istarget i860-*-*]
	 && ![istarget i960-*-*]
	 && ![istarget ip2k-*-*]
	 && ![istarget iq2000-*-*]
	 && ![istarget lm32-*-*]
	 && ![istarget m32c-*-*]
	 && ![istarget m32r-*-*]
	 && ![istarget m6811-*-*]
	 && ![istarget m6812-*-*]
	 && ![istarget m68hc1*-*-*]
	 && ![istarget mcore*-*-*]
	 && ![istarget mep-*-*]
	 && ![istarget microblaze-*-*]
	 && ![istarget mips*-*-elf]
	 && ![istarget mn10200-*-*]
	 && ![istarget moxie-*-*]
	 && ![istarget msp430-*-*]
	 && ![istarget mt-*-*]
	 && ![istarget nds32*-*-*]
	 && ![istarget or1k*-*-*]
	 && ![istarget pj-*-*]
	 && ![istarget rl78-*-*]
	 && ![istarget rx-*-*]
	 && ![istarget spu-*-*]
	 && ![istarget v850*-*-*]
	 && ![istarget visium-*-*]
	 && ![istarget xstormy16-*-*]
	 && ![istarget *-*-irix*]
	 && ![istarget *-*-rtems] } {
	return 1
    }
    return 0
}

# Returns true if the target ld supports the plugin API.
proc check_plugin_api_available { } {
    global plugin_api_available_saved
    global ld
    if {![info exists plugin_api_available_saved]} {
	# Check if the ld used by gcc supports --plugin.
	set ld_output [remote_exec host $ld "--help"]
	if { [ string first "-plugin PLUGIN" $ld_output ] >= 0 } {
	    set plugin_api_available_saved 1
	} else {
	    set plugin_api_available_saved 0
	}
    }
    return $plugin_api_available_saved
}

# Sets ld_sysroot to the current sysroot (empty if not supported) and
# returns true if the target ld supports sysroot.
proc check_sysroot_available { } {
    global ld_sysroot_available_saved ld ld_sysroot
    if {![info exists ld_sysroot_available_saved]} {
	# Check if ld supports --sysroot *other* than empty.
	set ld_sysroot [string trimright [lindex [remote_exec host $ld "--print-sysroot"] 1]]
	if { $ld_sysroot == "" } {
	    set ld_sysroot_available_saved 0
	} else {
	    set ld_sysroot_available_saved 1
	}
    }
    return $ld_sysroot_available_saved
}

# Returns true if the target compiler supports LTO
proc check_lto_available { } {
    global lto_available_saved
    global CC

    if {![info exists lto_available_saved]} {
        if { [which $CC] == 0 } {
	    set lto_available_saved 0
	    return 0
	}
	# Check if gcc supports -flto -fuse-linker-plugin
	set flags ""
	if [board_info [target_info name] exists cflags] {
	    append flags " [board_info [target_info name] cflags]"
	}
	if [board_info [target_info name] exists ldflags] {
	    append flags " [board_info [target_info name] ldflags]"
	}

	set basename "tmpdir/lto[pid]"
	set src ${basename}.c
	set output ${basename}.out
	set f [open $src "w"]
	puts $f "int main() { return 0; }"
	close $f
	remote_download host $src
	set lto_available_saved [run_host_cmd_yesno "$CC" "$flags -flto -fuse-linker-plugin $src -o $output"]
	remote_file host delete $src
	remote_file host delete $output
	file delete $src
    }
    return $lto_available_saved
}

# Returns true if the target compiler supports LTO  -ffat-lto-objects
proc check_lto_fat_available { } {
    global lto_fat_available_saved
    global CC

    if {![info exists lto_fat_available_saved]} {
        if { [which $CC] == 0 } {
	    set lto_fat_available_saved 0
	    return 0
	}
	# Check if gcc supports -flto -fuse-linker-plugin
	set flags ""
	if [board_info [target_info name] exists cflags] {
	    append flags " [board_info [target_info name] cflags]"
	}
	if [board_info [target_info name] exists ldflags] {
	    append flags " [board_info [target_info name] ldflags]"
	}

	set basename "tmpdir/lto[pid]"
	set src ${basename}.c
	set output ${basename}.out
	set f [open $src "w"]
	puts $f "int main() { return 0; }"
	close $f
	remote_download host $src
	set lto_fat_available_saved [run_host_cmd_yesno "$CC" "$flags -flto -ffat-lto-objects -fuse-linker-plugin $src -o $output"]
	remote_file host delete $src
	remote_file host delete $output
	file delete $src
    }
    return $lto_fat_available_saved
}

# Returns true if the target compiler supports LTO and -shared
proc check_lto_shared_available { } {
    global lto_shared_available_saved
    global CC

    if {![info exists lto_shared_available_saved]} {
        if { [which $CC] == 0 } {
	    set lto_shared_available_saved 0
	    return 0
	}
	# Check if gcc supports -flto -fuse-linker-plugin -shared
	set flags ""
	if [board_info [target_info name] exists cflags] {
	    append flags " [board_info [target_info name] cflags]"
	}
	if [board_info [target_info name] exists ldflags] {
	    append flags " [board_info [target_info name] ldflags]"
	}

	set basename "tmpdir/lto_shared[pid]"
	set src ${basename}.c
	set output ${basename}.so
	set f [open $src "w"]
	puts $f ""
	close $f
	remote_download host $src
	set lto_shared_available_saved [run_host_cmd_yesno "$CC" "$flags -shared -fPIC -flto -fuse-linker-plugin $src -o $output"]
	remote_file host delete $src
	remote_file host delete $output
	file delete $src
    }
    return $lto_shared_available_saved
}

# Check if the assembler supports CFI statements.

proc check_as_cfi { } {
    global check_as_cfi_result
    global as
    if [info exists check_as_cfi_result] {
	return $check_as_cfi_result
    }
    set as_file "tmpdir/check_as_cfi.s"
    set as_fh [open $as_file w 0666]
    puts $as_fh "# Generated file. DO NOT EDIT"
    puts $as_fh "\t.cfi_startproc"
    puts $as_fh "\t.cfi_endproc"
    close $as_fh
    remote_download host $as_file
    verbose -log "Checking CFI support:"
    rename "perror" "check_as_cfi_perror"
    proc perror { args } { }
    set success [ld_assemble $as $as_file "/dev/null"]
    rename "perror" ""
    rename "check_as_cfi_perror" "perror"
    #remote_file host delete $as_file
    set check_as_cfi_result $success
    return $success
}

# Returns true if IFUNC works.

proc check_ifunc_available { } {
    global ifunc_available_saved
    global CC

    if {![info exists ifunc_available_saved]} {
        if { [which $CC] == 0 } {
	    set ifunc_available_saved 0
	    return 0
	}
	# Check if gcc supports -flto -fuse-linker-plugin
	set flags ""
	if [board_info [target_info name] exists cflags] {
	    append flags " [board_info [target_info name] cflags]"
	}
	if [board_info [target_info name] exists ldflags] {
	    append flags " [board_info [target_info name] ldflags]"
	}

	set basename "tmpdir/ifunc[pid]"
	set src ${basename}.c
	set output ${basename}.out
	set f [open $src "w"]
	puts $f "extern int library_func2 (void);"
	puts $f "int main (void)"
	puts $f "{"
	puts $f "  if (library_func2 () != 2) __builtin_abort ();"
	puts $f "  return 0; "
	puts $f "}"
	puts $f "static int library_func1 (void) {return 2; }"
	puts $f "void *foo (void) __asm__ (\"library_func2\");"
	puts $f "void *foo (void) { return library_func1; }"
	puts $f "__asm__(\".type library_func2, %gnu_indirect_function\");"
	close $f
	remote_download host $src
	set ifunc_available_saved [run_host_cmd_yesno "$CC" "$flags $src -o $output"]
	if { $ifunc_available_saved == 1 } {
	  set ifunc_available_saved [run_host_cmd_yesno "$output" ""]
	}
	remote_file host delete $src
	remote_file host delete $output
	file delete $src
    }
    return $ifunc_available_saved
}

# Returns true if ifunc attribute works.

proc check_ifunc_attribute_available { } {
    global ifunc_attribute_available_saved
    global CC

    if {![info exists ifunc_attribute_available_saved]} {
        if { [which $CC] == 0 } {
	    set ifunc_attribute_available_saved 0
	    return 0
	}
	# Check if gcc supports -flto -fuse-linker-plugin
	set flags ""
	if [board_info [target_info name] exists cflags] {
	    append flags " [board_info [target_info name] cflags]"
	}
	if [board_info [target_info name] exists ldflags] {
	    append flags " [board_info [target_info name] ldflags]"
	}

	set basename "tmpdir/ifunc[pid]"
	set src ${basename}.c
	set output ${basename}.out
	set f [open $src "w"]
	puts $f "extern int library_func2 (void) __attribute__ ((ifunc (\"foo\")));"
	puts $f "int main (void)"
	puts $f "{"
	puts $f "  if (library_func2 () != 2) __builtin_abort ();"
	puts $f "  return 0; "
	puts $f "}"
	puts $f "static int library_func1 (void) {return 2; }"
	puts $f "void *foo (void) { return library_func1; }"
	close $f
	remote_download host $src
	set ifunc_attribute_available_saved [run_host_cmd_yesno "$CC" "$flags $src -o $output"]
	if { $ifunc_attribute_available_saved == 1 } {
	  set ifunc_attribute_available_saved [run_host_cmd_yesno "$output" ""]
	}
	remote_file host delete $src
	remote_file host delete $output
	file delete $src
    }
    return $ifunc_attribute_available_saved
}

# Provide virtual target "cfi" for targets supporting CFI.

rename "istarget" "istarget_ld"
proc istarget { target } {
    if {$target == "cfi"} {
	return [check_as_cfi]
    }
    return [istarget_ld $target]
}
