#   Copyright (C) 1994-2015 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.

# Please email any bugs, comments, and/or additions to this file to:
# bug-dejagnu@prep.ai.mit.edu

# Written by Ian Lance Taylor <ian@cygnus.com>

if ![is_remote host] {
    if {[which $OBJCOPY] == 0} then {
        perror "$OBJCOPY does not exist"
        return
    }
}

send_user "Version [binutil_version $OBJCOPY]"

if ![is_remote host] {
    set tempfile tmpdir/bintest.o
    set copyfile tmpdir/copy
} else {
    set tempfile [remote_download host tmpdir/bintest.o]
    set copyfile copy
}

# Test that objcopy does not modify a file when copying it.

proc objcopy_test {testname srcfile} {
    global OBJCOPY
    global OBJCOPYFLAGS
    global srcdir
    global subdir
    global tempfile
    global copyfile

    if {![binutils_assemble $srcdir/$subdir/${srcfile} tmpdir/bintest.o]} then {
 	perror "unresolved $testname"
	unresolved "objcopy ($testname)"
	return
    }

    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS $tempfile ${copyfile}.o"]

    if ![string equal "" $got] then {
	fail "objcopy ($testname)"
    } else {
	send_log "cmp $tempfile ${copyfile}.o\n"
	verbose "cmp $tempfile ${copyfile}.o"
	if [is_remote host] {
	    set src1 tmpdir/bintest.o
	    set src2 tmpdir/copy.o
	    remote_upload host $tempfile $src1
	    remote_upload host ${copyfile}.o $src2
	} else {
	    set src1 ${tempfile}
	    set src2 ${copyfile}.o
	}
	set status [remote_exec build cmp "${src1} ${src2}"]
	set exec_output [lindex $status 1]
	set exec_output [prune_warnings $exec_output]

	# On some systems the result of objcopy will not be identical.
	# Usually this is just because gas isn't using bfd to write the
	# files in the first place, and may order things a little
	# differently. Those systems should use setup_xfail here.

	setup_xfail "h8300-*-coff"
	setup_xfail "h8500-*-rtems*" "h8500-*-coff"
	setup_xfail "hppa*-*-*"
	setup_xfail "i960-*"
	setup_xfail "m68*-*-*coff" "m68*-*-hpux*" "m68*-*-lynxos*"
	setup_xfail "m68*-*-sysv*" "m68*-apple-aux*"
	setup_xfail "m8*-*"
	setup_xfail "sh-*-coff*"
	setup_xfail "tic80-*-*" "w65-*"

	clear_xfail "hppa*64*-*-hpux*" "hppa*-*-linux*" "hppa*-*-lites*"
	clear_xfail "hppa*-*-*n*bsd*" "hppa*-*-rtems*" "*-*-*elf*"
	clear_xfail "m68*-*-sysv4*"

	if [string equal "" $exec_output] then {
	    pass "objcopy ($testname)"
	} else {
	    send_log "$exec_output\n"
	    verbose "$exec_output" 1

	    # On OSF/1, this succeeds with gas and fails with /bin/as.
	    setup_xfail "alpha*-*-osf*"

	    fail "objcopy ($testname)"
	}
    }
}

objcopy_test "simple copy" bintest.s

# Test reversing bytes in a section.

set reversed ${tempfile}-reversed
set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -j .data --reverse-bytes=4 $tempfile $reversed"]

if ![string equal "" $got] then {
    fail "objcopy --reverse-bytes"
} else {
    if [is_remote host] {
        remote_upload host ${reversed} tmpdir/copy-reversed.o
        set reversed tmpdir/copy-reversed.o
    }

    set origdata [binutils_run $OBJDUMP "$OBJDUMPFLAGS -s -j .data $tempfile"]
    set revdata [binutils_run $OBJDUMP "$OBJDUMPFLAGS -s -j .data $reversed"]

    set want "^ \[0-9\]+ (\[0-9\]+)"
    set found_orig [regexp -lineanchor $want $origdata -> origdata]
    set found_rev [regexp -lineanchor $want $revdata -> revdata]

    if {$found_orig == 0 || $found_rev == 0} then {
	# som doesn't have a .data section
	setup_xfail "hppa*-*-hpux*"
	clear_xfail "hppa*64*-*-hpux*"

        fail "objcopy --reverse-bytes"
    } else {
        scan $origdata "%2x%2x%2x%2x" b1 b2 b3 b4
        scan $revdata "%2x%2x%2x%2x" c4 c3 c2 c1

        if {$b1 == $c1 && $b2 == $c2 && $b3 == $c3 && $b4 == $c4} then {
            pass "objcopy --reverse-bytes"
        } else {
            fail "objcopy --reverse-bytes"
        }
    }
}

# Test interleaved copy of multiple byte width

set sequence_file sequence_file
set file [open ${sequence_file} w]
puts ${file} "12345678"
close ${file}

if [is_remote host] {
    remote_upload host ${sequence_file} tmpdir/sequence_file
    set sequence_file tmpdir/sequence_file
}

set got [binutils_run $OBJCOPY "-I binary -i 4 -b 0 --interleave-width 2 ${sequence_file} ${copyfile}"]

if ![string equal "" $got] then {
    fail "objcopy -i --interleave-width"
} else {
    if [is_remote host] {
	remote_upload host ${copyfile} tmpdir/interleave_output
	set interleave_output tmpdir/interleave_output
    } else {
	set interleave_output ${copyfile}
    }

    set file [open ${interleave_output} r]
    gets $file line
    send_log "$line\n"
    verbose $line

    if ![string equal "1256" $line] then {
	fail "objcopy -i --interleave-width"
    }
    pass "objcopy -i --interleave-width"

    close $file
}

# Test generating S records.

# We make the srec filename 8.3 compatible. Note that the header string
# matched against depends on the name of the file. Ugh.

if [is_remote host] {
    set srecfile copy.sre
    set header_string S00B0000636F70792E737265C1
} else {
    set srecfile ${copyfile}.srec
    set header_string S0130000746D706469722F636F70792E7372656397
}

set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -O srec $tempfile ${srecfile}"]

if ![string equal "" $got] then {
    fail "objcopy -O srec"
} else {
    if [is_remote host] {
	remote_upload host ${srecfile} tmpdir/copy.srec
	set srecfile tmpdir/copy.srec
    }
    set file [open ${srecfile} r]

    # The first S record is fixed by the file name we are using.
    gets $file line
    send_log "$line\n"
    verbose $line
    if ![regexp "$header_string.*" $line] {
	send_log "bad header\n"
	fail "objcopy -O srec"
    } else {
	while {[gets $file line] != -1 \
	       && [regexp "^S\[123\]\[0-9a-fA-F\]+\[\r\n\]*$" $line]} {
	    send_log "$line\n"
	    verbose $line
	    set line "**EOF**"
	}
	send_log "$line\n"
	verbose $line
	if ![regexp "^S\[789\]\[0-9a-fA-F\]+\[\r\n\]*$" $line] then {
	    send_log "bad trailer\n"
	    fail "objcopy -O srec"
	} else {
	    if {[gets $file line] != -1} then {
		send_log "garbage at end\n"
		send_log "$line\n"
		verbose $line
		fail "objcopy -O srec"
	    } else {
		set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -f ${srecfile}"]
		if ![regexp "file format srec" $got] then {
		    send_log "objdump failed\n"
		    fail "objcopy -O srec"
		} else {
		    pass "objcopy -O srec"
		}
	    }
	}
    }

    close $file
}

# Test setting and adjusting the start address.  We only test this
# while generating S records, because we may not be able to set the
# start address for other object file formats, and the S record case
# is the only useful one anyhow.

set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -f $tempfile"]
if ![regexp "start address (\[0-9a-fA-FxX\]+)" $got all origstart] then {
    perror "objdump can not recognize bintest.o"
    set origstart ""
} else {
    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -O srec --set-start 0x7654 $tempfile ${copyfile}.srec"]
    if ![string equal "" $got] then {
	fail "objcopy --set-start"
    } else {
	set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -f ${copyfile}.srec"]
	if ![regexp "file format srec.*start address (\[0-9a-fA-FxX\]+)" $got all srecstart] then {
	    fail "objcopy --set-start"
	} else {
	    if {$srecstart != 0x7654} then {
		send_log "$srecstart != 0x7654\n"
		fail "objcopy --set-start"
	    } else {
		pass "objcopy --set-start"
	    }
	}
    }

    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -O srec --adjust-start 0x123 $tempfile ${copyfile}.srec"]
    if ![string equal "" $got] then {
	fail "objcopy --adjust-start"
    } else {
	set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -f ${copyfile}.srec"]
	if ![regexp "file format srec.*start address (\[0-9a-fA-FxX\]+)" $got all srecstart] then {
	    fail "objcopy --adjust-start"
	} else {
	    if {$srecstart != $origstart + 0x123} then {
		send_log "$srecstart != $origstart + 0x123\n"
		fail "objcopy --adjust-start"
	    } else {
		pass "objcopy --adjust-start"
	    }
	}
    }
}

# Test adjusting the overall VMA, and adjusting the VMA of a
# particular section.  We again only test this when generating S
# records.

set low ""
set lowname ""

set headers [binutils_run $OBJDUMP "$OBJDUMPFLAGS -h $tempfile"]

set headers_regexp "\[ 	0-9\]+(\[^ 	\]+)\[ 	\]*(\[0-9a-fA-F\]+)\[ 	\]+\[0-9a-fA-F\]+\[ 	\]+(\[0-9a-fA-F\]+)\[ 	\]+\[0-9a-fA-F\]+\[ 	\]+2\[*\]\[*\]\[0-9\]+(.*)"

set got $headers
while {[regexp $headers_regexp $got all name size vma rest]} {
    set vma 0x$vma
    set size 0x$size
    if {$size != 0} {
	if {$low == "" || $vma < $low} {
            set low $vma
	    set lowname $name
	}
    }
    set got $rest
}

if {$low == "" || $origstart == ""} then {
    perror "objdump can not recognize bintest.o"
} else {
    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -O srec --adjust-vma 0x123 $tempfile ${copyfile}.srec"]
    if ![string equal "" $got] then {
        fail "objcopy --adjust-vma"
    } else {
	set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -fh ${copyfile}.srec"]
	set want "file format srec.*start address\[ 	\]*(\[0-9a-fA-FxX\]+).*sec1\[ 	\]+\[0-9a-fA-F\]+\[ 	\]+(\[0-9a-fA-F\]+)"
	if ![regexp $want $got all start vma] then {
	    fail "objcopy --adjust-vma"
	} else {
	    set vma 0x$vma
	    if {$vma != $low + 0x123} then {
		send_log "$vma != $low + 0x123\n"
		fail "objcopy --adjust-vma"
	    } else {
		if {$start != $origstart + 0x123} then {
		    send_log "$start != $origstart + 0x123\n"
		    fail "objcopy --adjust-vma"
		} else {
		    pass "objcopy --adjust-vma"
		}
	    }
	}
    }

    set arg ""
    set got $headers
    while {[regexp $headers_regexp $got all name size vma rest]} {
	set vma 0x$vma
	if {$vma == $low} then {
	    set arg "$arg --adjust-section-vma $name+4"
	}
	set got $rest
    }

    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -O srec $arg $tempfile ${copyfile}.srec"]
    if ![string equal "" $got] then {
	fail "objcopy --adjust-section-vma +"
    } else {
	set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -h ${copyfile}.srec"]
	set want "file format srec.*sec1\[ 	\]+\[0-9a-fA-F\]+\[ 	\]+(\[0-9a-fA-F\]+)"
	if ![regexp $want $got all vma] then {
	    fail "objcopy --adjust-section-vma +"
	} else {
	    set vma 0x$vma
	    if {$vma != $low + 4} then {
		send_log "$vma != $low + 4\n"
		fail "objcopy --adjust-section-vma +"
	    } else {
		pass "objcopy --adjust-section-vma +"
	    }
	}
    }

    regsub -all "\\+4" $arg "=[expr $low + 4]" argeq
    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS -O srec $argeq $tempfile ${copyfile}.srec"]
    if ![string equal "" $got] then {
	fail "objcopy --adjust-section-vma ="
    } else {
	set got [binutils_run $OBJDUMP "$OBJDUMPFLAGS -h ${copyfile}.srec"]
	set want "file format srec.*sec1\[ 	\]+\[0-9a-fA-F\]+\[ 	\]+(\[0-9a-fA-F\]+)"
	if ![regexp $want $got all vma] then {
	    fail "objcopy --adjust-section-vma ="
	} else {
	    set vma 0x$vma
	    if {$vma != $low + 4} then {
		send_log "$vma != $low + 4\n"
		fail "objcopy --adjust-section-vma ="
	    } else {
		pass "objcopy --adjust-section-vma ="
	    }
	}
    }
}

# Test stripping an object.

proc strip_test { } {
    global AR
    global CC
    global STRIP
    global STRIPFLAGS
    global NM
    global NMFLAGS
    global srcdir
    global subdir
    global READELF

    set test "strip"

    if { [target_compile $srcdir/$subdir/testprog.c tmpdir/testprog.o object debug] != "" } {
	untested $test
	return
    }

    set osabi_fail "false"
    if [is_elf_format] {
	verbose -log "$READELF -a tmpdir/testprog.o > tmpdir/osabi.in"
	set exec_output [remote_exec host "$READELF -h tmpdir/testprog.o" "" "/dev/null" "tmpdir/osabi.in"]
	if { [lindex $exec_output 0] != 0 } then {
	    unresolved "$test preserving OS/ABI"
	    set osabi_fail "true"
	} else {
	    verbose -log "grep OS/ABI tmpdir/osabi.in"
	    catch "exec grep OS/ABI tmpdir/osabi.in" osabi_in
	}
    }

    if [is_remote host] {
	set archive libstrip.a
	set objfile [remote_download host tmpdir/testprog.o]
	remote_file host delete $archive
    } else {
	set archive tmpdir/libstrip.a
	set objfile tmpdir/testprog.o
    }

    remote_file build delete tmpdir/libstrip.a

    set exec_output [binutils_run $AR "rc $archive ${objfile}"]
    if ![string equal "" $exec_output] {
	fail $test
	unresolved "$test preserving OS/ABI"
	return
    }

    set exec_output [binutils_run $STRIP "-g $archive"]
    if ![string equal "" $exec_output] {
	fail $test
	unresolved "$test preserving OS/ABI"
	return
    }

    set exec_output [binutils_run $STRIP "$STRIPFLAGS $archive"]
    if ![string equal "" $exec_output] {
	fail $test
	unresolved "$test preserving OS/ABI"
	return
    }

    if { $osabi_fail != "true" && [is_elf_format] } {
	verbose -log "$READELF -a tmpdir/testprog.o > tmpdir/osabi.out"
	set exec_output [remote_exec host "$READELF -h tmpdir/testprog.o" "" "/dev/null" "tmpdir/osabi.out"]
	if { [lindex $exec_output 0] != 0 } then {
	    unresolved "$test preserving OS/ABI"
	} else {
	    verbose -log "grep OS/ABI tmpdir/osabi.out"
	    catch "exec grep OS/ABI tmpdir/osabi.out" osabi_out
	    if { "$osabi_in" == "$osabi_out" } {
		pass "$test preserving OS/ABI"
	    } else {
		fail "$test preserving OS/ABI"
	    }
	}
    }

    if { [target_compile $srcdir/$subdir/testprog.c tmpdir/testprog.o object debug] != "" } {
	untested $test
	return
    }

    if [is_remote host] {
	set objfile [remote_download host tmpdir/testprog.o]
    } else {
	set objfile tmpdir/testprog.o
    }

    set exec_output [binutils_run $STRIP "$STRIPFLAGS $objfile"]
    if ![string equal "" $exec_output] {
	fail $test
	return
    }

    set exec_output [binutils_run $NM "-a $NMFLAGS $objfile"]
    if ![string match "*: no symbols*" $exec_output] {
	fail $test
	return
    }

    pass $test
}

strip_test

# Test stripping an object file with saving a symbol

proc strip_test_with_saving_a_symbol { } {
    global CC
    global STRIP
    global STRIPFLAGS
    global NM
    global NMFLAGS
    global srcdir
    global subdir

    set test "strip with saving a symbol"

    if { [target_compile $srcdir/$subdir/testprog.c tmpdir/testprog.o object debug] != "" } {
	untested $test
	return
    }

    if [is_remote host] {
	set objfile [remote_download host tmpdir/testprog.o]
    } else {
	set objfile tmpdir/testprog.o
    }

    set exec_output [binutils_run $STRIP "$STRIPFLAGS -K main -K _main $objfile"]
    if ![string equal "" $exec_output] {
	fail $test
	return
    }

    set exec_output [binutils_run $NM "$NMFLAGS $objfile"]
    if {![regexp {^([0-9a-fA-F]+)?[ ]+[TD] main} $exec_output] \
         && ![regexp {^([0-9a-fA-F]+)?[ ]+T _main} $exec_output]} {
	fail $test
	return
    }

    pass $test
}

strip_test_with_saving_a_symbol

# Build a final executable.

if { [istarget *-*-cygwin] || [istarget *-*-mingw*] } {
    set test_prog "testprog.exe"
} else {
    set test_prog "testprog"
}

proc copy_setup { } {
    global srcdir
    global subdir
    global gcc_gas_flag
    global test_prog
    global host_triplet

    set res [build_wrapper testglue.o]
    set flags { debug }

    if { [istarget *-*-uclinux*] && ![istarget tic6x-*-*] } {
	return 1
    }

    if { $res != "" } {
	lappend flags "additional_flags=[lindex $res 1]"
	set add_libs "testglue.o"
    } else {
	set add_libs ""
    }

    if { [istarget *-*-linux*]
	 || [istarget *-*-gnu*] } {
	foreach i $gcc_gas_flag {
	    set flags "additional_flags=$i $flags"
	}
    }
    if { [target_compile "$srcdir/$subdir/testprog.c $add_libs" tmpdir/$test_prog executable $flags]  != "" } {
	return 2
    }

    set result [remote_load target tmpdir/$test_prog]
    set status [lindex $result 0]

    if { $status != "pass"  } {
	send_log "cannot run executable, status = ${status} on ${host_triplet}\n"
	return 3
    }

    return 0
}

# Test copying an executable.

proc copy_executable { prog flags test1 test2 } {
    global test_prog

    if [is_remote host] {
	set testfile [remote_download host tmpdir/$test_prog]
	set testcopy copyprog
    } else {
	set testfile tmpdir/$test_prog
	set testcopy tmpdir/copyprog
    }
    remote_file host delete $testcopy

    set exec_output [binutils_run $prog "$flags $testfile $testcopy"]

    if ![string equal "" $exec_output] {
	fail $test1
	if [string equal "" $test2] {
	    return
	}
	fail $test2
	return
    }

    if [is_remote host] {
	remote_upload host $testcopy tmpdir/copyprog
    }

    set status [remote_exec build "cmp" "tmpdir/$test_prog tmpdir/copyprog"]
    set exec_output [lindex $status 1]

    if [string equal "" $exec_output] then {
	pass $test1
    } else {
	send_log "$exec_output\n"
	verbose "$exec_output"

	# This will fail for many reasons.  For example, it will most
	# likely fail if a non-GNU linker is used.  Therefore, we do
	# not insist that it pass.  If you are using an assembler and
	# linker based on the same BFD as objcopy, it is worth
	# investigating to see why this failure occurs.  If we are
	# cross compiling, we assume that a GNU linker is being used,
	# and expect it to succeed.
	if {[isnative]} then {
	    setup_xfail "*-*-*"
	}

	# This also fails for mips*-*-elf targets.  See elf32-mips.c
	# mips_elf_sym_is_global.
	setup_xfail "mips*-*-elf"

	setup_xfail "arm*-*-coff"
	setup_xfail "arm*-*-pe"
	setup_xfail "*-*-mingw*"
	setup_xfail "*-*-cygwin*"

	fail $test1
    }

    if [string equal "" $test2] {
	return
    }

    set output [remote_load target tmpdir/copyprog]
    set status [lindex $output 0]
    if { $status != "pass" } {
	fail $test2
    } else {
	pass $test2
    }
}

# Test stripping an executable

proc strip_executable { prog flags test1 test2 } {
    global NM
    global NMFLAGS
    global READELF

    remote_file build delete tmpdir/striprog
    remote_download build tmpdir/copyprog tmpdir/striprog
    if [is_remote host] {
	set copyfile [remote_download host tmpdir/striprog]
    } else {
	set copyfile tmpdir/striprog
    }

    set osabi_fail "false"
    if [is_elf_format] {
	verbose -log "$READELF -a ${copyfile} > tmpdir/osabi.in"
	set exec_output [remote_exec host "$READELF -h ${copyfile}" "" "/dev/null" "tmpdir/osabi.in"]
	if { [lindex $exec_output 0] != 0 } then {
	    unresolved "$test1 preserving OS/ABI"
	    set osabi_fail "true"
	} else {
	    verbose -log "grep OS/ABI tmpdir/osabi.in"
	    catch "exec grep OS/ABI tmpdir/osabi.in" osabi_in
	}
     }

    set exec_output [binutils_run $prog "$flags ${copyfile}"]
    if ![string equal "" $exec_output] {
	fail $test1
	if [string equal "" $test2] {
	    return
	}
	fail $test2
	return
    }

    if [is_remote host] {
	remote_upload host ${copyfile} tmpdir/striprog
    }

    if { $osabi_fail != "true" && [is_elf_format] } {
	verbose -log "$READELF -a ${copyfile} > tmpdir/osabi.out"
	set exec_output [remote_exec host "$READELF -h ${copyfile}" "" "/dev/null" "tmpdir/osabi.out"]
	if { [lindex $exec_output 0] != 0 } then {
	    unresolved "$test1 preserving OS/ABI"
	} else {
	    verbose -log "grep OS/ABI tmpdir/osabi.out"
	    catch "exec grep OS/ABI tmpdir/osabi.out" osabi_out
	    if { "$osabi_in" == "$osabi_out" } {
		pass "$test1 preserving OS/ABI"
	    } else {
		fail "$test1 preserving OS/ABI"
	    }
	}
    }

    set exec_output [binutils_run $NM "$NMFLAGS ${copyfile}"]
    if ![string match "*: no symbols*" $exec_output] {
	fail $test1
	return
    }

    if [string equal "" $test2] {
	return
    }

    set result [remote_load target tmpdir/striprog]
    set status [lindex $result 0]
    if { $status != "pass" } {
	fail $test2
        return
    }

    pass $test2
}

# Test stripping an executable with saving a symbol

proc strip_executable_with_saving_a_symbol { prog flags test1 test2 } {
    global NM
    global NMFLAGS

    remote_file build delete tmpdir/striprog
    remote_download build tmpdir/copyprog tmpdir/striprog
    if [is_remote host] {
	set copyfile [remote_download host tmpdir/striprog]
    } else {
	set copyfile tmpdir/striprog
    }

    set exec_output [binutils_run $prog "$flags ${copyfile}"]
    if ![string equal "" $exec_output] {
	fail $test1
	if [string equal "" $test2] {
	    return
	}
	fail $test2
	return
    }

    set exec_output [binutils_run $NM "$NMFLAGS ${copyfile}"]
    if { [istarget mmix-knuth-mmixware] } {
	# Whenever there's a symbol in the mmo format, there's the symbol
	# Main, so remove it manually from the expected output for sake of
	# this test.

	# Using "" not {} to get the \n and \r translated.
	regsub "^\[0-9a-fA-F\]+\[ \]+T Main\[\n\r\]+" $exec_output "" exec_output
    }

    if {![regexp {^([0-9a-fA-F]+)?[ ]+[TD] main} $exec_output] \
         && ![regexp {^([0-9a-fA-F]+)?[ ]+[TD] _main} $exec_output]} {
	fail $test1
	return
    }

    if [string equal "" $test2] {
	return
    }

    if [is_remote host] {
	remote_upload host ${copyfile} tmpdir/striprog
    }

    set result [remote_load target tmpdir/striprog]
    set status [lindex $result 0]
    if { $status != "pass" } {
	fail $test2
        return
    }

    pass $test2
}

# Test keeping only debug symbols of an executable

proc keep_debug_symbols_and_test_copy { prog1 flags1 test1 prog2 flags2 test2 } {
    remote_file build delete tmpdir/striprog
    remote_download build tmpdir/copyprog tmpdir/striprog
    if [is_remote host] {
	set copyfile [remote_download host tmpdir/striprog]
    } else {
	set copyfile tmpdir/striprog
    }

    set exec_output [binutils_run $prog1 "$flags1 ${copyfile}"]
    if ![string equal "" $exec_output] {
	fail $test1
	return
    }
    pass $test1

    set exec_output [binutils_run $prog2 "$flags2 ${copyfile}"]
    if ![string equal "" $exec_output] {
	fail $test2
	return
    }
    pass $test2
}

# Tests that in a debug only copy of a file the sections
# headers whoes types have been changed to NOBITS still
# retain their sh_link fields.

proc keep_debug_symbols_and_check_links { prog flags test } {
    global READELF

    remote_file build delete tmpdir/striprog
    remote_download build tmpdir/copyprog tmpdir/striprog
    if [is_remote host] {
	set copyfile [remote_download host tmpdir/striprog]
    } else {
	set copyfile tmpdir/striprog
    }

    set exec_output [binutils_run $prog "$flags ${copyfile}"]
    if ![string equal "" $exec_output] {
	fail $test
	return
    }

    set got [binutils_run $READELF "-S --wide ${copyfile}"]

    set fails 0
    # Regexp to match a section with NOBITS type and extract its name and sh_link fields
    while {[regexp \
		{[^a-zA-Z]+([a-zA-Z0-9_\.]+)[ 	]+NOBITS[ 	]+[0-9a-fA-F]+ [0-9a-fA-F]+ [0-9a-fA-F]+ [0-9]+[ A]+([0-9]+)(.*)} \
		$got all name link rest]} {
	set sh_link 0x$link
	if {$sh_link == 0} {
	    # Only some NOBITS sections should have a non-zero sh_link field.
	    # Look for them by name.
	    verbose "NOBITS section .$name has a 0 sh_link field\n"
	    switch $name {
		"rela.*"	{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"rel.*"		{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"hash"		{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"gnu_version"	{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"dynsym"	{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"gnu.version_r"	{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"dynamic"	{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
		"symtab"	{ set fails 1 ; send_log "Expected non-zero sh_link for .$name\n" }
	    }
	}
	set got $rest
    }

    if {$fails == 0} {
	pass $test
    } else {
	fail $test
    }
}


set test1 "simple objcopy of executable"
set test1r "run objcopy of executable"
set test2 "strip executable"
set test2r "run stripped executable"
set test3 "strip executable with saving a symbol"
set test3r "run stripped executable with saving a symbol"
set test4 "keep only debug data"
set test5 "simple objcopy of debug data"
if [is_elf_format] {
    set test6 "NOBITS sections retain sh_link field"
}

switch [copy_setup] {
    "1" {
	# do nothing
    }
    "2" {
	untested $test1
	untested $test1r
	untested $test2
	untested $test2r
	untested $test3
	untested $test3r
	untested $test4
	untested $test5
	if [is_elf_format] {
	    untested $test6
	}
    }
    "3" {
	copy_executable "$OBJCOPY" "$OBJCOPYFLAGS" "$test1" ""
	unsupported $test1r
	strip_executable "$STRIP" "$STRIPFLAGS" "$test2" ""
	unsupported $test2r
	strip_executable_with_saving_a_symbol "$STRIP" "-K main -K _main $STRIPFLAGS" "$test3" ""
	unsupported $test3r
	keep_debug_symbols_and_test_copy "$STRIP" "--only-keep-debug $STRIPFLAGS" "$test4" \
					 "$OBJCOPY" "$OBJCOPYFLAGS" "$test5"
	if [is_elf_format] {
	    keep_debug_symbols_and_check_links "$STRIP" "--only-keep-debug $STRIPFLAGS" "$test6"
	}
    }
    "0" {
	copy_executable "$OBJCOPY" "$OBJCOPYFLAGS" "$test1" "$test1r"
	strip_executable "$STRIP" "$STRIPFLAGS" "$test2" "$test2r"
	strip_executable_with_saving_a_symbol "$STRIP" "-K main -K _main $STRIPFLAGS" "$test3" "$test3r"
	keep_debug_symbols_and_test_copy "$STRIP" "--only-keep-debug $STRIPFLAGS" "$test4" \
					 "$OBJCOPY" "$OBJCOPYFLAGS" "$test5"
	if [is_elf_format] {
	    keep_debug_symbols_and_check_links "$STRIP" "--only-keep-debug $STRIPFLAGS" "$test6"
	}
    }
}

proc objcopy_test_readelf {testname srcfile} {
    global OBJCOPY
    global OBJCOPYFLAGS
    global READELF
    global srcdir
    global subdir

    if {![binutils_assemble $srcdir/$subdir/${srcfile} tmpdir/bintest.o]} then {
	unresolved "objcopy ($testname)"
	return
    }

    verbose -log "$OBJCOPY $OBJCOPYFLAGS tmpdir/bintest.o tmpdir/copy.o"
    set exec_output [remote_exec host "$OBJCOPY $OBJCOPYFLAGS tmpdir/bintest.o tmpdir/copy.o"]
    if { [lindex $exec_output 0] != 0
	 || ![string equal "" [lindex $exec_output 1]] } then {
	fail "objcopy ($testname)"
	return
    }

    verbose -log "$READELF -a tmpdir/bintest.o > tmpdir/bintest.o.out"
    set exec_output [remote_exec host "$READELF -a tmpdir/bintest.o" "" "/dev/null" "tmpdir/bintest.o.out"]
    if { [lindex $exec_output 0] != 0 } then {
	unresolved "objcopy ($testname)"
	return
    }
    set exec_output [prune_warnings [lindex $exec_output 1]]
    if ![string equal "" $exec_output] then {
	unresolved "objcopy ($testname)"
	return
    }

    verbose -log "$READELF -a tmpdir/copy.o > tmpdir/copy.o.out"
    set exec_output [remote_exec host "$READELF -a tmpdir/copy.o" "" "/dev/null" "tmpdir/copy.o.out"]
    if { [lindex $exec_output 0] != 0 } then {
	unresolved "objcopy ($testname)"
	return
    }
    set exec_output [prune_warnings [lindex $exec_output 1]]
    if ![string equal "" $exec_output] then {
	unresolved "objcopy ($testname)"
	return
    }

    verbose -log "diff tmpdir/bintest.o.out tmpdir/copy.o.out"
    catch "exec diff tmpdir/bintest.o.out tmpdir/copy.o.out" exec_output
    set exec_output [prune_warnings $exec_output]

    if [string equal "" $exec_output] then {
	pass "objcopy ($testname)"
    } else {
	fail "objcopy ($testname)"
    }
}

proc objcopy_test_symbol_manipulation {} {
    global srcdir
    global subdir

    set test_list [lsort [glob -nocomplain $srcdir/$subdir/symbols-*.d]]
    foreach t $test_list {
        # We need to strip the ".d", but can leave the dirname.
        verbose [file rootname $t]
        run_dump_test [file rootname $t]
    }
}

# ia64 specific tests
if { ([istarget "ia64-*-elf*"]
       || [istarget "ia64-*-linux*"]) } {
    objcopy_test "ia64 link order" link-order.s
}

# ELF specific tests
if [is_elf_format] {
    objcopy_test_symbol_manipulation
    objcopy_test "ELF unknown section type" unknown.s
    objcopy_test_readelf "ELF group" group.s
    objcopy_test_readelf "ELF group" group-2.s
    objcopy_test_readelf "ELF group" group-3.s
    objcopy_test_readelf "ELF group" group-4.s
    run_dump_test "group-5"
    run_dump_test "group-6"
    run_dump_test "copy-1"
    run_dump_test "note-1"
}

run_dump_test "copy-2"
run_dump_test "copy-3"
run_dump_test "copy-4"
run_dump_test "pr19020a"
run_dump_test "pr19020b"

if [is_elf_format] {
    run_dump_test "strip-1"
    run_dump_test "strip-2"
    run_dump_test "strip-3"
    run_dump_test "strip-4"
    run_dump_test "strip-5"
    run_dump_test "strip-6"
    run_dump_test "strip-7"
    run_dump_test "strip-8"
    run_dump_test "strip-9"
    run_dump_test "strip-12"
    # Non-EABI ARM targets will set OSABI to ARM
    # The V850 sets the OSABI to UNIX - System V
    if { ![istarget "*-*-hpux*"]
	 && ![istarget "msp*-*-*"]
	 && ![istarget "visium-*-*"]
	 && ![istarget "v850*-*-*"]
         && !([istarget "arm*-*-*"] && ![istarget "arm-*-*eabi*"])} {
	run_dump_test "strip-10"
    }
    set extra_strip11 ""
    if { [istarget "sh64*-*"] } {
	# pr17755 testcase
	set extra_strip11 { { "as" "--isa=SHmedia --abi=64" } }
    }
    run_dump_test "strip-11" $extra_strip11

    if { [istarget "i*86-*"] || [istarget "x86_64-*-*"] } {
	# Check to make sure we don't strip a symbol named in relocations.
	set test "objcopy keeps symbols needed by relocs"

	set srcfile $srcdir/$subdir/needed-by-reloc.s

	if {![binutils_assemble $srcfile tmpdir/bintest.o]} then {
	    unresolved $test
	} else {
	    set got [binutils_run $OBJCOPY "$OBJCOPYFLAGS --strip-symbol=foo tmpdir/bintest.o ${copyfile}.o"]

	    if [regexp "not stripping symbol `foo' because it is named in a relocation" $got] {
		pass $test
	    } else {
		fail $test
	    }
	}
    }

    # The symbol table for some MIPS targets is sorted differently than
    # the ELF canonical order, so the regexps in localize-hidden-1.d fail
    # to match.  These tests must be matched to targets for which
    # targ_defvec=mips_elf32_be_vec,
    # targ_defvec=mips_elf32_le_vec,
    # targ_defvec=mips_elf32_n_be_vec or
    # targ_defvec=mips_elf32_n_le_vec in config.bfd.  When syncing,
    # don't forget that earlier case-matches trump later ones.
    if { ![istarget "mips*-sde-elf*"] && ![istarget "mips*-mti-elf*"]
	 && ![istarget "mips*-img-elf*"]
         && ![istarget "mips64*-*-openbsd*"] } {
	setup_xfail "mips*-*-irix5*" "mips*-*-irix6*" "mips*-*-elf*" \
	    "mips*-*-rtems*" "mips*-*-windiss" "mips*-*-none" \
	    "mips*-*-openbsd*" "mips*-*-chorus*"
    }
    run_dump_test "localize-hidden-1"
    run_dump_test "testranges"
    run_dump_test "testranges-ia64"

    run_dump_test "add-section"
    run_dump_test "add-symbol"
    run_dump_test "add-empty-section"

    run_dump_test "exclude-1a"
    run_dump_test "exclude-1b"
}
run_dump_test "localize-hidden-2"
