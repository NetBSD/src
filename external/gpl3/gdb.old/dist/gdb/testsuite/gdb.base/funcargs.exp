# Copyright 1992-2016 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This file was written by Fred Fish. (fnf@cygnus.com)


standard_testfile

set compile_flags {debug nowarnings quiet}
if [support_complex_tests] {
    lappend compile_flags "additional_flags=-DTEST_COMPLEX"
}

# Create and source the file that provides information about the compiler
# used to compile the test case.
if [get_compiler_info] {
    return -1
}

if {[prepare_for_testing $testfile.exp $testfile $srcfile $compile_flags]} {
    untested $testfile.exp
    return -1
}

#
# Locate actual args; integral types.
#

proc integral_args {} {
    global gdb_prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call0a
    gdb_breakpoint call0b
    gdb_breakpoint call0c
    gdb_breakpoint call0d
    gdb_breakpoint call0e

    # Run; should stop at call0a and print actual arguments.
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    gdb_test "" " call0a \\(c=97 'a', s=1, i=2, l=3\\) .*" "run to call0a"

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.
    gdb_test "print c" ".* = 97 'a'" "print c after run to call0a" 
    gdb_test "print s" ".* = 1" "print s after run to call0a"
    gdb_test "print i" ".* = 2" "print i after run to call0a"
    gdb_test "print l " ".* = 3" "print l after run to call0a"

    # Continue; should stop at call0b and print actual arguments.
    if [gdb_test "cont" ".* call0b \\(s=1, i=2, l=3, c=97 'a'\\) .*" "continue to call0b"] {
	gdb_suppress_tests
    }

    # Continue; should stop at call0c and print actual arguments.
    if [gdb_test "cont" ".* call0c \\(i=2, l=3, c=97 'a', s=1\\) .*" "continue to call0c"] {
	gdb_suppress_tests
    }

    # Continue; should stop at call0d and print actual arguments.
    if [gdb_test "cont" ".* call0d \\(l=3, c=97 'a', s=1, i=2\\) .*" "continue to call0d";] {
	gdb_suppress_tests
    }

    # Continue; should stop at call0e and print actual arguments.
    if [gdb_test "cont" ".* call0e \\(c1=97 'a', l=3, c2=97 'a', i=2, c3=97 'a', s=1, c4=97 'a', c5=97 'a'\\) .*" "continue to call0e" ] {
	gdb_suppress_tests
    }
    gdb_stop_suppressing_tests
}

#
# Locate actual args; unsigned integral types.
#

proc unsigned_integral_args {} {
    global gdb_prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call1a
    gdb_breakpoint call1b
    gdb_breakpoint call1c
    gdb_breakpoint call1d
    gdb_breakpoint call1e

    # Run; should stop at call1a and print actual arguments.
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    gdb_test "" " call1a \\(uc=98 'b', us=6, ui=7, ul=8\\) .*" "run to call1a"

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.
    gdb_test "print uc" ".* = 98 'b'"
    gdb_test "print us" ".* = 6"
    gdb_test "print ui" ".* = 7"
    gdb_test "print ul" ".* = 8"
    
    # Continue; should stop at call1b and print actual arguments.
    if [gdb_test "cont" ".* call1b \\(us=6, ui=7, ul=8, uc=98 'b'\\) .*" "continue to call1b"] {
	gdb_suppress_tests
    }

    # Continue; should stop at call1c and print actual arguments.
    if [gdb_test "cont" ".* call1c \\(ui=7, ul=8, uc=98 'b', us=6\\) .*" "continue to call1c"] {
	gdb_suppress_tests
    }

    # Continue; should stop at call1d and print actual arguments.
    if [gdb_test "cont" ".* call1d \\(ul=8, uc=98 'b', us=6, ui=7\\) .*" "continue to call1d"] {
	gdb_suppress_tests
    }

    # Continue; should stop at call1e and print actual arguments.
    if [gdb_test "cont" ".* call1e \\(uc1=98 'b', ul=8, uc2=98 'b', ui=7, uc3=98 'b', us=6, uc4=98 'b', uc5=98 'b'\\) .*" "continue to call1e"] {
	gdb_suppress_tests
    }
    gdb_stop_suppressing_tests
}

#
# Locate actual args; integrals mixed with floating point.
#

proc float_and_integral_args {} {
    global gdb_prompt
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call2a
    gdb_breakpoint call2b
    gdb_breakpoint call2c
    gdb_breakpoint call2d
    gdb_breakpoint call2e
    gdb_breakpoint call2f
    gdb_breakpoint call2g
    gdb_breakpoint call2h

    # Run; should stop at call2a and print actual arguments.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_run_cmd
    set test "run to call2a"
    gdb_test_multiple "" $test {
	 -re ".* call2a \\(c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5\\) .*$gdb_prompt $" {
	     pass $test
	 }
	 -re ".* call2a \\(c=97 'a', f1=.*, s=1, d1=5, i=2, f2=4, l=3, d2=5\\) .*$gdb_prompt $" {
	     xfail $test
	 }
    }

    # Print each arg as a double check to see if we can print
    gdb_test "print c" ".* = 97 'a'" "print c after run to call2a"
    gdb_test "print f1" ".* = 4" "print f1 after run to call2a"
    gdb_test "print s" ".* = 1" "print s after run to call2a"
    gdb_test "print d1" ".* = 5" "print d1 after run to call2a"
    gdb_test "print i" ".* = 2" "print i after run to call2a"
    gdb_test "print f2" ".* = 4" "print f2 after run to call2a"
    gdb_test "print l" ".* = 3" "print l after run to call2a"
    gdb_test "print d2" ".* = 5" "print d2 after run to call2a"

    setup_xfail "rs6000-*-*"
    # Continue; should stop at call2b and print actual arguments.
    if [gdb_test "cont" ".* call2b \\(f1=4, s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a'\\) .*" "continue to call2b"] {
	gdb_suppress_tests
    }

    # Continue; should stop at call2c and print actual arguments.
    if [gdb_test "cont" ".* call2c \\(s=1, d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4\\) .*" "continue to call2c"] {
	gdb_suppress_tests
    }

    # Continue; should stop at call2d and print actual arguments.
    if [gdb_test "cont" ".* call2d \\(d1=5, i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1\\) .*" "continue to call2d"] {
	gdb_suppress_tests
    }

    # Continue; should stop at call2e and print actual arguments.
    if [gdb_test "cont" ".* call2e \\(i=2, f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5\\) .*" "continue to call2e"] {
	gdb_suppress_tests
    }

    # Continue; should stop at call2f and print actual arguments.
    if [gdb_test "cont" ".* call2f \\(f2=4, l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2\\) .*" "continue to call2f"] {
	gdb_suppress_tests
    }

    # Continue; should stop at call2g and print actual arguments.
    if [gdb_test "cont" ".* call2g \\(l=3, d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4\\) .*" "continue to call2g"] {
	gdb_suppress_tests
    }

    # Continue; should stop at call2h and print actual arguments.
    if [gdb_test "cont" ".* call2h \\(d2=5, c=97 'a', f1=4, s=1, d1=5, i=2, f2=4, l=3\\) .*" "continue to call2h"] {
	gdb_suppress_tests
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    gdb_breakpoint call2i

    # Continue; should stop at call2i and print actual arguments.
    if [gdb_test "cont" ".* call2i \\(c1=97 'a', f1=4, c2=97 'a', c3=97 'a', d1=5, c4=97 'a', c5=97 'a', c6=97 'a', f2=4, s=1, c7=97 'a', d2=5\\) .*" "continue to call2i"] {
	gdb_suppress_tests
    }
    gdb_stop_suppressing_tests
}


#
# Locate actual args; _Complex types.
#

proc complex_args {} {
    global gdb_prompt

    delete_breakpoints

    gdb_breakpoint callca
    gdb_breakpoint callcb
    gdb_breakpoint callcc
    gdb_breakpoint callcd
    gdb_breakpoint callce
    gdb_breakpoint callcf

    # Run; should stop at call1a and print actual arguments.
    gdb_run_cmd
    gdb_test "" " callca \\(f1=1 \\+ 2 \\* I, f2=1 \\+ 2 \\* I, f3=1 \\+ 2 \\* I\\) .*" "run to call2a"

    gdb_test "cont" ".* callcb \\(d1=3 \\+ 4 \\* I, d2=3 \\+ 4 \\* I, d3=3 \\+ 4 \\* I\\) .*" "continue to callcb"
    gdb_test "cont" ".* callcc \\(ld1=5 \\+ 6 \\* I, ld2=5 \\+ 6 \\* I, ld3=5 \\+ 6 \\* I\\) .*" "continue to callcc"
    gdb_test "cont" ".* callcd \\(fc1=1 \\+ 2 \\* I, dc1=3 \\+ 4 \\* I, ldc1=5 \\+ 6 \\* I\\) .*" "continue to callcd"
    gdb_test "cont" ".* callce \\(dc1=3 \\+ 4 \\* I, ldc1=5 \\+ 6 \\* I, fc1=1 \\+ 2 \\* I\\) .*" "continue to callce"
    gdb_test "cont" ".* callcf \\(ldc1=5 \\+ 6 \\* I, fc1=1 \\+ 2 \\* I, dc1=3 \\+ 4 \\* I\\) .*" "continue to callcf"
}


#
# Locate actual args; _Complex types and integral.
#
proc complex_integral_args {} {
    global gdb_prompt

    delete_breakpoints

    gdb_breakpoint callc1a
    gdb_breakpoint callc1b

    # Run; should stop at call1a and print actual arguments.
    gdb_run_cmd
    gdb_test "" " callc1a \\(c=97 'a', s=1, i=2, ui=7, l=3, fc1=1 \\+ 2 \\* I, dc1=3 \\+ 4 \\* I, ldc1=5 \\+ 6 \\* I\\) .*" "run to callc1a"

    gdb_test "cont" ".* callc1b \\(ldc1=5 \\+ 6 \\* I\\, c=97 'a', s=1, i=2, fc1=1 \\+ 2 \\* I, ui=7, l=3, dc1=3 \\+ 4 \\* I\\) .*" "continue to callc1b"
}

#
# Locate actual args; _Complex types and integral/float.
#
proc complex_float_integral_args {} {
    global gdb_prompt

    delete_breakpoints

    gdb_breakpoint callc2a
    gdb_breakpoint callc2b

    # Run; should stop at call1a and print actual arguments.
    gdb_run_cmd
    gdb_test "" " callc2a \\(c=97 'a', s=1, i=2, ui=7, l=3, f=4, d=5, fc1=1 \\+ 2 \\* I, dc1=3 \\+ 4 \\* I, ldc1=5 \\+ 6 \\* I\\) .*" "run to callc2a"

    gdb_test "cont" ".* callc2b \\(fc1=1 \\+ 2 \\* I, c=97 'a', s=1, i=2, ui=7, ldc1=5 \\+ 6 \\* I\\, l=3, f=4, d=5, dc1=3 \\+ 4 \\* I\\) .*" "continue to callc2b"
}

#
# Locate actual args; dereference pointers to ints and floats.
#

proc pointer_args {} {
    global gdb_prompt
    global hex
    global det_file

    delete_breakpoints

    gdb_breakpoint call3a
    gdb_breakpoint call3b
    gdb_breakpoint call3c

    # Run; should stop at call3a and print actual arguments.
    # Try dereferencing the arguments.

    gdb_run_cmd
    gdb_test "" " call3a \\(cp=$hex <c> \"a.*\", sp=$hex <s>, ip=$hex <i>, lp=$hex <l>\\) .*" "run to call3a"

    gdb_test "print *cp" ".* = 97 'a'"
    gdb_test "print *sp" ".* = 1"
    gdb_test "print *ip" ".* = 2"
    gdb_test "print *lp" ".* = 3"

    # Continue; should stop at call3b and print actual arguments.
    # Try dereferencing the arguments.
    if [gdb_test "cont" ".* call3b \\(ucp=$hex <uc> \"b.*\", usp=$hex <us>, uip=$hex <ui>, ulp=$hex <ul>\\) .*" "continue to call3b"] {
	gdb_suppress_tests
    }

    gdb_test "print *ucp" ".* = 98 'b'"
    gdb_test "print *usp" ".* = 6"
    gdb_test "print *uip" ".* = 7"
    gdb_test "print *ulp" ".* = 8"

    # Continue; should stop at call3c and print actual arguments.
    # Try dereferencing the arguments.
    if [gdb_test "cont" ".* call3c \\(fp=$hex <f>, dp=$hex <d>\\) .*" "continue to call3c"] {
	gdb_suppress_tests
    }

    gdb_test "print *fp" ".* = 4"
    gdb_test "print *dp" ".* = 5"

#    pass "locate actual args, pointer types"
    gdb_stop_suppressing_tests
}

#
# Locate actual args; structures and unions passed by reference.
#

proc structs_by_reference {} {
    global gdb_prompt
    global hex
    global det_file
    global target_sizeof_int
    global target_sizeof_long
    global target_bigendian_p

    delete_breakpoints

    gdb_breakpoint call4a
    gdb_breakpoint call4b

    # Run; should stop at call4a and print actual arguments.
    # Try dereferencing the arguments.

    gdb_run_cmd
    gdb_test "" " call4a \\(stp=$hex <st>\\) .*" "run to call4a"

    gdb_test "print *stp" ".* = \{s1 = 101, s2 = 102\}"

    # Continue; should stop at call4b and print actual arguments.

    gdb_test "cont" ".* call4b \\(unp=$hex <un>\\) .*" "continue to call4b"

    # Try dereferencing the arguments.
    if { $target_sizeof_long == $target_sizeof_int } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 1\}" \
		"print *unp (sizeof long == sizeof int)"
    } elseif { ! $target_bigendian_p } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 1\}" \
		"print *unp (little-endian, sizeof long != sizeof int)"
    } elseif { $target_sizeof_long == 8 && $target_sizeof_int == 4 } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 4294967296\}" \
		"print *unp (big-endian, sizeof long == 8, sizeof int = 4)"
    } elseif { $target_sizeof_long == 4 && $target_sizeof_int == 2 } {
	gdb_test "print *unp" ".* = \{u1 = 1, u2 = 65536\}" \
		"print *unp (big-endian, sizeof long == 4, sizeof int = 2)"
    } else {
	fail "print *unp (unknown case)"
    }

    pass "locate actual args, structs/unions passed by reference"
    gdb_stop_suppressing_tests
}

#
# Locate actual args; structures and unions passed by value.
#

proc structs_by_value {} {
    global gdb_prompt
    global hex
    global det_file
    global target_sizeof_int
    global target_sizeof_long
    global target_bigendian_p

    delete_breakpoints

    gdb_breakpoint call5a
    gdb_breakpoint call5b

    # Run; should stop at call5a and print actual arguments.
    # Try dereferencing the arguments.

    gdb_run_cmd
    gdb_test "" " call5a \\(st=\{s1 = 101, s2 = 102\}\\) .*" "run to call5a"

    gdb_test "print st" ".* = \{s1 = 101, s2 = 102\}"

    # Continue; should stop at call5b and print actual arguments.
    if { $target_sizeof_long == $target_sizeof_int } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 2\}\\) .*" \
		"continue to call5b (sizeof long == sizeof int)"
    } elseif { ! $target_bigendian_p } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 2\}\\) .*" \
		"continue to call5b (little-endian, sizeof long != sizeof int)"
    } elseif { $target_sizeof_long == 8 && $target_sizeof_int == 4 } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 8589934592\}\\) .*" \
		"continue to call5b (big-endian, sizeof long == 8, sizeof int = 4)"
    } elseif { $target_sizeof_long == 4 && $target_sizeof_int == 2 } {
	gdb_test "cont" ".* call5b \\(un=\{u1 = 2, u2 = 131072\}\\) .*" \
		"continue to call5b (big-endian, sizeof long == 4, sizeof int = 2)"
    } else {
	fail "continue to call5b (unknown case)"
    }

    # Try dereferencing the arguments.
    if { $target_sizeof_long == $target_sizeof_int } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 2\}" \
		"print un (sizeof long == sizeof int)"
    } elseif { ! $target_bigendian_p } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 2\}" \
		"print un (little-endian, sizeof long != sizeof int)"
    } elseif { $target_sizeof_long == 8 && $target_sizeof_int == 4 } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 8589934592\}" \
		"print un (big-endian, sizeof long == 8, sizeof int = 4)"
    } elseif { $target_sizeof_long == 4 && $target_sizeof_int == 2 } {
	gdb_test "print un" ".* = \{u1 = 2, u2 = 131072\}" \
		"print un (big-endian, sizeof long == 4, sizeof int = 2)"
    } else {
	fail "print un (unknown case)"
    }

    gdb_stop_suppressing_tests
}

#
# Locate actual args; discard, shuffle, and call
#

proc discard_and_shuffle {} {
    global gdb_prompt
    global hex
    global decimal
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call6a
    gdb_breakpoint call6b
    gdb_breakpoint call6c
    gdb_breakpoint call6d
    gdb_breakpoint call6e
    gdb_breakpoint call6f
    gdb_breakpoint call6g
    gdb_breakpoint call6h

    # Run; should stop at call6a and print actual arguments.
    # Print backtrace.

    gdb_run_cmd
    gdb_test "" "Breakpoint $decimal, call6a .*" "run to call6a"

    setup_xfail "rs6000-*-*"

    gdb_test_multiple "backtrace 100" "backtrace from call6a" {
	-re " call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .* main \\(.*\\) .*$gdb_prompt $" {
	    pass "backtrace from call6a"
	}
	-re " call6a \\(c=97 'a', s=1, i=2, l=3, f=.*, d=5, uc=98 'b', us=6, ui=7, ul=8\\) .* main \\(.*\\) .*$gdb_prompt $" {
	    xfail "backtrace from call6a"
	}
    }

    # Continue; should stop at call6b and print actual arguments.
    # Print backtrace.

    gdb_continue call6b

    if [gdb_test_sequence "backtrace 100" "backtrace from call6b" {
	"\[\r\n\]#0 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#1 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#2 .* main \\(.*\\) at "
    } ] {
	gdb_suppress_tests
    }

    # Continue; should stop at call6c and print actual arguments.
    # Print backtrace.

    gdb_continue call6c

    if [gdb_test_sequence "backtrace 100" "backtrace from call6c" {
	"\[\r\n\]#0 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#1 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#2 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#3 .* main \\(.*\\) at "
    } ] {
	gdb_suppress_tests
    }
    # Continue; should stop at call6d and print actual arguments.
    # Print backtrace.

    gdb_continue call6d

    if [gdb_test_sequence "backtrace 100" "backtrace from call6d" {
	"\[\r\n\]#0 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#1 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#2 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#3 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#4 .* main \\(.*\\) at "
    } ] {
	gdb_suppress_tests
    }

    # Continue; should stop at call6e and print actual arguments.
    # Print backtrace.

    gdb_continue call6e

    if [gdb_test_sequence "backtrace 100" "backtrace from call6e" {
	"\[\r\n\]#0 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#1 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#2 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#3 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#4 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#5 .* main \\(.*\\) at "
    } ] {
	gdb_suppress_tests
    }

    # Continue; should stop at call6f and print actual arguments.
    # Print backtrace.

    gdb_continue call6f

    if [gdb_test_sequence "backtrace 100" "backtrace from call6f" {
	"\[\r\n\]#0 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#1 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#2 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#3 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#4 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#5 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#6 .* main \\(.*\\) at "
    } ] {
	gdb_suppress_tests
    }

    # Continue; should stop at call6g and print actual arguments.
    # Print backtrace.

    gdb_continue call6g

    if [gdb_test_sequence "backtrace 100" "backtrace from call6g" {
	"\[\r\n\]#0 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#1 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#2 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#3 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#4 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#5 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#6 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#7 .* main \\(.*\\) at "
    } ] {
	gdb_suppress_tests
    }

    # Continue; should stop at call6h and print actual arguments.
    # Print backtrace.

    gdb_continue call6h

    if [gdb_test_sequence "backtrace 100" "backtrace from call6h" {
	"\[\r\n\]#0 .* call6h \\(us=6, ui=7, ul=8\\) "
	"\[\r\n\]#1 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#2 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#3 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#4 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#5 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#6 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#7 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#8 .* main \\(.*\\) at "
    } ] {
	gdb_suppress_tests
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    gdb_breakpoint call6i
    gdb_breakpoint call6j
    gdb_breakpoint call6k

    # Continue; should stop at call6i and print actual arguments.
    # Print backtrace.

    gdb_continue call6i

    if [gdb_test_sequence "backtrace 100" "backtrace from call6i" {
	"\[\r\n\]#0 .* call6i \\(ui=7, ul=8\\) "
	"\[\r\n\]#1 .* call6h \\(us=6, ui=7, ul=8\\) "
	"\[\r\n\]#2 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#3 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#4 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#5 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#6 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#7 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#8 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#9 .* main \\(.*\\) at "
    } ] {
	gdb_suppress_tests
    }

    # Continue; should stop at call6j and print actual arguments.
    # Print backtrace.

    gdb_continue call6j

    if [gdb_test_sequence "backtrace 100" "backtrace from call6j" {
	"\[\r\n\]#0 .* call6j \\(ul=8\\) "
	"\[\r\n\]#1 .* call6i \\(ui=7, ul=8\\) "
	"\[\r\n\]#2 .* call6h \\(us=6, ui=7, ul=8\\) "
	"\[\r\n\]#3 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#4 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#5 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#6 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#7 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#8 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#9 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#10 .* main \\(.*\\) at "
    } ] {
	gdb_suppress_tests
    }

    # Continue; should stop at call6k and print actual arguments.
    # Print backtrace.
    gdb_continue call6k

    if [gdb_test_sequence "backtrace 100" "backtrace from call6k" {
	"\[\r\n\]#0 .* call6k \\(\\) "
	"\[\r\n\]#1 .* call6j \\(ul=8\\) "
	"\[\r\n\]#2 .* call6i \\(ui=7, ul=8\\) "
	"\[\r\n\]#3 .* call6h \\(us=6, ui=7, ul=8\\) "
	"\[\r\n\]#4 .* call6g \\(uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#5 .* call6f \\(d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#6 .* call6e \\(f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#7 .* call6d \\(l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#8 .* call6c \\(i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#9 .* call6b \\(s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#10 .* call6a \\(c=97 'a', s=1, i=2, l=3, f=4, d=5, uc=98 'b', us=6, ui=7, ul=8\\) "
	"\[\r\n\]#11 .* main \\(.*\\) at "
    } ] {
	gdb_suppress_tests
    }
    gdb_stop_suppressing_tests
}


#
# Locate actual args; shuffle round robin and call
#

proc shuffle_round_robin {} {
    global gdb_prompt
    global hex
    global decimal
    global det_file
    global gcc_compiled

    delete_breakpoints

    gdb_breakpoint call7a
    gdb_breakpoint call7b
    gdb_breakpoint call7c
    gdb_breakpoint call7d
    gdb_breakpoint call7e
    gdb_breakpoint call7f
    gdb_breakpoint call7g
    gdb_breakpoint call7h

    # Run; should stop at call7a and print actual arguments.
    # Print backtrace.

    gdb_run_cmd
    gdb_test "" "Breakpoint $decimal, call7a .*" "run to call7a"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test_multiple "backtrace 100" "backtrace from call7a" {
	-re " call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .* main \\(.*\\) .*$gdb_prompt $" {
	    pass "backtrace from call7a"
	}
	-re " call7a \\(c=97 'a', i=2, s=1, l=3, f=.*, uc=98 'b', d=5, us=6, ul=8, ui=7\\) .* main \\(.*\\) .*$gdb_prompt $" {
	    xfail "backtrace from call7a"
	}
    }

    # Continue; should stop at call7b and print actual arguments.
    # Print backtrace.

    gdb_continue call7b

    if {$gcc_compiled} then { setup_xfail "rs6000-*-*" }

    gdb_test_sequence "backtrace 100" "backtrace from call7b" {
	"\[\r\n\]#0 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	"\[\r\n\]#1 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	"\[\r\n\]#2 .* main \\(.*\\) at "
    }

    # Continue; should stop at call7c and print actual arguments.
    # Print backtrace.

    gdb_continue call7c

    gdb_test_sequence "backtrace 100" "backtrace from call7c" {
	"\[\r\n\]#0 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	"\[\r\n\]#1 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	"\[\r\n\]#2 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	"\[\r\n\]#3 .* main \\(.*\\) at "
    }

    # Continue; should stop at call7d and print actual arguments.
    # Print backtrace.

    gdb_continue call7d

    gdb_test_sequence "backtrace 100" "backtrace from call7d" {
	"\[\r\n\]#0 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	"\[\r\n\]#1 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	"\[\r\n\]#2 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	"\[\r\n\]#3 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	"\[\r\n\]#4 .* main \\(.*\\) at "
    }

    gdb_continue call7e

    gdb_test_sequence "backtrace 100" "backtrace from call7e" {
	"\[\r\n\]#0 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	"\[\r\n\]#1 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	"\[\r\n\]#2 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	"\[\r\n\]#3 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	"\[\r\n\]#4 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	"\[\r\n\]#5 .* main \\(.*\\) at "
    }

    # Continue; should stop at call7f and print actual arguments.
    # Print backtrace.

    gdb_continue call7f

    gdb_test_sequence "backtrace 100" "backtrace from call7f" {
	"\[\r\n\]#0 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	"\[\r\n\]#1 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	"\[\r\n\]#2 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	"\[\r\n\]#3 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	"\[\r\n\]#4 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	"\[\r\n\]#5 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	"\[\r\n\]#6 .* main \\(.*\\) at "
    }

    # Continue; should stop at call7g and print actual arguments.
    # Print backtrace.

    gdb_continue call7g

    gdb_test_sequence "backtrace 100" "backtrace from call7g" {
	"\[\r\n\]#0 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	"\[\r\n\]#1 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	"\[\r\n\]#2 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	"\[\r\n\]#3 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	"\[\r\n\]#4 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	"\[\r\n\]#5 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	"\[\r\n\]#6 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	"\[\r\n\]#7 .* main \\(.*\\) at "
    }

    gdb_continue call7h

    gdb_test_sequence "backtrace 100" "backtrace from call7h" {
	"\[\r\n\]#0 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	"\[\r\n\]#1 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	"\[\r\n\]#2 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	"\[\r\n\]#3 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	"\[\r\n\]#4 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	"\[\r\n\]#5 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	"\[\r\n\]#6 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	"\[\r\n\]#7 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	"\[\r\n\]#8 .* main \\(.*\\) at "
    }

    # monitor only allows 8 breakpoints; w89k board allows 10, so
    # break them up into two groups.
    delete_breakpoints
    gdb_breakpoint call7i
    gdb_breakpoint call7j
    gdb_breakpoint call7k

    # Continue; should stop at call7i and print actual arguments.
    # Print backtrace.

    gdb_continue call7i

    gdb_test_sequence "backtrace 100" "backtrace from call7i" {
	"\[\r\n\]#0 .* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) "
	"\[\r\n\]#1 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	"\[\r\n\]#2 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	"\[\r\n\]#3 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	"\[\r\n\]#4 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	"\[\r\n\]#5 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	"\[\r\n\]#6 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	"\[\r\n\]#7 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	"\[\r\n\]#8 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	"\[\r\n\]#9 .* main \\(.*\\) at "
    }

    # Continue; should stop at call7j and print actual arguments.
    # Print backtrace.

    gdb_continue call7j

    gdb_test_sequence "backtrace 100" "backtrace from call7j" {
	"\[\r\n\]#0 .* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) "
	"\[\r\n\]#1 .* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) "
	"\[\r\n\]#2 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	"\[\r\n\]#3 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	"\[\r\n\]#4 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	"\[\r\n\]#5 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	"\[\r\n\]#6 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	"\[\r\n\]#7 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	"\[\r\n\]#8 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	"\[\r\n\]#9 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	"\[\r\n\]#10 .* main \\(.*\\) at "
    }

    # Continue; should stop at call7k and print actual arguments.
    # Print backtrace.

    gdb_continue call7k

    gdb_test_sequence "backtrace 100" "backtrace from call7k" {
	"\[\r\n\]#0 .* call7k \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	"\[\r\n\]#1 .* call7j \\(ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8\\) "
	"\[\r\n\]#2 .* call7i \\(ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6\\) "
	"\[\r\n\]#3 .* call7h \\(us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5\\) "
	"\[\r\n\]#4 .* call7g \\(d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b'\\) "
	"\[\r\n\]#5 .* call7f \\(uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3, f=4\\) "
	"\[\r\n\]#6 .* call7e \\(f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1, l=3\\) "
	"\[\r\n\]#7 .* call7d \\(l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2, s=1\\) "
	"\[\r\n\]#8 .* call7c \\(s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a', i=2\\) "
	"\[\r\n\]#9 .* call7b \\(i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7, c=97 'a'\\) "
	"\[\r\n\]#10 .* call7a \\(c=97 'a', i=2, s=1, l=3, f=4, uc=98 'b', d=5, us=6, ul=8, ui=7\\) "
	"\[\r\n\]#11 .* main \\(.*\\) at "
    }
    gdb_stop_suppressing_tests
}

#
# Locate actual args; recursive passing of structs by value
#

proc recursive_structs_by_value {} {
    global gdb_prompt
    global hex
    global decimal
    global det_file

    delete_breakpoints

    gdb_breakpoint hitbottom

    # Run; should stop at hitbottom and print actual arguments.
    # Print backtrace.
    gdb_run_cmd
    gdb_test "" "Breakpoint $decimal, hitbottom .*" "run to hitbottom"

    gdb_test_sequence "backtrace 100" "recursive passing of structs by value" {
	"\[\r\n\]#0 .* hitbottom \\(\\) "
	"\[\r\n\]#1 .* recurse \\(a=\{s = 0, i = 0, l = 0\}, depth=0\\) "
	"\[\r\n\]#2 .* recurse \\(a=\{s = 1, i = 1, l = 1\}, depth=1\\) "
	"\[\r\n\]#3 .* recurse \\(a=\{s = 2, i = 2, l = 2\}, depth=2\\) "
	"\[\r\n\]#4 .* recurse \\(a=\{s = 3, i = 3, l = 3\}, depth=3\\) "
	"\[\r\n\]#5 .* recurse \\(a=\{s = 4, i = 4, l = 4\}, depth=4\\) "
	"\[\r\n\]#6 .* test_struct_args \\(\\) "
	"\[\r\n\]#7 .* main \\(.*\\) at "
    }
    gdb_stop_suppressing_tests
}

#
# Test for accessing local stack variables in functions which call alloca
#
proc localvars_after_alloca { } {
    global gdb_prompt
    global hex
    global decimal
    global gcc_compiled

    if { ! [ runto localvars_after_alloca ] } then { gdb_suppress_tests; }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c after runto localvars_after_alloca"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s after runto localvars_after_alloca"
    gdb_test "print i" " = 2" "print i after runto localvars_after_alloca"
    gdb_test "print l" " = 3" "print l after runto localvars_after_alloca"

    # Lame regexp.
    gdb_test "next" ".*" "next in localvars_after_alloca()"

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    gdb_test "print c" " = 97 'a'" "print c in localvars_after_alloca"
    gdb_test "print s" " = 1" "print s in localvars_after_alloca"
    gdb_test "print i" " = 2" "print i in localvars_after_alloca"
    gdb_test "print l" " = 3" "print l in localvars_after_alloca"

    gdb_test "backtrace 8" "#0.*localvars_after_alloca \\(c=97 'a', s=1, i=2, l=3\\).*#1.*main.*" "backtrace after alloca"
    gdb_stop_suppressing_tests
}

proc call_after_alloca { } {
    global gdb_prompt
    global hex
    global decimal
    global gcc_compiled

    if { ! [ runto call_after_alloca_subr ] } then { gdb_suppress_tests; }

    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c in call_after_alloca"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s in call_after_alloca"
    gdb_test "print i" " = 2" "print i in call_after_alloca"
    gdb_test "print l" " = 3" "print l in call_after_alloca"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "backtrace 8" "#0.*call_after_alloca_subr \\(c=97 'a', s=1, i=2, l=3, uc=98 'b', us=11, ui=12, ul=13\\).*#1.*call_after_alloca \\(c=97 'a', s=1, i=2, l=3\\).*#2.*main.*" "backtrace from call_after_alloca_subr"
    gdb_stop_suppressing_tests
}

#
# Test for accessing local stack variables, backtraces, finish,
# and finally stepping into indirect calls.  The point is that on the PA
# these use a funky `dyncall' mechanism which GDB needs to know about.
#
proc localvars_in_indirect_call { } {
    global gdb_prompt
    global hex
    global decimal
    global gcc_compiled

    # Can not use "runto call0a" as call0a is called several times
    # during single run.  Instead stop in a marker function and
    # take control from there.
    if { ! [ runto marker_indirect_call ] } then { gdb_suppress_tests; }

    # break on the next call to call0a, then delete all the breakpoints
    # and start testing.
    gdb_breakpoint call0a
    gdb_continue call0a
    delete_breakpoints
    
    # Print each arg as a double check to see if we can print
    # them here as well as with backtrace.

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print c" " = 97 'a'" "print c in localvars_in_indirect_call"
    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "print s" " = 1" "print s in localvars_in_indirect_call"
    gdb_test "print i" " = 2" "print i in localvars_in_indirect_call"
    gdb_test "print l" " = 3" "print l in localvars_in_indirect_call"

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "backtrace 8" \
	"#0.*call0a \\(c=97 'a', s=1, i=2, l=3\\).*#1.*main.*" \
	"backtrace in indirectly called function"

    # 
    # "finish" brings us back to main.  We then will try to step through
    # the second indirect call.  
    # On some targets (e.g. m68k) gdb will stop from the finish in midline
    # of the first indirect call. This is due to stack adjustment instructions
    # after the indirect call. In these cases we will step till we hit the
    # second indirect call.
    #

    gdb_test_multiple "finish" "finish from indirectly called function" {
	-re "\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*First.*$gdb_prompt $" {
	    # If the branch instruction is not the last instruction in the
	    # function call line, we'll stop at that line, and need an extra
	    # "step" to continue the test.
	    send_gdb "step\n"
	    exp_continue
	}
	-re ".*\\(\\*pointer_to_call0a\\) \\(c, s, i, l\\);.*Second.*$gdb_prompt $" {
	    pass "finish from indirectly called function"
	}
	-re ".*$gdb_prompt $" {
	    fail "finish from indirectly called function"
	    gdb_suppress_tests
	}
	default { 
	    fail "finish from indirectly called function"
	    gdb_suppress_tests
	}
    }

    if {!$gcc_compiled} then { setup_xfail "rs6000-*-*" }
    gdb_test "step" "call0a \\(c=97 'a', s=1, i=2, l=3\\).*" \
	"stepping into indirectly called function"
    gdb_stop_suppressing_tests
}

#
# Test for stepping into indirect calls which may have trampolines (possibly
# cascaded) on both the call path and the gdb_suppress_tests; path.
# to handle trampolines.
#
proc test_stepping_over_trampolines { } {
    global gdb_prompt
    global hex
    global decimal

    # Stop in a marker function and take control from there.
    if { ! [ runto marker_call_with_trampolines ] } then { gdb_suppress_tests; }

    # Cater for gdb stopping in midline, see comment for finish above.
    gdb_test_multiple "finish" "finish from marker_call_with_trampolines" {
	-re "marker_call_with_trampolines ..;.*$gdb_prompt $" {
	    send_gdb "step\n"
	    exp_continue
	}
	-re "pointer_to_call_with_trampolines.*$gdb_prompt $" {
	    pass "finish from marker_call_with_trampolines"
	}
	-re ".*$gdb_prompt $" {
	    fail "finish from marker_call_with_trampolines"
	}
	default { 
	    fail "finish from marker_call_with_trampolines"
	    gdb_suppress_tests
	}
    }

    # Try to step into the target function.
    gdb_test "step" "call_with_trampolines \\(d1=5\\).*" \
	"stepping into function called with trampolines"

    # Make we can backtrace and the argument looks correct.  */
    gdb_test "backtrace 8" "#0.*call_with_trampolines \\(d1=5\\).*1.*main.*" \
	"backtrace through call with trampolines"

    # Make sure we can get back to main.
    # Stepping back to main might stop again after the gdb_suppress_tests; statement
    # or immediately transfer control back to main if optimizations
    # are performed.
    gdb_test_multiple "step" "stepping back to main from function called with trampolines" {
	-re "main .* at.*$gdb_prompt $" {
	    pass "stepping back to main from function called with trampolines"
	    gdb_suppress_tests
	}
	-re "\}.*End of call_with_trampolines.*$gdb_prompt $" {
	    send_gdb "step\n"
	    exp_continue
	}
	-re ".*$gdb_prompt $" {
	    fail "stepping back to main from function called with trampolines"
	}
	default {
	    fail "stepping back to main from function called with trampolines"
	    gdb_suppress_tests
	}
    }
    gdb_stop_suppressing_tests
}

set prev_timeout $timeout
if [istarget "mips*tx39-*"] {
    set timeout 300
} else {
    set timeout 60
}

# Determine expected output for unsigned long variables,
# the output varies with sizeof (unsigned long).

gdb_test_multiple "print sizeof (long)" "getting sizeof long" {
    -re ".\[0-9\]* = 4.*$gdb_prompt $" {
	set target_sizeof_long 4
	# pass silently
    }
    -re ".\[0-9\]* = 8.*$gdb_prompt $" {
	set target_sizeof_long 8
	# pass silently
    }
}

gdb_test_multiple "print sizeof (int)" "getting sizeof int" {
    -re ".\[0-9\]* = 2.*$gdb_prompt $" {
	set target_sizeof_int 2
	# pass silently
    }
    -re ".\[0-9\]* = 4.*$gdb_prompt $" {
	set target_sizeof_int 4
	# pass silently
    }
    -re ".\[0-9\]* = 8.*$gdb_prompt $" {
	set target_sizeof_int 8
	# pass silently
    }
}

gdb_test_multiple "show endian" "getting target endian" {
    -re ".*little endian.*$gdb_prompt $" {
	set target_bigendian_p 0
	# pass silently
    }
    -re ".*big endian.*$gdb_prompt $" {
	set target_bigendian_p 1
	# pass silently
    }
}

# Perform tests

gdb_test_no_output "set print frame-arguments all"

integral_args
unsigned_integral_args
if {![target_info exists gdb,skip_float_tests]} {
  float_and_integral_args
}

# Test _Complex type here if supported.
if [support_complex_tests] {
    complex_args

    complex_integral_args

    if {![target_info exists gdb,skip_float_tests]} {
	complex_float_integral_args
    }
}

pointer_args
structs_by_reference
structs_by_value
discard_and_shuffle
shuffle_round_robin
recursive_structs_by_value
localvars_after_alloca
call_after_alloca
localvars_in_indirect_call
test_stepping_over_trampolines

set timeout $prev_timeout
