// -*- C -*-
:option:::insn-bit-size:8
:option:::insn-specifying-widths:true
:option:::hi-bit-nr:7
:model:::mn10300:mn10300:
:model:::am33:am33:
:model:::am33_2:am33_2:

// What do we do with an illegal instruction?
:internal::::illegal:
{
  PC = cia;
  program_interrupt(SD, CPU, cia, SIM_SIGILL);
}

// 1000 DnDn imm8....; mov imm8,Dn (imm8 is sign extended)
4.0x8,2.DM1,2.DN0=DM1+8.IMM8:S0i:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /*  OP_8000 (); */
  signed32 immed = EXTEND8 (IMM8);
  State.regs[REG_D0+DN0] = immed;
  PC = cia;
}

// 1000 DmDn; mov Dm,Dn (Dm != Dn, see above when Dm == Dn)
4.0x8,2.DM1,2.DN0!DM1:S0:::mov
"mov"
*mn10300
*am33
*am33_2
{
  PC = cia;
  /* OP_80 (); */
  State.regs[REG_D0+DN0] = State.regs[REG_D0+DM1];
}


// 1111 0001 1110 DmAn; mov Dm,An
8.0xf1+1110,2.DM1,2.AN0:D0:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F1E0 (); */
  PC = cia;
  State.regs[REG_A0 + AN0] = State.regs[REG_D0 + DM1];
}


// 1111 0001 1101 AmDn; mov Am,Dn
8.0xf1+1101,2.AM1,2.DN0:D0a:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F1D0 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = State.regs[REG_A0 + AM1];
}


// 1001 AnAn imm8....; mov imm8,An (imm8 is zero-extended)
4.0x9,2.AM1,2.AN0=AM1+8.IMM8:S0ai:::mov
"mov"
*mn10300
*am33
*am33_2
{
   PC = cia;
   /* OP_9000 (); */
   State.regs[REG_A0+AN0] = IMM8;
}


// 1001 AmAn; mov Am,An (Am != An, save above when Am == An)
4.0x9,2.AM1,2.AN0!AM1:S0a:::mov
"mov"
*mn10300
*am33
*am33_2
{
   PC = cia;
   /* OP_90 (); */
   State.regs[REG_A0+AN0] = State.regs[REG_A0+AM1];
}


// 0011 11An; mov SP,An
4.0x3,11,2.AN0:S0b:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_3C (); */
  PC = cia;
  State.regs[REG_A0 + AN0] = State.regs[REG_SP];
}


// 1111 0010 1111 Am00; mov Am,SP
8.0xf2+4.0xf,2.AM1,00:D0b:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F2F0 (); */
  PC = cia;
  State.regs[REG_SP] = State.regs[REG_A0 + AM1];
}


// 1111 0010 1110 01Dn; mov PSW,Dn
8.0xf2+4.0xe,01,2.DN0:D0c:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F2E4 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = PSW;
}


// 1111 0010 1111 Dm11; mov Dm,PSW
8.0xf2+4.0xf,2.DM1,11:D0d:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F2F3 (); */
  PC = cia;
  PSW = State.regs[REG_D0 + DM1];
}


// 1111 0010 1110 00Dn; mov MDR,Dn
8.0xf2+4.0xe,00,2.DN0:D0e:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F2E0 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = State.regs[REG_MDR];
}


// 1111 0010 1111 Dm10; mov Dm,MDR
8.0xf2+4.0xf,2.DM1,10:D0f:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F2F2 (); */
  PC = cia;
  State.regs[REG_MDR] = State.regs[REG_D0 + DM1];
}


// 0111 DnAm; mov (Am),Dn
4.0x7,2.DN1,2.AM0:S0c:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_70 (); */
  PC = cia;
  State.regs[REG_D0 + DN1] = load_word (State.regs[REG_A0 + AM0]);
}


// 1111 1000 0000 DnAm d8......; mov (d8,Am),Dn (d8 is sign-extended)
8.0xf8+4.0x0,2.DN1,2.AM0+8.D8:D1:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F80000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_word ((State.regs[REG_A0 + AM0] + EXTEND8 (D8)));
}


// 1111 1010 0000 DnAm d16.....; mov (d16,Am),Dn (d16 is sign-extended.)
8.0xfa+4.0x0,2.DN1,2.AM0+8.D16A+8.D16B:D2:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FA000000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_word ((State.regs[REG_A0 + AM0] + EXTEND16 (FETCH16(D16A, D16B))));
}


// 1111 1100 0000 DnAm d32.....; mov (d32,Am),Dn
8.0xfc+4.0x0,2.DN1,2.AM0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FC000000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_word ((State.regs[REG_A0 + AM0]
		  + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
}


// 0101 10Dn d8......; mov (d8,SP),Dn (d8 is zero-extended)
4.0x5,10,2.DN0+8.D8:S1:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_5800 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = load_word (State.regs[REG_SP] + D8);
}


// 1111 1010 1011 01Dn d16.....; mov (d16,SP),Dn (d16 is zero-extended.)
8.0xfa+4.0xb,01,2.DN0+8.IMM16A+8.IMM16B:D2a:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FAB40000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_word (State.regs[REG_SP] + FETCH16(IMM16A, IMM16B));
}


// 1111 1010 1011 01Dn d32.....; mov (d32,SP),Dn
8.0xfc+4.0xb,01,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FCB40000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
     = load_word (State.regs[REG_SP] + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0011 00Dn DiAm; mov (Di,Am),Dn
8.0xf3+00,2.DN2,2.DI,2.AM0:D0g:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F300 (); */
  PC = cia;
  State.regs[REG_D0 + DN2]
    = load_word ((State.regs[REG_A0 + AM0] + State.regs[REG_D0 + DI]));
}


// 0011 00Dn abs16...; mov (abs16),Dn (abs16 is zero-extended)
4.0x3,00,2.DN0+8.IMM16A+8.IMM16B:S2:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_300000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = load_word (FETCH16(IMM16A, IMM16B));
}

// 1111 1100 1010 01Dn abs32...; mov (abs32),Dn
8.0xfc+4.0xa,01,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4b:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FCA40000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = load_word (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0000 0000 AnAm; mov (Am),An
8.0xf0+4.0x0,2.AN1,2.AM0:D0h:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F000 (); */
  PC = cia;
  State.regs[REG_A0 + AN1] = load_word (State.regs[REG_A0 + AM0]);
}


// 1111 1000 0010 AnAm d8......; mov (d8,Am),An (d8 is sign-extended)
8.0xf8+4.0x2,2.AN1,2.AM0+8.D8:D1a:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F82000 (); */
  PC = cia;
  State.regs[REG_A0 + AN1]
    = load_word ((State.regs[REG_A0 + AM0] + EXTEND8 (D8)));
}


// 1111 1010 0010 AnAm d16.....; mov (d16,Am),An (d16 is sign-extended.)
8.0xfa+4.0x2,2.AN1,2.AM0+8.D16A+8.D16B:D2b:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FA200000 (); */
  PC = cia;
  State.regs[REG_A0 + AN1]
    = load_word ((State.regs[REG_A0 + AM0]
		  + EXTEND16 (FETCH16(D16A, D16B))));
}


// 1111 1100 0010 AnAm d32.....; mov (d32,Am),An
8.0xfc+4.0x2,2.AN1,2.AM0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4c:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FC200000 (); */
  PC = cia;
  State.regs[REG_A0 + AN1]
    = load_word ((State.regs[REG_A0 + AM0]
		  + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
}


// 0101 11An d8......; mov (d8,SP),An (d8 is zero-extended)
4.0x5,11,2.AN0+8.D8:S1a:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_5C00 (); */
  PC = cia;
  State.regs[REG_A0 + AN0]
    = load_word (State.regs[REG_SP] + D8);
}


// 1111 1010 1011 00An d16.....; mov (d16,SP),An (d16 is zero-extended.)
8.0xfa+4.0xb,00,2.AN0+8.IMM16A+8.IMM16B:D2c:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FAB00000 (); */
  PC = cia;
  State.regs[REG_A0 + AN0]
    = load_word (State.regs[REG_SP] + FETCH16(IMM16A, IMM16B));
}


// 1111 1100 1011 00An d32.....; mov (d32,SP),An
8.0xfc+4.0xb,00,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4d:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FCB00000 (); */
  PC = cia;
  State.regs[REG_A0 + AN0]
    = load_word (State.regs[REG_SP]
		 + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0011 10An DiAm; mov (Di,Am),An
8.0xf3+10,2.AN2,2.DI,2.AM0:D0i:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F380 (); */
  PC = cia;
  State.regs[REG_A0 + AN2]
    = load_word ((State.regs[REG_A0 + AM0]
		 + State.regs[REG_D0 + DI]));
}


// 1111 1010 1010 00An abs16...; mov (abs16),An (abs16 is zero-extended)
8.0xfa+4.0xa,00,2.AN0+8.IMM16A+8.IMM16B:D2d:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FAA00000 (); */
  PC = cia;
  State.regs[REG_A0 + AN0] = load_word (FETCH16(IMM16A, IMM16B));
}


// 1111 1100 1010 00An abs32...; mov (abs32),An
8.0xfc+4.0xa,00,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4e:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FCA00000 (); */
  PC = cia;
  State.regs[REG_A0 + AN0]
    = load_word (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 1000 1111 00Am d8......; mov (d8,Am),SP (d8 is sign-extended)
8.0xf8+4.0xf,00,2.AM0+8.D8:D1b:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F8F000 (); */
  PC = cia;
  State.regs[REG_SP]
    = load_word ((State.regs[REG_A0 + AM0] + EXTEND8 (D8)));
}


// 0110 DmAn; mov Dm,(An)
4.0x6,2.DM1,2.AN0:S0d:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_60 (); */
  PC = cia;
  store_word (State.regs[REG_A0 + AN0], State.regs[REG_D0 + DM1]);
}


// 1111 1000 0001 DmAn d8......; mov Dm,(d8,An) (d8 is sign-extended)
8.0xf8+4.0x1,2.DM1,2.AN0+8.D8:D1c:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F81000 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1010 0001 DmAn d16.....; mov Dm,(d16,An) (d16 is sign-extended.)
8.0xfa+4.0x1,2.DM1,2.AN0+8.D16A+8.D16B:D2e:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FA100000 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0] + EXTEND16 (FETCH16(D16A, D16B))),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 0001 DmAn d32.....; mov Dm,(d32,An)
8.0xfc+4.0x1,2.DM1,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4f:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FC100000 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0]
	       + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)),
	      State.regs[REG_D0 + DM1]);
}


// 0100 Dm10 d8......; mov Dm,(d8,SP) (d8 is zero-extended)
4.0x4,2.DM1,10+8.D8:S1b:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_4200 (); */
  PC = cia;
  store_word (State.regs[REG_SP] + D8, State.regs[REG_D0 + DM1]);
}


// 1111 1010 1001 Dm01 d16.....; mov Dm,(d16,SP) (d16 is zero-extended.)
8.0xfa+4.0x9,2.DM1,01+8.IMM16A+8.IMM16B:D2f:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FA910000 (); */
  PC = cia;
  store_word (State.regs[REG_SP] + FETCH16(IMM16A, IMM16B),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 1001 Dm01 d32.....; mov Dm,(d32,SP)
8.0xfc+4.0x9,2.DM1,01+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4g:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FC910000 (); */
  PC = cia;
  store_word (State.regs[REG_SP] + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DM1]);
}


// 1111 0011 01Dm DiAn; mov Dm,(Di,An)
8.0xf3+01,2.DM2,2.DI,2.AN0:D0j:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F340 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0] + State.regs[REG_D0 + DI]),
	      State.regs[REG_D0 + DM2]);
}


// 0000 Dm01 abs16..., mov Dm,(abs16) (abs16 is zero-extended).
4.0x0,2.DM1,01+8.IMM16A+8.IMM16B:S2a:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_10000 (); */
  PC = cia;
  store_word (FETCH16(IMM16A, IMM16B), State.regs[REG_D0 + DM1]);
}


// 1111 1100 1000 Dm01 abs32...; mov Dm,(abs32)
8.0xfc+4.0x8,2.DM1,01+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4h:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FC810000 (); */
  PC = cia;
  store_word (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DM1]);
}


// 1111 0000 0001 AmAn; mov Am,(An)
8.0xf0+4.0x1,2.AM1,2.AN0:D0k:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F010 (); */
  PC = cia;
  store_word (State.regs[REG_A0 + AN0], State.regs[REG_A0 + AM1]);
}


// 1111 1000 0011 AmAn d8......; mov Am,(d8,An) (d8 is sign-extended)
8.0xf8+4.0x3,2.AM1,2.AN0+8.D8:D1d:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F83000 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)),
	      State.regs[REG_A0 + AM1]);
}


// 1111 1010 0011 AmAn d16.....; mov Am,(d16,An) (d16 is sign-extended.)
8.0xfa+4.0x3,2.AM1,2.AN0+8.D16A+8.D16B:D2g:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FA300000 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0] + EXTEND16 (FETCH16(D16A, D16B))),
	      State.regs[REG_A0 + AM1]);
}


// 1111 1100 0011 AmAn d32.....; mov Am,(d32,An)
8.0xfc+4.0x3,2.AM1,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4i:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FC300000 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0]
	       + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)),
	      State.regs[REG_A0 + AM1]);
}


// 0100 Am11 d8......; mov Am,(d8,SP) (d8 is zero-extended)
4.0x4,2.AM1,11+8.D8:S1c:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_4300 (); */
  PC = cia;
  store_word (State.regs[REG_SP] + (D8), State.regs[REG_A0 + (AM1)]);
}


// 1111 1010 1001 Am00 d16.....; mov Am,(d16,SP) (d16 is zero-extended.)
8.0xfa+4.0x9,2.AM1,00+8.IMM16A+8.IMM16B:D2h:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_FA900000 (); */
  PC = cia;
  store_word (State.regs[REG_SP] + FETCH16(IMM16A, IMM16B),
	      State.regs[REG_A0 + AM1]);
}


// 1111 1100 1001 Am00 d32.....; mov Am,(d32,SP)
8.0xfc+4.0x9,2.AM1,00+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4j:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_FC900000 (); */
  PC = cia;
  store_word (State.regs[REG_SP] + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_A0 + AM1]);
}


// 1111 0011 11Am DiAn; mov Am,(Di,An)
8.0xf3+11,2.AM2,2.DI,2.AN0:D0l:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_F3C0 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0] + State.regs[REG_D0 + DI]),
	      State.regs[REG_A0 + AM2]);
}


// 1111 1010 1000 Am00 abs16...; mov Am,(abs16) (abs16 is zero-extended)
8.0xfa+4.0x8,2.AM1,00+8.IMM16A+8.IMM16B:D2i:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_FA800000 (); */
  PC = cia;
  store_word (FETCH16(IMM16A, IMM16B),
	      State.regs[REG_A0 + AM1]);
}


// 1111 1100 1000 Am00 abs32...; mov Am,(abs32)
8.0xfc+4.0x8,2.AM1,00+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4k:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_FC800000 (); */
  PC = cia;
  store_word (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_A0 + AM1]);
}


// 1111 1000 1111 01An d8......; mov SP,(d8,An) (d8 is sign-extended)
8.0xf8+4.0xf,01,2.AN0+8.D8:D1e:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_F8F400 (); */
  PC = cia;
  store_word (State.regs[REG_A0 + AN0] + EXTEND8 (D8),
	      State.regs[REG_SP]);
}


// 0010 11Dn imm16...; mov imm16,Dn (imm16 is sign-extended)
4.0x2,11,2.DN0+8.IMM16A+8.IMM16B:S2b:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_2C0000 (); */
  unsigned32 value;

  PC = cia;
  value = EXTEND16 (FETCH16(IMM16A, IMM16B));
  State.regs[REG_D0 + DN0] = value;
}


// 1111 1100 1100 11Dn imm32...; mov imm32,Dn
8.0xfc+4.0xc,11,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4l:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_FCCC0000 (); */
  unsigned32 value;

  PC = cia;
  value = FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
  State.regs[REG_D0 + DN0] = value;
}


// 0010 01An imm16...; mov imm16,An (imm16 is zero-extended)
4.0x2,01,2.AN0+8.IMM16A+8.IMM16B:S2c:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_240000 (); */
  unsigned32 value;

  PC = cia;
  value = FETCH16(IMM16A, IMM16B);
  State.regs[REG_A0 + AN0] = value;
}


// 1111 1100 1101 11An imm32...; mov imm32,An
8.0xfc+4.0xd,11,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4m:::mov
"mov"
*mn10300

*am33
*am33_2

{
    /* OP_FCDC0000 (); */
    PC = cia;
    State.regs[REG_A0 + AN0] = FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
}


// 1111 0000 0100 DnAm; movbu (Am),Dn
8.0xf0+4.0x4,2.DN1,2.AM0:D0:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F040 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_byte (State.regs[REG_A0 + AM0]);
}


// 1111 1000 0100 DnAm d8......; movbu (d8,Am),Dn (d8 is sign-extended)
8.0xf8+4.0x4,2.DN1,2.AM0+8.D8:D1f:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F84000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_byte ((State.regs[REG_A0 + AM0] + EXTEND8 (D8)));
}


// 1111 1010 0100 DnAm d16.....; movbu (d16,Am),Dn (d16 is sign-extended.)
8.0xfa+4.0x4,2.DN1,2.AM0+8.D16A+8.D16B:D2:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FA400000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_byte ((State.regs[REG_A0 + AM0]
		  + EXTEND16 (FETCH16(D16A, D16B))));
}


// 1111 1100 0100 DnAm d32.....; movbu (d32,Am),Dn
8.0xfc+4.0x4,2.DN1,2.AM0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FC400000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_byte ((State.regs[REG_A0 + AM0]
		  + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
}


// 1111 1000 1011 10Dn d8......; movbu (d8,SP),Dn (d8 is zero-extended)
8.0xf8+4.0xb,10,2.DN0+8.D8:D1a:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F8B800 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_byte ((State.regs[REG_SP] + (D8)));
}


// 1111 1010 1011 10Dn d16.....; movbu (d16,SP),Dn (d16 is zero-extended.)
8.0xfa+4.0xb,10,2.DN0+8.IMM16A+8.IMM16B:D2a:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FAB80000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_byte ((State.regs[REG_SP]
		  + FETCH16(IMM16A, IMM16B)));
}


// 1111 1100 1011 10Dn d32.....; movbu (d32,SP),Dn
8.0xfc+4.0xb,10,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FCB80000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_byte (State.regs[REG_SP]
		 + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0100 00Dn DiAm; movbu (Di,Am),Dn
8.0xf4+00,2.DN2,2.DI,2.AM0:D0a:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F400 (); */
  PC = cia;
  State.regs[REG_D0 + DN2]
    = load_byte ((State.regs[REG_A0 + AM0]
		  + State.regs[REG_D0 + DI]));
}


// 0011 01Dn abs16...; movbu (abs16),Dn (abs16 is zero-extended)
4.0x3,01,2.DN0+8.IMM16A+8.IMM16B:S2:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_340000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = load_byte (FETCH16(IMM16A, IMM16B));
}


// 1111 1100 1010 10Dn abs32...; movbu (abs32),Dn
8.0xfc+4.0xa,10,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4b:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FCA80000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_byte (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0000 0101 DmAn; movbu Dm,(An)
8.0xf0+4.0x5,2.DM1,2.AN0:D0b:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F050 (); */
  PC = cia;
  store_byte (State.regs[REG_A0 + AN0], State.regs[REG_D0 + DM1]);
}


// 1111 1000 0101 DmAn d8......; movbu Dm,(d8,An) (d8 is sign-extended)
8.0xf8+4.0x5,2.DM1,2.AN0+8.D8:D1b:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F85000 (); */
  PC = cia;
  store_byte ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1010 0101 DmAn d16.....; movbu Dm,(d16,An) (d16 is sign-extended.)
8.0xfa+4.0x5,2.DM1,2.AN0+8.D16A+8.D16B:D2b:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FA500000 (); */
  PC = cia;
  store_byte ((State.regs[REG_A0 + AN0] + EXTEND16 (FETCH16(D16A, D16B))),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 0101 DmAn d32.....; movbu Dm,(d32,An)
8.0xfc+4.0x5,2.DM1,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4c:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FC500000 (); */
  PC = cia;
  store_byte ((State.regs[REG_A0 + AN0]
	       + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1000 1001 Dm10 d8......; movbu Dm,(d8,SP) (d8 is zero-extended)
8.0xf8+4.0x9,2.DM1,10+8.D8:D1c:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F89200 (); */
  PC = cia;
  store_byte (State.regs[REG_SP] + (D8), State.regs[REG_D0 + DM1]);
}


// 1111 1010 1001 Dm10 d16.....; movbu Dm,(d16,SP) (d16 is zero-extended.)
8.0xfa+4.0x9,2.DM1,10+8.IMM16A+8.IMM16B:D2c:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FA920000 (); */
  PC = cia;
  store_byte (State.regs[REG_SP] + FETCH16(IMM16A, IMM16B),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 1001 Dm10 d32.....; movbu Dm,(d32,SP)
8.0xfc+4.0x9,2.DM1,10+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4d:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FC920000 (); */
  PC = cia;
  store_byte (State.regs[REG_SP] + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DM1]);
}


// 1111 0100 01Dm DiAn; movbu Dm,(Di,An)
8.0xf4+01,2.DM2,2.DI,2.AN0:D0c:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F440 (); */
  PC = cia;
  store_byte ((State.regs[REG_A0 + AN0] + State.regs[REG_D0 + DI]),
	      State.regs[REG_D0 + DM2]);
}


// 0000 Dm10 abs16...; movbu Dm,(abs16) (abs16 is zero-extended)
4.0x0,2.DM1,10+8.IMM16A+8.IMM16B:S2a:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_20000 (); */
  PC = cia;
  store_byte (FETCH16(IMM16A, IMM16B),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 1000 Dm10 abs32...; movbu Dm,(abs32)
8.0xfc+4.0x8,2.DM1,10+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4e:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FC820000 (); */
  PC = cia;
  store_byte (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DM1]);
}


// 1111 0000 0110 DnAm; movhu (Am),Dn
8.0xf0+4.0x6,2.DN1,2.AM0:D0:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F060 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_half (State.regs[REG_A0 + AM0]);
}


// 1111 1000 0110 DnAm d8......; movhu (d8,Am),Dn (d8 is sign-extended)
8.0xf8+4.0x6,2.DN1,2.AM0+8.D8:D1d:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F86000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_half ((State.regs[REG_A0 + AM0] + EXTEND8 (D8)));
}


// 1111 1010 0110 DnAm d16.....; movhu (d16,Am),Dn (d16 is sign-extended.)
8.0xfa+4.0x6,2.DN1,2.AM0+8.D16A+8.D16B:D2:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FA600000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_half ((State.regs[REG_A0 + AM0]
		  + EXTEND16 (FETCH16(D16A, D16B))));
}


// 1111 1100 0110 DnAm d32.....; movhu (d32,Am),Dn
8.0xfc+4.0x6,2.DN1,2.AM0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FC600000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_half ((State.regs[REG_A0 + AM0]
		  + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
}


// 1111 1000 1011 11Dn d8.....; movhu (d8,SP),Dn (d8 is zero-extended)
8.0xf8+4.0xb,11,2.DN0+8.D8:D1a:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F8BC00 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_half ((State.regs[REG_SP] + (D8)));
}


// 1111 1010 1011 11Dn d16.....; movhu (d16,SP),Dn (d16 is zero-extended.)
8.0xfa+4.0xb,11,2.DN0+8.IMM16A+8.IMM16B:D2a:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FABC0000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_half ((State.regs[REG_SP] + FETCH16(IMM16A, IMM16B)));
}


// 1111 1100 1011 11Dn d32.....; movhu (d32,SP),Dn
8.0xfc+4.0xb,11,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FCBC0000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_half (State.regs[REG_SP] + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0100 10Dn DiAm; movhu (Di,Am),Dn
8.0xf4+10,2.DN2,2.DI,2.AM0:D0a:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F480 (); */
  PC = cia;
  State.regs[REG_D0 + DN2]
    = load_half ((State.regs[REG_A0 + AM0] + State.regs[REG_D0 + DI]));
}


// 0011 10Dn abs16...; movhu (abs16),Dn (abs16 is zero-extended)
4.0x3,10,2.DN0+8.IMM16A+8.IMM16B:S2:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_380000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = load_half (FETCH16(IMM16A, IMM16B));
}


// 1111 1100 1010 11Dn abs32...; movhu (abs32),Dn
8.0xfc+4.0xa,11,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4b:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FCAC0000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_half (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0000 0111 DmAn; movhu Dm,(An)
8.0xf0+4.0x7,2.DM1,2.AN0:D0b:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F070 (); */
  PC = cia;
  store_half (State.regs[REG_A0 + AN0],
	      State.regs[REG_D0 + DM1]);
}


// 1111 1000 0111 DmAn d8......; movhu Dm,(d8,An) (d8 is sign-extended)
8.0xf8+4.0x7,2.DM1,2.AN0+8.D8:D1b:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F87000 (); */
  PC = cia;
  store_half ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1010 0111 DnAm d16.....; movhu Dm,(d16,An) (d16 is sign-extended.)
8.0xfa+4.0x7,2.DM1,2.AN0+8.D16A+8.D16B:D2b:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FA700000 (); */
  PC = cia;
  store_half ((State.regs[REG_A0 + AN0] + EXTEND16 (FETCH16(D16A, D16B))),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 0111 DmAn d32.....; movhu Dm,(d32,An)
8.0xfc+4.0x7,2.DM1,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4c:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FC700000 (); */
  PC = cia;
  store_half ((State.regs[REG_A0 + AN0]
	       + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1000 1001 Dm11 d8....; movhu Dm,(d8,SP) (d8 is zero-extended)
8.0xf8+4.0x9,2.DM1,11+8.D8:D1c:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F89300 (); */
  PC = cia;
  store_half (State.regs[REG_SP] + (D8),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1010 1001 Dm11 d16.....; movhu Dm,(d16,SP) (d16 is zero-extended.)
8.0xfa+4.0x9,2.DM1,11+8.IMM16A+8.IMM16B:D2c:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FA930000 (); */
  PC = cia;
  store_half (State.regs[REG_SP] + FETCH16(IMM16A, IMM16B),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 1001 Dm11 d32.....; movhu Dm,(d32,SP)
8.0xfc+4.0x9,2.DM1,11+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4d:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FC930000 (); */
  PC = cia;
  store_half (State.regs[REG_SP] + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DM1]);
}


// 1111 0100 11Dm DiAn; movhu Dm,(Di,An)
8.0xf4+11,2.DM2,2.DI,2.AN0:D0c:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F4C0 (); */
  PC = cia;
  store_half ((State.regs[REG_A0 + AN0] + State.regs[REG_D0 + DI]),
	      State.regs[REG_D0 + DM2]);
}


// 0000 Dm11 abs16...; movhu Dm,(abs16) (abs16 is zero-extended)
4.0x0,2.DM1,11+8.IMM16A+8.IMM16B:S2a:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_30000 (); */
  PC = cia;
  store_half (FETCH16(IMM16A, IMM16B), State.regs[REG_D0 + DM1]);
}


// 1111 1100 1000 Dm11 abs32...; movhu Dm,(abs32)
8.0xfc+4.0x8,2.DM1,11+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4e:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FC830000 (); */
  PC = cia;
  store_half (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DM1]);
}


// 1111 0010 1101 00Dn; ext Dn
8.0xf2+4.0xd,00,2.DN0:D0:::ext
"ext"
*mn10300

*am33
*am33_2

{
  /* OP_F2D0 (); */
  PC = cia;
  if (State.regs[REG_D0 + DN0] & 0x80000000)
    State.regs[REG_MDR] = -1;
  else
    State.regs[REG_MDR] = 0;
}


// 0001 00Dn; extb Dn
4.0x1,00,2.DN0:S0:::extb
"extb"
*mn10300

*am33
*am33_2

{
  /* OP_10 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = EXTEND8 (State.regs[REG_D0 + DN0]);
}


// 0001 01Dn; extbu Dn
4.0x1,01,2.DN0:S0:::extbu
"extbu"
*mn10300

*am33
*am33_2

{
  /* OP_14 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] &= 0xff;
}


// 0001 10Dn; exth Dn
4.0x1,10,2.DN0:S0:::exth
"exth"
*mn10300

*am33
*am33_2

{
  /* OP_18 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = EXTEND16 (State.regs[REG_D0 + DN0]);
}


// 0001 11Dn; exthu Dn
4.0x1,11,2.DN0:S0:::exthu
"exthu"
*mn10300

*am33
*am33_2

{
  /* OP_1C (); */
  PC = cia;
  State.regs[REG_D0 + DN0] &= 0xffff;
}


// 0000 Dn00; clr Dn
4.0x0,2.DN1,00:S0:::clr
"clr"
*mn10300

*am33
*am33_2

{
  /* OP_0 (); */
  PC = cia;
  State.regs[REG_D0 + DN1] = 0;

  PSW |= PSW_Z;
  PSW &= ~(PSW_V | PSW_C | PSW_N);
}


// 1110 DmDn; add Dm,Dn
4.0xe,2.DM1,2.DN0:S0:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_E0 (); */
  PC = cia;
  genericAdd(State.regs[REG_D0 + DM1], REG_D0 + DN0);
}

// 1111 0001 0110 DmAn; add Dm,An
8.0xf1+4.0x6,2.DM1,2.AN0:D0:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_F160 (); */
  PC = cia;
  genericAdd(State.regs[REG_D0 + DM1], REG_A0 + AN0);
}


// 1111 0001 0101 AmDn; add Am,Dn
8.0xf1+4.0x5,2.AM1,2.DN0:D0a:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_F150 (); */
  PC = cia;
  genericAdd(State.regs[REG_A0 + AM1], REG_D0 + DN0);
}


// 1111 0001 0111 AmAn; add Am,An
8.0xf1+4.0x7,2.AM1,2.AN0:D0b:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_F170 (); */
  PC = cia;
  genericAdd(State.regs[REG_A0 + AM1], REG_A0 + AN0);
}


// 0010 10Dn imm8....; add imm8,Dn (imm8 is sign-extended)
4.0x2,10,2.DN0+8.IMM8:S1:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_2800 (); */
  PC = cia;
  genericAdd(EXTEND8(IMM8), REG_D0 + DN0);
}


// 1111 1010 1100 00Dn imm16...; add imm16,Dn
8.0xfa+4.0xc,00,2.DN0+8.IMM16A+8.IMM16B:D2:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_FAC00000 (); */
  PC = cia;
  genericAdd(EXTEND16(FETCH16(IMM16A, IMM16B)), REG_D0 + DN0);
}


// 1111 1100 1100 00Dn imm32...; add imm32,Dn
8.0xfc+4.0xc,00,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_FCC00000 (); */
  PC = cia;
  genericAdd(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), REG_D0 + DN0);
}


// 0010 00An imm8....; add imm8,An (imm8 is sign-extended)
4.0x2,00,2.AN0+8.IMM8:S1a:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_2000 (); */
  PC = cia;
  genericAdd(EXTEND8(IMM8), REG_A0 + AN0);
}


// 1111 1010 1101 00An imm16...; add imm16,An (imm16 is sign-extended.)
8.0xfa+4.0xd,00,2.AN0+8.IMM16A+8.IMM16B:D2a:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_FAD00000 (); */
  PC = cia;
  genericAdd(EXTEND16(FETCH16(IMM16A, IMM16B)), REG_A0 + AN0);
}


// 1111 1100 1101 00An imm32...; add imm32,An
8.0xfc+4.0xd,00,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_FCD00000 (); */
  PC = cia;
  genericAdd(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), REG_A0 + AN0);
}


// 1111 1000 1111 1110 imm8....; add imm8,SP (imm8 is sign-extended.)
8.0xf8+8.0xfe+8.IMM8:D1:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_F8FE00 (); */
  unsigned32 imm;

  /* Note: no PSW changes. */
  PC = cia;
  imm = EXTEND8 (IMM8);
  State.regs[REG_SP] += imm;
}


// 1111 1010 1111 1110 imm16...; add imm16,SP (imm16 is sign-extended.)
8.0xfa+8.0xfe+8.IMM16A+8.IMM16B:D2b:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_FAFE0000 (); */
  unsigned32 imm;

  /* Note: no PSW changes. */
  PC = cia;
  imm = EXTEND16 (FETCH16(IMM16A, IMM16B));
  State.regs[REG_SP] += imm;
}


// 1111 1100 1111 1110 imm32...; add imm32,SP
8.0xfc+8.0xfe+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4b:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_FCFE0000 (); */
  unsigned32 imm;

  /* Note: no PSW changes. */
  PC = cia;
  imm = FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
  State.regs[REG_SP] += imm;
}


// 1111 0001 0100 DmDn; addc Dm,Dn
8.0xf1+4.0x4,2.DM1,2.DN0:D0:::addc
"addc"
*mn10300

*am33
*am33_2

{
  /* OP_F140 (); */
  int z, c, n, v;
  unsigned32 reg1, reg2, sum;

  PC = cia;
  reg1 = State.regs[REG_D0 + DM1];
  reg2 = State.regs[REG_D0 + DN0];
  sum = reg1 + reg2 + ((PSW & PSW_C) != 0);
  State.regs[REG_D0 + DN0] = sum;

  z = ((PSW & PSW_Z) != 0) && (sum == 0);
  n = (sum & 0x80000000);
  c = (sum < reg1) || (sum < reg2);
  v = ((reg2 & 0x80000000) == (reg1 & 0x80000000)
       && (reg2 & 0x80000000) != (sum & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
	  | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}


// 1111 0001 0000 DmDn; sub Dm,Dn
8.0xf1+4.0x0,2.DM1,2.DN0:D0:::sub
"sub"
*mn10300

*am33
*am33_2

{
  /* OP_F100 (); */
  PC = cia;
  genericSub(State.regs[REG_D0 + DM1], REG_D0 + DN0);
}

// 1111 0001 0010 DmAn; sub DmAn
8.0xf1+4.0x2,2.DM1,2.AN0:D0a:::sub
"sub"
*mn10300

*am33
*am33_2

{
  /* OP_F120 (); */
  PC = cia;
  genericSub(State.regs[REG_D0 + DM1], REG_A0 + AN0);
}


// 1111 0001 0001 AmDn; sub AmDn
8.0xf1+4.0x1,2.AM1,2.DN0:D0b:::sub
"sub"
*mn10300

*am33
*am33_2

{
  /* OP_F110 (); */
  PC = cia;
  genericSub(State.regs[REG_A0 + AM1], REG_D0 + DN0);
}


// 1111 0001 0011 AmAn; sub Am,An
8.0xf1+4.0x3,2.AM1,2.AN0:D0c:::sub
"sub"
*mn10300

*am33
*am33_2

{
  /* OP_F130 (); */
  PC = cia;
  genericSub(State.regs[REG_A0 + AM1], REG_A0 + AN0);
}


// 1111 1100 1100 01Dn imm32...; sub imm32,Dn
8.0xfc+4.0xc,01,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::sub
"sub"
*mn10300

*am33
*am33_2

{
  /* OP_FCC40000 (); */
  PC = cia;
  genericSub(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), REG_D0 + DN0);
}


// 1111 1100 1101 01An imm32...; sub imm32,An
8.0xfc+4.0xd,01,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::sub
"sub"
*mn10300

*am33
*am33_2

{
  /* OP_FCD40000 (); */
  PC = cia;
  genericSub(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), REG_A0 + AN0);
}


// 1111 0001 1000 DmDn; subc Dm,Dn
8.0xf1+4.0x8,2.DM1,2.DN0:D0:::subc
"subc"
*mn10300

*am33
*am33_2

{
  /* OP_F180 (); */
  int z, c, n, v;
  unsigned32 reg1, reg2, difference;

  PC = cia;
  reg1 = State.regs[REG_D0 + DM1];
  reg2 = State.regs[REG_D0 + DN0];
  difference = reg2 - reg1 - ((PSW & PSW_C) != 0);
  State.regs[REG_D0 + DN0] = difference;

  z = ((PSW & PSW_Z) != 0) && (difference == 0);
  n = (difference & 0x80000000);
  c = (reg1 > reg2);
  v = ((reg2 & 0x80000000) != (reg1 & 0x80000000)
       && (reg2 & 0x80000000) != (difference & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
	  | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}


// 1111 0010 0100 DmDn; mul Dm,Dn
8.0xf2+4.0x4,2.DM1,2.DN0:D0:::mul
"mul"
*mn10300

*am33
*am33_2

{
  /* OP_F240 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]
          *  (signed64)(signed32)State.regs[REG_D0 + DM1]);
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 0010 0101 DmDn; mulu Dm,Dn
8.0xf2+4.0x5,2.DM1,2.DN0:D0:::mulu
"mulu"
*mn10300

*am33
*am33_2

{
  /* OP_F250 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((unsigned64)State.regs[REG_D0 + DN0]
          * (unsigned64)State.regs[REG_D0 + DM1]);
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 0010 0110 DmDn; div Dm,Dn
8.0xf2+4.0x6,2.DM1,2.DN0:D0:::div
"div"
*mn10300

*am33
*am33_2

{
  /* OP_F260 (); */
  signed64 temp;
  signed32 denom;
  int n, z, v;

  PC = cia;
  denom = (signed32)State.regs[REG_D0 + DM1];

  temp = State.regs[REG_MDR];
  temp <<= 32;
  temp |= State.regs[REG_D0 + DN0];
  if ( !(v = (0 == denom)) )
    {
      State.regs[REG_MDR] = temp % (signed32)State.regs[REG_D0 + DM1];
      temp /= (signed32)State.regs[REG_D0 + DM1];
      State.regs[REG_D0 + DN0] = temp & 0xffffffff;
    }
  else
    {
      State.regs[REG_MDR] = temp;
      State.regs[REG_D0 + DN0] = 0xff;
    }
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (v ? PSW_V : 0));
}


// 1111 0010 0111 DmDn; divu Dm,Dn
8.0xf2+4.0x7,2.DM1,2.DN0:D0:::divu
"divu"
*mn10300

*am33
*am33_2

{
  /* OP_F270 (); */
  unsigned64 temp;
  unsigned32 denom;
  int n, z, v;

  PC = cia;
  denom = (unsigned32)State.regs[REG_D0 + DM1];
  temp = State.regs[REG_MDR];
  temp <<= 32;
  temp |= State.regs[REG_D0 + DN0];
  if ( !(v = (0 == denom)) ) 
    {
      State.regs[REG_MDR] = temp % State.regs[REG_D0 + DM1];
      temp /= State.regs[REG_D0 + DM1];
      State.regs[REG_D0 + DN0] = temp & 0xffffffff;
    }
  else
    {
      State.regs[REG_MDR] = temp;
      State.regs[REG_D0 + DN0] = 0xff;
    }
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (v ? PSW_V : 0));
}


// 0100 Dn00; inc Dn
4.0x4,2.DN1,00:S0:::inc
"inc"
*mn10300

*am33
*am33_2

{
  /* OP_40 (); */
  unsigned32 imm;

  PC = cia;
  imm = 1;
  genericAdd(imm, REG_D0 + DN1);
}


// 0100 An01
4.0x4,2.AN1,01:S0a:::inc
"inc"
*mn10300

*am33
*am33_2

{
  /* OP_41 (); */
  PC = cia;
  State.regs[REG_A0 + AN1] += 1;
}


// 0101 00An; inc4 An
4.0x5,00,2.AN0:S0:::inc4
"inc4"
*mn10300

*am33
*am33_2

{
  /* OP_50 (); */
  PC = cia;
  State.regs[REG_A0 + AN0] += 4;
}


// 1010 DnDn imm8....; cmp imm8,Dn (imm8 is sign-extended.)
4.0xa,2.DM1,2.DN0=DM1+IMM8:S0i:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  PC = cia;
  /* OP_A000 (); */
  genericCmp(EXTEND8 (IMM8), State.regs[REG_D0 + DN0]);
}


// 1010 DmDn; cmp Dm,Dn (Dm != Dn, see above when Dm == Dn)
4.0xa,2.DM1,2.DN0!DM1:S0:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  PC = cia;
  /* OP_A0 (); */
  genericCmp(State.regs[REG_D0 + DM1], State.regs[REG_D0 + DN0]);
}


// 1111 0001 1010 DmAn; cmp Dm,An
8.0xf1+4.0xa,2.DM1,2.AN0:D0:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  /* OP_F1A0 (); */
  PC = cia;
  genericCmp(State.regs[REG_D0 + DM1], State.regs[REG_A0 + AN0]);
}


// 1111 0001 1001 AmDn; cmp Am,Dn
8.0xf1+4.0x9,2.AM1,2.DN0:D0a:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  /* OP_F190 (); */
  PC = cia;
  genericCmp(State.regs[REG_A0 + AM1], State.regs[REG_D0 + DN0]);
}


// 1011 AnAn imm8....; cmp imm8,An (imm8 is zero-extended.)
4.0xb,2.AM1,2.AN0=AM1+IMM8:S0ai:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  PC = cia;
  /* OP_B000 (); */
  genericCmp(IMM8,
	     State.regs[REG_A0 + AN0]);
}


// 1011 AmAn; cmp Am,An (Dm != Dn, see above when Dm == Dn)
4.0xb,2.AM1,2.AN0!AM1:S0a:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  PC = cia;
  /* OP_B0 (); */
  genericCmp(State.regs[REG_A0 + AM1], State.regs[REG_A0 + AN0]);
}


// 1111 1010 1100 10Dn imm16...; cmp imm16,Dn (imm16 is sign-extended.)
8.0xfa+4.0xc,10,2.DN0+8.IMM16A+8.IMM16B:D2:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  /* OP_FAC80000 (); */
  PC = cia;
  genericCmp(EXTEND16(FETCH16(IMM16A, IMM16B)),
	     State.regs[REG_D0 + DN0]);
}


// 1111 1100 1100 10Dn imm32...; cmp imm32,Dn
8.0xfc+4.0xc,10,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  /* OP_FCC80000 (); */
  PC = cia;
  genericCmp(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	     State.regs[REG_D0 + DN0]);
}


// 1111 1010 1101 10An imm16...; cmp imm16,An (imm16 is zero-extended.)
8.0xfa+4.0xd,10,2.AN0+8.IMM16A+8.IMM16B:D2a:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  /* OP_FAD80000 (); */
  PC = cia;
  genericCmp(FETCH16(IMM16A, IMM16B),
	     State.regs[REG_A0 + AN0]);
}


// 1111 1100 1101 10An imm32...; cmp imm32,An
8.0xfc+4.0xd,10,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  /* OP_FCD80000 (); */
  PC = cia;
  genericCmp(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	     State.regs[REG_A0 + AN0]);
}


// 1111 0010 0000 DmDn; and Dm,Dn
8.0xf2+4.0x0,2.DM1,2.DN0:D0:::and
"and"
*mn10300

*am33
*am33_2

{
  /* OP_F200 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0] &= State.regs[REG_D0 + DM1];
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1000 1110 00Dn imm8....; and imm8,Dn (imm8 is zero-extended.)
8.0xf8+4.0xe,00,2.DN0+8.IMM8:D1:::and
"and"
*mn10300

*am33
*am33_2

{
  /* OP_F8E000 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0] &= IMM8;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1010 1110 00Dn imm16...; and imm16,Dn (imm16 is zero-extended.)
8.0xfa+4.0xe,00,2.DN0+8.IMM16A+8.IMM16B:D2:::and
"and"
*mn10300

*am33
*am33_2

{
  /* OP_FAE00000 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0] &= FETCH16(IMM16A, IMM16B);
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1100 1110 00Dn imm32...; and imm32,Dn
8.0xfc+4.0xe,00,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::and
"and"
*mn10300

*am33
*am33_2

{
  /* OP_FCE00000 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0]
    &= FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1010 1111 1100 imm16...; and imm16,PSW (imm16 is zero-extended.)
8.0xfa+8.0xfc+8.IMM16A+8.IMM16B:D2a:::and
"and"
*mn10300

*am33
*am33_2

{
  /* OP_FAFC0000 (); */
  PC = cia;
  PSW &= FETCH16(IMM16A, IMM16B);
}



// 1111 0010 0001 DmDn; or DmDn
8.0xf2+4.0x1,2.DM1,2.DN0:D0:::or
"or"
*mn10300

*am33
*am33_2

{
  /* OP_F210 (); */
  PC = cia;
  genericOr(State.regs[REG_D0 + DM1], REG_D0 + DN0);
}


// 1111 1000 1110 01Dn imm8....; or imm8,Dn (imm8 is zero-extended.)n
8.0xf8+4.0xe,01,2.DN0+8.IMM8:D1:::or
"or"
*mn10300

*am33
*am33_2

{
  /* OP_F8E400 (); */
  PC = cia;
  genericOr(IMM8, REG_D0 + DN0);
}


// 1111 1010 1110 01Dn imm16...; or imm16,DN (imm16 is zero-extended.)
8.0xfa+4.0xe,01,2.DN0+8.IMM16A+8.IMM16B:D2:::or
"or"
*mn10300

*am33
*am33_2

{
  /* OP_FAE40000 (); */
  PC = cia;
  genericOr(FETCH16(IMM16A, IMM16B), REG_D0 + DN0);
}


// 1111 1100 1110 01Dn imm32...; or imm32,Dn
8.0xfc+4.0xe,01,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::or
"or"
*mn10300

*am33
*am33_2

{
  /* OP_FCE40000 (); */
  PC = cia;
  genericOr(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), REG_D0 + DN0);
}


// 1111 1010 1111 1101 imm16...; or imm16,PSW (imm16 is zero-extended.)
8.0xfa+8.0xfd+8.IMM16A+8.IMM16B:D2a:::or
"or"
*mn10300

*am33
*am33_2

{
  /* OP_FAFD0000 (); */
  PC = cia;
  PSW |= FETCH16(IMM16A, IMM16B);
}


// 1111 0010 0010 DmDn; xor Dm,Dn
8.0xf2+4.0x2,2.DM1,2.DN0:D0:::xor
"xor"
*mn10300

*am33
*am33_2

{
  /* OP_F220 (); */
  PC = cia;
  genericXor(State.regs[REG_D0 + DM1], REG_D0 + DN0);
}


// 1111 1010 1110 10Dn imm16...; xor imm16,Dn (imm16 is zero-extended.)
8.0xfa+4.0xe,10,2.DN0+8.IMM16A+8.IMM16B:D2:::xor
"xor"
*mn10300

*am33
*am33_2

{
  /* OP_FAE80000 (); */
  PC = cia;
  genericXor(FETCH16(IMM16A, IMM16B), REG_D0 + DN0);
}


// 1111 1100 1110 10Dn imm32...; xor imm32,Dn
8.0xfc+4.0xe,10,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::xor
"xor"
*mn10300

*am33
*am33_2

{
  /* OP_FCE80000 (); */
  PC = cia;
  genericXor(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), REG_D0 + DN0);
}


// 1111 0010 0011 00Dn; not Dn
8.0xf2+4.0x3,00,2.DN0:D0:::not
"not"
*mn10300

*am33
*am33_2

{
  /* OP_F230 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0] = ~State.regs[REG_D0 + DN0];
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1000 1110 11Dn imm8....; btst imm8,Dn (imm8 is zero-extended.)
8.0xf8+4.0xe,11,2.DN0+8.IMM8:D1:::btst
"btst"
*mn10300

*am33
*am33_2

{
  /* OP_F8EC00 (); */
  PC = cia;
  genericBtst(IMM8, State.regs[REG_D0 + DN0]);
}


// 1111 1010 1110 11Dn imm16.....; btst imm16,Dn (imm16 is zero-extended.)
8.0xfa+4.0xe,11,2.DN0+8.IMM16A+8.IMM16B:D2:::btst
"btst"
*mn10300

*am33
*am33_2

{
  /* OP_FAEC0000 (); */
  PC = cia;
  genericBtst(FETCH16(IMM16A, IMM16B), State.regs[REG_D0 + DN0]);
}


// 1111 1100 1110 11Dn imm32...; btst imm32,Dn
8.0xfc+4.0xe,11,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::btst
"btst"
*mn10300

*am33
*am33_2

{
  /* OP_FCEC0000 (); */
  PC = cia;
  genericBtst(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DN0]);
}


// 1111 1110 0000 0010 abs32... imm8....; btst imm8,(abs32) (imm8 is zero-extended., processing unit: byte)
8.0xfe+8.0x02+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D+8.IMM8:D5:::btst
"btst"
*mn10300

*am33
*am33_2

{
  /* OP_FE020000 (); */
  PC = cia;
  genericBtst(IMM8,
	      load_byte(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
}


// 1111 1010 1111 10An d8...... imm8....; 
// btst imm8,(d8,An) (d8 is sign-extended,imm8 is zero-extended., processing unit: byte)
8.0xfa+4.0xf,10,2.AN0+8.D8+8.IMM8:D2a:::btst
"btst"
*mn10300

*am33
*am33_2

{
  /* OP_FAF80000 (); */
  PC = cia;
  genericBtst(IMM8,
	      load_byte(State.regs[REG_A0 + AN0] + EXTEND8(D8)));
}


// 1111 0000 1000 DmAn; bset Dm,(An) (Processing unit byte)
8.0xf0+4.8,2.DM1,2.AN0:D0:::bset
"bset"
*mn10300

*am33
*am33_2

{
  /* OP_F080 (); */
  unsigned32 temp;
  int z;

  PC = cia;
  temp = load_byte (State.regs[REG_A0 + AN0]);
  z = (temp & State.regs[REG_D0 + DM1]) == 0;
  temp |= State.regs[REG_D0 + DM1];
  store_byte (State.regs[REG_A0 + AN0], temp);
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0);
}


// 1111 1110 0000 0000 abs32... imm8....;
// bset imm8,(abs32) (imm8 is zero-extended., processing unit: byte)
8.0xfe+8.0x00+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D+8.IMM8:D5:::bset
"bset"
*mn10300

*am33
*am33_2

{
  /* OP_FE000000 (); */
  unsigned32 temp;
  int z;

  PC = cia;
  temp = load_byte (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
  z = (temp & IMM8) == 0;
  temp |= IMM8;
  store_byte (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), temp);
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0);
}


// 1111 1010 1111 00AnAn d8...... imm8....;
// bset imm8,(d8,An) (d8 is sign-extended, imm8 is zero-extended., processing unit: byte)
8.0xfa+4.0xf,00,2.AN0+8.D8+8.IMM8:D2:::bset
"bset"
*mn10300

*am33
*am33_2

{
  /* OP_FAF00000 (); */
  unsigned32 temp;
  int z;

  PC = cia;
  temp = load_byte ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)));
  z = (temp & (IMM8)) == 0;
  temp |= (IMM8);
  store_byte ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)), temp);
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0);
}


// 1111 0000 1001 DmAn; bclr Dm,(An) (Processing unit byte)
8.0xf0+4.0x9,2.DM1,2.AN0:D0:::bclr
"bclr"
*mn10300

*am33
*am33_2

{
  /* OP_F090 (); */
  unsigned32 temp;
  int z;

  PC = cia;
  temp = load_byte (State.regs[REG_A0 + AN0]);
  z = (temp & State.regs[REG_D0 + DM1]) == 0;
  temp = temp & ~State.regs[REG_D0 + DM1];
  store_byte (State.regs[REG_A0 + AN0], temp);
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0);
}


// 1111 1110 0000 0001 abs32... imm8....;
// bclr imm8,(abs32) (imm8 is zero-extended., processing unit: byte)
8.0xfe+8.0x01+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D+8.IMM8:D5:::bclr
"bclr"
*mn10300

*am33
*am33_2

{
  /* OP_FE010000 (); */
  unsigned32 temp;
  int z;

  PC = cia;
  temp = load_byte (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
  z = (temp & IMM8) == 0;
  temp = temp & ~(IMM8);
  store_byte (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), temp);
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0);
}


// 1111 1010 1111 01An d8...... imm8....;
// bclr imm8,(d8,An) (d8 is sign-extended, imm8 is zero-extended., processing unit: byte)
8.0xfa+4.0xf,01,2.AN0+8.D8+8.IMM8:D2:::bclr
"bclr"
*mn10300

*am33
*am33_2

{
  /* OP_FAF40000 (); */
  unsigned32 temp;
  int z;

  PC = cia;
  temp = load_byte ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)));
  z = (temp & (IMM8)) == 0;
  temp = temp & ~(IMM8);
  store_byte ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)), temp);
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0);
}


// 1111 0010 1011 DmDn; asr Dm,Dn
8.0xf2+4.0xb,2.DM1,2.DN0:D0:::asr
"asr"
*mn10300

*am33
*am33_2

{
  /* OP_F2B0 (); */
  signed32 temp;
  int z, n, c;

  PC = cia;
  temp = State.regs[REG_D0 + DN0];
  c = temp & 1;
  temp >>= State.regs[REG_D0 + DM1];
  State.regs[REG_D0 + DN0] = temp;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1111 1000 1100 10Dn imm8...; asr imm8,Dn (imm8 is zero-extended.)
8.0xf8+4.0xc,10,2.DN0+8.IMM8:D1:::asr
"asr"
*mn10300

*am33
*am33_2

{
  /* OP_F8C800 (); */
  signed32 temp;
  int z, n, c;

  PC = cia;
  temp = State.regs[REG_D0 + DN0];
  c = temp & 1;
  temp >>= IMM8;
  State.regs[REG_D0 + DN0] = temp;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1111 0010 1010 DmDn; lsr Dm,Dn
8.0xf2+4.0xa,2.DM1,2.DN0:D0:::lsr
"lsr"
*mn10300

*am33
*am33_2

{
  /* OP_F2A0 (); */
  int z, n, c;

  PC = cia;
  c = State.regs[REG_D0 + DN0] & 1;
  State.regs[REG_D0 + DN0]
    >>= State.regs[REG_D0 + DM1];
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1111 1000 1100 01Dn imm8...; lsr imm8,Dn (imm8 is zero-extended.)
8.0xf8+4.0xc,01,2.DN0+8.IMM8:D1:::lsr
"lsr"
*mn10300

*am33
*am33_2

{
  /* OP_F8C400 (); */
  int z, n, c;

  PC = cia;
  c = State.regs[REG_D0 + DN0] & 1;
  State.regs[REG_D0 + DN0] >>=  IMM8;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1111 0010 1001 DmDn; asl Dm,Dn
8.0xf2+4.0x9,2.DM1,2.DN0:D0:::asl
"asl"
*mn10300

*am33
*am33_2

{
  /* OP_F290 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0]
    <<= State.regs[REG_D0 + DM1];
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1000 1100 00Dn imm8...; asl imm8,Dn (imm8 is zero-extended.)
8.0xf8+4.0xc,00,2.DN0+8.IMM8:D1:::asl
"asl"
*mn10300

*am33
*am33_2

{
  /* OP_F8C000 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0] <<= IMM8;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 0101 01Dn; als2 Dn
4.0x5,01,2.DN0:S0:::asl2
"asl2"
*mn10300

*am33
*am33_2

{
  /* OP_54 (); */
  int n, z;
  PC = cia;

  State.regs[REG_D0 + DN0] <<= 2;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 0010 1000 01Dn; ror Dn
8.0xf2+4.0x8,01,2.DN0:D0:::ror
"ror"
*mn10300

*am33
*am33_2

{
  /* OP_F284 (); */
  unsigned32 value;
  int c,n,z;

  PC = cia;
  value = State.regs[REG_D0 + DN0];
  c = (value & 0x1);

  value >>= 1;
  value |= ((PSW & PSW_C) != 0) ? 0x80000000 : 0;
  State.regs[REG_D0 + DN0] = value;
  z = (value == 0);
  n = (value & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1111 0010 1000 00Dn; rol Dn
8.0xf2+4.0x8,00,2.DN0:D0:::rol
"rol"
*mn10300

*am33
*am33_2

{
  /* OP_F280 (); */
  unsigned32 value;
  int c,n,z;

  PC = cia;
  value = State.regs[REG_D0 + DN0];
  c = (value & 0x80000000) ? 1 : 0;

  value <<= 1;
  value |= ((PSW & PSW_C) != 0);
  State.regs[REG_D0 + DN0] = value;
  z = (value == 0);
  n = (value & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1100 1000 d8......; beq (d8,PC) (d8 is sign-extended)
8.0xc8+8.D8:S1:::beq
"beq"
*mn10300

*am33
*am33_2

{
  /* OP_C800 (); */
  PC = cia;
  if ((PSW & PSW_Z))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 1001 d8......; bne (d8,PC) (d8 is sign-extended)
8.0xc9+8.D8:S1:::bne
"bne"
*mn10300

*am33
*am33_2

{
  /* OP_C900 (); */
  PC = cia;
  if (!(PSW & PSW_Z))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0001 d8......; bgt (d8,PC) (d8 is sign-extended)
8.0xc1+8.D8:S1:::bgt
"bgt"
*mn10300

*am33
*am33_2

{
  /* OP_C100 (); */
  PC = cia;
  if (!((PSW & PSW_Z)
        || (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0))))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0010 d8......; bge (d8,PC) (d8 is sign-extended)
8.0xc2+8.D8:S1:::bge
"bge"
*mn10300

*am33
*am33_2

{
  /* OP_C200 (); */
  PC = cia;
  if (!(((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0)))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0011 d8......; ble (d8,PC) (d8 is sign-extended)
8.0xc3+8.D8:S1:::ble
"ble"
*mn10300

*am33
*am33_2

{
  /* OP_C300 (); */
  PC = cia;
  if ((PSW & PSW_Z)
      || (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0)))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0000 d8......; blt (d8,PC) (d8 is sign-extended)
8.0xc0+8.D8:S1:::blt
"blt"
*mn10300

*am33
*am33_2

{
  /* OP_C000 (); */
  PC = cia;
  if (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0101 d8......; bhi (d8,PC) (d8 is sign-extended)
8.0xc5+8.D8:S1:::bhi
"bhi"
*mn10300

*am33
*am33_2

{
  /* OP_C500 (); */
  PC = cia;
  if (!(((PSW & PSW_C) != 0) || (PSW & PSW_Z) != 0))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0110 d8......; bcc (d8,PC) (d8 is sign-extended)
8.0xc6+8.D8:S1:::bcc
"bcc"
*mn10300

*am33
*am33_2

{
  /* OP_C600 (); */
  PC = cia;
  if (!(PSW & PSW_C))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0101 d8......; bls (d8,PC) (d8 is sign-extended)
8.0xc7+8.D8:S1:::bls
"bls"
*mn10300

*am33
*am33_2

{
  /* OP_C700 (); */
  PC = cia;
  if (((PSW & PSW_C) != 0) || (PSW & PSW_Z) != 0)
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0100 d8......; bcs (d8,PC) (d8 is sign-extended)
8.0xc4+8.D8:S1:::bcs
"bcs"
*mn10300

*am33
*am33_2

{
  /* OP_C400 (); */
  PC = cia;
  if (PSW & PSW_C)
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1111 1000 1110 1000 d8......; bvc (d8,PC) (d8 is sign-extended)
8.0xf8+8.0xe8+8.D8:D1:::bvc
"bvc"
*mn10300

*am33
*am33_2

{
  /* OP_F8E800 (); */
  PC = cia;
  if (!(PSW & PSW_V))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1111 1000 1110 1001 d8......; bvs (d8,PC) (d8 is sign-extended)
8.0xf8+8.0xe9+8.D8:D1:::bvs
"bvs"
*mn10300

*am33
*am33_2

{
  /* OP_F8E900 (); */
  PC = cia;
  if (PSW & PSW_V)
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1111 1000 1110 1010 d8......; bnc (d8,PC) (d8 is sign-extended)
8.0xf8+8.0xea+8.D8:D1:::bnc
"bnc"
*mn10300

*am33
*am33_2

{
  /* OP_F8EA00 (); */
  PC = cia;
  if (!(PSW & PSW_N))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1111 1000 1110 1010 d8......; bns (d8,PC) (d8 is sign-extended)
8.0xf8+8.0xeb+8.D8:D1:::bns
"bns"
*mn10300

*am33
*am33_2

{
  /* OP_F8EB00 (); */
  PC = cia;
  if (PSW & PSW_N)
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 1010 d8......; bra (d8,PC) (d8 is sign-extended)
8.0xca+8.D8:S1:::bra
"bra"
*mn10300

*am33
*am33_2

{
  /* OP_CA00 (); */
  PC = cia;
  State.regs[REG_PC] += EXTEND8 (D8);
  nia = PC;
}


// 1101 1000; leq
8.0xd8:S0:::leq
"leq"
*mn10300

*am33
*am33_2

{
  /* OP_D8 (); */
  PC = cia;
  if (PSW & PSW_Z)
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 1001; lne
8.0xd9:S0:::lne
"lne"
*mn10300

*am33
*am33_2

{
  /* OP_D9 (); */
  PC = cia;
  if (!(PSW & PSW_Z))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0001; lgt
8.0xd1:S0:::lgt
"lgt"
*mn10300

*am33
*am33_2

{
  /* OP_D1 (); */
  PC = cia;
  if (!((PSW & PSW_Z)
        || (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0))))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0010; lge
8.0xd2:S0:::lge
"lge"
*mn10300

*am33
*am33_2

{
  /* OP_D2 (); */
  PC = cia;
  if (!(((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0)))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0011; lle
8.0xd3:S0:::lle
"lle"
*mn10300

*am33
*am33_2

{
  /* OP_D3 (); */
  PC = cia;
  if ((PSW & PSW_Z)
      || (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0)))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0000; llt
8.0xd0:S0:::llt
"llt"
*mn10300

*am33
*am33_2

{
  /* OP_D0 (); */
  PC = cia;
  if (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0101; lhi
8.0xd5:S0:::lhi
"lhi"
*mn10300

*am33
*am33_2

{
  /* OP_D5 (); */
  PC = cia;
  if (!(((PSW & PSW_C) != 0) || (PSW & PSW_Z) != 0))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0110; lcc
8.0xd6:S0:::lcc
"lcc"
*mn10300

*am33
*am33_2

{
  /* OP_D6 (); */
  PC = cia;
  if (!(PSW & PSW_C))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0111; lls
8.0xd7:S0:::lls
"lls"
*mn10300

*am33
*am33_2

{
  /* OP_D7 (); */
  PC = cia;
  if (((PSW & PSW_C) != 0) || (PSW & PSW_Z) != 0)
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0100; lcs
8.0xd4:S0:::lcs
"lcs"
*mn10300

*am33
*am33_2

{
  /* OP_D4 (); */
  PC = cia;
  if (PSW & PSW_C)
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 1010; lra
8.0xda:S0:::lra
"lra"
*mn10300

*am33
*am33_2

{
  /* OP_DA (); */
  PC = cia;
  State.regs[REG_PC] = State.regs[REG_LAR] - 4;
  nia = PC;
}


// 1101 1010; setlb
8.0xdb:S0:::setlb
"setlb"
*mn10300

*am33
*am33_2

{
  /* OP_DB (); */
  PC = cia;
  State.regs[REG_LIR] = load_word (State.regs[REG_PC] + 1);
  State.regs[REG_LAR] = State.regs[REG_PC] + 5;
}


// 1111 0000 1111 01An; jmp (An)
8.0xf0+4.0xf,01,2.AN0:D0:::jmp
"jmp"
*mn10300

*am33
*am33_2

{
  /* OP_F0F4 (); */
  PC = State.regs[REG_A0 + AN0];
  nia = PC;
}


// 1100 1100 d16.....; jmp (d16,PC) (d16 is sign-extended.)
8.0xcc+8.D16A+8.D16B:S2:::jmp
"jmp"
*mn10300

*am33
*am33_2

{
  /* OP_CC0000 (); */
  PC = cia + EXTEND16(FETCH16(D16A, D16B));
  nia = PC;
}


// 1101 1100 d32........; jmp (d32, PC)
8.0xdc+8.D32A+8.D32B+8.D32C+8.D32D:S4:::jmp
"jmp"
*mn10300

*am33
*am33_2

{
  /* OP_DC000000 (); */
  PC = cia + FETCH32(D32A, D32B, D32C, D32D);
  nia = PC;
}


// 1111 0000 1111 00An; calls (An)
8.0xf0+4.0xf,00,2.AN0:D0:::calls
"calls"
*mn10300

*am33
*am33_2

{
  /* OP_F0F0 (); */
  unsigned32 next_pc, sp;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = State.regs[REG_PC] + 2;
  store_word(sp, next_pc);
  State.regs[REG_MDR] = next_pc;
  State.regs[REG_PC] = State.regs[REG_A0 + AN0];
  nia = PC;
}


// 1111 1010 1111 1111 d16.....; calls (d16,PC) (d16 is sign-extended.)
8.0xfa+8.0xff+8.D16A+8.D16B:D2:::calls
"calls"
*mn10300

*am33
*am33_2

{
  /* OP_FAFF0000 (); */
  unsigned32 next_pc, sp;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = State.regs[REG_PC] + 4;
  store_word(sp, next_pc);
  State.regs[REG_MDR] = next_pc;
  State.regs[REG_PC] += EXTEND16 (FETCH16(D16A, D16B));
  nia = PC;
}


// 1111 1100 1111 1111 d32.....; calls (d32,PC)
8.0xfc+8.0xff+8.D32A+8.D32B+8.D32C+8.D32D:D4:::calls
"calls"
*mn10300

*am33
*am33_2

{
  /* OP_FCFF0000 (); */
  unsigned32 next_pc, sp;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = State.regs[REG_PC] + 6;
  store_word(sp, next_pc);
  State.regs[REG_MDR] = next_pc;
  State.regs[REG_PC] += FETCH32(D32A, D32B, D32C, D32D);
  nia = PC;
}


// 1111 0000 1111 1100; rets
8.0xf0+8.0xfc:D0:::rets
"rets"
*mn10300

*am33
*am33_2

{
  /* OP_F0FC (); */
  unsigned32 sp;

  sp = State.regs[REG_SP];
  State.regs[REG_PC] = load_word(sp);
  nia = PC;
}


// 1111 0000 1111 1101; rti
8.0xf0+8.0xfd:D0:::rti
"rti"
*mn10300

*am33
*am33_2

{
  /* OP_F0FD (); */
  unsigned32 sp;

  sp = State.regs[REG_SP];
  PSW = load_half(sp);
  State.regs[REG_PC] = load_word(sp+4);
  State.regs[REG_SP] +=8;
  nia = PC;
}


// 1111 0000 1111 1110; trap
8.0xf0+8.0xfe:D0:::trap
"trap"
*mn10300

*am33
*am33_2

{
  /* OP_F0FE (); */
  unsigned32 sp, next_pc;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = State.regs[REG_PC] + 2;
  store_word(sp, next_pc);
  nia = PC;
}


// 1111 0000 1111 1111; rtm
8.0xf0+8.0xff:D0:::rtm
"rtm"
*mn10300

*am33
*am33_2

{
  /* OP_F0FF (); */
  PC = cia;
  abort ();
}


// 1100 1011; nop
8.0xcb:S0:::nop
"nop"
*mn10300

*am33
*am33_2

{
  /* OP_CB (); */
  PC = cia;
}


// 1111 0101 0000  DmDn; udf20 Dm,Dn
8.0xf5+4.0x0,2.DM1,2.DN0:D0:::putx
"putx"
*mn10300
{
  /* OP_F500 (); */
  PC = cia;
  State.regs[REG_MDRQ] = State.regs[REG_D0 + DN0];
}


// 1111 0110 1111 DmDn; udf15 Dm,Dn
8.0xf6+4.0xf,2.DM1,2.DN0:D0:::getx
"getx"
*mn10300

*am33
*am33_2

{
  /* OP_F6F0 (); */
  int z, n;

  PC = cia;
  z = (State.regs[REG_MDRQ] == 0);
  n = ((State.regs[REG_MDRQ] & 0x80000000) != 0);
  State.regs[REG_D0 + DN0] = State.regs[REG_MDRQ];

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0) | (n ? PSW_N : 0);
}


// 1111 0110 0000 DmDn; udf00 Dm,Dn
8.0xf6+4.0x0,2.DM1,2.DN0:D0:::mulq
"mulq"
*mn10300

*am33
*am33_2

{
  /* OP_F600 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]
          *  (signed64)(signed32)State.regs[REG_D0 + DM1]);
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1001 0000 00Dn imm8....; udf00 imm8,Dn (imm8 is sign-extended.)
8.0xf9+4.0x,00,2.DN0+8.IMM8:D1:::mulq
"mulq"
*mn10300

*am33
*am33_2

{
  /* OP_F90000 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]
          * (signed64)(signed32)EXTEND8 (IMM8));
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1011 0000 00Dn imm16...; udf00 imm16,Dn (imm16 is sign-extended.)
8.0xfb+4.0x0,00,2.DN0+8.IMM16A+8.IMM16B:D2:::mulq
"mulq"
*mn10300

*am33
*am33_2

{
  /* OP_FB000000 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]
          * (signed64)(signed32)EXTEND16 (FETCH16(IMM16A, IMM16B)));
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1101 0000 00Dn imm32...; udf00 imm32,Dn
8.0xfd+4.0x0,00,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::mulq
"mulq"
*mn10300

*am33
*am33_2

{
  /* OP_FD000000 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]
          * (signed64)(signed32)(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 0110 0001 DmDn; udf01 Dm,Dn
8.0xf6+4.0x1,2.DM1,2.DN0:D0:::mulqu
"mulqu"
*mn10300

*am33
*am33_2

{
  /* OP_F610 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((unsigned64) State.regs[REG_D0 + DN0]
	  * (unsigned64) State.regs[REG_D0 + DM1]);
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1001 0001 01Dn imm8....; udfu01 imm8,Dn (imm8 is zero-extended.)
8.0xf9+4.0x1,01,2.DN0+8.IMM8:D1:::mulqu
"mulqu"
*mn10300

*am33
*am33_2

{
  /* OP_F91400 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((unsigned64)State.regs[REG_D0 + DN0]
	  * (unsigned64)EXTEND8 (IMM8));
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1011 0001 01Dn imm16...; udfu01 imm16,Dn (imm16 is zero-extended.)
8.0xfb+4.0x1,01,2.DN0+8.IMM16A+8.IMM16B:D2:::mulqu
"mulqu"
*mn10300

*am33
*am33_2

{
  /* OP_FB140000 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((unsigned64)State.regs[REG_D0 + DN0]
	  * (unsigned64) EXTEND16 (FETCH16(IMM16A, IMM16B)));
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1101 0001 01Dn imm32...; udfu01 imm32,Dn
8.0xfd+4.0x1,01,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::mulqu
"mulqu"
*mn10300

*am33
*am33_2

{
  /* OP_FD140000 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((unsigned64)State.regs[REG_D0 + DN0]
          * (unsigned64)(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 0110 0100 DmDn; udf04 Dm,Dn
8.0xf6+4.0x4,2.DM1,2.DN0:D0:::sat16
"sat16"
*mn10300

*am33
*am33_2

{
  /* OP_F640 (); */
  int temp;

  PC = cia;
  temp = State.regs[REG_D0 + DM1];
  temp = (temp > 0x7fff ? 0x7fff : temp);
  temp = (temp < -0x8000 ? -0x8000 : temp);
  State.regs[REG_D0 + DN0] = temp;
}


// 1111 0110 0101 DmDn; udf05 Dm,Dn
8.0xf6+4.0x5,2.DM1,2.DN0:D0:::sat24
"sat24"
*mn10300

*am33
*am33_2

{
  /* OP_F650 (); */
  int temp;

  PC = cia;
  temp = State.regs[REG_D0 + DM1];
  temp = (temp > 0x7fffff ? 0x7fffff : temp);
  temp = (temp < -0x800000 ? -0x800000 : temp);
  State.regs[REG_D0 + DN0] = temp;
}


// 1111 0110 0111 DmDn; udf07 Dm,Dn
8.0xf6+4.0x7,2.DM1,2.DN0:D0:::bsch
"bsch"
*mn10300

*am33
*am33_2

{
  /* OP_F670 (); */
  int temp, c;

  PC = cia;
  temp = State.regs[REG_D0 + DM1];
  temp <<= (State.regs[REG_D0 + DN0] & 0x1f);
  c = (temp != 0 ? 1 : 0);
  PSW &= ~(PSW_C);
  PSW |= (c ? PSW_C : 0);
}


// 1111 0000 1100 0000; syscall
8.0xf0+8.0xc0:D0:::syscall
"syscall"
*mn10300

*am33
*am33_2

{
  /* OP_F0C0 (); */
  PC = cia;
  do_syscall ();
}


// 1111 1111; break
8.0xff:S0:::break
"break"
*mn10300

*am33
*am33_2

{
  /* OP_FF (); */
  PC = cia;
  program_interrupt(SD, CPU, cia, SIM_SIGTRAP);
}

// 1100 1110 regs....; movm (SP),regs
8.0xce+8.REGS:S1:::movm
"movm"
*mn10300

*am33
*am33_2

{
  /* OP_CE00 (); */
  unsigned32 sp = State.regs[REG_SP];
  unsigned32 mask;

  PC = cia;
  mask = REGS;

  if (mask & 0x8)
    {
      sp += 4;
      State.regs[REG_LAR] = load_word (sp);
      sp += 4;
      State.regs[REG_LIR] = load_word (sp);
      sp += 4;
      State.regs[REG_MDR] = load_word (sp);
      sp += 4;
      State.regs[REG_A0 + 1] = load_word (sp);
      sp += 4;
      State.regs[REG_A0] = load_word (sp);
      sp += 4;
      State.regs[REG_D0 + 1] = load_word (sp);
      sp += 4;
      State.regs[REG_D0] = load_word (sp);
      sp += 4;
    }

  if (mask & 0x10)
    {
      State.regs[REG_A0 + 3] = load_word (sp);
      sp += 4;
    }

  if (mask & 0x20)
    {
      State.regs[REG_A0 + 2] = load_word (sp);
      sp += 4;
    }

  if (mask & 0x40)
    {
      State.regs[REG_D0 + 3] = load_word (sp);
      sp += 4;
    }

  if (mask & 0x80)
    {
      State.regs[REG_D0 + 2] = load_word (sp);
      sp += 4;
    }

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {
      if (mask & 0x1)
	{
	  /* Need to restore MDRQ, MCRH, MCRL, and MCVF */
	  sp += 16;
	  State.regs[REG_E0 + 1] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 0] = load_word (sp);
	  sp += 4;
	}

      if (mask & 0x2)
        {
	  State.regs[REG_E0 + 7] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 6] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 5] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 4] = load_word (sp);
	  sp += 4;
	}

      if (mask & 0x4)
	{
	  State.regs[REG_E0 + 3] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 2] = load_word (sp);
	  sp += 4;
	}
    }

  /* And make sure to update the stack pointer.  */
  State.regs[REG_SP] = sp;
}


// 1100 1111 regs....; movm regs,(SP)
8.0xcf+8.REGS:S1a:::movm
"movm"
*mn10300

*am33
*am33_2

{
  /* OP_CF00 (); */
  unsigned32 sp = State.regs[REG_SP];
  unsigned32 mask;

  PC = cia;
  mask = REGS;

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {
      if (mask & 0x4)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 2]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 3]);
	}

      if (mask & 0x2)
        {
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 4]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 5]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 6]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 7]);
	}

      if (mask & 0x1)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 0]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 1]);
	  sp -= 16;
	  /* Need to save MDRQ, MCRH, MCRL, and MCVF */
	}
    }

  if (mask & 0x80)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 2]);
    }

  if (mask & 0x40)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 3]);
    }

  if (mask & 0x20)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 2]);
    }

  if (mask & 0x10)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 3]);
    }

  if (mask & 0x8)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0]);
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 1]);
      sp -= 4;
      store_word (sp, State.regs[REG_A0]);
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 1]);
      sp -= 4;
      store_word (sp, State.regs[REG_MDR]);
      sp -= 4;
      store_word (sp, State.regs[REG_LIR]);
      sp -= 4;
      store_word (sp, State.regs[REG_LAR]);
      sp -= 4;
    }

  /* And make sure to update the stack pointer.  */
  State.regs[REG_SP] = sp;
}

// 1100 1101 d16..... regs.... imm8....;
// call (d16,PC),regs,imm8 (d16 is sign-extended., imm8 is zero-extended.)
8.0xcd+8.D16A+8.D16B+8.REGS+8.IMM8:S4:::call
"call"
*mn10300

*am33
*am33_2

{
  /* OP_CD000000 (); */
  unsigned32 next_pc, sp;
  unsigned32 mask;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = PC + 5;
  store_word(sp, next_pc);

  mask = REGS;

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {
      if (mask & 0x4)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 2]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 3]);
	}

      if (mask & 0x2)
        {
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 4]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 5]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 6]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 7]);
	}

      if (mask & 0x1)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 0]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 1]);
	  sp -= 16;
	  /* Need to save MDRQ, MCRH, MCRL, and MCVF */
	}
    }

  if (mask & 0x80)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 2]);
    }

  if (mask & 0x40)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 3]);
    }

  if (mask & 0x20)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 2]);
    }

  if (mask & 0x10)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 3]);
    }

  if (mask & 0x8)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0]);
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 1]);
      sp -= 4;
      store_word (sp, State.regs[REG_A0]);
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 1]);
      sp -= 4;
      store_word (sp, State.regs[REG_MDR]);
      sp -= 4;
      store_word (sp, State.regs[REG_LIR]);
      sp -= 4;
      store_word (sp, State.regs[REG_LAR]);
      sp -= 4;
    }

  /* Update the stack pointer, note that the register saves to do not
     modify SP.  The SP adjustment is derived totally from the imm8
     field.  */
  State.regs[REG_SP] -= IMM8;
  State.regs[REG_MDR] = next_pc;
  State.regs[REG_PC] += EXTEND16 (FETCH16(D16A, D16B));
  nia = PC;
}


// 1101 1101 d32..... regs.... imm8....;
// call (d32,PC),regs,imm8 (imm8 is zero-extended.)
8.0xdd+8.D32A+8.D32B+8.D32C+8.D32D+8.REGS+8.IMM8:S6:::call
"call"
*mn10300

*am33
*am33_2

{
  /* OP_DD000000 (); */
  unsigned32 next_pc, sp;
  unsigned32 mask;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = State.regs[REG_PC] + 7;
  /* could assert that nia == next_pc here */
  store_word(sp, next_pc);

  mask = REGS;

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {
      if (mask & 0x4)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 2]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 3]);
	}

      if (mask & 0x2)
        {
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 4]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 5]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 6]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 7]);
	}

      if (mask & 0x1)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 0]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 1]);
	  sp -= 16;
	  /* Need to save MDRQ, MCRH, MCRL, and MCVF */
	}
    }

  if (mask & 0x80)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 2]);
    }

  if (mask & 0x40)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 3]);
    }

  if (mask & 0x20)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 2]);
    }

  if (mask & 0x10)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 3]);
    }

  if (mask & 0x8)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0]);
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 1]);
      sp -= 4;
      store_word (sp, State.regs[REG_A0]);
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 1]);
      sp -= 4;
      store_word (sp, State.regs[REG_MDR]);
      sp -= 4;
      store_word (sp, State.regs[REG_LIR]);
      sp -= 4;
      store_word (sp, State.regs[REG_LAR]);
      sp -= 4;
    }

  /* Update the stack pointer, note that the register saves to do not
     modify SP.  The SP adjustment is derived totally from the imm8
     field.  */
  State.regs[REG_SP] -= IMM8;
  State.regs[REG_MDR] = next_pc;
  State.regs[REG_PC] += FETCH32(D32A, D32B, D32C, D32D);
  nia = PC;
}


// 1101 1111 regs.... imm8....; ret regs,imm8 (imm8 is zero-extended.)
8.0xdf+8.REGS+8.IMM8:S2:::ret
"ret"
*mn10300

*am33
*am33_2

{
  /* OP_DF0000 (); */
  unsigned32 sp, offset;
  unsigned32 mask;

  PC = cia;
  State.regs[REG_SP] += IMM8;
  sp = State.regs[REG_SP];

  offset = -4;
  mask = REGS;

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {

      if (mask & 0x4)
	{
	  State.regs[REG_E0 + 2] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 3] = load_word (sp + offset);
	  offset -= 4;
	}

      if (mask & 0x2)
        {
	  State.regs[REG_E0 + 4] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 5] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 6] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 7] = load_word (sp + offset);
	  offset -= 4;
	}

      if (mask & 0x1)
	{
	  /* Need to restore MDRQ, MCRH, MCRL, and MCVF */
	  offset -= 16;
	  State.regs[REG_E0 + 0] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 1] = load_word (sp + offset);
	  offset -= 4;
	}

    }

  if (mask & 0x80)
    {
      State.regs[REG_D0 + 2] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x40)
    {
      State.regs[REG_D0 + 3] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x20)
    {
      State.regs[REG_A0 + 2] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x10)
    {
      State.regs[REG_A0 + 3] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x8)
    {
      State.regs[REG_D0] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_D0 + 1] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_A0] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_A0 + 1] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_MDR] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_LIR] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_LAR] = load_word (sp + offset);
      offset -= 4;
    }

  /* Restore the PC value.  */
  State.regs[REG_PC] = load_word(sp);
  nia = PC;
}


// 1101 1110 regs.... imm8....; retf regs,imm8 (imm8 is zero-extended.)
8.0xde+8.REGS+8.IMM8:S2:::retf
"retf"
*mn10300

*am33
*am33_2

{
  /* OP_DE0000 (); */
  unsigned32 sp, offset;
  unsigned32 mask;

  PC = cia;
  State.regs[REG_SP] += IMM8;
  sp = State.regs[REG_SP];
  State.regs[REG_PC] = State.regs[REG_MDR];

  offset = -4;
  mask = REGS;

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {

      if (mask & 0x4)
	{
	  State.regs[REG_E0 + 2] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 3] = load_word (sp + offset);
	  offset -= 4;
	}

      if (mask & 0x2)
        {
	  State.regs[REG_E0 + 4] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 5] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 6] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 7] = load_word (sp + offset);
	  offset -= 4;
	}

      if (mask & 0x1)
	{
	  /* Need to restore MDRQ, MCRH, MCRL, and MCVF */
	  offset -= 16;
	  State.regs[REG_E0 + 0] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 1] = load_word (sp + offset);
	  offset -= 4;
	}

    }

  if (mask & 0x80)
    {
      State.regs[REG_D0 + 2] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x40)
    {
      State.regs[REG_D0 + 3] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x20)
    {
      State.regs[REG_A0 + 2] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x10)
    {
      State.regs[REG_A0 + 3] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x8)
    {
      State.regs[REG_D0] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_D0 + 1] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_A0] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_A0 + 1] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_MDR] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_LIR] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_LAR] = load_word (sp + offset);
      offset -= 4;
    }
  nia = PC;
}


:include::am33:am33.igen

