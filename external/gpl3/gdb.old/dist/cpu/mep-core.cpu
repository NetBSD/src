; Toshiba MeP Media Engine architecture description.  -*- Scheme -*-
; Copyright 2011 Free Software Foundation, Inc.
;
; Contributed by Red Hat Inc;
;
; This file is part of the GNU Binutils.
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
; MA 02110-1301, USA.

(include "simplify.inc")

(define-pmacro isa-enum ()
  (isas mep 
; begin-isa-enum
	ext_core1 ext_cop1_16 ext_cop1_32 ext_cop1_48 ext_cop1_64
; end-isa-enum
  )
)

(define-arch
  (name mep)
  (comment "Toshiba MeP Media Engine")
  (insn-lsb0? #f) ;; work around cgen limitation
  (machs mep h1 c5)
  isa-enum
)

(define-isa
  (name mep)
  (comment "MeP core instruction set")
  (default-insn-word-bitsize 32)
  (default-insn-bitsize 32)
  (base-insn-bitsize 32)
)

; begin-isas
(define-isa
  (name ext_core1)
  (comment "MeP core extension instruction set")
  (default-insn-word-bitsize 32)
  (default-insn-bitsize 32)
  (base-insn-bitsize 32)
)

(define-isa
  (name ext_cop1_16)
  (comment "MeP coprocessor instruction set")
  (default-insn-word-bitsize 32)
  (default-insn-bitsize 32)
  (base-insn-bitsize 32)
)

(define-isa
  (name ext_cop1_32)
  (comment "MeP coprocessor instruction set")
  (default-insn-word-bitsize 32)
  (default-insn-bitsize 32)
  (base-insn-bitsize 32)
)

(define-isa
  (name ext_cop1_48)
  (comment "MeP coprocessor instruction set")
  (default-insn-word-bitsize 32)
  (default-insn-bitsize 32)
  (base-insn-bitsize 32)
)

(define-isa
  (name ext_cop1_64)
  (comment "MeP coprocessor instruction set")
  (default-insn-word-bitsize 32)
  (default-insn-bitsize 32)
  (base-insn-bitsize 32)
)

(define-pmacro all-mep-isas () (ISA mep,ext_core1,ext_cop1_16,ext_cop1_32,ext_cop1_48,ext_cop1_64))

(define-pmacro all-mep-core-isas () (ISA mep,ext_core1,ext_cop1_32))

(define-pmacro all-core-isa-list () mep,ext_core1)
; end-isas

(define-cpu
  (name mepf)
  (comment "MeP family")
  (endian either)
  (insn-chunk-bitsize 16)
  (word-bitsize 32)
)

(define-mach
  (name mep)
  (comment "MeP media engine")
  (cpu mepf)
  isa-enum
)

(define-mach
  (name h1)
  (comment "H1 media engine")
  (cpu mepf)
  isa-enum
)

(define-mach
  (name c5)
  (comment "C5 media engine")
  (cpu mepf)
  isa-enum
)

(define-model
  (name mep)
  (comment "MeP media engine processor")
  (mach c5) ; mach gets changed by MeP-Integrator

  (unit u-exec "execution unit" ()
	1 1 ; issue done
	() () () ())

  ; Branch unit
  (unit u-branch "Branch Unit" ()
	0 0 ; issue done
	() ; state
	() ; inputs
	((pc)) ; outputs
	() ; profile action (default)
	)

  ; Multiply unit
  (unit u-multiply "Multiply Unit" ()
	0 0 ; issue done
	() ; state
	() ; inputs
	() ; outputs
	() ; profile action (default)
	)

  ; Divide unit
  (unit u-divide "Divide Unit" ()
	0 0 ; issue done
	() ; state
	() ; inputs
	() ; outputs
	() ; profile action (default)
	)

  ; Stcb unit
  (unit u-stcb "stcb Unit" ()
	0 0 ; issue done
	() ; state
	() ; inputs
	() ; outputs
	() ; profile action (default)
	)

  ; Ldcb unit
  (unit u-ldcb "ldcb Unit" ()
	0 0 ; issue done
	() ; state
	() ; inputs
	() ; outputs
	() ; profile action (default)
	)

  ; Load gpr unit
  (unit u-load-gpr "Load into GPR Unit" ()
	0 0 ; issue done
	() ; state
	() ; inputs
	((loadreg INT -1)) ; outputs
	() ; profile action (default)
	)

  (unit u-ldcb-gpr "Ldcb into GPR Unit" ()
	0 0 ; issue done
	() ; state
	() ; inputs
	((loadreg INT -1)) ; outputs
	() ; profile action (default)
	)

  ; Multiply into GPR unit
  (unit u-mul-gpr "Multiply into GPR Unit" ()
	0 0 ; issue done
	() ; state
	() ; inputs
	((resultreg INT -1)) ; outputs
	() ; profile action (default)
	)

  ; Use gpr unit -- stalls if GPR not ready
  (unit u-use-gpr "Use GPR Unit" ()
	0 0 ; issue done
	() ; state
	((usereg INT -1)) ; inputs
	() ; outputs
	() ; profile action (default)
	)

  ; Use ctrl-reg unit -- stalls if CTRL-REG not ready
  (unit u-use-ctrl-reg "Use CTRL-REG Unit" ()
	0 0 ; issue done
	() ; state
	((usereg INT -1)) ; inputs
	() ; outputs
	() ; profile action (default)
	)

  ; Store ctrl-reg unit -- stalls if CTRL-REG not ready
  (unit u-store-ctrl-reg "Store CTRL-REG Unit" ()
	0 0 ; issue done
	() ; state
	() ; inputs
	((storereg INT -1)) ; outputs
	() ; profile action (default)
	)
)

; Hardware elements.

(dnh h-pc "program counter" (PC PROFILE all-mep-isas) (pc) () () ())

(define-hardware
  (name h-gpr)
  (comment "General purpose registers")
  (attrs all-mep-isas CACHE-ADDR PROFILE)
  (type register SI (16))
  (indices keyword "$"
	   (("0" 0) ("1" 1) ("2" 2) ("3" 3) ("4" 4) ("5" 5)
	    ("6" 6) ("7" 7) ("8" 8) ("9" 9) ("10" 10) ("11" 11)
	    ; "$8" is the preferred name for register 8, but "$tp", "$gp"
	    ; and "$sp" are preferred for their respective registers.
	    (fp  8) (tp 13) (gp 14) (sp 15)
	    ("12" 12) ("13" 13) ("14" 14) ("15" 15)))
)

(define-hardware
  (name h-csr)
  (comment "Control/special registers")
  (attrs all-mep-isas PROFILE)
  (type register SI (32))
  (indices keyword "$"
	   ((pc 0)   (lp 1)   (sar 2)   (rpb  4) (rpe 5)   (rpc 6)
	    (hi 7)   (lo 8)   (mb0 12)  (me0 13) (mb1 14)  (me1 15)
	    (psw 16) (id 17)  (tmp 18)  (epc 19) (exc 20)  (cfg 21)
	    (npc 23) (dbg 24) (depc 25) (opt 26) (rcfg 27) (ccfg 28)
; begin-extra-csr-registers
	    (vid 22)
; end-extra-csr-registers
  ))
  (get (index) (c-call SI "cgen_get_csr_value" index))
  (set (index newval) (c-call VOID "cgen_set_csr_value" index newval))
)

(define-pmacro (-reg-pair n) ((.sym n) n))
(define-hardware
  (name h-cr64)
  (comment "64-bit coprocessor registers")
  (attrs all-mep-isas)
  ; This assumes that the data path of the co-pro is 64 bits.
  (type register DI (32))
  (indices keyword "$c" (.map -reg-pair (.iota 32)))
  (set (index newval) (c-call VOID "h_cr64_queue_set" index newval))
)
(define-hardware
  (name h-cr64-w)
  (comment "64-bit coprocessor registers, pending writes")
  (attrs all-mep-isas)
  ; This assumes that the data path of the co-pro is 64 bits.
  (type register DI (32))
)

(define-hardware
  (name h-cr)
  (comment "32-bit coprocessor registers")
  (attrs all-mep-isas VIRTUAL)
  (type register SI (32))
  (indices keyword "$c" (.map -reg-pair (.iota 32)))
  (set (index newval) (c-call VOID "h_cr64_set" index (ext DI newval)))
  (get (index) (trunc SI (c-call DI "h_cr64_get" index)))
)

;; Given a coprocessor control register number N, expand to a
;; name/index pair: ($ccrN N)
(define-pmacro (-ccr-reg-pair n) ((.sym "$ccr" n) n))

(define-hardware
  (name h-ccr)
  (comment "Coprocessor control registers")
  (attrs all-mep-isas)
  (type register SI (64))
  (indices keyword "" (.map -ccr-reg-pair (.iota 64)))
  (set (index newval) (c-call VOID "h_ccr_queue_set" index newval))
)
(define-hardware
  (name h-ccr-w)
  (comment "Coprocessor control registers, pending writes")
  (attrs all-mep-isas)
  (type register SI (64))
)


; Instruction fields.  Bit numbering reversed.

; Conventions:
;
; N = number of bits in value
; A = alignment (2 or 4, omit for 1)
; B = leftmost (i.e. closest to zero) bit position
;
; -- Generic Fields (f-*) --
; N		number of bits in *value* (1-24)
; [us]		signed vs unsigned
; B		position of left-most bit (4-16)
; aA		opt. alignment (2=drop 1 lsb, 4=drop 2 lsbs, etc)
; n		opt. for noncontiguous fields
; f-foo-{hi,lo}	msb/lsb parts of field f-foo
;
; -- Operands --
; pcrelNaA	PC-relative branch target (signed)
; pcabsNaA	Absolute branch target (unsigned)
;
; [us]dispNaA	[un]signed displacement
; [us]immN	[un]signed immediate value
; addrNaA	absolute address (unsigned)
;
; Additional prefixes may be used for special cases.

(dnf f-major   "major opcode"            (all-mep-core-isas)    0  4)

(dnf f-rn      "register n"              (all-mep-core-isas)    4  4)
(dnf f-rn3     "register 0-7"            (all-mep-core-isas)    5  3)
(dnf f-rm      "register m"              (all-mep-core-isas)    8  4)
(dnf f-rl      "register l"              (all-mep-core-isas)   12  4)
(dnf f-sub2    "sub opcode (2 bits)"     (all-mep-core-isas)   14  2)
(dnf f-sub3    "sub opcode (3 bits)"     (all-mep-core-isas)   13  3)
(dnf f-sub4    "sub opcode (4 bits)"     (all-mep-core-isas)   12  4)
(dnf f-ext     "extended field"          (all-mep-core-isas)   16  8)
(dnf f-ext4    "extended field 16:4"     (all-mep-core-isas)   16  4)
(dnf f-ext62   "extended field 20:2"     (all-mep-core-isas)   20  2)
(dnf f-crn     "copro register n"        (all-mep-core-isas)    4  4)

(df f-csrn-hi "cr hi 1u15" (all-mep-core-isas) 15 1 UINT #f #f)
(df f-csrn-lo "cr lo 4u8"  (all-mep-core-isas)  8 4 UINT #f #f)
(define-multi-ifield
  (name f-csrn)
  (comment "control reg")
  (attrs all-mep-core-isas)
  (mode UINT)
  (subfields f-csrn-hi f-csrn-lo)
  (insert (sequence ()
		    (set (ifield f-csrn-lo) (and (ifield f-csrn) #xf))
		    (set (ifield f-csrn-hi) (srl (ifield f-csrn) 4))))
  (extract (set (ifield f-csrn)
		(or (sll (ifield f-csrn-hi) 4) (ifield f-csrn-lo))))
  )

(df f-crnx-hi "crx hi 1u28" (all-mep-core-isas) 28 1 UINT #f #f)
(df f-crnx-lo "crx lo 4u4"  (all-mep-core-isas)  4 4 UINT #f #f)
(define-multi-ifield
  (name f-crnx)
  (comment "copro register n (0-31)")
  (attrs all-mep-core-isas)
  (mode UINT)
  (subfields f-crnx-hi f-crnx-lo)
  (insert (sequence ()
		    (set (ifield f-crnx-lo) (and (ifield f-crnx) #xf))
		    (set (ifield f-crnx-hi) (srl (ifield f-crnx) 4))))
  (extract (set (ifield f-crnx)
		(or (sll (ifield f-crnx-hi) 4) (ifield f-crnx-lo))))
  )

; Miscellaneous fields.

(define-pmacro (dnfb n)
  (dnf (.sym f- n) (.str "bit " n) (all-mep-isas) n 1))

; Define small fields used throughout the instruction set description.
; Each field (eg. `f-N') is at single bit field at position N.

(dnfb  0)
(dnfb  1)
(dnfb  2)
(dnfb  3)
(dnfb  4)
(dnfb  5)
(dnfb  6)
(dnfb  7)
(dnfb  8)
(dnfb  9)
(dnfb  10)
(dnfb  11)
(dnfb  12)
(dnfb  13)
(dnfb  14)
(dnfb  15)
(dnfb  16)
(dnfb  17)
(dnfb  18)
(dnfb  19)
(dnfb  20)
(dnfb  21)
(dnfb  22)
(dnfb  23)
(dnfb  24)
(dnfb  25)
(dnfb  26)
(dnfb  27)
(dnfb  28)
(dnfb  29)
(dnfb  30)
(dnfb  31)

; Branch/Jump target addresses

(df f-8s8a2 "pc-rel addr (8 bits)"    (all-mep-core-isas PCREL-ADDR)  8  7 INT
    ((value pc) (sra SI (sub SI value    pc) 1))
    ((value pc) (add SI (mul SI value 2) pc)))

(df f-12s4a2 "pc-rel addr (12 bits)"  (all-mep-core-isas PCREL-ADDR)  4 11 INT
    ((value pc) (sra SI (sub SI value    pc) 1))
    ((value pc) (add SI (mul SI value 2) pc)))

(df f-17s16a2 "pc-rel addr (17 bits)" (all-mep-core-isas PCREL-ADDR) 16 16 INT
    ((value pc) (sra SI (sub SI value    pc) 1))
    ((value pc) (add SI (mul SI value 2) pc)))

(df f-24s5a2n-hi "24s5a2n hi 16s16" (all-mep-core-isas PCREL-ADDR) 16 16  INT #f #f)
(df f-24s5a2n-lo "24s5a2n lo 7s5a2" (all-mep-core-isas PCREL-ADDR)  5  7 UINT #f #f)
(define-multi-ifield
  (name f-24s5a2n)
  (comment "pc-rel addr (24 bits align 2)")
  (attrs all-mep-core-isas PCREL-ADDR)
  (mode INT)
  (subfields f-24s5a2n-hi f-24s5a2n-lo)
  (insert (sequence ()
		    (set (ifield f-24s5a2n)
			 (sub (ifield f-24s5a2n) pc))
		    (set (ifield f-24s5a2n-lo)
			 (srl (and (ifield f-24s5a2n) #xfe) 1))
		    (set (ifield f-24s5a2n-hi)
			 (sra INT (ifield f-24s5a2n) 8))))
  (extract (set (ifield f-24s5a2n)
		(add SI (or (mul (ifield f-24s5a2n-hi) 256)
			    (sll (ifield f-24s5a2n-lo) 1))
		     pc)))
  )

(df f-24u5a2n-hi "24u5a2n hi 16u16" (all-mep-core-isas) 16 16 UINT #f #f)
(df f-24u5a2n-lo "24u5a2n lo 7u5a2" (all-mep-core-isas)  5  7 UINT #f #f)
(define-multi-ifield
  (name f-24u5a2n)
  (comment "abs jump target (24 bits, alignment 2)")
  (attrs all-mep-core-isas ABS-ADDR)
  (mode UINT)
  (subfields f-24u5a2n-hi f-24u5a2n-lo)
  (insert (sequence ()
		    (set (ifield f-24u5a2n-lo)
			 (srl (and (ifield f-24u5a2n) #xff) 1))
		    (set (ifield f-24u5a2n-hi)
			 (srl (ifield f-24u5a2n) 8))
		    ))
  (extract (set (ifield f-24u5a2n)
		(or (sll (ifield f-24u5a2n-hi) 8)
		    (sll (ifield f-24u5a2n-lo) 1))))
  )

; Displacement fields.

(df f-2u6     "SAR offset (2 bits)"    (all-mep-core-isas)  6  2 UINT #f #f)
(df f-7u9     "tp-rel b (7 bits)"      (all-mep-core-isas)  9  7 UINT #f #f)
(df f-7u9a2   "tp-rel h (7 bits)"      (all-mep-core-isas)  9  6 UINT
    ((value pc) (srl SI value 1))
    ((value pc) (mul SI value 2)))
(df f-7u9a4   "tp/sp-rel w (7 bits)"   (all-mep-core-isas)  9  5 UINT
    ((value pc) (srl SI value 2))
    ((value pc) (sll SI value 2)))
(df f-16s16   "general 16-bit s-val"   (all-mep-core-isas) 16 16  INT #f #f)

; Immediate fields.

(df f-2u10   "swi level (2 bits)"      (all-mep-core-isas) 10  2 UINT #f #f)
(df f-3u5    "bit offset (3 bits)"     (all-mep-core-isas)  5  3 UINT #f #f)
(df f-4u8    "bCC const (4 bits)"      (all-mep-core-isas)  8  4 UINT #f #f)
(df f-5u8    "slt & shifts (5 bits)"   (all-mep-core-isas)  8  5 UINT #f #f)
(df f-5u24   "clip immediate (5 bits)" (all-mep-core-isas) 24  5 UINT #f #f)
(df f-6s8    "add immediate (6 bits)"  (all-mep-core-isas)  8  6  INT #f #f)
(df f-8s8    "add imm (8 bits)"        (all-mep-core-isas)  8  8  INT #f #f)
(df f-16u16  "general 16-bit u-val"    (all-mep-core-isas) 16 16 UINT #f #f)
(df f-12u16  "cmov fixed 1"            (all-mep-core-isas) 16 12 UINT #f #f)
(df f-3u29   "cmov fixed 2"            (all-mep-core-isas) 29  3 UINT #f #f)


; These are all for the coprocessor opcodes

; The field is like IJKiiiiiii where I and J are toggled if K is set,
; for compatibility with older cores.
(define-pmacro (compute-cdisp10 val)
  (cond SI
	((and SI (cond SI ((and SI val #x80) (xor SI val #x300)) (else val)) #x200)
	 (sub (cond SI ((and SI val #x80) (xor SI val #x300)) (else val)) #x400))
	(else
	 (cond SI ((and SI val #x80) (xor SI val #x300)) (else val)))
	)
  )
(define-pmacro (extend-cdisp10 val)
  (cond SI
	((and SI (compute-cdisp10 val) #x200)
	 (sub (and SI (compute-cdisp10 val) #x3ff) #x400))
	(else
	 (and SI (compute-cdisp10 val) #x3ff))
	)
  )

(df f-cdisp10    "cop imm10"          (all-mep-core-isas)   22  10 INT
    ((value pc) (extend-cdisp10 value))
    ((value pc) (extend-cdisp10 value))
    )

; Non-contiguous fields.

(df f-24u8a4n-hi "24u8a4n hi 16u16" (all-mep-core-isas) 16 16 UINT #f #f)
(df f-24u8a4n-lo "24u8a4n lo 8u8a4" (all-mep-core-isas)  8  6 UINT #f #f)
(define-multi-ifield
  (name f-24u8a4n)
  (comment "absolute 24-bit address")
  (attrs all-mep-core-isas)
  (mode UINT)
  (subfields f-24u8a4n-hi f-24u8a4n-lo)
  (insert (sequence ()
		    (set (ifield f-24u8a4n-hi) (srl (ifield f-24u8a4n) 8))
		    (set (ifield f-24u8a4n-lo) (srl (and (ifield f-24u8a4n) #xfc) 2))))
  (extract (set (ifield f-24u8a4n)
		(or (sll (ifield f-24u8a4n-hi) 8)
		    (sll (ifield f-24u8a4n-lo) 2))))
  )

(df f-24u8n-hi "24u8n hi 16u16" (all-mep-core-isas) 16 16 UINT #f #f)
(df f-24u8n-lo "24u8n lo  8u8"  (all-mep-core-isas)  8  8 UINT #f #f)
(define-multi-ifield
  (name f-24u8n)
  (comment "24-bit constant")
  (attrs all-mep-core-isas)
  (mode UINT)
  (subfields f-24u8n-hi f-24u8n-lo)
  (insert (sequence ()
		    (set (ifield f-24u8n-hi) (srl (ifield f-24u8n) 8))
		    (set (ifield f-24u8n-lo) (and (ifield f-24u8n) #xff))))
  (extract (set (ifield f-24u8n)
		(or (sll (ifield f-24u8n-hi) 8)
		    (ifield f-24u8n-lo))))
  )

(df f-24u4n-hi "24u4n hi  8u4"  (all-mep-core-isas)  4  8 UINT #f #f)
(df f-24u4n-lo "24u4n lo 16u16" (all-mep-core-isas) 16 16 UINT #f #f)
(define-multi-ifield
  (name f-24u4n)
  (comment "coprocessor code")
  (attrs all-mep-core-isas)
  (mode UINT)
  (subfields f-24u4n-hi f-24u4n-lo)
  (insert (sequence ()
		    (set (ifield f-24u4n-hi) (srl (ifield f-24u4n) 16))
		    (set (ifield f-24u4n-lo) (and (ifield f-24u4n) #xffff))))
  (extract (set (ifield f-24u4n)
		(or (sll (ifield f-24u4n-hi) 16)
		    (ifield f-24u4n-lo))))
  )

(define-multi-ifield
  (name f-callnum)
  (comment "system call number field")
  (attrs all-mep-core-isas)
  (mode UINT)
  (subfields f-5 f-6 f-7 f-11)
  (insert (sequence ()
		    (set (ifield f-5)  (and (srl (ifield f-callnum) 3) 1))
		    (set (ifield f-6)  (and (srl (ifield f-callnum) 2) 1))
		    (set (ifield f-7)  (and (srl (ifield f-callnum) 1) 1))
		    (set (ifield f-11) (and (ifield f-callnum) 1))))
  (extract (set (ifield f-callnum)
		(or (sll (ifield f-5) 3)
		    (or (sll (ifield f-6) 2)
			(or (sll (ifield f-7) 1)
			    (ifield f-11))))))
  )

(df f-ccrn-hi "ccrn hi  2u28" (all-mep-core-isas) 28 2 UINT #f #f)
(df f-ccrn-lo "ccrn lo  4u4"  (all-mep-core-isas)  4 4 UINT #f #f)
(define-multi-ifield
  (name f-ccrn)
  (comment "Coprocessor register number field")
  (attrs all-mep-core-isas)
  (mode UINT)
  (subfields f-ccrn-hi f-ccrn-lo)
  (insert (sequence ()
		    (set (ifield f-ccrn-hi)  (and (srl (ifield f-ccrn) 4) #x3))
		    (set (ifield f-ccrn-lo)  (and (ifield f-ccrn) #xf))))
  (extract (set (ifield f-ccrn)
		(or (sll (ifield f-ccrn-hi) 4)
		    (ifield f-ccrn-lo))))
  )

; Operands.

;; Only LABEL, REGNUM, FMAX_FLOAT and FMAX_INT are now relevant for correct
;; operation.  The others are mostly kept for backwards compatibility,
;; although they do affect the dummy prototypes in
;; gcc/config/mep/intrinsics.h.
(define-attr
  (type enum)
  (for operand)
  (name CDATA)
  (comment "datatype to use for C intrinsics mapping")
  (values LABEL REGNUM FMAX_FLOAT FMAX_INT
	  POINTER LONG ULONG SHORT USHORT CHAR UCHAR CP_DATA_BUS_INT)
  (default LONG))

(define-attr
  (type enum)
  (for insn)
  (name CPTYPE)
  (comment "datatype to use for coprocessor values")
  (values CP_DATA_BUS_INT VECT V2SI V4HI V8QI V2USI V4UHI V8UQI)
  (default CP_DATA_BUS_INT))

(define-attr
  (type enum)
  (for insn)
  (name CRET)
  ;; VOID - all arguments are passed as parameters; if any are written, pointers to them are passed.
  ;; FIRST - the first argument is the return value.
  ;; FIRSTCOPY - the first argument is the return value, but a copy is also the first parameter.
  (values VOID FIRST FIRSTCOPY)
  (default VOID)
  (comment "Insn's intrinsic returns void, or the first argument rather than (or in addition to) passing it."))

(define-attr
  (type integer)
  (for operand)
  (name ALIGN)
  (comment "alignment of immediate operands")
  (default 1))

(define-attr
  (for operand)
  (type boolean)
  (name RELOC_IMPLIES_OVERFLOW)
  (comment "Operand should not be considered as a candidate for relocs"))

(define-attr
  (for hardware)
  (type boolean)
  (name IS_FLOAT)
  (comment "Register contains a floating point value"))

(define-pmacro (dpop name commment attrib hwr field func)
  (define-full-operand name comment attrib
    hwr DFLT field ((parse func)) () ()))
(define-pmacro (dprp name commment attrib hwr field pafunc prfunc)
  (define-full-operand name comment attrib
    hwr DFLT field ((parse pafunc) (print prfunc)) () ()))

(dnop r0        "register 0"              (all-mep-core-isas) h-gpr   0)
(dnop rn        "register Rn"             (all-mep-core-isas) h-gpr   f-rn)
(dnop rm        "register Rm"             (all-mep-core-isas) h-gpr   f-rm)
(dnop rl        "register Rl"             (all-mep-core-isas) h-gpr   f-rl)
(dnop rn3       "register 0-7"            (all-mep-core-isas) h-gpr   f-rn3)

;; Variants of RM/RN with different CDATA attributes.  See comment above
;; CDATA for more details.

(dnop rma       "register Rm holding pointer"          (all-mep-core-isas (CDATA POINTER)) h-gpr   f-rm)

(dnop rnc       "register Rn holding char"             (all-mep-core-isas (CDATA LONG))    h-gpr   f-rn)
(dnop rnuc      "register Rn holding unsigned char"    (all-mep-core-isas (CDATA LONG))    h-gpr   f-rn)
(dnop rns       "register Rn holding short"            (all-mep-core-isas (CDATA LONG))    h-gpr   f-rn)
(dnop rnus      "register Rn holding unsigned short"   (all-mep-core-isas (CDATA LONG))    h-gpr   f-rn)
(dnop rnl       "register Rn holding long"             (all-mep-core-isas (CDATA LONG))    h-gpr   f-rn)
(dnop rnul      "register Rn holding unsigned  long"   (all-mep-core-isas (CDATA ULONG))   h-gpr   f-rn)

(dnop rn3c       "register 0-7 holding unsigned char"    (all-mep-core-isas (CDATA LONG))  h-gpr   f-rn3)
(dnop rn3uc      "register 0-7 holding byte"             (all-mep-core-isas (CDATA LONG))  h-gpr   f-rn3)
(dnop rn3s       "register 0-7 holding unsigned short"   (all-mep-core-isas (CDATA LONG))  h-gpr   f-rn3)
(dnop rn3us      "register 0-7 holding short"            (all-mep-core-isas (CDATA LONG))  h-gpr   f-rn3)
(dnop rn3l       "register 0-7 holding unsigned long"    (all-mep-core-isas (CDATA LONG))  h-gpr   f-rn3)
(dnop rn3ul      "register 0-7 holding long"             (all-mep-core-isas (CDATA ULONG)) h-gpr   f-rn3)


(dnop lp        "link pointer"            (all-mep-core-isas) h-csr   1)
(dnop sar       "shift amount register"   (all-mep-core-isas) h-csr   2)
(dnop hi        "high result"             (all-mep-core-isas) h-csr   7)
(dnop lo        "low result"              (all-mep-core-isas) h-csr   8)
(dnop mb0       "modulo begin register 0" (all-mep-core-isas) h-csr  12)
(dnop me0       "modulo end register 0"   (all-mep-core-isas) h-csr  13)
(dnop mb1       "modulo begin register 1" (all-mep-core-isas) h-csr  14)
(dnop me1       "modulo end register 1"   (all-mep-core-isas) h-csr  15)
(dnop psw       "program status word"     (all-mep-core-isas) h-csr  16)
(dnop epc	"exception prog counter"  (all-mep-core-isas) h-csr  19)
(dnop exc       "exception cause"         (all-mep-core-isas) h-csr  20)
(dnop npc       "nmi program counter"     (all-mep-core-isas) h-csr  23)
(dnop dbg       "debug register"          (all-mep-core-isas) h-csr  24)
(dnop depc      "debug exception pc"      (all-mep-core-isas) h-csr  25)
(dnop opt       "option register"         (all-mep-core-isas) h-csr  26)
(dnop r1        "register 1"              (all-mep-core-isas) h-gpr   1)
(dnop tp        "tiny data area pointer"  (all-mep-core-isas) h-gpr  13)
(dnop sp        "stack pointer"           (all-mep-core-isas) h-gpr  15)
(dprp tpr       "TP register"             (all-mep-core-isas) h-gpr  13       "tpreg" "tpreg")
(dprp spr       "SP register"             (all-mep-core-isas) h-gpr  15       "spreg" "spreg")

(define-full-operand
  csrn "control/special register" (all-mep-core-isas (CDATA REGNUM)) h-csr
  DFLT f-csrn ((parse "csrn")) () ()
)

(dnop csrn-idx  "control/special reg idx" (all-mep-core-isas) h-uint  f-csrn)
(dnop crn64     "copro Rn (64-bit)"       (all-mep-core-isas (CDATA CP_DATA_BUS_INT)) h-cr64  f-crn)
(dnop crn       "copro Rn (32-bit)"       (all-mep-core-isas (CDATA CP_DATA_BUS_INT)) h-cr    f-crn)
(dnop crnx64    "copro Rn (0-31, 64-bit)" (all-mep-core-isas (CDATA CP_DATA_BUS_INT)) h-cr64  f-crnx)
(dnop crnx      "copro Rn (0-31, 32-bit)" (all-mep-core-isas (CDATA CP_DATA_BUS_INT)) h-cr    f-crnx)
(dnop ccrn      "copro control reg CCRn"  (all-mep-core-isas (CDATA REGNUM)) h-ccr   f-ccrn)
(dnop cccc      "copro flags"             (all-mep-core-isas) h-uint  f-rm)

(dprp pcrel8a2  "pc-rel addr (8 bits)"    (all-mep-core-isas (CDATA LABEL) RELAX) h-sint  f-8s8a2   "mep_align" "address")
(dprp pcrel12a2 "pc-rel addr (12 bits)"   (all-mep-core-isas (CDATA LABEL) RELAX) h-sint  f-12s4a2  "mep_align" "address")
(dprp pcrel17a2 "pc-rel addr (17 bits)"   (all-mep-core-isas (CDATA LABEL) RELAX) h-sint  f-17s16a2 "mep_align" "address")
(dprp pcrel24a2 "pc-rel addr (24 bits)"   (all-mep-core-isas (CDATA LABEL))       h-sint  f-24s5a2n "mep_align" "address")
(dprp pcabs24a2 "pc-abs addr (24 bits)"   (all-mep-core-isas (CDATA LABEL))       h-uint  f-24u5a2n "mep_alignu" "address")

(dpop sdisp16   "displacement (16 bits)"  (all-mep-core-isas) h-sint  f-16s16    "signed16")
(dpop simm16    "signed imm (16 bits)"    (all-mep-core-isas) h-sint  f-16s16    "signed16")
(dpop uimm16    "unsigned imm (16 bits)"  (all-mep-core-isas) h-uint  f-16u16    "unsigned16")
(dnop code16    "uci/dsp code (16 bits)"  (all-mep-core-isas) h-uint  f-16u16)

(dnop udisp2    "SSARB addend (2 bits)"   (all-mep-core-isas) h-sint  f-2u6)
(dnop uimm2     "interrupt (2 bits)"      (all-mep-core-isas) h-uint  f-2u10)

(dnop simm6     "add const (6 bits)"      (all-mep-core-isas) h-sint  f-6s8)
(dnop simm8     "mov const (8 bits)"      (all-mep-core-isas RELOC_IMPLIES_OVERFLOW) 
                                             h-sint  f-8s8)

(dpop addr24a4  "sw/lw addr (24 bits)"    (all-mep-core-isas (ALIGN 4)) h-uint  f-24u8a4n  "mep_alignu")
(dnop code24    "coprocessor code"        (all-mep-core-isas) h-uint  f-24u4n)

(dnop callnum   "system call number"      (all-mep-core-isas) h-uint  f-callnum)
(dnop uimm3     "bit immediate (3 bits)"  (all-mep-core-isas) h-uint  f-3u5)
(dnop uimm4     "bCC const (4 bits)"      (all-mep-core-isas) h-uint  f-4u8)
(dnop uimm5     "bit/shift val (5 bits)"  (all-mep-core-isas) h-uint  f-5u8)

(dpop udisp7    "tp-rel b (7 bits)"       (all-mep-core-isas)           h-uint  f-7u9      "unsigned7")
(dpop udisp7a2  "tp-rel h (7 bits)"       (all-mep-core-isas (ALIGN 2)) h-uint  f-7u9a2    "unsigned7")
(dpop udisp7a4  "tp/sp-rel w (7 bits)"    (all-mep-core-isas (ALIGN 4)) h-uint  f-7u9a4    "unsigned7")
(dpop uimm7a4   "sp w-addend (7 bits)"    (all-mep-core-isas (ALIGN 4)) h-uint  f-7u9a4    "mep_alignu")

(dnop uimm24    "immediate (24 bits)"     (all-mep-core-isas) h-uint  f-24u8n)

(dnop cimm4     "cache immed'te (4 bits)" (all-mep-core-isas) h-uint  f-rn)
(dnop cimm5     "clip immediate (5 bits)" (all-mep-core-isas) h-uint  f-5u24)

(dpop cdisp10   "copro addend (8/10 bits)" (all-mep-core-isas) h-sint  f-cdisp10  "cdisp10")
(dpop cdisp10a2 "copro addend (8/10 bits)" (all-mep-core-isas) h-sint  f-cdisp10  "cdisp10")
(dpop cdisp10a4 "copro addend (8/10 bits)" (all-mep-core-isas) h-sint  f-cdisp10  "cdisp10")
(dpop cdisp10a8 "copro addend (8/10 bits)" (all-mep-core-isas) h-sint  f-cdisp10  "cdisp10")

; Special operand representing the various ways that the literal zero can be
; specified.
(define-full-operand
  zero "Zero operand" (all-mep-core-isas) h-sint DFLT f-nil
  ((parse "zero")) () ()
)

; Attributes.

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_BIT_INSN)
  (comment "optional bit manipulation instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_MUL_INSN)
  (comment "optional 32-bit multiply instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_DIV_INSN)
  (comment "optional 32-bit divide instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_DEBUG_INSN)
  (comment "optional debug instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_LDZ_INSN)
  (comment "optional leading zeroes instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_ABS_INSN)
  (comment "optional absolute difference instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_AVE_INSN)
  (comment "optional average instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_MINMAX_INSN)
  (comment "optional min/max instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_CLIP_INSN)
  (comment "optional clipping instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_SAT_INSN)
  (comment "optional saturation instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_UCI_INSN)
  (comment "optional UCI instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_DSP_INSN)
  (comment "optional DSP instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_CP_INSN)
  (comment "optional coprocessor-related instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_CP64_INSN)
  (comment "optional coprocessor-related 64 data bit instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name OPTIONAL_VLIW64)
  (comment "optional vliw64 mode (vliw32 is default)"))

(define-attr
  (for insn)
  (type enum)
  (name STALL)
  (attrs META)
  (values NONE SHIFTI INT2 LOAD STORE LDC STC LDCB STCB SSARB FSFT RET
	  ADVCK MUL MULR DIV)
  (default NONE)
  (comment "gcc stall attribute"))

(define-attr
  (for insn)
  (type string)
  (name INTRINSIC)
  (attrs META)
  (comment "gcc intrinsic name"))

(define-attr
  (for insn)
  (type enum)
  (name SLOT)
  (attrs META)
  (values NONE C3 V1 V3 P0S P0 P1)
  (default NONE)
  (comment "coprocessor slot type"))

(define-attr
  (for insn)
  (type boolean)
  (name MAY_TRAP)
  (comment "instruction may generate an exception"))

; Attributes for scheduling restrictions in vliw mode

(define-attr
  (for insn)
  (type boolean)
  (name VLIW_ALONE)
  (comment "instruction can be scheduled alone in vliw mode"))

(define-attr
  (for insn)
  (type boolean)
  (name VLIW_NO_CORE_NOP)
  (comment "there is no corresponding nop core instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name VLIW_NO_COP_NOP)
  (comment "there is no corresponding nop coprocessor instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name VLIW64_NO_MATCHING_NOP)
  (comment "there is no corresponding nop coprocessor instruction"))
(define-attr
  (for insn)
  (type boolean)
  (name VLIW32_NO_MATCHING_NOP)
  (comment "there is no corresponding nop coprocessor instruction"))

(define-attr
  (for insn)
  (type boolean)
  (name VOLATILE)
  (comment "Insn is volatile."))

(define-attr
  (for insn)
  (type integer)
  (name LATENCY)
  (comment "The latency of this insn, used for scheduling as an intrinsic in gcc")
  (default 0))

; The MeP config tool will edit this.
(define-attr
  (type enum)
  (for insn)
  (name CONFIG)
  (values NONE ; config-attr-start
	default
	  ) ; config-attr-end
)


; Enumerations.

(define-normal-insn-enum major "major opcodes" (all-mep-core-isas) MAJ_
  f-major
  (.map .str (.iota 16))
)


(define-pmacro (dni-isa xname xcomment xattrs xsyntax xformat xsemantics xtiming isa)
  (define-insn          
    (name xname)        
    (comment xcomment)
    (.splice attrs (.unsplice xattrs) (ISA isa))
    (syntax xsyntax)
    (format xformat)
    (semantics xsemantics)
    (.splice timing (.unsplice xtiming))
    )
) 
  
(define-pmacro (dnmi-isa xname xcomment xattrs xsyntax xemit isa)
  (dnmi xname xcomment (.splice (.unsplice xattrs) (ISA isa)) xsyntax xemit)
)

; For making profiling calls and dynamic configuration
(define-pmacro (cg-profile caller callee)
  (c-call "cg_profile" caller callee)
)
; For dynamic configuration only
(define-pmacro (cg-profile-jump caller callee)
  (c-call "cg_profile_jump" caller callee)
)

; For defining Core Instructions
(define-pmacro (dnci xname xcomment xattrs xsyntax xformat xsemantics xtiming)
  (dni-isa xname xcomment xattrs xsyntax xformat xsemantics xtiming all-core-isa-list)
)
(define-pmacro (dncmi xname xcomment xattrs xsyntax xemit)
  (dnmi-isa xname xcomment xattrs xsyntax xemit all-core-isa-list)
)

; For defining Coprocessor Instructions
;(define-pmacro (dncpi xname xcomment xattrs xsyntax xformat xsemantics xtiming)  (dni-isa xname xcomment xattrs xsyntax xformat xsemantics xtiming cop)
;)

;; flag setting macro
(define-pmacro (set-bit xop xbitnum xval) 
  (set xop (or 
	    (and xop (inv (sll 1 xbitnum)))
	    (and (sll 1 xbitnum) (sll xval xbitnum)))))

;; some flags we commonly use in vliw reasoning / mode-switching etc.
(define-pmacro (get-opt.vliw64) (and (srl opt 6) 1))
(define-pmacro (get-opt.vliw32) (and (srl opt 5) 1))
(define-pmacro (get-rm.lsb) (and rm 1))
(define-pmacro (get-psw.om) (and (srl psw 12) 1))
(define-pmacro (get-psw.nmi) (and (srl psw 9) 1))
(define-pmacro (get-psw.iep) (and (srl psw 1) 1))
(define-pmacro (get-psw.ump) (and (srl psw 3) 1))
(define-pmacro (get-epc.etom) (and epc 1))
(define-pmacro (get-npc.ntom) (and npc 1))
(define-pmacro (get-lp.ltom) (and lp 1))

(define-pmacro (set-psw.om zval) (set-bit (raw-reg h-csr 16) 12 zval))
(define-pmacro (set-psw.nmi zval) (set-bit (raw-reg h-csr 16) 9 zval))
(define-pmacro (set-psw.umc zval) (set-bit (raw-reg h-csr 16) 2 zval))
(define-pmacro (set-psw.iec zval) (set-bit (raw-reg h-csr 16) 0 zval))
(define-pmacro (set-rpe.elr zval) (set-bit (raw-reg h-csr 5) 0 zval))


;; the "3 way switch" depending on our current operating mode and vliw status flags
(define-pmacro (core-vliw-switch core-rtl vliw32-rtl vliw64-rtl) 
  (cond
   ((andif (get-psw.om) (get-opt.vliw64)) vliw64-rtl)
   ((andif (get-psw.om) (get-opt.vliw32)) vliw32-rtl)
   (else core-rtl)))

;; the varying-pcrel idiom
(define-pmacro (set-vliw-modified-pcrel-offset xtarg xa xb xc)
  (core-vliw-switch (set xtarg (add pc xa))
		    (set xtarg (add pc xb))
		    (set xtarg (add pc xc))))

;; the increasing-alignment idiom in branch displacements
(define-pmacro (set-vliw-alignment-modified xtarg zaddr)
  (core-vliw-switch (set xtarg (and zaddr (inv 1)))
		    (set xtarg (and zaddr (inv 3)))
		    (set xtarg (and zaddr (inv 7)))))

;; the increasing-alignment idiom in option-only form
(define-pmacro (set-vliw-aliignment-modified-by-option xtarg zaddr)
  (if (get-opt.vliw32)
      (set xtarg (and zaddr (inv 3)))
      (set xtarg (and zaddr (inv 7)))))



; pmacros needed for coprocessor modulo addressing.

; Taken from supplement ``The operation of the modulo addressing'' in
; Toshiba documentation rev 2.2, p. 34.

(define-pmacro (compute-mask0)
  (sequence SI ((SI temp))
    (set temp (or mb0 me0))
    (srl (const SI -1) (c-call SI "do_ldz" temp))))

(define-pmacro (mod0 immed)
  (sequence SI ((SI modulo-mask))
	    (set modulo-mask (compute-mask0))
	    (if SI (eq (and rma modulo-mask) me0)
		(or (and rma (inv modulo-mask)) mb0)
		(add rma (ext SI immed)))))

(define-pmacro (compute-mask1)
  (sequence SI ((SI temp))
    (set temp (or mb1 me1))
    (srl (const SI -1) (c-call SI "do_ldz" temp))))

(define-pmacro (mod1 immed)
  (sequence SI ((SI modulo-mask))
	    (set modulo-mask (compute-mask1))
	    (if SI (eq (and rma modulo-mask) me1)
		(or (and rma (inv modulo-mask)) mb1)
		(add rma (ext SI immed)))))


; Instructions.

; A pmacro for use in semantic bodies of unimplemented insns.
(define-pmacro (unimp mnemonic) (nop))

; Core specific instructions
; (include "mep-h1.cpu") ; -- exposed by MeP-Integrator
(include "mep-c5.cpu") ; -- exposed by MeP-Integrator

; Load/store instructions.

(dnci sb "store byte (register indirect)" ((STALL STORE))
     "sb $rnc,($rma)"
     (+ MAJ_0 rnc rma (f-sub4 8))
     (sequence ()
	       (c-call VOID "check_write_to_text" rma)
	       (set (mem UQI rma) (and rnc #xff)))
     ((mep (unit u-use-gpr (in usereg rnc))
	   (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci sh "store half-word (register indirect)" ((STALL STORE))
     "sh $rns,($rma)"
     (+ MAJ_0 rns rma (f-sub4 9))
     (sequence ()
	       (c-call VOID "check_write_to_text" (and rma (inv 1)))
	       (set (mem UHI (and rma (inv 1))) (and rns #xffff)))
     ((mep (unit u-use-gpr (in usereg rns))
	   (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci sw "store word (register indirect)" ((STALL STORE))
     "sw $rnl,($rma)"
     (+ MAJ_0 rnl rma (f-sub4 10))
     (sequence ()
	       (c-call VOID "check_write_to_text" (and rma (inv 3)))
	       (set (mem USI (and rma (inv 3))) rnl))
     ((mep (unit u-use-gpr (in usereg rnl))
	   (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lb "load byte (register indirect)" ((STALL LOAD) (LATENCY 2))
     "lb $rnc,($rma)"
     (+ MAJ_0 rnc rma (f-sub4 12))
     (set rnc (ext SI (mem QI rma)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rnc)))))

(dnci lh "load half-word (register indirect)" ((STALL LOAD) (LATENCY 2))
     "lh $rns,($rma)"
     (+ MAJ_0 rns rma (f-sub4 13))
     (set rns (ext SI (mem HI (and rma (inv 1)))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rns)))))

(dnci lw "load word (register indirect)" ((STALL LOAD) (LATENCY 2))
     "lw $rnl,($rma)"
     (+ MAJ_0 rnl rma (f-sub4 14))
     (set rnl (mem SI (and rma (inv 3))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rnl)))))

(dnci lbu "load unsigned byte (register indirect)" ((STALL LOAD) (LATENCY 2))
     "lbu $rnuc,($rma)"
     (+ MAJ_0 rnuc rma (f-sub4 11))
     (set rnuc (zext SI (mem UQI rma)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rnuc)))))

(dnci lhu "load unsigned half-word (register indirect)" ((STALL LOAD) (LATENCY 2))
     "lhu $rnus,($rma)"
     (+ MAJ_0 rnus rma (f-sub4 15))
     (set rnus (zext SI (mem UHI (and rma (inv 1)))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rnus)))))

(dnci sw-sp "store word (sp relative)" ((STALL STORE))
     "sw $rnl,$udisp7a4($spr)"
     (+ MAJ_4 rnl (f-8 0) udisp7a4 (f-sub2 2))
     (sequence ()
	       (c-call VOID "check_write_to_text" (and (add udisp7a4 sp) (inv 3)))
	       (set (mem SI (and (add udisp7a4 sp) (inv 3))) rnl))
     ((mep (unit u-use-gpr (in usereg rnl))
	   (unit u-use-gpr (in usereg sp))
	   (unit u-exec))))


(dnci lw-sp "load word (sp relative)" ((STALL LOAD) (LATENCY 2))
     "lw $rnl,$udisp7a4($spr)"
     (+ MAJ_4 rnl (f-8 0) udisp7a4 (f-sub2 3))
     (set rnl (mem SI (and (add udisp7a4 sp) (inv 3))))
     ((mep (unit u-use-gpr (in usereg sp))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rnl)))))

(dnci sb-tp "store byte (tp relative)" ((STALL STORE))
     "sb $rn3c,$udisp7($tpr)"
     (+ MAJ_8 (f-4 0) rn3c (f-8 0) udisp7)
     (sequence ()
	       (c-call VOID "check_write_to_text" (add (zext SI udisp7) tp))
	       (set (mem QI (add (zext SI udisp7) tp)) (and rn3c #xff)))
     ((mep (unit u-use-gpr (in usereg rn3c))
	   (unit u-use-gpr (in usereg tp))
	   (unit u-exec))))

(dnci sh-tp "store half-word (tp relative)" ((STALL STORE))
     "sh $rn3s,$udisp7a2($tpr)"
     (+ MAJ_8 (f-4 0) rn3s (f-8 1) udisp7a2 (f-15 0))
     (sequence ()
	       (c-call VOID "check_write_to_text" (and (add (zext SI udisp7a2) tp) (inv 1)))
	       (set (mem HI (and (add (zext SI udisp7a2) tp) (inv 1))) (and rn3s #xffff)))
     ((mep (unit u-use-gpr (in usereg rn3s))
	   (unit u-use-gpr (in usereg tp))
	   (unit u-exec))))

(dnci sw-tp "store word (tp relative)" ((STALL STORE))
     "sw $rn3l,$udisp7a4($tpr)"
     (+ MAJ_4 (f-4 0) rn3l (f-8 1) udisp7a4 (f-sub2 2))
     (sequence ()
	       (c-call VOID "check_write_to_text" (and (add (zext SI udisp7a4) tp) (inv 3)))
	       (set (mem SI (and (add (zext SI udisp7a4) tp) (inv 3))) rn3l))
     ((mep (unit u-use-gpr (in usereg rn3l))
	   (unit u-use-gpr (in usereg tp))
	   (unit u-exec))))

(dnci lb-tp "load byte (tp relative)" ((STALL LOAD) (LATENCY 2))
     "lb $rn3c,$udisp7($tpr)"
     (+ MAJ_8 (f-4 1) rn3c (f-8 0) udisp7)
     (set rn3c (ext SI (mem QI (add (zext SI udisp7) tp))))
     ((mep (unit u-use-gpr (in usereg tp))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rn3c)))))

(dnci lh-tp "load half-word (tp relative)" ((STALL LOAD) (LATENCY 2))
     "lh $rn3s,$udisp7a2($tpr)"
     (+ MAJ_8 (f-4 1) rn3s (f-8 1) udisp7a2 (f-15 0))
     (set rn3s (ext SI (mem HI (and (add (zext SI udisp7a2) tp) (inv 1)))))
     ((mep (unit u-use-gpr (in usereg tp))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rn3s)))))

(dnci lw-tp "load word (tp relative)" ((STALL LOAD) (LATENCY 2))
     "lw $rn3l,$udisp7a4($tpr)"
     (+ MAJ_4 (f-4 0) rn3l (f-8 1) udisp7a4 (f-sub2 3))
     (set rn3l (mem SI (and (add (zext SI udisp7a4) tp) (inv 3))))
     ((mep (unit u-use-gpr (in usereg tp))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rn3l)))))

(dnci lbu-tp "load unsigned byte (tp relative)" ((STALL LOAD) (LATENCY 2))
     "lbu $rn3uc,$udisp7($tpr)"
     (+ MAJ_4 (f-4 1) rn3uc (f-8 1) udisp7)
     (set rn3uc (zext SI (mem QI (add (zext SI udisp7) tp))))
     ((mep (unit u-use-gpr (in usereg tp))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rn3uc)))))

(dnci lhu-tp "load unsigned half-word (tp relative)" ((STALL LOAD) (LATENCY 2))
     "lhu $rn3us,$udisp7a2($tpr)"
     (+ MAJ_8 (f-4 1) rn3us (f-8 1) udisp7a2 (f-15 1))
     (set rn3us (zext SI (mem HI (and (add (zext SI udisp7a2) tp) (inv 1)))))
     ((mep (unit u-use-gpr (in usereg tp))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rn3us)))))

(dnci sb16 "store byte (16 bit displacement)" ((STALL STORE))
     "sb $rnc,$sdisp16($rma)"
     (+ MAJ_12 rnc rma (f-sub4 8) sdisp16)
     (sequence ()
	       (c-call VOID "check_write_to_text" (add rma (ext SI sdisp16)))
	       (set (mem QI (add rma (ext SI sdisp16))) (and rnc #xff)))
     ((mep (unit u-use-gpr (in usereg rnc))
	   (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci sh16 "store half-word (16 bit displacement)" ((STALL STORE))
     "sh $rns,$sdisp16($rma)"
     (+ MAJ_12 rns rma (f-sub4 9) sdisp16)
     (sequence ()
	       (c-call VOID "check_write_to_text" (and (add rma (ext SI sdisp16)) (inv 1)))
	       (set (mem HI (and (add rma (ext SI sdisp16)) (inv 1))) (and rns #xffff)))
     ((mep (unit u-use-gpr (in usereg rns))
	   (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci sw16 "store word (16 bit displacement)" ((STALL STORE))
     "sw $rnl,$sdisp16($rma)"
     (+ MAJ_12 rnl rma (f-sub4 10) sdisp16)
     (sequence ()
	       (c-call "check_write_to_text" (and (add rma (ext SI sdisp16)) (inv 3)))
	       (set (mem SI (and (add rma (ext SI sdisp16)) (inv 3))) rnl))
     ((mep (unit u-use-gpr (in usereg rnl))
	   (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lb16 "load byte (16 bit displacement)" ((STALL LOAD) (LATENCY 2))
     "lb $rnc,$sdisp16($rma)"
     (+ MAJ_12 rnc rma (f-sub4 12) sdisp16)
     (set rnc (ext SI (mem QI (add rma (ext SI sdisp16)))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rnc)))))

(dnci lh16 "load half-word (16 bit displacement)" ((STALL LOAD) (LATENCY 2))
     "lh $rns,$sdisp16($rma)"
     (+ MAJ_12 rns rma (f-sub4 13) sdisp16)
     (set rns (ext SI (mem HI (and (add rma (ext SI sdisp16)) (inv 1)))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rns)))))

(dnci lw16 "load word (16 bit displacement)" ((STALL LOAD) (LATENCY 2))
     "lw $rnl,$sdisp16($rma)"
     (+ MAJ_12 rnl rma (f-sub4 14) sdisp16)
     (set rnl (mem SI (and (add rma (ext SI sdisp16)) (inv 3))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rnl)))))

(dnci lbu16 "load unsigned byte (16 bit displacement)" ((STALL LOAD) (LATENCY 2))
     "lbu $rnuc,$sdisp16($rma)"
     (+ MAJ_12 rnuc rma (f-sub4 11) sdisp16)
     (set rnuc (zext SI (mem QI (add rma (ext SI sdisp16)))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rnuc)))))

(dnci lhu16 "load unsigned half-word (16 bit displacement)" ((STALL LOAD) (LATENCY 2))
     "lhu $rnus,$sdisp16($rma)"
     (+ MAJ_12 rnus rma (f-sub4 15) sdisp16)
     (set rnus (zext SI (mem HI (and (add rma (ext SI sdisp16)) (inv 1)))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec)
	   (unit u-load-gpr (out loadreg rnus)))))

(dnci sw24 "store word (24 bit absolute addressing)" ((STALL STORE))
     "sw $rnl,($addr24a4)"
     (+ MAJ_14 rnl addr24a4 (f-sub2 2))
     (sequence ()
	       (c-call VOID "check_write_to_text" (zext SI addr24a4))
	       (set (mem SI (zext SI addr24a4)) rnl))
     ((mep (unit u-use-gpr (in usereg rnl))
	   (unit u-exec))))

(dnci lw24 "load word (24 bit absolute addressing)" ((STALL LOAD) (LATENCY 2))
     "lw $rnl,($addr24a4)"
     (+ MAJ_14 rnl addr24a4 (f-sub2 3))
     (set rnl (mem SI (zext SI addr24a4)))
     ((mep (unit u-exec)
	   (unit u-load-gpr (out loadreg rnl)))))


; Extension instructions.

(dnci extb "sign extend byte" ()
     "extb $rn"
     (+ MAJ_1 rn (f-rm 0) (f-sub4 13))
     (set rn (ext SI (and QI rn #xff)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci exth "sign extend half-word" ()
     "exth $rn"
     (+ MAJ_1 rn (f-rm 2) (f-sub4 13))
     (set rn (ext SI (and HI rn #xffff)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci extub "zero extend byte" ()
     "extub $rn"
     (+ MAJ_1 rn (f-rm 8) (f-sub4 13))
     (set rn (zext SI (and rn #xff)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci extuh "zero extend half-word" ()
     "extuh $rn"
     (+ MAJ_1 rn (f-rm 10) (f-sub4 13))
     (set rn (zext SI (and rn #xffff)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))


; Shift amount manipulation instructions.

(dnci ssarb "set sar to bytes" ((STALL SSARB) VOLATILE)
     "ssarb $udisp2($rm)"
     (+ MAJ_1 (f-4 0) (f-5 0) udisp2 rm (f-sub4 12))
     (if (c-call BI "big_endian_p")
         (set sar (zext SI (mul (and (add udisp2 rm) 3) 8)))
         (set sar (sub 32 (zext SI (mul (and (add udisp2 rm) 3) 8)))))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))


; Move instructions.

(dnci mov "move" ()
     "mov $rn,$rm"
     (+ MAJ_0 rn rm (f-sub4 0))
     (set rn rm)
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci movi8 "move 8-bit immediate" ()
     "mov $rn,$simm8"
     (+ MAJ_5 rn simm8)
     (set rn (ext SI simm8))
     ())

(dnci movi16 "move 16-bit immediate" ()
     "mov $rn,$simm16"
     (+ MAJ_12 rn (f-rm 0) (f-sub4 1) simm16)
     (set rn (ext SI simm16))
     ())

(dnci movu24 "move 24-bit unsigned immediate" ()
     "movu $rn3,$uimm24"
     (+ MAJ_13 (f-4 0) rn3 uimm24)
     (set rn3 (zext SI uimm24))
     ())

(dnci movu16 "move 16-bit unsigned immediate" ()
     "movu $rn,$uimm16"
     (+ MAJ_12 rn (f-rm 1) (f-sub4 1) uimm16)
     (set rn (zext SI uimm16))
     ())

(dnci movh "move high 16-bit immediate" ()
     "movh $rn,$uimm16"
     (+ MAJ_12 rn (f-rm 2) (f-sub4 1) uimm16)
     (set rn (sll uimm16 16))
     ())


; Arithmetic instructions.

(dnci add3 "add three registers" ()
     "add3 $rl,$rn,$rm"
     (+ MAJ_9 rn rm rl)
     (set rl (add rn rm))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci add "add" ()
     "add $rn,$simm6"
     (+ MAJ_6 rn simm6 (f-sub2 0))
     (set rn (add rn (ext SI simm6)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci add3i "add two registers and immediate" ()
     "add3 $rn,$spr,$uimm7a4"
     (+ MAJ_4 rn (f-8 0) uimm7a4 (f-sub2 0))
     (set rn (add sp (zext SI uimm7a4)))
     ((mep (unit u-use-gpr (in usereg sp))
	   (unit u-exec))))

(dnci advck3 "add overflow check" ((STALL ADVCK))
     "advck3 \\$0,$rn,$rm"
     (+ MAJ_0 rn rm (f-sub4 7))
     (if (add-oflag rn rm 0)
	 (set r0 1)
	 (set r0 0))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci sub "subtract" ()
     "sub $rn,$rm"
     (+ MAJ_0 rn rm (f-sub4 4))
     (set rn (sub rn rm))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm)))))

(dnci sbvck3 "subtraction overflow check" ((STALL ADVCK))
     "sbvck3 \\$0,$rn,$rm"
     (+ MAJ_0 rn rm (f-sub4 5))
     (if (sub-oflag rn rm 0)
	 (set r0 1)
	 (set r0 0))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci neg "negate" ()
     "neg $rn,$rm"
     (+ MAJ_0 rn rm (f-sub4 1))
     (set rn (neg rm))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci slt3 "set if less than" ()
     "slt3 \\$0,$rn,$rm"
     (+ MAJ_0 rn rm (f-sub4 2))
     (if (lt rn rm)
	 (set r0 1)
	 (set r0 0))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci sltu3 "set less than unsigned" ()
     "sltu3 \\$0,$rn,$rm"
     (+ MAJ_0 rn rm (f-sub4 3))
     (if (ltu rn rm)
	 (set r0 1)
	 (set r0 0))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci slt3i "set if less than immediate" ()
     "slt3 \\$0,$rn,$uimm5"
     (+ MAJ_6 rn uimm5 (f-sub3 1))
     (if (lt rn (zext SI uimm5))
	 (set r0 1)
	 (set r0 0))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci sltu3i "set if less than unsigned immediate" ()
     "sltu3 \\$0,$rn,$uimm5"
     (+ MAJ_6 rn uimm5 (f-sub3 5))
     (if (ltu rn (zext SI uimm5))
	 (set r0 1)
	 (set r0 0))
     ())

(dnci sl1ad3 "shift left one and add" ((STALL INT2))
     "sl1ad3 \\$0,$rn,$rm"
     (+ MAJ_2 rn rm (f-sub4 6))
     (set r0 (add (sll rn 1) rm))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci sl2ad3 "shift left two and add" ((STALL INT2))
     "sl2ad3 \\$0,$rn,$rm"
     (+ MAJ_2 rn rm (f-sub4 7))
     (set r0 (add (sll rn 2) rm))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci add3x "three operand add (extended)" ()
     "add3 $rn,$rm,$simm16"
     (+ MAJ_12 rn rm (f-sub4 0) simm16)
     (set rn (add rm (ext SI simm16)))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci slt3x "set if less than (extended)" ()
     "slt3 $rn,$rm,$simm16"
     (+ MAJ_12 rn rm (f-sub4 2) simm16)
     (if (lt rm (ext SI simm16))
	 (set rn 1)
	 (set rn 0))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci sltu3x "set if less than unsigned (extended)" ()
     "sltu3 $rn,$rm,$uimm16"
     (+ MAJ_12 rn rm (f-sub4 3) uimm16)
     (if (ltu rm (zext SI uimm16))
	 (set rn 1)
	 (set rn 0))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))


; Logical instructions.

(dnci or "bitwise or" ()
     "or $rn,$rm"
     (+ MAJ_1 rn rm (f-sub4 0))
     (set rn (or rn rm))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci and "bitwise and" ()
     "and $rn,$rm"
     (+ MAJ_1 rn rm (f-sub4 1))
     (set rn (and rn rm))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci xor "bitwise exclusive or" ()
     "xor $rn,$rm"
     (+ MAJ_1 rn rm (f-sub4 2))
     (set rn (xor rn rm))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci nor "bitwise negated or" ()
     "nor $rn,$rm"
     (+ MAJ_1 rn rm (f-sub4 3))
     (set rn (inv (or rn rm)))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci or3 "or three operand" ()
     "or3 $rn,$rm,$uimm16"
     (+ MAJ_12 rn rm (f-sub4 4) uimm16)
     (set rn (or rm (zext SI uimm16)))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci and3 "and three operand" ()
     "and3 $rn,$rm,$uimm16"
     (+ MAJ_12 rn rm (f-sub4 5) uimm16)
     (set rn (and rm (zext SI uimm16)))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci xor3 "exclusive or three operand" ()
     "xor3 $rn,$rm,$uimm16"
     (+ MAJ_12 rn rm (f-sub4 6) uimm16)
     (set rn (xor rm (zext SI uimm16)))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))


; Shift instructions.

(dnci sra "shift right arithmetic" ((STALL INT2))
     "sra $rn,$rm"
     (+ MAJ_2 rn rm (f-sub4 13))
     (set rn (sra rn (and rm #x1f)))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci srl "shift right logical" ((STALL INT2))
     "srl $rn,$rm"
     (+ MAJ_2 rn rm (f-sub4 12))
     (set rn (srl rn (and rm #x1f)))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci sll "shift left logical" ((STALL INT2))
     "sll $rn,$rm"
     (+ MAJ_2 rn rm (f-sub4 14))
     (set rn (sll rn (and rm #x1f)))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))

(dnci srai "shift right arithmetic (immediate)" ((STALL SHIFTI))
     "sra $rn,$uimm5"
     (+ MAJ_6 rn uimm5 (f-sub3 3))
     (set rn (sra rn uimm5))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci srli "shift right logical (immediate)" ((STALL SHIFTI))
     "srl $rn,$uimm5"
     (+ MAJ_6 rn uimm5 (f-sub3 2))
     (set rn (srl rn uimm5))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci slli "shift left logical (immediate)" ((STALL SHIFTI))
     "sll $rn,$uimm5"
     (+ MAJ_6 rn uimm5 (f-sub3 6))
     (set rn (sll rn uimm5))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci sll3 "three-register shift left logical" ((STALL INT2))
     "sll3 \\$0,$rn,$uimm5"
     (+ MAJ_6 rn uimm5 (f-sub3 7))
     (set r0 (sll rn uimm5))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci fsft "field shift" ((STALL FSFT) VOLATILE)
     "fsft $rn,$rm"
     (+ MAJ_2 rn rm (f-sub4 15))
     (sequence ((DI temp) (QI shamt))
	       (set shamt (and sar #x3f))
	       (set temp (sll (or (sll (zext DI rn) 32) (zext DI rm)) shamt))
	       (set rn (subword SI (srl temp 32) 1)))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))


; Branch/jump instructions.

(dnci bra "branch" (RELAXABLE)
     "bra $pcrel12a2"
     (+ MAJ_11 pcrel12a2 (f-15 0))
     (set-vliw-alignment-modified pc pcrel12a2)
     ((mep (unit u-branch)
	   (unit u-exec))))

(dnci beqz "branch if equal zero" (RELAXABLE)
     "beqz $rn,$pcrel8a2"
     (+ MAJ_10 rn pcrel8a2 (f-15 0))
     (if (eq rn 0)
	 (set-vliw-alignment-modified pc pcrel8a2))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec)
	   (unit u-branch))))

(dnci bnez "branch if not equal zero" (RELAXABLE)
     "bnez $rn,$pcrel8a2"
     (+ MAJ_10 rn pcrel8a2 (f-15 1))
     (if (ne rn 0)
	 (set-vliw-alignment-modified pc pcrel8a2))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec)
	   (unit u-branch))))

(dnci beqi "branch equal immediate" (RELAXABLE)
     "beqi $rn,$uimm4,$pcrel17a2"
     (+ MAJ_14 rn uimm4 (f-sub4 0) pcrel17a2)
     (if (eq rn (zext SI uimm4))
	 (set-vliw-alignment-modified pc pcrel17a2))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec)
	   (unit u-branch))))

(dnci bnei "branch not equal immediate" (RELAXABLE)
     "bnei $rn,$uimm4,$pcrel17a2"
     (+ MAJ_14 rn uimm4 (f-sub4 4) pcrel17a2)
     (if (ne rn (zext SI uimm4))
	 (set-vliw-alignment-modified pc pcrel17a2))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec)
	   (unit u-branch))))

(dnci blti "branch less than immediate" (RELAXABLE)
     "blti $rn,$uimm4,$pcrel17a2"
     (+ MAJ_14 rn uimm4 (f-sub4 12) pcrel17a2)
     (if (lt rn (zext SI uimm4))
	 (set-vliw-alignment-modified pc pcrel17a2))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec)
	   (unit u-branch))))

(dnci bgei "branch greater than immediate" (RELAXABLE)
     "bgei $rn,$uimm4,$pcrel17a2"
     (+ MAJ_14 rn uimm4 (f-sub4 8) pcrel17a2)
     (if (ge rn (zext SI uimm4))
	 (set-vliw-alignment-modified pc pcrel17a2))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec)
	   (unit u-branch))))

(dnci beq "branch equal" ()
     "beq $rn,$rm,$pcrel17a2"
     (+ MAJ_14 rn rm (f-sub4 1) pcrel17a2)
     (if (eq rn rm)
	 (set-vliw-alignment-modified pc pcrel17a2))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-branch))))

(dnci bne "branch not equal" ()
     "bne $rn,$rm,$pcrel17a2"
     (+ MAJ_14 rn rm (f-sub4 5) pcrel17a2)
     (if (ne rn rm)
	 (set-vliw-alignment-modified pc pcrel17a2))
     ((mep (unit u-use-gpr (in usereg rn))
           (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-branch))))

(dnci bsr12 "branch to subroutine (12 bit displacement)" (RELAXABLE)
     "bsr $pcrel12a2"
     (+ MAJ_11 pcrel12a2 (f-15 1))
     (sequence ()
	       (cg-profile pc pcrel12a2)
	       (set-vliw-modified-pcrel-offset lp 2 4 8)
	       (set-vliw-alignment-modified pc pcrel12a2))
     ((mep (unit u-exec)
	   (unit u-branch))))

(dnci bsr24 "branch to subroutine (24 bit displacement)" ()
     "bsr $pcrel24a2"
     (+ MAJ_13 (f-4 1) (f-sub4 9) pcrel24a2)
     (sequence ()
	       (cg-profile pc pcrel24a2)
	       (set-vliw-modified-pcrel-offset lp 4 4 8)
	       (set-vliw-alignment-modified pc pcrel24a2))
     ((mep (unit u-exec)
	   (unit u-branch))))

(dnci jmp "jump" ()
     "jmp $rm"
     (+ MAJ_1 (f-rn 0) rm (f-sub4 14))
     (sequence ()
	       (if (eq (get-psw.om) 0)
		   ;; core mode
		   (if (get-rm.lsb)
		       (sequence ()
				 (set-psw.om 1) ;; enter VLIW mode
				 (set-vliw-aliignment-modified-by-option pc rm))
		       (set pc (and rm (inv 1))))
		   ;; VLIW mode
		   (if (get-rm.lsb)
		       (sequence ()
				 (set-psw.om 0) ;; enter core mode
				 (set pc (and rm (inv 1))))
		       (set-vliw-aliignment-modified-by-option pc rm)))
	       (cg-profile-jump pc rm))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-branch))))

(dnci jmp24 "jump (24 bit target)" ()
     "jmp $pcabs24a2"
     (+ MAJ_13 (f-4 1) (f-sub4 8) pcabs24a2)
     (sequence ()
	       (set-vliw-alignment-modified pc (or (and pc #xf0000000) pcabs24a2))
	       (cg-profile-jump pc pcabs24a2))
     ((mep (unit u-exec)
	   (unit u-branch))))

(dnci jsr "jump to subroutine" ()
     "jsr $rm"
     (+ MAJ_1 (f-rn 0) rm (f-sub4 15))
     (sequence ()
	       (cg-profile pc rm)
	       (set-vliw-modified-pcrel-offset lp 2 4 8)
	       (set-vliw-alignment-modified pc rm))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-branch))))

(dnci ret "return from subroutine" ((STALL RET))
     "ret"
     (+ MAJ_7 (f-rn 0) (f-rm 0) (f-sub4 2))
     (sequence ()
	       (if (eq (get-psw.om) 0)
		   ;; core mode
		   (if (get-lp.ltom) ;; link-pointer "toggle mode" bit
		       (sequence ()
				 (set-psw.om 1) ;; enter VLIW mode
				 (set-vliw-aliignment-modified-by-option pc lp))
		       (set pc (and lp (inv 1))))
		   ;; VLIW mode
		   (if (get-lp.ltom) ;; link-pointer "toggle mode" bit
		       (sequence ()
				 (set-psw.om 0) ;; enter VLIW mode
				 (set pc (and lp (inv 1))))
		       (set-vliw-aliignment-modified-by-option pc lp)))
	       (c-call VOID "notify_ret" pc))
     ((mep (unit u-exec)
	   (unit u-branch))))


; Repeat instructions.

(dnci repeat "repeat specified repeat block" ()
     "repeat $rn,$pcrel17a2"
     (+ MAJ_14 rn (f-rm 0) (f-sub4 9) pcrel17a2)
     (sequence ()
	       (set-vliw-modified-pcrel-offset (reg h-csr 4) 4 4 8)
	       (set-vliw-alignment-modified (reg h-csr 5) pcrel17a2)
	       (set (reg h-csr 6) rn))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci erepeat "endless repeat" ()
     "erepeat $pcrel17a2"
     (+ MAJ_14 (f-rn 0) (f-rm 1) (f-sub4 9) pcrel17a2)
     (sequence ()
	       (set-vliw-modified-pcrel-offset (reg h-csr 4) 4 4 8)
	       (set-vliw-alignment-modified (reg h-csr 5) pcrel17a2)
	       (set-rpe.elr 1)
	       ; rpc may be undefined for erepeat
	       ; use 1 to trigger repeat logic in the sim's main loop
	       (set (reg h-csr 6) 1))
     ())


; Control instructions.

;; special store variants

(dnci stc_lp "store to control register lp" ((STALL STC))
      "stc $rn,\\$lp" 
      (+ MAJ_7 rn (f-csrn-lo 1) (f-csrn-hi 0) (f-12 1) (f-13 0) (f-14 0))  
      (set lp rn)     
      ((mep (unit u-use-gpr (in usereg rn))
	    (unit u-store-ctrl-reg (out storereg lp))
	    (unit u-exec))))

(dnci stc_hi "store to control register hi" ((STALL STC))
      "stc $rn,\\$hi" 
      (+ MAJ_7 rn (f-csrn-lo 7) (f-csrn-hi 0) (f-12 1) (f-13 0) (f-14 0))  
      (set hi rn)     
      ((mep (unit u-use-gpr (in usereg rn))
	    (unit u-store-ctrl-reg (out storereg hi))
	    (unit u-exec))))

(dnci stc_lo "store to control register lo" ((STALL STC))
      "stc $rn,\\$lo" 
      (+ MAJ_7 rn (f-csrn-lo 8) (f-csrn-hi 0) (f-12 1) (f-13 0) (f-14 0))  
      (set lo rn)    
      ((mep (unit u-use-gpr (in usereg rn))
	    (unit u-store-ctrl-reg (out storereg lo))
	    (unit u-exec))))

;; general store

(dnci stc "store to control register" (VOLATILE (STALL STC))
     "stc $rn,$csrn"
     (+ MAJ_7 rn csrn (f-12 1) (f-13 0) (f-14 0))
     (set csrn rn)
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-store-ctrl-reg (out storereg csrn))
	   (unit u-exec))))

;; special load variants 

(dnci ldc_lp "load from control register lp" ((STALL LDC))
      "ldc $rn,\\$lp"    
      (+ MAJ_7 rn (f-csrn-lo 1) (f-csrn-hi 0) (f-12 1) (f-13 0) (f-14 1))     
      (set rn lp)     
      ((mep (unit u-use-ctrl-reg (in usereg lp))
	    (unit u-exec)
	    (unit u-load-gpr (out loadreg rn)))))
       

(dnci ldc_hi "load from control register hi" ((STALL LDC))
      "ldc $rn,\\$hi"    
      (+ MAJ_7 rn (f-csrn-lo 7) (f-csrn-hi 0) (f-12 1) (f-13 0) (f-14 1))
      (set rn hi)
      ((mep (unit u-use-ctrl-reg (in usereg hi))
	    (unit u-exec)
	    (unit u-load-gpr (out loadreg rn)))))

(dnci ldc_lo "load from control register lo" ((STALL LDC))
      "ldc $rn,\\$lo"
      (+ MAJ_7 rn (f-csrn-lo 8) (f-csrn-hi 0) (f-12 1) (f-13 0) (f-14 1))     
      (set rn lo)
      ((mep (unit u-use-ctrl-reg (in usereg lo))
	    (unit u-exec)
	    (unit u-load-gpr (out loadreg rn)))))

;; general load

(dnci ldc "load from control register" (VOLATILE (STALL LDC) (LATENCY 2))
     "ldc $rn,$csrn"
     (+ MAJ_7 rn csrn (f-12 1) (f-13 0) (f-14 1))
     (if (eq (ifield f-csrn) 0) 
	 ;; loading from the pc
	 (set-vliw-modified-pcrel-offset rn 2 4 8)
	 ;; loading from something else
	 (set rn csrn))
      ((mep (unit u-use-ctrl-reg (in usereg csrn))
	    (unit u-exec)
	    (unit u-load-gpr (out loadreg rn)))))

(dnci di "disable interrupt" (VOLATILE)
     "di"
     (+ MAJ_7 (f-rn 0) (f-rm 0) (f-sub4 0))
     ; clear psw.iec
     (set psw (sll (srl psw 1) 1)) 
     ())

(dnci ei "enable interrupt" (VOLATILE)
     "ei"
     (+ MAJ_7 (f-rn 0) (f-rm 1) (f-sub4 0))
     ; set psw.iec
     (set psw (or psw 1))
     ())

(dnci reti "return from interrupt" ((STALL RET))
     "reti"
     (+ MAJ_7 (f-rn 0) (f-rm 1) (f-sub4 2))
     (if (eq (get-psw.om) 0)
	 ;; core operation mode
	 (if (get-psw.nmi)
	     ;; return from NMI
	     (if (get-npc.ntom)
		 ;; return in VLIW operation mode
		 (sequence ()
			   (set-psw.om 1)
			   (set-vliw-aliignment-modified-by-option pc npc)
			   (set-psw.nmi 0))
		 ;; return in core mode
		 (sequence ()
			   (set pc (and npc (inv 1)))
			   (set-psw.nmi 0)))
	     ;; return from non-NMI
	     (if (get-epc.etom)
		 ;; return in VLIW mode
		 (sequence () 
			   (set-psw.om 1)
			   (set-vliw-aliignment-modified-by-option pc epc)
			   (set-psw.umc (get-psw.ump))
			   (set-psw.iec (get-psw.iep)))
		 ;; return in core mode
		 (sequence ()
			   (set pc (and epc (inv 1)))
			   (set-psw.umc (get-psw.ump))
			   (set-psw.iec (get-psw.iep)))))
	 ;; VLIW operation mode
	 ;; xxx undefined
	 (nop))
     ((mep (unit u-exec)
	   (unit u-branch))))

(dnci halt "halt pipeline" (VOLATILE)
     "halt"
     (+ MAJ_7 (f-rn 0) (f-rm 2) (f-sub4 2))
     ; set psw.halt
     (set (raw-reg h-csr 16) (or psw (sll 1 11)))
     ())

(dnci sleep "sleep pipeline" (VOLATILE)
     "sleep"
     (+ MAJ_7 (f-rn 0) (f-rm 6) (f-sub4 2))
     (c-call VOID "do_sleep")
     ())

(dnci swi "software interrupt" (MAY_TRAP VOLATILE)
     "swi $uimm2"
     (+ MAJ_7 (f-rn 0) (f-8 0) (f-9 0) uimm2 (f-sub4 6))
     (cond
      ((eq uimm2 0) (set exc (or exc (sll 1 4))))
      ((eq uimm2 1) (set exc (or exc (sll 1 5))))
      ((eq uimm2 2) (set exc (or exc (sll 1 6))))
      ((eq uimm2 3) (set exc (or exc (sll 1 7)))))
     ())

(dnci break "break exception" (MAY_TRAP VOLATILE)
     "break"
     (+ MAJ_7 (f-rn 0) (f-rm 3) (f-sub4 2))
     (set pc (c-call USI "break_exception" pc))
     ((mep (unit u-exec)
	   (unit u-branch))))

(dnci syncm "synchronise with memory" (VOLATILE)
     "syncm"
     (+ MAJ_7 (f-rn 0) (f-rm 1) (f-sub4 1))
     (unimp "syncm")
     ())

(dnci stcb "store in control bus space" (VOLATILE (STALL STCB))
     "stcb $rn,$uimm16"
     (+ MAJ_15 rn (f-rm 0) (f-sub4 4) uimm16)
     (c-call VOID "do_stcb" rn uimm16)
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec)
	   (unit u-stcb))))

(dnci ldcb "load from control bus space" (VOLATILE (STALL LDCB) (LATENCY 3))
     "ldcb $rn,$uimm16"
     (+ MAJ_15 rn (f-rm 1) (f-sub4 4) uimm16)
     (set rn (c-call SI "do_ldcb" uimm16))
      ((mep (unit u-ldcb)
	    (unit u-exec)
	    (unit u-ldcb-gpr (out loadreg rn)))))


; Bit manipulation instructions.
; The following instructions become the reserved instruction when the
; bit manipulation option is off.

(dnci bsetm "set bit in memory" (OPTIONAL_BIT_INSN)
     "bsetm ($rma),$uimm3"
     (+ MAJ_2 (f-4 0) uimm3 rma (f-sub4 0))
     (sequence ()
	       (c-call "check_option_bit" pc)
	       (set (mem UQI rma) (or (mem UQI rma) (sll 1 uimm3))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci bclrm "clear bit in memory" (OPTIONAL_BIT_INSN)
     "bclrm ($rma),$uimm3"
     (+ MAJ_2 (f-4 0) uimm3 rma (f-sub4 1))
     (sequence ()
	       (c-call "check_option_bit" pc)
	       (set (mem UQI rma) (and (mem UQI rma) (inv (sll 1 uimm3)))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci bnotm "toggle bit in memory" (OPTIONAL_BIT_INSN)
     "bnotm ($rma),$uimm3"
     (+ MAJ_2 (f-4 0) uimm3 rma (f-sub4 2))
     (sequence ()
	       (c-call "check_option_bit" pc)
	       (set (mem UQI rma) (xor (mem UQI rma) (sll 1 uimm3))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci btstm "test bit in memory" (OPTIONAL_BIT_INSN)
     "btstm \\$0,($rma),$uimm3"
     (+ MAJ_2 (f-4 0) uimm3 rma (f-sub4 3))
     (sequence ()
	       (c-call "check_option_bit" pc)
	       (set r0 (zext SI (and UQI (mem UQI rma) (sll 1 uimm3)))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci tas "test and set" (OPTIONAL_BIT_INSN)
     "tas $rn,($rma)"
     (+ MAJ_2 rn rma (f-sub4 4))
     (sequence ((SI result))
	       (c-call "check_option_bit" pc)
	       (set result (zext SI (mem UQI rma)))
	       (set (mem UQI rma) 1)
	       (set rn result))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))


; Data cache instruction.

(dnci cache "cache operations" (VOLATILE)
     "cache $cimm4,($rma)"
     (+ MAJ_7 cimm4 rma (f-sub4 4))
     (c-call VOID "do_cache" cimm4 rma pc)
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))


; Multiply instructions.
; These instructions become the RI when the 32-bit multiply
; instruction option is off.

(dnci mul "multiply" (OPTIONAL_MUL_INSN (STALL MUL))
     "mul $rn,$rm"
     (+ MAJ_1 rn rm (f-sub4 4))
     (sequence ((DI result))
	       (c-call "check_option_mul" pc)
	       (set result (mul (ext DI rn) (ext DI rm)))
	       (set hi (subword SI result 0))
	       (set lo (subword SI result 1)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-multiply))))

(dnci mulu "multiply unsigned" (OPTIONAL_MUL_INSN (STALL MUL))
     "mulu $rn,$rm"
     (+ MAJ_1 rn rm (f-sub4 5))
     (sequence ((DI result))
	       (c-call "check_option_mul" pc)
	       (set result (mul (zext UDI rn) (zext UDI rm)))
	       (set hi (subword SI result 0))
	       (set lo (subword SI result 1)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-multiply))))

(dnci mulr "multiply, lo -> reg" (OPTIONAL_MUL_INSN (STALL MULR) (LATENCY 3))
     "mulr $rn,$rm"
     (+ MAJ_1 rn rm (f-sub4 6))
     (sequence ((DI result))
	       (c-call "check_option_mul" pc)
	       (set result (mul (ext DI rn) (ext DI rm)))
	       (set hi (subword SI result 0))
	       (set lo (subword SI result 1))
	       (set rn (subword SI result 1)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-multiply)
	   (unit u-mul-gpr (out resultreg rn)))))

(dnci mulru "multiply unsigned, lo -> reg" (OPTIONAL_MUL_INSN (STALL MULR) (LATENCY 3))
     "mulru $rn,$rm"
     (+ MAJ_1 rn rm (f-sub4 7))
     (sequence ((DI result))
	       (c-call "check_option_mul" pc)
	       (set result (mul (zext UDI rn) (zext UDI rm)))
	       (set hi (subword SI result 0))
	       (set lo (subword SI result 1))
	       (set rn (subword SI result 1)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-multiply)
	   (unit u-mul-gpr (out resultreg rn)))))

(dnci madd "multiply accumulate" (OPTIONAL_MUL_INSN (STALL MUL))
     "madd $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 #x3004))
     (sequence ((DI result))
	       (c-call "check_option_mul" pc)
	       (set result (or (sll (zext DI hi) 32) (zext DI lo)))
	       (set result (add result (mul (ext DI rn) (ext DI rm))))
	       (set hi (subword SI result 0))
	       (set lo (subword SI result 1)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-multiply))))

(dnci maddu "multiply accumulate unsigned" (OPTIONAL_MUL_INSN (STALL MUL))
     "maddu $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 #x3005))
     (sequence ((DI result))
	       (c-call "check_option_mul" pc)
	       (set result (or (sll (zext DI hi) 32) (zext DI lo)))
	       (set result (add result (mul (zext UDI rn) (zext UDI rm))))
	       (set hi (subword SI result 0))
	       (set lo (subword SI result 1)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-multiply))))


(dnci maddr "multiply accumulate, lo -> reg" (OPTIONAL_MUL_INSN (STALL MULR) (LATENCY 3))
     "maddr $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 #x3006))
     (sequence ((DI result))
	       (c-call "check_option_mul" pc)
	       (set result (or (sll (zext DI hi) 32) (zext DI lo)))
	       (set result (add result (mul (ext DI rn) (ext DI rm))))
	       (set hi (subword SI result 0))
	       (set lo (subword SI result 1))
	       (set rn (subword SI result 1)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-multiply)
	   (unit u-mul-gpr (out resultreg rn)))))

(dnci maddru "multiple accumulate unsigned, lo -> reg" (OPTIONAL_MUL_INSN (STALL MULR) (LATENCY 3))
     "maddru $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 #x3007))
     (sequence ((DI result))
	       (c-call "check_option_mul" pc)
	       (set result (or (sll (zext DI hi) 32) (zext DI lo)))
	       (set result (add result (mul (zext UDI rn) (zext UDI rm))))
	       (set hi (subword SI result 0))
	       (set lo (subword SI result 1))
	       (set rn (subword SI result 1)))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-multiply)
	   (unit u-mul-gpr (out resultreg rn)))))


; Divide instructions.
; These instructions become the RI when the 32-bit divide instruction
; option is off.

(dnci div "divide" (OPTIONAL_DIV_INSN (STALL DIV) (LATENCY 34) MAY_TRAP)
     "div $rn,$rm"
     (+ MAJ_1 rn rm (f-sub4 8))
     (sequence ()
	       (c-call "check_option_div" pc)
	       (if (eq rm 0)
		   (set pc (c-call USI "zdiv_exception" pc))
		   ; Special case described on p. 76.
		   (if (and (eq rn #x80000000)
			    (eq rm #xffffffff))
		       (sequence ()
				 (set lo #x80000000)
				 (set hi 0))
		       (sequence ()
				 (set lo (div rn rm))
				 (set hi (mod rn rm))))))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-divide)
           (unit u-branch))))

(dnci divu "divide unsigned" (OPTIONAL_DIV_INSN (STALL DIV) (LATENCY 34) MAY_TRAP)
     "divu $rn,$rm"
     (+ MAJ_1 rn rm (f-sub4 9))
     (sequence ()
	       (c-call "check_option_div" pc)
	       (if (eq rm 0)
		   (set pc (c-call USI "zdiv_exception" pc))
		   (sequence ()
			     (set lo (udiv rn rm))
			     (set hi (umod rn rm)))))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-divide)
           (unit u-branch))))


; Debug functions.
; These instructions become the RI when the debug function option is
; off.

(dnci dret "return from debug exception" (OPTIONAL_DEBUG_INSN)
     "dret"
     (+ MAJ_7 (f-rn 0) (f-rm 1) (f-sub4 3))
     (sequence ()
	       (c-call "check_option_debug" pc)
	       ; set DBG.DM.
	       (set dbg (and dbg (inv (sll SI 1 15))))
	       (set pc depc))
     ((mep (unit u-exec)
	   (unit u-branch))))

(dnci dbreak "generate debug exception" (OPTIONAL_DEBUG_INSN MAY_TRAP VOLATILE)
     "dbreak"
     (+ MAJ_7 (f-rn 0) (f-rm 3) (f-sub4 3))
     (sequence ()
	       (c-call "check_option_debug" pc)
	       ; set DBG.DPB.
	       (set dbg (or dbg 1)))
     ())


; Leading zero instruction.

(dnci ldz "leading zeroes" (OPTIONAL_LDZ_INSN (STALL INT2))
     "ldz $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 0))
     (sequence ()
	       (c-call "check_option_ldz" pc)
	       (set rn (c-call SI "do_ldz" rm)))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec))))


; Absolute difference instruction.

(dnci abs "absolute difference" (OPTIONAL_ABS_INSN (STALL INT2))
     "abs $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 3))
     (sequence ()
	       (c-call "check_option_abs" pc)
	       (set rn (abs (sub rn rm))))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))


; Average instruction.

(dnci ave "average" (OPTIONAL_AVE_INSN (STALL INT2))
     "ave $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 2))
     (sequence ()
	       (c-call "check_option_ave" pc)
	       (set rn (sra (add (add rn rm) 1) 1)))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))


; MIN/MAX instructions.

(dnci min "minimum" (OPTIONAL_MINMAX_INSN (STALL INT2))
     "min $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 4))
     (sequence ()
	       (c-call "check_option_minmax" pc)
	       (if (gt rn rm)
		   (set rn rm)))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci max "maximum" (OPTIONAL_MINMAX_INSN (STALL INT2))
     "max $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 5))
     (sequence ()
	       (c-call "check_option_minmax" pc)
	       (if (lt rn rm)
		   (set rn rm)))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci minu "minimum unsigned" (OPTIONAL_MINMAX_INSN (STALL INT2))
     "minu $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 6))
     (sequence ()
	       (c-call "check_option_minmax" pc)
	       (if (gtu rn rm)
		   (set rn rm)))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci maxu "maximum unsigned" (OPTIONAL_MINMAX_INSN (STALL INT2))
     "maxu $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 7))
     (sequence ()
	       (c-call "check_option_minmax" pc)
	       (if (ltu rn rm)
		   (set rn rm)))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))


; Clipping instruction.

(dnci clip "clip" (OPTIONAL_CLIP_INSN (STALL INT2))
     "clip $rn,$cimm5"
     (+ MAJ_15 rn (f-rm 0) (f-sub4 1) (f-ext #x10) cimm5 (f-29 0) (f-30 0) (f-31 0))
     (sequence ((SI min) (SI max))
	       (c-call "check_option_clip" pc)
	       (set max (sub (sll 1 (sub cimm5 1)) 1))
	       (set min (neg (sll 1 (sub cimm5 1))))
	       (cond
		((eq cimm5 0) (set rn 0))
		((gt rn max) (set rn max))
		((lt rn min) (set rn min))))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci clipu "clip unsigned" (OPTIONAL_CLIP_INSN (STALL INT2))
     "clipu $rn,$cimm5"
     (+ MAJ_15 rn (f-rm 0) (f-sub4 1) (f-ext #x10) cimm5 (f-29 0) (f-30 0) (f-31 1))
     (sequence ((SI max))
	       (c-call "check_option_clip" pc)
	       (set max (sub (sll 1 cimm5) 1))
	       (cond
		((eq cimm5 0) (set rn 0))
		((gt rn max) (set rn max))
		((lt rn 0) (set rn 0))))
     ((mep (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))


; Saturation instructions.

(dnci sadd "saturating addition" (OPTIONAL_SAT_INSN (STALL INT2))
     "sadd $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 8))
     (sequence ()
	       (c-call "check_option_sat" pc)
	       (if (add-oflag rn rm 0)
		   (if (nflag rn)
		       ; underflow
		       (set rn (neg (sll 1 31)))
		       ; overflow
		       (set rn (sub (sll 1 31) 1)))
		   (set rn (add rn rm))))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci ssub "saturating subtraction" (OPTIONAL_SAT_INSN (STALL INT2))
     "ssub $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 10))
     (sequence ()
	       (c-call "check_option_sat" pc)
	       (if (sub-oflag rn rm 0)
		   (if (nflag rn)
		       ; underflow
		       (set rn (neg (sll 1 31)))
		       ; overflow
		       (set rn (sub (sll 1 31) 1)))
		   (set rn (sub rn rm))))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci saddu "saturating unsigned addition" (OPTIONAL_SAT_INSN (STALL INT2))
     "saddu $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 9))
     (sequence ()
	       (c-call "check_option_sat" pc)
	       (if (add-cflag rn rm 0)
		   (set rn (inv 0))
		   (set rn (add rn rm))))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))

(dnci ssubu "saturating unsigned subtraction" (OPTIONAL_SAT_INSN (STALL INT2))
     "ssubu $rn,$rm"
     (+ MAJ_15 rn rm (f-sub4 1) (f-16u16 11))
     (sequence ()
	       (c-call "check_option_sat" pc)
	       (if (sub-cflag rn rm 0)
		   (set rn 0)
		   (set rn (sub rn rm))))
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-use-gpr (in usereg rn))
	   (unit u-exec))))


; UCI and DSP options are defined in an external file.
; See `mep-sample-ucidsp.cpu' for a sample.


; Coprocessor instructions.

(dnci swcp "store word coprocessor" (OPTIONAL_CP_INSN (STALL STORE))
     "swcp $crn,($rma)"
     (+ MAJ_3 crn rma (f-sub4 8))
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call VOID "check_write_to_text" (and rma (inv SI 3)))
	       (set (mem SI (and rma (inv SI 3))) crn))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lwcp "load word coprocessor" (OPTIONAL_CP_INSN (STALL LOAD))
     "lwcp $crn,($rma)"
     (+ MAJ_3 crn rma (f-sub4 9))
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set crn (mem SI (and rma (inv SI 3)))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci smcp "smcp" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL STORE))
     "smcp $crn64,($rma)"
     (+ MAJ_3 crn64 rma (f-sub4 10))
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call "check_option_cp64" pc)
	       (c-call VOID "check_write_to_text" rma)
	       (c-call "do_smcp" rma crn64 pc))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lmcp "lmcp" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL LOAD))
     "lmcp $crn64,($rma)"
     (+ MAJ_3 crn64 rma (f-sub4 11))
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call "check_option_cp64" pc)
	       (set crn64 (c-call DI "do_lmcp" rma pc)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci swcpi "swcp (post-increment)" (OPTIONAL_CP_INSN (STALL STORE))
     "swcpi $crn,($rma+)"
     (+ MAJ_3 crn rma (f-sub4 0))
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call VOID "check_write_to_text" (and rma (inv SI 3)))
	       (set (mem SI (and rma (inv SI 3))) crn)
	       (set rma (add rma 4)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lwcpi "lwcp (post-increment)" (OPTIONAL_CP_INSN (STALL LOAD))
     "lwcpi $crn,($rma+)"
     (+ MAJ_3 crn rma (f-sub4 1))
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set crn (mem SI (and rma (inv SI 3))))
	       (set rma (add rma 4)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci smcpi "smcp (post-increment)" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL STORE))
     "smcpi $crn64,($rma+)"
     (+ MAJ_3 crn64 rma (f-sub4 2))
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call "check_option_cp64" pc)
	       (c-call VOID "check_write_to_text" rma)
	       (c-call "do_smcpi" (index-of rma) crn64 pc)
	       (set rma rma)) ; reference as output for intrinsic generation
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lmcpi "lmcp (post-increment)" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL LOAD))
     "lmcpi $crn64,($rma+)"
     (+ MAJ_3 crn64 rma (f-sub4 3))
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call "check_option_cp64" pc)
	       (set crn64 (c-call DI "do_lmcpi" (index-of rma) pc))
	       (set rma rma)) ; reference as output for intrinsic generation
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci swcp16 "swcp (16-bit displacement)" (OPTIONAL_CP_INSN (STALL STORE))
     "swcp $crn,$sdisp16($rma)"
     (+ MAJ_15 crn rma (f-sub4 12) sdisp16)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set (mem SI (and (add rma sdisp16) (inv SI 3))) crn))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lwcp16 "lwcp (16-bit displacement)" (OPTIONAL_CP_INSN (STALL LOAD))
     "lwcp $crn,$sdisp16($rma)"
     (+ MAJ_15 crn rma (f-sub4 13) sdisp16)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set crn (mem SI (and (add rma sdisp16) (inv SI 3)))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci smcp16 "smcp (16-bit displacement)" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL STORE))
     "smcp $crn64,$sdisp16($rma)"
     (+ MAJ_15 crn64 rma (f-sub4 14) sdisp16)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call "check_option_cp64" pc)
	       (c-call "do_smcp16" rma sdisp16 crn64 pc))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lmcp16 "lmcp (16-bit displacement)" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL LOAD))
     "lmcp $crn64,$sdisp16($rma)"
     (+ MAJ_15 crn64 rma (f-sub4 15) sdisp16)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call "check_option_cp64" pc)
	       (set crn64 (c-call DI "do_lmcp16" rma sdisp16 pc)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci sbcpa "store byte coprocessor" (OPTIONAL_CP_INSN (STALL STORE))
     "sbcpa $crn,($rma+),$cdisp10"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 0) (f-ext62 0) cdisp10)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call VOID "check_write_to_text" rma)
	       (set (mem QI rma) (and crn #xff))
	       (set rma (add rma (ext SI cdisp10))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lbcpa "load byte coprocessor" (OPTIONAL_CP_INSN (STALL LOAD))
     "lbcpa $crn,($rma+),$cdisp10"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x4) (f-ext62 #x0) cdisp10)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set crn (ext SI (mem QI rma)))
	       (set rma (add rma (ext SI cdisp10))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci shcpa "store half-word coprocessor" (OPTIONAL_CP_INSN (STALL STORE))
     "shcpa $crn,($rma+),$cdisp10a2"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x1) (f-ext62 #x0) cdisp10a2)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call VOID "check_write_to_text" (and rma (inv SI 1)))
	       (set (mem HI (and rma (inv SI 1))) (and crn #xffff))
	       (set rma (add rma (ext SI cdisp10a2))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lhcpa "load half-word coprocessor" (OPTIONAL_CP_INSN (STALL LOAD))
     "lhcpa $crn,($rma+),$cdisp10a2"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x5) (f-ext62 #x0) cdisp10a2)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set crn (ext SI (mem HI (and rma (inv SI 1)))))
	       (set rma (add rma (ext SI cdisp10a2))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci swcpa "store word coprocessor" (OPTIONAL_CP_INSN (STALL STORE))
     "swcpa $crn,($rma+),$cdisp10a4"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x2) (f-ext62 #x0) cdisp10a4)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call VOID "check_write_to_text" (and rma (inv SI 3)))
	       (set (mem SI (and rma (inv SI 3))) crn)
	       (set rma (add rma (ext SI cdisp10a4))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lwcpa "load word coprocessor" (OPTIONAL_CP_INSN (STALL LOAD))
     "lwcpa $crn,($rma+),$cdisp10a4"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x6) (f-ext62 #x0) cdisp10a4)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set crn (mem SI (and rma (inv SI 3))))
	       (set rma (add rma (ext SI cdisp10a4))))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci smcpa "smcpa" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL STORE))
     "smcpa $crn64,($rma+),$cdisp10a8"
     (+ MAJ_15 crn64 rma (f-sub4 5) (f-ext4 #x3) (f-ext62 #x0) cdisp10a8)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call "check_option_cp64" pc)
	       (c-call VOID "check_write_to_text" rma)
	       (c-call "do_smcpa" (index-of rma) cdisp10a8 crn64 pc)
	       (set rma rma)) ; reference as output for intrinsic generation
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lmcpa "lmcpa" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN (STALL LOAD))
     "lmcpa $crn64,($rma+),$cdisp10a8"
     (+ MAJ_15 crn64 rma (f-sub4 5) (f-ext4 #x7) (f-ext62 #x0) cdisp10a8)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call "check_option_cp64" pc)
	       (set crn64 (c-call DI "do_lmcpa" (index-of rma) cdisp10a8 pc))
	       (set rma rma)) ; reference as output for intrinsic generation
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))


(dnci sbcpm0 "sbcpm0" (OPTIONAL_CP_INSN)
     "sbcpm0 $crn,($rma+),$cdisp10"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x0) (f-ext62 #x2) cdisp10)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call VOID "check_write_to_text" rma)
	       (set (mem QI rma) (and crn #xff))
	       (set rma (mod0 cdisp10)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lbcpm0 "lbcpm0" (OPTIONAL_CP_INSN)
     "lbcpm0 $crn,($rma+),$cdisp10"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x4) (f-ext62 #x2) cdisp10)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set crn (ext SI (mem QI rma)))
	       (set rma (mod0 cdisp10)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci shcpm0 "shcpm0" (OPTIONAL_CP_INSN)
     "shcpm0 $crn,($rma+),$cdisp10a2"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x1) (f-ext62 #x2) cdisp10a2)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call VOID "check_write_to_text" (and rma (inv SI 1)))
	       (set (mem HI (and rma (inv SI 1))) (and crn #xffff))
	       (set rma (mod0 cdisp10a2)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lhcpm0 "lhcpm0" (OPTIONAL_CP_INSN)
     "lhcpm0 $crn,($rma+),$cdisp10a2"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x5) (f-ext62 #x2) cdisp10a2)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set crn (ext SI (mem HI (and rma (inv SI 1)))))
	       (set rma (mod0 cdisp10a2)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci swcpm0 "swcpm0" (OPTIONAL_CP_INSN)
     "swcpm0 $crn,($rma+),$cdisp10a4"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x2) (f-ext62 #x2) cdisp10a4)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call VOID "check_write_to_text" (and rma (inv SI 3)))
	       (set (mem SI (and rma (inv SI 3))) crn)
	       (set rma (mod0 cdisp10a4)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lwcpm0 "lwcpm0" (OPTIONAL_CP_INSN)
     "lwcpm0 $crn,($rma+),$cdisp10a4"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x6) (f-ext62 #x2) cdisp10a4)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set crn (mem SI (and rma (inv SI 3))))
	       (set rma (mod0 cdisp10a4)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci smcpm0 "smcpm0" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN)
     "smcpm0 $crn64,($rma+),$cdisp10a8"
     (+ MAJ_15 crn64 rma (f-sub4 5) (f-ext4 #x3) (f-ext62 #x2) cdisp10a8)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call "check_option_cp64" pc)
	       (c-call VOID "check_write_to_text" rma)
	       (c-call "do_smcp" rma crn64 pc)
	       (set rma (mod0 cdisp10a8)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lmcpm0 "lmcpm0" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN)
     "lmcpm0 $crn64,($rma+),$cdisp10a8"
     (+ MAJ_15 crn64 rma (f-sub4 5) (f-ext4 #x7) (f-ext62 #x2) cdisp10a8)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call "check_option_cp64" pc)
	       (set crn64 (c-call DI "do_lmcp" rma pc))
	       (set rma (mod0 cdisp10a8)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci sbcpm1 "sbcpm1" (OPTIONAL_CP_INSN)
     "sbcpm1 $crn,($rma+),$cdisp10"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x0) (f-ext62 #x3) cdisp10)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call VOID "check_write_to_text" rma)
	       (set (mem QI rma) (and crn #xff))
	       (set rma (mod1 cdisp10)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lbcpm1 "lbcpm1" (OPTIONAL_CP_INSN)
     "lbcpm1 $crn,($rma+),$cdisp10"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x4) (f-ext62 #x3) cdisp10)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set crn (ext SI (mem QI rma)))
	       (set rma (mod1 cdisp10)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci shcpm1 "shcpm1" (OPTIONAL_CP_INSN)
     "shcpm1 $crn,($rma+),$cdisp10a2"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x1) (f-ext62 #x3) cdisp10a2)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call VOID "check_write_to_text" (and rma (inv SI 1)))
	       (set (mem HI (and rma (inv SI 1))) (and crn #xffff))
	       (set rma (mod1 cdisp10a2)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lhcpm1 "lhcpm1" (OPTIONAL_CP_INSN)
     "lhcpm1 $crn,($rma+),$cdisp10a2"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x5) (f-ext62 #x3) cdisp10a2)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set crn (ext SI (mem HI (and rma (inv SI 1)))))
	       (set rma (mod1 cdisp10a2)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci swcpm1 "swcpm1" (OPTIONAL_CP_INSN)
     "swcpm1 $crn,($rma+),$cdisp10a4"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x2) (f-ext62 #x3) cdisp10a4)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call VOID "check_write_to_text" (and rma (inv SI 3)))
	       (set (mem SI (and rma (inv SI 3))) crn)
	       (set rma (mod1 cdisp10a4)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lwcpm1 "lwcpm1" (OPTIONAL_CP_INSN)
     "lwcpm1 $crn,($rma+),$cdisp10a4"
     (+ MAJ_15 crn rma (f-sub4 5) (f-ext4 #x6) (f-ext62 #x3) cdisp10a4)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (set crn (ext SI (mem SI (and rma (inv SI 3)))))
	       (set rma (mod1 cdisp10a4)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci smcpm1 "smcpm1" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN)
     "smcpm1 $crn64,($rma+),$cdisp10a8"
     (+ MAJ_15 crn64 rma (f-sub4 5) (f-ext4 #x3) (f-ext62 #x3) cdisp10a8)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call "check_option_cp64" pc)
	       (c-call "do_smcp" rma crn64 pc)
	       (c-call VOID "check_write_to_text" rma)
	       (set rma (mod1 cdisp10a8)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnci lmcpm1 "lmcpm1" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN)
     "lmcpm1 $crn64,($rma+),$cdisp10a8"
     (+ MAJ_15 crn64 rma (f-sub4 5) (f-ext4 #x7) (f-ext62 #x3) cdisp10a8)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (c-call "check_option_cp64" pc)
	       (set crn64 (c-call DI "do_lmcp" rma pc))
	       (set rma (mod1 cdisp10a8)))
     ((mep (unit u-use-gpr (in usereg rma))
	   (unit u-exec))))

(dnop cp_flag       "branch condition register"  (all-mep-isas) h-ccr   1)

(dnci bcpeq "branch coprocessor equal" (OPTIONAL_CP_INSN RELAXABLE)
     "bcpeq $cccc,$pcrel17a2"
     (+ MAJ_13 (f-rn 8) cccc (f-sub4 4) pcrel17a2)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (if (eq (xor cccc cp_flag) 0)
	       (set-vliw-alignment-modified pc pcrel17a2)))
     ())

(dnci bcpne "branch coprocessor not equal" (OPTIONAL_CP_INSN RELAXABLE)
     "bcpne $cccc,$pcrel17a2"
     (+ MAJ_13 (f-rn 8) cccc (f-sub4 5) pcrel17a2)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (if (ne (xor cccc cp_flag) 0)
	       (set-vliw-alignment-modified pc pcrel17a2)))
     ())

(dnci bcpat "branch coprocessor and true" (OPTIONAL_CP_INSN RELAXABLE)
     "bcpat $cccc,$pcrel17a2"
     (+ MAJ_13 (f-rn 8) cccc (f-sub4 6) pcrel17a2)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (if (ne (and cccc cp_flag) 0)
	       (set-vliw-alignment-modified pc pcrel17a2)))
     ())

(dnci bcpaf "branch coprocessor and false" (OPTIONAL_CP_INSN RELAXABLE)
     "bcpaf $cccc,$pcrel17a2"
     (+ MAJ_13 (f-rn 8) cccc (f-sub4 7) pcrel17a2)
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (if (eq (and cccc cp_flag) 0)
	       (set-vliw-alignment-modified pc pcrel17a2)))
     ())

(dnci synccp "synchronise with coprocessor" (OPTIONAL_CP_INSN)
     "synccp"
     (+ MAJ_7 (f-rn 0) (f-rm 2) (f-sub4 1))
     (sequence ()
	       (c-call "check_option_cp" pc)
	       (unimp "synccp"))
     ())

(dnci jsrv "jump to vliw subroutine " (OPTIONAL_CP_INSN)
     "jsrv $rm"
     (+ MAJ_1 (f-rn 8) rm (f-sub4 15))
     (sequence ()
	       (cg-profile pc rm)
	       (c-call "check_option_cp" pc)
	       (core-vliw-switch

		;; in core operating mode
		(sequence ()
			  (set lp (or (add pc 2) 1))
			  (set-vliw-aliignment-modified-by-option pc rm)
			  (set-psw.om 1)) ;; to VLIW operation mode

		;; in VLIW32 operating mode
		(sequence ()
			  (set lp (or (add pc 4) 1))
			  (set pc (and rm (inv 1)))
			  (set-psw.om 0)) ;; to core operation mode

		;; in VLIW64 operating mode
		(sequence ()
			  (set lp (or (add pc 8) 1))
			  (set pc (and rm (inv 1)))
			  (set-psw.om 0)))) ;; to core operation mode
     ((mep (unit u-use-gpr (in usereg rm))
	   (unit u-exec)
	   (unit u-branch))))

(dnci bsrv "branch to vliw subroutine" (OPTIONAL_CP_INSN)
     "bsrv $pcrel24a2"
     (+ MAJ_13 (f-4 1) (f-sub4 11) pcrel24a2)
     (sequence ()
	       (cg-profile pc pcrel24a2)
	       (c-call "check_option_cp" pc)
	       (core-vliw-switch

		;; in core operating mode
		(sequence ()
			  (set lp (or (add pc 4) 1))
			  (set-vliw-aliignment-modified-by-option pc pcrel24a2)
			  (set-psw.om 1)) ;; to VLIW operation mode

		;; in VLIW32 operating mode
		(sequence ()
			  (set lp (or (add pc 4) 1))
			  (set pc (and pcrel24a2 (inv 1)))
			  (set-psw.om 0)) ;; to core operation mode

		;; in VLIW64 operating mode
		(sequence ()
			  (set lp (or (add pc 8) 1))
			  (set pc (and pcrel24a2 (inv 1)))
			  (set-psw.om 0)))) ;; to core operation mode
     ((mep (unit u-exec)
	   (unit u-branch))))


; An instruction for test instrumentation.
; Using a reserved opcode.

(dnci sim-syscall "simulator system call" ()
     "--syscall--"
     (+ MAJ_7 (f-4 1) callnum (f-8 0) (f-9 0) (f-10 0) (f-sub4 0))
     (c-call "do_syscall" pc callnum)
     ())

(define-pmacro (dnri n major minor)
  (dnci (.sym ri- n) "reserved instruction" ()
	"--reserved--"
	(+ major rn rm (f-sub4 minor))
	(set pc (c-call USI "ri_exception" pc))
	((mep (unit u-exec)
	      (unit u-branch)))))

(dnri 0  MAJ_0   6)
(dnri 1  MAJ_1  10)
(dnri 2  MAJ_1  11)
(dnri 3  MAJ_2   5)
(dnri 4  MAJ_2   8)
(dnri 5  MAJ_2   9)
(dnri 6  MAJ_2  10)
(dnri 7  MAJ_2  11)
(dnri 8  MAJ_3   4)
(dnri 9  MAJ_3   5)
(dnri 10 MAJ_3   6)
(dnri 11 MAJ_3   7)
(dnri 12 MAJ_3  12)
(dnri 13 MAJ_3  13)
(dnri 14 MAJ_3  14)
(dnri 15 MAJ_3  15)
(dnri 17 MAJ_7   7)
(dnri 20 MAJ_7  14)
(dnri 21 MAJ_7  15)
(dnri 22 MAJ_12  7)
(dnri 23 MAJ_14 13)
;(dnri 24 MAJ_15  3)
(dnri 26 MAJ_15  8)
; begin core-specific reserved insns
; end core-specific reserved insns


; Macro instructions.

(dnmi nop "nop"
      ()
      "nop"
      (emit mov (rn 0) (rm 0)))

; Emit the 16 bit form of these 32 bit insns when the displacement is zero.
;
(dncmi sb16-0 "store byte (explicit 16 bit displacement of zero)" (NO-DIS)
     "sb $rnc,$zero($rma)"
     (emit sb rnc rma))

(dncmi sh16-0 "store half (explicit 16 bit displacement of zero)" (NO-DIS)
     "sh $rns,$zero($rma)"
     (emit sh rns rma))

(dncmi sw16-0 "store word (explicit 16 bit displacement of zero)" (NO-DIS)
     "sw $rnl,$zero($rma)"
     (emit sw rnl rma))

(dncmi lb16-0 "load byte (explicit 16 bit displacement of zero)" (NO-DIS)
     "lb $rnc,$zero($rma)"
     (emit lb rnc rma))

(dncmi lh16-0 "load half (explicit 16 bit displacement of zero)" (NO-DIS)
     "lh $rns,$zero($rma)"
     (emit lh rns rma))

(dncmi lw16-0 "load word (explicit 16 bit displacement of zero)" (NO-DIS)
     "lw $rnl,$zero($rma)"
     (emit lw rnl rma))

(dncmi lbu16-0 "load unsigned byte (explicit 16 bit displacement of zero)" (NO-DIS)
     "lbu $rnuc,$zero($rma)"
     (emit lbu rnuc rma))

(dncmi lhu16-0 "load unsigned half (explicit 16 bit displacement of zero)" (NO-DIS)
     "lhu $rnus,$zero($rma)"
     (emit lhu rnus rma))

(dncmi swcp16-0 "swcp (explicit 16-bit displacement of zero)" (OPTIONAL_CP_INSN NO-DIS)
     "swcp $crn,$zero($rma)"
     (emit swcp crn rma))

(dncmi lwcp16-0 "lwcp (explicit 16-bit displacement of zero)" (OPTIONAL_CP_INSN NO-DIS)
     "lwcp $crn,$zero($rma)"
     (emit lwcp crn rma))

(dncmi smcp16-0 "smcp (explicit 16-bit displacement of zero)" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN NO-DIS)
     "smcp $crn64,$zero($rma)"
     (emit smcp crn64 rma))

(dncmi lmcp16-0 "lmcp (explicit 16-bit displacement of zero)" (OPTIONAL_CP_INSN OPTIONAL_CP64_INSN NO-DIS)
     "lmcp $crn64,$zero($rma)"
     (emit lmcp crn64 rma))
