/* original parser id follows */
/* yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93" */
/* (use YYMAJOR/YYMINOR for ifdefs dependent on parser version) */

#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9

#define YYEMPTY        (-1)
#define yyclearin      (yychar = YYEMPTY)
#define yyerrok        (yyerrflag = 0)
#define YYRECOVERING() (yyerrflag != 0)
#define YYENOMEM       (-2)
#define YYEOF          0
#undef YYBTYACC
#define YYBTYACC 0
#define YYDEBUGSTR YYPREFIX "debug"
#define YYPREFIX "yy"

#define YYPURE 0

#line 40 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"

#include "defs.h"
#include <ctype.h>
#include "expression.h"
#include "value.h"
#include "parser-defs.h"
#include "language.h"
#include "c-lang.h"
#include "d-lang.h"
#include "bfd.h" /* Required by objfiles.h.  */
#include "symfile.h" /* Required by objfiles.h.  */
#include "objfiles.h" /* For have_full_symbols and have_partial_symbols */
#include "charset.h"
#include "block.h"

#define parse_type(ps) builtin_type (parse_gdbarch (ps))
#define parse_d_type(ps) builtin_d_type (parse_gdbarch (ps))

/* Remap normal yacc parser interface names (yyparse, yylex, yyerror, etc),
   as well as gratuitiously global symbol names, so we can have multiple
   yacc generated parsers in gdb.  Note that these are only the variables
   produced by yacc.  If other parser generators (bison, byacc, etc) produce
   additional global names that conflict at link time, then those parser
   generators need to be fixed instead of adding those names to this list.  */

#define	yymaxdepth d_maxdepth
#define	yyparse	d_parse_internal
#define	yylex	d_lex
#define	yyerror	d_error
#define	yylval	d_lval
#define	yychar	d_char
#define	yydebug	d_debug
#define	yypact	d_pact
#define	yyr1	d_r1
#define	yyr2	d_r2
#define	yydef	d_def
#define	yychk	d_chk
#define	yypgo	d_pgo
#define	yyact	d_act
#define	yyexca	d_exca
#define	yyerrflag d_errflag
#define	yynerrs	d_nerrs
#define	yyps	d_ps
#define	yypv	d_pv
#define	yys	d_s
#define	yy_yys	d_yys
#define	yystate	d_state
#define	yytmp	d_tmp
#define	yyv	d_v
#define	yy_yyv	d_yyv
#define	yyval	d_val
#define	yylloc	d_lloc
#define	yyreds	d_reds	/* With YYDEBUG defined */
#define	yytoks	d_toks	/* With YYDEBUG defined */
#define	yyname	d_name	/* With YYDEBUG defined */
#define	yyrule	d_rule	/* With YYDEBUG defined */
#define	yylhs	d_yylhs
#define	yylen	d_yylen
#define	yydefre	d_yydefred
#define	yydgoto	d_yydgoto
#define	yysindex d_yysindex
#define	yyrindex d_yyrindex
#define	yygindex d_yygindex
#define	yytable	d_yytable
#define	yycheck	d_yycheck
#define	yyss	d_yyss
#define	yysslim	d_yysslim
#define	yyssp	d_yyssp
#define	yystacksize d_yystacksize
#define	yyvs	d_yyvs
#define	yyvsp	d_yyvsp

#ifndef YYDEBUG
#define YYDEBUG 1	/* Default to yydebug support */
#endif

#define YYFPRINTF parser_fprintf

/* The state of the parser, used internally when we are parsing the
   expression.  */

static struct parser_state *pstate = NULL;

int yyparse (void);

static int yylex (void);

void yyerror (char *);

#line 135 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
#ifdef YYSTYPE
#undef  YYSTYPE_IS_DECLARED
#define YYSTYPE_IS_DECLARED 1
#endif
#ifndef YYSTYPE_IS_DECLARED
#define YYSTYPE_IS_DECLARED 1
typedef union
  {
    struct {
      LONGEST val;
      struct type *type;
    } typed_val_int;
    struct {
      DOUBLEST dval;
      struct type *type;
    } typed_val_float;
    struct symbol *sym;
    struct type *tval;
    struct typed_stoken tsval;
    struct stoken sval;
    struct ttype tsym;
    struct symtoken ssym;
    int ival;
    struct block *bval;
    enum exp_opcode opcode;
    struct stoken_vector svec;
  } YYSTYPE;
#endif /* !YYSTYPE_IS_DECLARED */
#line 158 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
/* YYSTYPE gets defined by %union */
static int parse_number (struct parser_state *, const char *,
			 int, int, YYSTYPE *);

static void push_expression_name (struct parser_state *, struct stoken);
#line 148 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.c"

/* compatibility with bison */
#ifdef YYPARSE_PARAM
/* compatibility with FreeBSD */
# ifdef YYPARSE_PARAM_TYPE
#  define YYPARSE_DECL() yyparse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)
# else
#  define YYPARSE_DECL() yyparse(void *YYPARSE_PARAM)
# endif
#else
# define YYPARSE_DECL() yyparse(void)
#endif

/* Parameters sent to lex. */
#ifdef YYLEX_PARAM
# define YYLEX_DECL() yylex(void *YYLEX_PARAM)
# define YYLEX yylex(YYLEX_PARAM)
#else
# define YYLEX_DECL() yylex(void)
# define YYLEX yylex()
#endif

/* Parameters sent to yyerror. */
#ifndef YYERROR_DECL
#define YYERROR_DECL() yyerror(const char *s)
#endif
#ifndef YYERROR_CALL
#define YYERROR_CALL(msg) yyerror(msg)
#endif

extern int YYPARSE_DECL();

#define IDENTIFIER 257
#define TYPENAME 258
#define COMPLETE 259
#define NAME_OR_INT 260
#define INTEGER_LITERAL 261
#define FLOAT_LITERAL 262
#define CHARACTER_LITERAL 263
#define STRING_LITERAL 264
#define ENTRY 265
#define ERROR 266
#define TRUE_KEYWORD 267
#define FALSE_KEYWORD 268
#define NULL_KEYWORD 269
#define SUPER_KEYWORD 270
#define CAST_KEYWORD 271
#define SIZEOF_KEYWORD 272
#define TYPEOF_KEYWORD 273
#define TYPEID_KEYWORD 274
#define INIT_KEYWORD 275
#define IMMUTABLE_KEYWORD 276
#define CONST_KEYWORD 277
#define SHARED_KEYWORD 278
#define STRUCT_KEYWORD 279
#define UNION_KEYWORD 280
#define CLASS_KEYWORD 281
#define INTERFACE_KEYWORD 282
#define ENUM_KEYWORD 283
#define TEMPLATE_KEYWORD 284
#define DELEGATE_KEYWORD 285
#define FUNCTION_KEYWORD 286
#define DOLLAR_VARIABLE 287
#define ASSIGN_MODIFY 288
#define OROR 289
#define ANDAND 290
#define EQUAL 291
#define NOTEQUAL 292
#define LEQ 293
#define GEQ 294
#define LSH 295
#define RSH 296
#define HATHAT 297
#define IDENTITY 298
#define NOTIDENTITY 299
#define INCREMENT 300
#define DECREMENT 301
#define DOTDOT 302
#define YYERRCODE 256
typedef int YYINT;
static const YYINT yylhs[] = {                           -1,
    0,    0,    6,    7,    7,    8,    8,    8,    9,    9,
   10,   10,   11,   11,   12,   12,   13,   13,   14,   14,
   15,   15,   15,   15,   17,   17,   18,   18,   19,   19,
   19,   19,   16,   16,   16,   20,   20,   20,   20,   21,
   21,   21,   21,   22,   22,   22,   22,   22,   22,   22,
   22,   22,   22,   23,   23,   24,   24,   25,   25,   25,
   25,   25,   25,   30,   30,   31,   31,   32,   27,   28,
   29,   29,   26,   26,   26,   26,   26,   26,   26,   26,
   26,   26,   26,   26,   26,   26,    5,    4,    4,    1,
    1,    3,    3,   33,   33,   33,   33,    2,    2,    2,
    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
};
static const YYINT yylen[] = {                            2,
    1,    1,    1,    1,    3,    1,    3,    3,    1,    5,
    1,    3,    1,    3,    1,    3,    1,    3,    1,    3,
    1,    1,    1,    1,    3,    3,    3,    3,    3,    3,
    3,    3,    1,    3,    3,    1,    3,    3,    3,    1,
    3,    3,    3,    2,    2,    2,    2,    2,    2,    2,
    2,    1,    1,    5,    4,    1,    3,    1,    2,    2,
    1,    1,    1,    1,    3,    0,    1,    0,    5,    4,
    3,    6,    3,    1,    3,    4,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    3,    1,    3,    1,
    2,    1,    2,    1,    2,    3,    4,    1,    2,    2,
    3,    2,    2,    3,    2,    2,    3,    2,    2,    3,
};
static const YYINT yydefred[] = {                         0,
   88,   98,   78,   82,   83,   84,   90,   80,   81,   79,
    0,    0,    0,    0,    0,   77,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    2,
    0,   86,    1,    3,    0,    0,    0,    0,    0,    0,
    0,   19,    0,   22,   23,   24,    0,    0,   40,   52,
   53,    0,   58,   61,   62,   63,    0,  103,    0,  106,
    0,  100,    0,  109,    0,   44,   49,   48,   47,   45,
   46,   64,    0,    0,    0,    0,   51,   50,   91,    0,
    0,   93,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   59,
   60,    0,   68,    0,  104,    0,  107,  101,  110,    0,
   87,    0,   73,   95,    0,    0,   75,    5,    8,    7,
    0,    0,    0,    0,    0,   20,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   41,
   42,   43,   57,   71,    0,    0,    0,    0,   89,   65,
   55,    0,   76,    0,    0,   70,    0,   54,   97,   10,
    0,   69,   72,
};
#if defined(YYDESTRUCT_CALL) || defined(YYSTYPE_TOSTRING)
static const YYINT yystos[] = {                           0,
  257,  258,  260,  261,  262,  263,  264,  267,  268,  269,
  271,  279,  280,  281,  283,  287,   38,   43,   45,   42,
  300,  301,   91,   40,  126,   33,  304,  305,  306,  307,
  308,  309,  310,  311,  312,  313,  314,  315,  316,  317,
  318,  319,  320,  321,  322,  323,  324,  325,  326,  327,
  328,  329,  330,  331,  332,  333,   40,  259,  308,  259,
  308,  259,  308,  259,  308,  326,  326,  326,  326,  326,
  326,  312,  334,  335,  307,  310,  326,  326,  264,   42,
   91,  337,   46,   44,  288,   61,   63,  289,  290,  124,
   94,   38,  291,  292,   60,   62,  293,  294,  295,  296,
  298,  299,   43,   45,  126,   42,   47,   37,  297,  300,
  301,   91,   40,  307,  259,   46,  259,  259,  259,   44,
   93,   41,   41,  337,  261,  257,  259,  311,  312,  312,
  310,  315,  316,  317,  318,  319,  320,  320,  320,  320,
  320,  320,  324,  324,  320,  320,  325,  325,  325,  326,
  326,  326,  326,   93,  312,  334,  336,   41,  257,  312,
  326,   93,  259,   58,  302,   93,  335,  326,  337,  313,
  312,   41,   93,
};
#endif /* YYDESTRUCT_CALL || YYSTYPE_TOSTRING */
static const YYINT yydgoto[] = {                         27,
   28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
   38,   39,   40,   41,   42,   43,   44,   45,   46,   47,
   48,   49,   50,   51,   52,   53,   54,   55,   56,   73,
   74,  157,   82,
};
static const YYINT yysindex[] = {                       999,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  -30, -227, -201, -127,  -57,    0, 1108, 1108, 1108, 1108,
 1108, 1108, 1108,  999, 1108, 1108,    0, -258,  -11,    0,
  -32,    0,    0,    0,  -15,  -56,  -60, -264,  -91,  -42,
   76,    0,  -58,    0,    0,    0,  -18,  205,    0,    0,
    0,  -40,    0,    0,    0,    0,  -82,    0,  -39,    0,
  -35,    0,  -34,    0,  -33,    0,    0,    0,    0,    0,
    0,    0,   -8,   50,   82,   92,    0,    0,    0,  -11,
 -108,    0,  -53, 1108, 1108, 1108, 1108, 1108, 1108, 1108,
 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108,
 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108, 1108,    0,
    0, 1041,    0,  122,    0,  -77,    0,    0,    0, 1108,
    0, 1108,    0,    0,   90,  -66,    0,    0,    0,    0,
  145, -264,  -91,  -42,   76,    0, -211, -211, -211, -211,
 -211, -211,  -18,  -18, -211, -211,  205,  205,  205,    0,
    0,    0,    0,    0,  -95,  -36, 1108, 1108,    0,    0,
    0,  -11,    0, 1108, 1108,    0,  167,    0,    0,    0,
  117,    0,    0,
};
static const YYINT yyrindex[] = {                         0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  123,    0,    0,    0,    0,   28,   60,    0,
   97,    0,    0,    0,  164,    9,  215,  952,  775,  888,
  854,    0,  505,    0,    0,    0,  314,   55,    0,    0,
    0,  124,    0,    0,    0,    0,    0,    0,   35,    0,
   37,    0,   40,    0,  136,    0,    0,    0,    0,    0,
    0,    0,  -19,    0,    0,    0,    0,    0,    0,  109,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    1,    0,    0,    0,    0,
    0,  956,  925,  896,  870,    0,  532,  577,  601,  611,
  768,  811,  463,  490,  815,  880,  151,  421,  448,    0,
    0,    0,    0,    0,  -10,    0,  178,    0,    0,    0,
    0,  129,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,
};
#if YYBTYACC
static const YYINT yycindex[] = {                         0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,
};
#endif
static const YYINT yygindex[] = {                         0,
    0,    0,   30,  160,    0,   25,  144,  315,   66,    0,
  143,  150,  153,  155,  157,  169,    0,    0,    0,   11,
   42,   -2,    0,    0,    0,    0,    0,    0,    0,  139,
   96,    0,  -59,
};
#define YYTABLESIZE 1409
static const YYINT yytable[] = {                        113,
   89,   95,   87,   96,   86,   79,  116,  120,    6,   57,
  116,  116,  116,   83,   66,   67,   68,   69,   70,   71,
  124,   67,   77,   78,  103,   89,  104,   85,   84,    1,
   80,   58,   90,   64,  102,  120,  105,   89,   89,   99,
   89,   89,   89,   89,   89,   89,   89,   89,   76,    6,
  112,   91,    6,   75,   36,    1,  166,   60,   89,   92,
   89,   89,   89,   89,   85,   85,    6,   85,   85,   85,
   85,   85,   85,   67,   85,  102,  102,  105,  105,   81,
   99,   99,   64,   99,  100,   85,  114,   85,   85,   85,
   85,   89,   36,   89,   89,   36,   74,   36,   36,   36,
   92,    6,  169,  150,  151,  152,  153,  105,   94,  143,
  144,  131,   36,   92,   36,   36,   36,   36,   85,  161,
   85,   85,  122,   56,   89,  102,   89,  105,   96,    1,
   99,   62,  123,   74,   74,  108,   74,   74,   74,   74,
   74,   74,  121,   74,  147,  148,  149,   36,   36,   94,
   37,   85,  125,   85,   74,  168,   74,   74,   74,   74,
   56,   56,  158,    4,   56,   56,   56,   56,   56,   96,
   56,   59,   61,   63,   65,    2,  108,  108,   36,  159,
   36,   56,  162,   56,   56,   56,   56,   74,   37,   74,
   74,   37,  163,   37,   37,   37,   12,   13,   14,    1,
   15,   64,  164,  126,    4,  127,  165,  172,   37,  173,
   37,   37,   37,   37,    9,   66,   56,   56,   66,  115,
   74,    4,   74,  117,  118,  119,  108,  128,   88,  170,
  132,   85,   93,   94,   97,   98,   99,  100,  133,  101,
  102,  108,  134,   37,   37,  135,  106,   56,  136,   56,
  156,  107,  167,    0,    0,    9,  109,    0,    9,  110,
  111,  137,  138,  139,  140,  141,  142,    0,    0,  145,
  146,    0,    9,    0,   37,    9,   37,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   89,   89,
   89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
   89,   89,   89,    0,    0,    0,    0,    9,    0,    0,
    6,    0,    0,   33,    0,   85,   85,   85,   85,   85,
   85,   85,   85,   85,   85,   85,   85,   85,   85,   85,
    0,    0,    0,    0,    0,    0,    0,   72,    0,    0,
    0,    0,   36,   36,   36,   36,   36,   36,   36,   36,
   36,   33,   36,   36,   33,    0,   36,   33,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   33,    0,   33,   33,   33,   33,    0,    0,    0,
    0,    0,    0,    0,   74,   74,   74,   74,   74,   74,
   74,   74,   74,   74,   74,   74,   74,   74,   74,  129,
  130,    0,    0,    0,    0,    0,   33,   33,    0,    0,
    0,   56,   56,   56,   56,   56,   56,   56,   56,   56,
   38,   56,   56,    0,    0,   56,  155,    0,    0,    0,
    0,    0,    0,    0,  160,    0,    0,   33,   37,   37,
   37,   37,   37,   37,   37,   37,   37,   39,   37,   37,
    0,    0,   37,    0,    0,    0,    0,    0,   38,    0,
    0,   38,   34,   38,   38,   38,    0,    0,    0,    0,
    0,   72,    0,    0,    0,    0,    0,    0,   38,  171,
   38,   38,   38,   38,    0,   39,    0,    0,   39,   35,
   39,   39,   39,    0,    0,    0,    0,    0,    0,    0,
   34,    0,    9,   34,   21,   39,   34,   39,   39,   39,
   39,    0,    0,   38,   38,    0,    9,    0,    0,    0,
   34,    0,   34,   34,   34,   34,    0,   35,    0,    0,
   35,   25,    0,   35,    0,    0,    0,    0,    0,    0,
   39,   39,   21,    0,   38,   21,   38,   35,   21,   35,
   35,   35,   35,    0,    0,   34,   34,    0,    0,    0,
    0,    0,   21,    0,    0,   21,    0,   21,    0,   25,
    0,   39,   25,   39,    0,   25,   26,    0,    0,    0,
    0,    0,   35,   35,    0,    0,   34,    0,    0,   25,
    0,    0,   25,    0,   25,    0,    0,   21,   21,    0,
   29,   33,   33,   33,   33,   33,   33,   33,   33,   33,
   31,   33,   33,   35,   26,   33,    0,   26,    0,    0,
   26,    0,    0,    0,   25,   25,    0,    0,   21,    0,
    0,    0,    0,    0,   26,    0,    0,   26,   29,   26,
    0,   29,    0,    0,   29,    0,    0,    0,   31,    0,
    0,   31,    0,    0,   31,   25,    0,    0,   29,    0,
    0,   29,    0,   29,    0,    0,    0,    0,   31,   26,
   26,   31,    0,   31,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   29,   29,    0,    0,    0,    0,    0,
   26,    0,    0,   31,   31,    0,    0,    0,   38,   38,
   38,   38,   38,   38,   38,   38,   38,    0,   38,   38,
    0,    0,   38,    0,   29,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   31,   39,   39,   39,   39,   39,
   39,   39,   39,   39,    0,   39,   39,    0,    0,   39,
   34,   34,   34,   34,   34,   34,   34,   34,   34,    0,
   34,   34,    0,    0,   34,    0,    0,   30,    0,    0,
    0,    0,    0,    0,   13,    0,    0,   35,   35,   35,
   35,   35,   35,   35,   35,   35,    0,   35,   35,    0,
    0,   35,   21,   21,   21,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   30,   21,    0,   30,    0,
   32,   30,    0,    0,   27,   13,    0,    0,   13,   25,
   25,   25,    0,    0,    0,   30,    0,    0,   30,    0,
   30,    0,   13,   25,    0,   13,    0,   13,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   32,    0,
    0,   32,   27,   17,   32,   27,    0,    0,   27,    0,
   30,   30,    0,    0,   26,   26,   26,   13,   32,   18,
    0,   32,   27,   32,    0,   27,    0,   27,   26,   28,
    0,    0,    0,    0,    0,    0,    0,   15,   29,   29,
   29,   30,    0,    0,   17,   16,    0,   17,   31,   31,
   31,    0,   29,   32,   32,    0,    0,   27,   27,    0,
   18,   17,   31,   18,   17,    0,   17,   28,    0,    0,
   28,    0,    0,   28,   14,    0,    0,   18,   15,    0,
   18,   15,   18,    0,   32,    0,   16,   28,   27,   16,
   28,    0,   28,    0,    0,   15,   17,   17,   15,    0,
   15,   11,    0,   16,    0,   12,   16,    0,   16,    0,
    0,    0,   18,   18,    0,   14,    0,    0,   14,    0,
    0,    0,   28,   28,    0,    0,    0,   17,    0,    0,
   15,    0,   14,    0,    0,   14,    0,   14,   16,    0,
    0,    0,   11,   18,    0,   11,   12,    0,    0,   12,
    0,    0,    0,   28,    0,    0,    0,    0,    0,   11,
    0,   15,   11,   12,   11,    0,   12,   14,   12,   16,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   26,    0,    0,    0,    0,   17,    0,   24,    0,
   20,   18,    0,   19,   11,    0,    0,    0,   12,    0,
    0,    0,    0,    0,    0,   30,   30,   30,    0,    0,
    0,    0,   13,   13,   13,    0,    0,    0,    0,   30,
    0,    0,    0,   26,    0,    0,   13,    0,   17,    0,
   24,    0,   20,   18,    0,   19,    0,    0,    0,   23,
    0,    0,    0,    0,    0,    0,    0,    0,   32,   32,
   32,    0,   27,   27,   27,    0,    0,    0,    0,    0,
    0,    0,   32,    0,    0,    0,   27,    0,    0,    0,
    0,    0,    0,    0,   25,    0,    0,    0,    0,    0,
    0,   23,    0,  154,    0,    0,    0,    0,    0,    0,
   26,   17,   17,   17,    0,   17,    0,   24,    0,   20,
   18,    0,   19,    0,    0,   17,    0,   18,   18,   18,
    0,    0,    0,    0,    0,    0,   25,   28,   28,   28,
    0,   18,    0,    0,    0,   15,   15,   15,    0,    0,
    0,   28,    0,   16,   16,   16,    0,    0,    0,   15,
    0,    0,    0,    0,    0,    0,    0,   16,   23,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   14,   14,   14,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   14,    0,    0,    0,
    0,    0,    0,   25,    0,    0,    0,    0,    0,   11,
   11,    0,    0,   12,   12,    0,    0,    0,    0,    0,
    0,    0,    0,   11,    0,    1,    2,   12,    3,    4,
    5,    6,    7,    0,    0,    8,    9,   10,    0,   11,
    0,    0,    0,    0,    0,    0,    0,   12,   13,   14,
    0,   15,    0,    0,    0,   16,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    1,   21,   22,
    3,    4,    5,    6,    7,    0,    0,    8,    9,   10,
    0,   11,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   16,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   21,   22,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    1,    0,    0,    3,    4,    5,
    6,    7,    0,    0,    8,    9,   10,    0,   11,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   16,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   21,   22,
};
static const YYINT yycheck[] = {                         40,
    0,   60,   63,   62,   61,  264,   46,   44,    0,   40,
   46,   46,   46,   46,   17,   18,   19,   20,   21,   22,
   80,   41,   25,   26,   43,  290,   45,    0,   44,  257,
   42,  259,  124,   44,    0,   44,    0,   37,   38,    0,
   40,   41,   42,   43,   44,   45,   46,   47,   24,   41,
   91,   94,   44,   24,    0,  257,   93,  259,   58,    0,
   60,   61,   62,   63,   37,   38,   58,   40,   41,   42,
   43,   44,   45,   93,   47,   41,   42,   41,   42,   91,
   41,   42,   93,  295,  296,   58,   57,   60,   61,   62,
   63,   91,   38,   93,   94,   41,    0,   43,   44,   45,
   41,   93,  162,  106,  107,  108,  109,  126,    0,   99,
  100,   87,   58,   38,   60,   61,   62,   63,   91,  122,
   93,   94,   41,    0,  124,   91,  126,   91,    0,  257,
   91,  259,   41,   37,   38,    0,   40,   41,   42,   43,
   44,   45,   93,   47,  103,  104,  105,   93,   94,   41,
    0,  124,  261,  126,   58,  158,   60,   61,   62,   63,
   37,   38,   41,    0,   41,   42,   43,   44,   45,   41,
   47,   12,   13,   14,   15,  258,   41,   42,  124,  257,
  126,   58,   93,   60,   61,   62,   63,   91,   38,   93,
   94,   41,  259,   43,   44,   45,  279,  280,  281,  257,
  283,  259,   58,  257,   41,  259,  302,   41,   58,   93,
   60,   61,   62,   63,    0,   93,   93,   94,   41,  259,
  124,   58,  126,  259,  259,  259,   91,   84,  289,  164,
   88,  288,  291,  292,  293,  294,  295,  296,   89,  298,
  299,   37,   90,   93,   94,   91,   42,  124,   92,  126,
  112,   47,  157,   -1,   -1,   41,  297,   -1,   44,  300,
  301,   93,   94,   95,   96,   97,   98,   -1,   -1,  101,
  102,   -1,   58,   -1,  124,   61,  126,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  288,  289,
  290,  291,  292,  293,  294,  295,  296,  297,  298,  299,
  300,  301,  302,   -1,   -1,   -1,   -1,   93,   -1,   -1,
  302,   -1,   -1,    0,   -1,  288,  289,  290,  291,  292,
  293,  294,  295,  296,  297,  298,  299,  300,  301,  302,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   23,   -1,   -1,
   -1,   -1,  288,  289,  290,  291,  292,  293,  294,  295,
  296,   38,  298,  299,   41,   -1,  302,   44,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   58,   -1,   60,   61,   62,   63,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  288,  289,  290,  291,  292,  293,
  294,  295,  296,  297,  298,  299,  300,  301,  302,   85,
   86,   -1,   -1,   -1,   -1,   -1,   93,   94,   -1,   -1,
   -1,  288,  289,  290,  291,  292,  293,  294,  295,  296,
    0,  298,  299,   -1,   -1,  302,  112,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  120,   -1,   -1,  124,  288,  289,
  290,  291,  292,  293,  294,  295,  296,    0,  298,  299,
   -1,   -1,  302,   -1,   -1,   -1,   -1,   -1,   38,   -1,
   -1,   41,    0,   43,   44,   45,   -1,   -1,   -1,   -1,
   -1,  157,   -1,   -1,   -1,   -1,   -1,   -1,   58,  165,
   60,   61,   62,   63,   -1,   38,   -1,   -1,   41,    0,
   43,   44,   45,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   38,   -1,  288,   41,    0,   58,   44,   60,   61,   62,
   63,   -1,   -1,   93,   94,   -1,  302,   -1,   -1,   -1,
   58,   -1,   60,   61,   62,   63,   -1,   38,   -1,   -1,
   41,    0,   -1,   44,   -1,   -1,   -1,   -1,   -1,   -1,
   93,   94,   38,   -1,  124,   41,  126,   58,   44,   60,
   61,   62,   63,   -1,   -1,   93,   94,   -1,   -1,   -1,
   -1,   -1,   58,   -1,   -1,   61,   -1,   63,   -1,   38,
   -1,  124,   41,  126,   -1,   44,    0,   -1,   -1,   -1,
   -1,   -1,   93,   94,   -1,   -1,  124,   -1,   -1,   58,
   -1,   -1,   61,   -1,   63,   -1,   -1,   93,   94,   -1,
    0,  288,  289,  290,  291,  292,  293,  294,  295,  296,
    0,  298,  299,  124,   38,  302,   -1,   41,   -1,   -1,
   44,   -1,   -1,   -1,   93,   94,   -1,   -1,  124,   -1,
   -1,   -1,   -1,   -1,   58,   -1,   -1,   61,   38,   63,
   -1,   41,   -1,   -1,   44,   -1,   -1,   -1,   38,   -1,
   -1,   41,   -1,   -1,   44,  124,   -1,   -1,   58,   -1,
   -1,   61,   -1,   63,   -1,   -1,   -1,   -1,   58,   93,
   94,   61,   -1,   63,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   93,   94,   -1,   -1,   -1,   -1,   -1,
  124,   -1,   -1,   93,   94,   -1,   -1,   -1,  288,  289,
  290,  291,  292,  293,  294,  295,  296,   -1,  298,  299,
   -1,   -1,  302,   -1,  124,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  124,  288,  289,  290,  291,  292,
  293,  294,  295,  296,   -1,  298,  299,   -1,   -1,  302,
  288,  289,  290,  291,  292,  293,  294,  295,  296,   -1,
  298,  299,   -1,   -1,  302,   -1,   -1,    0,   -1,   -1,
   -1,   -1,   -1,   -1,    0,   -1,   -1,  288,  289,  290,
  291,  292,  293,  294,  295,  296,   -1,  298,  299,   -1,
   -1,  302,  288,  289,  290,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   38,  302,   -1,   41,   -1,
    0,   44,   -1,   -1,    0,   41,   -1,   -1,   44,  288,
  289,  290,   -1,   -1,   -1,   58,   -1,   -1,   61,   -1,
   63,   -1,   58,  302,   -1,   61,   -1,   63,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   38,   -1,
   -1,   41,   38,    0,   44,   41,   -1,   -1,   44,   -1,
   93,   94,   -1,   -1,  288,  289,  290,   93,   58,    0,
   -1,   61,   58,   63,   -1,   61,   -1,   63,  302,    0,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,    0,  288,  289,
  290,  124,   -1,   -1,   41,    0,   -1,   44,  288,  289,
  290,   -1,  302,   93,   94,   -1,   -1,   93,   94,   -1,
   41,   58,  302,   44,   61,   -1,   63,   38,   -1,   -1,
   41,   -1,   -1,   44,    0,   -1,   -1,   58,   41,   -1,
   61,   44,   63,   -1,  124,   -1,   41,   58,  124,   44,
   61,   -1,   63,   -1,   -1,   58,   93,   94,   61,   -1,
   63,    0,   -1,   58,   -1,    0,   61,   -1,   63,   -1,
   -1,   -1,   93,   94,   -1,   41,   -1,   -1,   44,   -1,
   -1,   -1,   93,   94,   -1,   -1,   -1,  124,   -1,   -1,
   93,   -1,   58,   -1,   -1,   61,   -1,   63,   93,   -1,
   -1,   -1,   41,  124,   -1,   44,   41,   -1,   -1,   44,
   -1,   -1,   -1,  124,   -1,   -1,   -1,   -1,   -1,   58,
   -1,  124,   61,   58,   63,   -1,   61,   93,   63,  124,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   33,   -1,   -1,   -1,   -1,   38,   -1,   40,   -1,
   42,   43,   -1,   45,   93,   -1,   -1,   -1,   93,   -1,
   -1,   -1,   -1,   -1,   -1,  288,  289,  290,   -1,   -1,
   -1,   -1,  288,  289,  290,   -1,   -1,   -1,   -1,  302,
   -1,   -1,   -1,   33,   -1,   -1,  302,   -1,   38,   -1,
   40,   -1,   42,   43,   -1,   45,   -1,   -1,   -1,   91,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  288,  289,
  290,   -1,  288,  289,  290,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  302,   -1,   -1,   -1,  302,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  126,   -1,   -1,   -1,   -1,   -1,
   -1,   91,   -1,   93,   -1,   -1,   -1,   -1,   -1,   -1,
   33,  288,  289,  290,   -1,   38,   -1,   40,   -1,   42,
   43,   -1,   45,   -1,   -1,  302,   -1,  288,  289,  290,
   -1,   -1,   -1,   -1,   -1,   -1,  126,  288,  289,  290,
   -1,  302,   -1,   -1,   -1,  288,  289,  290,   -1,   -1,
   -1,  302,   -1,  288,  289,  290,   -1,   -1,   -1,  302,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  302,   91,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  288,  289,  290,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  302,   -1,   -1,   -1,
   -1,   -1,   -1,  126,   -1,   -1,   -1,   -1,   -1,  288,
  289,   -1,   -1,  288,  289,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  302,   -1,  257,  258,  302,  260,  261,
  262,  263,  264,   -1,   -1,  267,  268,  269,   -1,  271,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  279,  280,  281,
   -1,  283,   -1,   -1,   -1,  287,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,  300,  301,
  260,  261,  262,  263,  264,   -1,   -1,  267,  268,  269,
   -1,  271,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  287,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  300,  301,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  257,   -1,   -1,  260,  261,  262,
  263,  264,   -1,   -1,  267,  268,  269,   -1,  271,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  287,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  300,  301,
};
#if YYBTYACC
static const YYINT yyctable[] = {                        -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
};
#endif
#define YYFINAL 27
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 302
#define YYUNDFTOKEN 338
#define YYTRANSLATE(a) ((a) > YYMAXTOKEN ? YYUNDFTOKEN : (a))
#if YYDEBUG
static const char *const yyname[] = {

"$end",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'!'",0,
0,0,"'%'","'&'",0,"'('","')'","'*'","'+'","','","'-'","'.'","'/'",0,0,0,0,0,0,0,
0,0,0,"':'",0,"'<'","'='","'>'","'?'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,"'['",0,"']'","'^'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,"'|'",0,"'~'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"error","IDENTIFIER","TYPENAME",
"COMPLETE","NAME_OR_INT","INTEGER_LITERAL","FLOAT_LITERAL","CHARACTER_LITERAL",
"STRING_LITERAL","ENTRY","ERROR","TRUE_KEYWORD","FALSE_KEYWORD","NULL_KEYWORD",
"SUPER_KEYWORD","CAST_KEYWORD","SIZEOF_KEYWORD","TYPEOF_KEYWORD",
"TYPEID_KEYWORD","INIT_KEYWORD","IMMUTABLE_KEYWORD","CONST_KEYWORD",
"SHARED_KEYWORD","STRUCT_KEYWORD","UNION_KEYWORD","CLASS_KEYWORD",
"INTERFACE_KEYWORD","ENUM_KEYWORD","TEMPLATE_KEYWORD","DELEGATE_KEYWORD",
"FUNCTION_KEYWORD","DOLLAR_VARIABLE","ASSIGN_MODIFY","OROR","ANDAND","EQUAL",
"NOTEQUAL","LEQ","GEQ","LSH","RSH","HATHAT","IDENTITY","NOTIDENTITY",
"INCREMENT","DECREMENT","DOTDOT","$accept","start","StringExp","BasicType",
"TypeExp","IdentifierExp","ArrayLiteral","Expression","CommaExpression",
"AssignExpression","ConditionalExpression","OrOrExpression","AndAndExpression",
"OrExpression","XorExpression","AndExpression","CmpExpression",
"ShiftExpression","EqualExpression","IdentityExpression","RelExpression",
"AddExpression","MulExpression","UnaryExpression","CastExpression",
"PowExpression","PostfixExpression","PrimaryExpression","CallExpression",
"IndexExpression","SliceExpression","ArgumentList","ArgumentList_opt","$$1",
"BasicType2","illegal-symbol",
};
static const char *const yyrule[] = {
"$accept : start",
"start : Expression",
"start : TypeExp",
"Expression : CommaExpression",
"CommaExpression : AssignExpression",
"CommaExpression : AssignExpression ',' CommaExpression",
"AssignExpression : ConditionalExpression",
"AssignExpression : ConditionalExpression '=' AssignExpression",
"AssignExpression : ConditionalExpression ASSIGN_MODIFY AssignExpression",
"ConditionalExpression : OrOrExpression",
"ConditionalExpression : OrOrExpression '?' Expression ':' ConditionalExpression",
"OrOrExpression : AndAndExpression",
"OrOrExpression : OrOrExpression OROR AndAndExpression",
"AndAndExpression : OrExpression",
"AndAndExpression : AndAndExpression ANDAND OrExpression",
"OrExpression : XorExpression",
"OrExpression : OrExpression '|' XorExpression",
"XorExpression : AndExpression",
"XorExpression : XorExpression '^' AndExpression",
"AndExpression : CmpExpression",
"AndExpression : AndExpression '&' CmpExpression",
"CmpExpression : ShiftExpression",
"CmpExpression : EqualExpression",
"CmpExpression : IdentityExpression",
"CmpExpression : RelExpression",
"EqualExpression : ShiftExpression EQUAL ShiftExpression",
"EqualExpression : ShiftExpression NOTEQUAL ShiftExpression",
"IdentityExpression : ShiftExpression IDENTITY ShiftExpression",
"IdentityExpression : ShiftExpression NOTIDENTITY ShiftExpression",
"RelExpression : ShiftExpression '<' ShiftExpression",
"RelExpression : ShiftExpression LEQ ShiftExpression",
"RelExpression : ShiftExpression '>' ShiftExpression",
"RelExpression : ShiftExpression GEQ ShiftExpression",
"ShiftExpression : AddExpression",
"ShiftExpression : ShiftExpression LSH AddExpression",
"ShiftExpression : ShiftExpression RSH AddExpression",
"AddExpression : MulExpression",
"AddExpression : AddExpression '+' MulExpression",
"AddExpression : AddExpression '-' MulExpression",
"AddExpression : AddExpression '~' MulExpression",
"MulExpression : UnaryExpression",
"MulExpression : MulExpression '*' UnaryExpression",
"MulExpression : MulExpression '/' UnaryExpression",
"MulExpression : MulExpression '%' UnaryExpression",
"UnaryExpression : '&' UnaryExpression",
"UnaryExpression : INCREMENT UnaryExpression",
"UnaryExpression : DECREMENT UnaryExpression",
"UnaryExpression : '*' UnaryExpression",
"UnaryExpression : '-' UnaryExpression",
"UnaryExpression : '+' UnaryExpression",
"UnaryExpression : '!' UnaryExpression",
"UnaryExpression : '~' UnaryExpression",
"UnaryExpression : CastExpression",
"UnaryExpression : PowExpression",
"CastExpression : CAST_KEYWORD '(' TypeExp ')' UnaryExpression",
"CastExpression : '(' TypeExp ')' UnaryExpression",
"PowExpression : PostfixExpression",
"PowExpression : PostfixExpression HATHAT UnaryExpression",
"PostfixExpression : PrimaryExpression",
"PostfixExpression : PostfixExpression INCREMENT",
"PostfixExpression : PostfixExpression DECREMENT",
"PostfixExpression : CallExpression",
"PostfixExpression : IndexExpression",
"PostfixExpression : SliceExpression",
"ArgumentList : AssignExpression",
"ArgumentList : ArgumentList ',' AssignExpression",
"ArgumentList_opt :",
"ArgumentList_opt : ArgumentList",
"$$1 :",
"CallExpression : PostfixExpression '(' $$1 ArgumentList_opt ')'",
"IndexExpression : PostfixExpression '[' ArgumentList ']'",
"SliceExpression : PostfixExpression '[' ']'",
"SliceExpression : PostfixExpression '[' AssignExpression DOTDOT AssignExpression ']'",
"PrimaryExpression : '(' Expression ')'",
"PrimaryExpression : IdentifierExp",
"PrimaryExpression : IdentifierExp '.' COMPLETE",
"PrimaryExpression : IdentifierExp '.' IDENTIFIER COMPLETE",
"PrimaryExpression : DOLLAR_VARIABLE",
"PrimaryExpression : NAME_OR_INT",
"PrimaryExpression : NULL_KEYWORD",
"PrimaryExpression : TRUE_KEYWORD",
"PrimaryExpression : FALSE_KEYWORD",
"PrimaryExpression : INTEGER_LITERAL",
"PrimaryExpression : FLOAT_LITERAL",
"PrimaryExpression : CHARACTER_LITERAL",
"PrimaryExpression : StringExp",
"PrimaryExpression : ArrayLiteral",
"ArrayLiteral : '[' ArgumentList_opt ']'",
"IdentifierExp : IDENTIFIER",
"IdentifierExp : IdentifierExp '.' IDENTIFIER",
"StringExp : STRING_LITERAL",
"StringExp : StringExp STRING_LITERAL",
"TypeExp : BasicType",
"TypeExp : BasicType BasicType2",
"BasicType2 : '*'",
"BasicType2 : '*' BasicType2",
"BasicType2 : '[' INTEGER_LITERAL ']'",
"BasicType2 : '[' INTEGER_LITERAL ']' BasicType2",
"BasicType : TYPENAME",
"BasicType : CLASS_KEYWORD IdentifierExp",
"BasicType : CLASS_KEYWORD COMPLETE",
"BasicType : CLASS_KEYWORD IdentifierExp COMPLETE",
"BasicType : STRUCT_KEYWORD IdentifierExp",
"BasicType : STRUCT_KEYWORD COMPLETE",
"BasicType : STRUCT_KEYWORD IdentifierExp COMPLETE",
"BasicType : UNION_KEYWORD IdentifierExp",
"BasicType : UNION_KEYWORD COMPLETE",
"BasicType : UNION_KEYWORD IdentifierExp COMPLETE",
"BasicType : ENUM_KEYWORD IdentifierExp",
"BasicType : ENUM_KEYWORD COMPLETE",
"BasicType : ENUM_KEYWORD IdentifierExp COMPLETE",

};
#endif

int      yydebug;
int      yynerrs;

int      yyerrflag;
int      yychar;
YYSTYPE  yyval;
YYSTYPE  yylval;

/* define the initial stack-sizes */
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH  YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH  10000
#endif
#endif

#define YYINITSTACKSIZE 200

typedef struct {
    unsigned stacksize;
    YYINT    *s_base;
    YYINT    *s_mark;
    YYINT    *s_last;
    YYSTYPE  *l_base;
    YYSTYPE  *l_mark;
} YYSTACKDATA;
/* variables for the parser stack */
static YYSTACKDATA yystack;
#line 643 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"

/* Take care of parsing a number (anything that starts with a digit).
   Set yylval and return the token type; update lexptr.
   LEN is the number of characters in it.  */

/*** Needs some error checking for the float case ***/

static int
parse_number (struct parser_state *ps, const char *p,
	      int len, int parsed_float, YYSTYPE *putithere)
{
  ULONGEST n = 0;
  ULONGEST prevn = 0;
  ULONGEST un;

  int i = 0;
  int c;
  int base = input_radix;
  int unsigned_p = 0;
  int long_p = 0;

  /* We have found a "L" or "U" suffix.  */
  int found_suffix = 0;

  ULONGEST high_bit;
  struct type *signed_type;
  struct type *unsigned_type;

  if (parsed_float)
    {
      const struct builtin_d_type *builtin_d_types;
      const char *suffix;
      int suffix_len;
      char *s, *sp;

      /* Strip out all embedded '_' before passing to parse_float.  */
      s = (char *) alloca (len + 1);
      sp = s;
      while (len-- > 0)
	{
	  if (*p != '_')
	    *sp++ = *p;
	  p++;
	}
      *sp = '\0';
      len = strlen (s);

      if (! parse_float (s, len, &putithere->typed_val_float.dval, &suffix))
	return ERROR;

      suffix_len = s + len - suffix;

      if (suffix_len == 0)
	{
	  putithere->typed_val_float.type
	    = parse_d_type (ps)->builtin_double;
	}
      else if (suffix_len == 1)
	{
	  /* Check suffix for `f', `l', or `i' (float, real, or idouble).  */
	  if (tolower (*suffix) == 'f')
	    {
	      putithere->typed_val_float.type
		= parse_d_type (ps)->builtin_float;
	    }
	  else if (tolower (*suffix) == 'l')
	    {
	      putithere->typed_val_float.type
		= parse_d_type (ps)->builtin_real;
	    }
	  else if (tolower (*suffix) == 'i')
	    {
	      putithere->typed_val_float.type
		= parse_d_type (ps)->builtin_idouble;
	    }
	  else
	    return ERROR;
	}
      else if (suffix_len == 2)
	{
	  /* Check suffix for `fi' or `li' (ifloat or ireal).  */
	  if (tolower (suffix[0]) == 'f' && tolower (suffix[1] == 'i'))
	    {
	      putithere->typed_val_float.type
		= parse_d_type (ps)->builtin_ifloat;
	    }
	  else if (tolower (suffix[0]) == 'l' && tolower (suffix[1] == 'i'))
	    {
	      putithere->typed_val_float.type
		= parse_d_type (ps)->builtin_ireal;
	    }
	  else
	    return ERROR;
	}
      else
	return ERROR;

      return FLOAT_LITERAL;
    }

  /* Handle base-switching prefixes 0x, 0b, 0 */
  if (p[0] == '0')
    switch (p[1])
      {
      case 'x':
      case 'X':
	if (len >= 3)
	  {
	    p += 2;
	    base = 16;
	    len -= 2;
	  }
	break;

      case 'b':
      case 'B':
	if (len >= 3)
	  {
	    p += 2;
	    base = 2;
	    len -= 2;
	  }
	break;

      default:
	base = 8;
	break;
      }

  while (len-- > 0)
    {
      c = *p++;
      if (c == '_')
	continue;	/* Ignore embedded '_'.  */
      if (c >= 'A' && c <= 'Z')
	c += 'a' - 'A';
      if (c != 'l' && c != 'u')
	n *= base;
      if (c >= '0' && c <= '9')
	{
	  if (found_suffix)
	    return ERROR;
	  n += i = c - '0';
	}
      else
	{
	  if (base > 10 && c >= 'a' && c <= 'f')
	    {
	      if (found_suffix)
	        return ERROR;
	      n += i = c - 'a' + 10;
	    }
	  else if (c == 'l' && long_p == 0)
	    {
	      long_p = 1;
	      found_suffix = 1;
	    }
	  else if (c == 'u' && unsigned_p == 0)
	    {
	      unsigned_p = 1;
	      found_suffix = 1;
	    }
	  else
	    return ERROR;	/* Char not a digit */
	}
      if (i >= base)
	return ERROR;		/* Invalid digit in this base.  */
      /* Portably test for integer overflow.  */
      if (c != 'l' && c != 'u')
	{
	  ULONGEST n2 = prevn * base;
	  if ((n2 / base != prevn) || (n2 + i < prevn))
	    error (_("Numeric constant too large."));
	}
      prevn = n;
    }

  /* An integer constant is an int or a long.  An L suffix forces it to
     be long, and a U suffix forces it to be unsigned.  To figure out
     whether it fits, we shift it right and see whether anything remains.
     Note that we can't shift sizeof (LONGEST) * HOST_CHAR_BIT bits or
     more in one operation, because many compilers will warn about such a
     shift (which always produces a zero result).  To deal with the case
     where it is we just always shift the value more than once, with fewer
     bits each time.  */
  un = (ULONGEST) n >> 2;
  if (long_p == 0 && (un >> 30) == 0)
    {
      high_bit = ((ULONGEST) 1) << 31;
      signed_type = parse_d_type (ps)->builtin_int;
      /* For decimal notation, keep the sign of the worked out type.  */
      if (base == 10 && !unsigned_p)
	unsigned_type = parse_d_type (ps)->builtin_long;
      else
	unsigned_type = parse_d_type (ps)->builtin_uint;
    }
  else
    {
      int shift;
      if (sizeof (ULONGEST) * HOST_CHAR_BIT < 64)
	/* A long long does not fit in a LONGEST.  */
	shift = (sizeof (ULONGEST) * HOST_CHAR_BIT - 1);
      else
	shift = 63;
      high_bit = (ULONGEST) 1 << shift;
      signed_type = parse_d_type (ps)->builtin_long;
      unsigned_type = parse_d_type (ps)->builtin_ulong;
    }

  putithere->typed_val_int.val = n;

  /* If the high bit of the worked out type is set then this number
     has to be unsigned_type.  */
  if (unsigned_p || (n & high_bit))
    putithere->typed_val_int.type = unsigned_type;
  else
    putithere->typed_val_int.type = signed_type;

  return INTEGER_LITERAL;
}

/* Temporary obstack used for holding strings.  */
static struct obstack tempbuf;
static int tempbuf_init;

/* Parse a string or character literal from TOKPTR.  The string or
   character may be wide or unicode.  *OUTPTR is set to just after the
   end of the literal in the input string.  The resulting token is
   stored in VALUE.  This returns a token value, either STRING or
   CHAR, depending on what was parsed.  *HOST_CHARS is set to the
   number of host characters in the literal.  */

static int
parse_string_or_char (const char *tokptr, const char **outptr,
		      struct typed_stoken *value, int *host_chars)
{
  int quote;

  /* Build the gdb internal form of the input string in tempbuf.  Note
     that the buffer is null byte terminated *only* for the
     convenience of debugging gdb itself and printing the buffer
     contents when the buffer contains no embedded nulls.  Gdb does
     not depend upon the buffer being null byte terminated, it uses
     the length string instead.  This allows gdb to handle C strings
     (as well as strings in other languages) with embedded null
     bytes */

  if (!tempbuf_init)
    tempbuf_init = 1;
  else
    obstack_free (&tempbuf, NULL);
  obstack_init (&tempbuf);

  /* Skip the quote.  */
  quote = *tokptr;
  ++tokptr;

  *host_chars = 0;

  while (*tokptr)
    {
      char c = *tokptr;
      if (c == '\\')
	{
	   ++tokptr;
	   *host_chars += c_parse_escape (&tokptr, &tempbuf);
	}
      else if (c == quote)
	break;
      else
	{
	  obstack_1grow (&tempbuf, c);
	  ++tokptr;
	  /* FIXME: this does the wrong thing with multi-byte host
	     characters.  We could use mbrlen here, but that would
	     make "set host-charset" a bit less useful.  */
	  ++*host_chars;
	}
    }

  if (*tokptr != quote)
    {
      if (quote == '"' || quote == '`')
	error (_("Unterminated string in expression."));
      else
	error (_("Unmatched single quote."));
    }
  ++tokptr;

  /* FIXME: should instead use own language string_type enum
     and handle D-specific string suffixes here. */
  if (quote == '\'')
    value->type = C_CHAR;
  else
    value->type = C_STRING;

  value->ptr = obstack_base (&tempbuf);
  value->length = obstack_object_size (&tempbuf);

  *outptr = tokptr;

  return quote == '\'' ? CHARACTER_LITERAL : STRING_LITERAL;
}

struct token
{
  char *oper;
  int token;
  enum exp_opcode opcode;
};

static const struct token tokentab3[] =
  {
    {"^^=", ASSIGN_MODIFY, BINOP_EXP},
    {"<<=", ASSIGN_MODIFY, BINOP_LSH},
    {">>=", ASSIGN_MODIFY, BINOP_RSH},
  };

static const struct token tokentab2[] =
  {
    {"+=", ASSIGN_MODIFY, BINOP_ADD},
    {"-=", ASSIGN_MODIFY, BINOP_SUB},
    {"*=", ASSIGN_MODIFY, BINOP_MUL},
    {"/=", ASSIGN_MODIFY, BINOP_DIV},
    {"%=", ASSIGN_MODIFY, BINOP_REM},
    {"|=", ASSIGN_MODIFY, BINOP_BITWISE_IOR},
    {"&=", ASSIGN_MODIFY, BINOP_BITWISE_AND},
    {"^=", ASSIGN_MODIFY, BINOP_BITWISE_XOR},
    {"++", INCREMENT, BINOP_END},
    {"--", DECREMENT, BINOP_END},
    {"&&", ANDAND, BINOP_END},
    {"||", OROR, BINOP_END},
    {"^^", HATHAT, BINOP_END},
    {"<<", LSH, BINOP_END},
    {">>", RSH, BINOP_END},
    {"==", EQUAL, BINOP_END},
    {"!=", NOTEQUAL, BINOP_END},
    {"<=", LEQ, BINOP_END},
    {">=", GEQ, BINOP_END},
    {"..", DOTDOT, BINOP_END},
  };

/* Identifier-like tokens.  */
static const struct token ident_tokens[] =
  {
    {"is", IDENTITY, BINOP_END},
    {"!is", NOTIDENTITY, BINOP_END},

    {"cast", CAST_KEYWORD, OP_NULL},
    {"const", CONST_KEYWORD, OP_NULL},
    {"immutable", IMMUTABLE_KEYWORD, OP_NULL},
    {"shared", SHARED_KEYWORD, OP_NULL},
    {"super", SUPER_KEYWORD, OP_NULL},

    {"null", NULL_KEYWORD, OP_NULL},
    {"true", TRUE_KEYWORD, OP_NULL},
    {"false", FALSE_KEYWORD, OP_NULL},

    {"init", INIT_KEYWORD, OP_NULL},
    {"sizeof", SIZEOF_KEYWORD, OP_NULL},
    {"typeof", TYPEOF_KEYWORD, OP_NULL},
    {"typeid", TYPEID_KEYWORD, OP_NULL},

    {"delegate", DELEGATE_KEYWORD, OP_NULL},
    {"function", FUNCTION_KEYWORD, OP_NULL},
    {"struct", STRUCT_KEYWORD, OP_NULL},
    {"union", UNION_KEYWORD, OP_NULL},
    {"class", CLASS_KEYWORD, OP_NULL},
    {"interface", INTERFACE_KEYWORD, OP_NULL},
    {"enum", ENUM_KEYWORD, OP_NULL},
    {"template", TEMPLATE_KEYWORD, OP_NULL},
  };

/* If NAME is a type name in this scope, return it.  */

static struct type *
d_type_from_name (struct stoken name)
{
  struct symbol *sym;
  char *copy = copy_name (name);

  sym = lookup_symbol (copy, expression_context_block,
		       STRUCT_DOMAIN, NULL);
  if (sym != NULL)
    return SYMBOL_TYPE (sym);

  return NULL;
}

/* If NAME is a module name in this scope, return it.  */

static struct type *
d_module_from_name (struct stoken name)
{
  struct symbol *sym;
  char *copy = copy_name (name);

  sym = lookup_symbol (copy, expression_context_block,
		       MODULE_DOMAIN, NULL);
  if (sym != NULL)
    return SYMBOL_TYPE (sym);

  return NULL;
}

/* If NAME is a valid variable name in this scope, push it and return 1.
   Otherwise, return 0.  */

static int
push_variable (struct parser_state *ps, struct stoken name)
{
  char *copy = copy_name (name);
  struct field_of_this_result is_a_field_of_this;
  struct symbol *sym;
  sym = lookup_symbol (copy, expression_context_block, VAR_DOMAIN,
                       &is_a_field_of_this);
  if (sym && SYMBOL_CLASS (sym) != LOC_TYPEDEF)
    {
      if (symbol_read_needs_frame (sym))
        {
          if (innermost_block == 0 ||
              contained_in (block_found, innermost_block))
            innermost_block = block_found;
        }

      write_exp_elt_opcode (ps, OP_VAR_VALUE);
      /* We want to use the selected frame, not another more inner frame
         which happens to be in the same block.  */
      write_exp_elt_block (ps, NULL);
      write_exp_elt_sym (ps, sym);
      write_exp_elt_opcode (ps, OP_VAR_VALUE);
      return 1;
    }
  if (is_a_field_of_this.type != NULL)
    {
      /* It hangs off of `this'.  Must not inadvertently convert from a
         method call to data ref.  */
      if (innermost_block == 0 ||
          contained_in (block_found, innermost_block))
        innermost_block = block_found;
      write_exp_elt_opcode (ps, OP_THIS);
      write_exp_elt_opcode (ps, OP_THIS);
      write_exp_elt_opcode (ps, STRUCTOP_PTR);
      write_exp_string (ps, name);
      write_exp_elt_opcode (ps, STRUCTOP_PTR);
      return 1;
    }
  return 0;
}

/* Assuming a reference expression has been pushed, emit the
   STRUCTOP_PTR ops to access the field named NAME.  If NAME is a
   qualified name (has '.'), generate a field access for each part.  */

static void
push_fieldnames (struct parser_state *ps, struct stoken name)
{
  int i;
  struct stoken token;
  token.ptr = name.ptr;
  for (i = 0;  ;  i++)
    {
      if (i == name.length || name.ptr[i] == '.')
        {
          /* token.ptr is start of current field name.  */
          token.length = &name.ptr[i] - token.ptr;
          write_exp_elt_opcode (ps, STRUCTOP_PTR);
          write_exp_string (ps, token);
          write_exp_elt_opcode (ps, STRUCTOP_PTR);
          token.ptr += token.length + 1;
        }
      if (i >= name.length)
        break;
    }
}

/* Helper routine for push_expression_name.  Handle a TYPE symbol,
   where DOT_INDEX is the index of the first '.' if NAME is part of
   a qualified type.  */

static void
push_type_name (struct parser_state *ps, struct type *type,
		struct stoken name, int dot_index)
{
  if (dot_index == name.length)
    {
      write_exp_elt_opcode (ps, OP_TYPE);
      write_exp_elt_type (ps, type);
      write_exp_elt_opcode (ps, OP_TYPE);
    }
  else
    {
      struct stoken token;

      token.ptr = name.ptr;
      token.length = dot_index;

      dot_index = 0;

      while (dot_index < name.length && name.ptr[dot_index] != '.')
	dot_index++;
      token.ptr = name.ptr;
      token.length = dot_index;

      write_exp_elt_opcode (ps, OP_SCOPE);
      write_exp_elt_type (ps, type);
      write_exp_string (ps, token);
      write_exp_elt_opcode (ps, OP_SCOPE);

      if (dot_index < name.length)
	{
	  dot_index++;
	  name.ptr += dot_index;
	  name.length -= dot_index;
	  push_fieldnames (ps, name);
	}
    }
}

/* Helper routine for push_expression_name.  Like push_type_name,
   but used when TYPE is a module.  Returns 1 on pushing the symbol.  */

static int
push_module_name (struct parser_state *ps, struct type *module,
		  struct stoken name, int dot_index)
{
  if (dot_index == name.length)
    {
      write_exp_elt_opcode (ps, OP_TYPE);
      write_exp_elt_type (ps, module);
      write_exp_elt_opcode (ps, OP_TYPE);
      return 1;
    }
  else
    {
      struct symbol *sym;
      char *copy;

      copy = copy_name (name);
      sym = lookup_symbol_in_static_block (copy, expression_context_block,
					   VAR_DOMAIN);
      if (sym != NULL)
	sym = lookup_global_symbol (copy, expression_context_block,
				    VAR_DOMAIN);

      if (sym != NULL)
	{
	  if (SYMBOL_CLASS (sym) != LOC_TYPEDEF)
	    {
	      write_exp_elt_opcode (ps, OP_VAR_VALUE);
	      write_exp_elt_block (ps, NULL);
	      write_exp_elt_sym (ps, sym);
	      write_exp_elt_opcode (ps, OP_VAR_VALUE);
	    }
	  else
	    {
	      write_exp_elt_opcode (ps, OP_TYPE);
	      write_exp_elt_type (ps, SYMBOL_TYPE (sym));
	      write_exp_elt_opcode (ps, OP_TYPE);
	    }
	  return 1;
	}
    }

  return 0;
}

/* Handle NAME in an expression (or LHS), which could be a
   variable, type, or module.  */

static void
push_expression_name (struct parser_state *ps, struct stoken name)
{
  struct stoken token;
  struct type *typ;
  struct bound_minimal_symbol msymbol;
  char *copy;
  int doti;

  /* Handle VAR, which could be local or global.  */
  if (push_variable (ps, name) != 0)
    return;

  /* Handle MODULE.  */
  typ = d_module_from_name (name);
  if (typ != NULL)
    {
      if (push_module_name (ps, typ, name, name.length) != 0)
	return;
    }

  /* Handle TYPE.  */
  typ = d_type_from_name (name);
  if (typ != NULL)
    {
      push_type_name (ps, typ, name, name.length);
      return;
    }

  /* Handle VAR.FIELD1..FIELDN.  */
  for (doti = 0;  doti < name.length;  doti++)
    {
      if (name.ptr[doti] == '.')
	{
	  token.ptr = name.ptr;
	  token.length = doti;

	  if (push_variable (ps, token) != 0)
	    {
	      token.ptr = name.ptr + doti + 1;
	      token.length = name.length - doti - 1;
	      push_fieldnames (ps, token);
	      return;
	    }
	  break;
	}
    }

  /* Continue looking if we found a '.' in the name.  */
  if (doti < name.length)
    {
      token.ptr = name.ptr;
      for (;;)
	{
	  token.length = doti;

	  /* Handle PACKAGE.MODULE.  */
	  typ = d_module_from_name (token);
	  if (typ != NULL)
	    {
	      if (push_module_name (ps, typ, name, doti) != 0)
		return;
	    }
	  /* Handle TYPE.FIELD1..FIELDN.  */
	  typ = d_type_from_name (token);
	  if (typ != NULL)
	    {
	      push_type_name (ps, typ, name, doti);
	      return;
	    }

	  if (doti >= name.length)
	    break;
	  doti++;   /* Skip '.'  */
	  while (doti < name.length && name.ptr[doti] != '.')
	    doti++;
	}
    }

  /* Lookup foreign name in global static symbols.  */
  copy  = copy_name (name);
  msymbol = lookup_bound_minimal_symbol (copy);
  if (msymbol.minsym != NULL)
    write_exp_msymbol (ps, msymbol);
  else if (!have_full_symbols () && !have_partial_symbols ())
    error (_("No symbol table is loaded.  Use the \"file\" command"));
  else
    error (_("No symbol \"%s\" in current context."), copy);
}

/* This is set if a NAME token appeared at the very end of the input
   string, with no whitespace separating the name from the EOF.  This
   is used only when parsing to do field name completion.  */
static int saw_name_at_eof;

/* This is set if the previously-returned token was a structure operator.
   This is used only when parsing to do field name completion.  */
static int last_was_structop;

/* Read one token, getting characters through lexptr.  */

static int
yylex (void)
{
  int c;
  int namelen;
  unsigned int i;
  const char *tokstart;
  int saw_structop = last_was_structop;
  char *copy;

  last_was_structop = 0;

 retry:

  prev_lexptr = lexptr;

  tokstart = lexptr;
  /* See if it is a special token of length 3.  */
  for (i = 0; i < sizeof tokentab3 / sizeof tokentab3[0]; i++)
    if (strncmp (tokstart, tokentab3[i].oper, 3) == 0)
      {
	lexptr += 3;
	yylval.opcode = tokentab3[i].opcode;
	return tokentab3[i].token;
      }

  /* See if it is a special token of length 2.  */
  for (i = 0; i < sizeof tokentab2 / sizeof tokentab2[0]; i++)
    if (strncmp (tokstart, tokentab2[i].oper, 2) == 0)
      {
	lexptr += 2;
	yylval.opcode = tokentab2[i].opcode;
	return tokentab2[i].token;
      }

  switch (c = *tokstart)
    {
    case 0:
      /* If we're parsing for field name completion, and the previous
	 token allows such completion, return a COMPLETE token.
	 Otherwise, we were already scanning the original text, and
	 we're really done.  */
      if (saw_name_at_eof)
	{
	  saw_name_at_eof = 0;
	  return COMPLETE;
	}
      else if (saw_structop)
	return COMPLETE;
      else
        return 0;

    case ' ':
    case '\t':
    case '\n':
      lexptr++;
      goto retry;

    case '[':
    case '(':
      paren_depth++;
      lexptr++;
      return c;

    case ']':
    case ')':
      if (paren_depth == 0)
	return 0;
      paren_depth--;
      lexptr++;
      return c;

    case ',':
      if (comma_terminates && paren_depth == 0)
	return 0;
      lexptr++;
      return c;

    case '.':
      /* Might be a floating point number.  */
      if (lexptr[1] < '0' || lexptr[1] > '9')
	{
	  if (parse_completion)
	    last_was_structop = 1;
	  goto symbol;		/* Nope, must be a symbol.  */
	}
      /* FALL THRU into number case.  */

    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      {
	/* It's a number.  */
	int got_dot = 0, got_e = 0, toktype;
	const char *p = tokstart;
	int hex = input_radix > 10;

	if (c == '0' && (p[1] == 'x' || p[1] == 'X'))
	  {
	    p += 2;
	    hex = 1;
	  }

	for (;; ++p)
	  {
	    /* Hex exponents start with 'p', because 'e' is a valid hex
	       digit and thus does not indicate a floating point number
	       when the radix is hex.  */
	    if ((!hex && !got_e && tolower (p[0]) == 'e')
		|| (hex && !got_e && tolower (p[0] == 'p')))
	      got_dot = got_e = 1;
	    /* A '.' always indicates a decimal floating point number
	       regardless of the radix.  If we have a '..' then its the
	       end of the number and the beginning of a slice.  */
	    else if (!got_dot && (p[0] == '.' && p[1] != '.'))
		got_dot = 1;
	    /* This is the sign of the exponent, not the end of the number.  */
	    else if (got_e && (tolower (p[-1]) == 'e' || tolower (p[-1]) == 'p')
		     && (*p == '-' || *p == '+'))
	      continue;
	    /* We will take any letters or digits, ignoring any embedded '_'.
	       parse_number will complain if past the radix, or if L or U are
	       not final.  */
	    else if ((*p < '0' || *p > '9') && (*p != '_') &&
		     ((*p < 'a' || *p > 'z') && (*p < 'A' || *p > 'Z')))
	      break;
	  }

	toktype = parse_number (pstate, tokstart, p - tokstart,
				got_dot|got_e, &yylval);
	if (toktype == ERROR)
	  {
	    char *err_copy = (char *) alloca (p - tokstart + 1);

	    memcpy (err_copy, tokstart, p - tokstart);
	    err_copy[p - tokstart] = 0;
	    error (_("Invalid number \"%s\"."), err_copy);
	  }
	lexptr = p;
	return toktype;
      }

    case '@':
      {
	const char *p = &tokstart[1];
	size_t len = strlen ("entry");

	while (isspace (*p))
	  p++;
	if (strncmp (p, "entry", len) == 0 && !isalnum (p[len])
	    && p[len] != '_')
	  {
	    lexptr = &p[len];
	    return ENTRY;
	  }
      }
      /* FALLTHRU */
    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '|':
    case '&':
    case '^':
    case '~':
    case '!':
    case '<':
    case '>':
    case '?':
    case ':':
    case '=':
    case '{':
    case '}':
    symbol:
      lexptr++;
      return c;

    case '\'':
    case '"':
    case '`':
      {
	int host_len;
	int result = parse_string_or_char (tokstart, &lexptr, &yylval.tsval,
					   &host_len);
	if (result == CHARACTER_LITERAL)
	  {
	    if (host_len == 0)
	      error (_("Empty character constant."));
	    else if (host_len > 2 && c == '\'')
	      {
		++tokstart;
		namelen = lexptr - tokstart - 1;
		goto tryname;
	      }
	    else if (host_len > 1)
	      error (_("Invalid character constant."));
	  }
	return result;
      }
    }

  if (!(c == '_' || c == '$'
	|| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')))
    /* We must have come across a bad character (e.g. ';').  */
    error (_("Invalid character '%c' in expression"), c);

  /* It's a name.  See how long it is.  */
  namelen = 0;
  for (c = tokstart[namelen];
       (c == '_' || c == '$' || (c >= '0' && c <= '9')
	|| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));)
    c = tokstart[++namelen];

  /* The token "if" terminates the expression and is NOT
     removed from the input stream.  */
  if (namelen == 2 && tokstart[0] == 'i' && tokstart[1] == 'f')
    return 0;

  /* For the same reason (breakpoint conditions), "thread N"
     terminates the expression.  "thread" could be an identifier, but
     an identifier is never followed by a number without intervening
     punctuation.  "task" is similar.  Handle abbreviations of these,
     similarly to breakpoint.c:find_condition_and_thread.  */
  if (namelen >= 1
      && (strncmp (tokstart, "thread", namelen) == 0
	  || strncmp (tokstart, "task", namelen) == 0)
      && (tokstart[namelen] == ' ' || tokstart[namelen] == '\t'))
    {
      const char *p = tokstart + namelen + 1;

      while (*p == ' ' || *p == '\t')
        p++;
      if (*p >= '0' && *p <= '9')
        return 0;
    }

  lexptr += namelen;

 tryname:

  yylval.sval.ptr = tokstart;
  yylval.sval.length = namelen;

  /* Catch specific keywords.  */
  copy = copy_name (yylval.sval);
  for (i = 0; i < sizeof ident_tokens / sizeof ident_tokens[0]; i++)
    if (strcmp (copy, ident_tokens[i].oper) == 0)
      {
	/* It is ok to always set this, even though we don't always
	   strictly need to.  */
	yylval.opcode = ident_tokens[i].opcode;
	return ident_tokens[i].token;
      }

  if (*tokstart == '$')
    return DOLLAR_VARIABLE;

  yylval.tsym.type
    = language_lookup_primitive_type (parse_language (pstate),
				      parse_gdbarch (pstate), copy);
  if (yylval.tsym.type != NULL)
    return TYPENAME;

  /* Input names that aren't symbols but ARE valid hex numbers,
     when the input radix permits them, can be names or numbers
     depending on the parse.  Note we support radixes > 16 here.  */
  if ((tokstart[0] >= 'a' && tokstart[0] < 'a' + input_radix - 10)
      || (tokstart[0] >= 'A' && tokstart[0] < 'A' + input_radix - 10))
    {
      YYSTYPE newlval;	/* Its value is ignored.  */
      int hextype = parse_number (pstate, tokstart, namelen, 0, &newlval);
      if (hextype == INTEGER_LITERAL)
	return NAME_OR_INT;
    }

  if (parse_completion && *lexptr == '\0')
    saw_name_at_eof = 1;

  return IDENTIFIER;
}

int
d_parse (struct parser_state *par_state)
{
  int result;
  struct cleanup *back_to;

  /* Setting up the parser state.  */
  gdb_assert (par_state != NULL);
  pstate = par_state;

  back_to = make_cleanup (null_cleanup, NULL);

  make_cleanup_restore_integer (&yydebug);
  make_cleanup_clear_parser_state (&pstate);
  yydebug = parser_debug;

  /* Initialize some state used by the lexer.  */
  last_was_structop = 0;
  saw_name_at_eof = 0;

  result = yyparse ();
  do_cleanups (back_to);
  return result;
}

void
yyerror (char *msg)
{
  if (prev_lexptr)
    lexptr = prev_lexptr;

  error (_("A %s in expression, near `%s'."), (msg ? msg : "error"), lexptr);
}

#line 1983 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.c"

#if YYDEBUG
#include <stdio.h>		/* needed for printf */
#endif

#include <stdlib.h>	/* needed for xmalloc, etc */
#include <string.h>	/* needed for memset */

/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack(YYSTACKDATA *data)
{
    int i;
    unsigned newsize;
    YYINT *newss;
    YYSTYPE *newvs;

    if ((newsize = data->stacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return YYENOMEM;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;

    i = (int) (data->s_mark - data->s_base);
    newss = (YYINT *)xrealloc(data->s_base, newsize * sizeof(*newss));
    if (newss == 0)
        return YYENOMEM;

    data->s_base = newss;
    data->s_mark = newss + i;

    newvs = (YYSTYPE *)xrealloc(data->l_base, newsize * sizeof(*newvs));
    if (newvs == 0)
        return YYENOMEM;

    data->l_base = newvs;
    data->l_mark = newvs + i;

    data->stacksize = newsize;
    data->s_last = data->s_base + newsize - 1;
    return 0;
}

#if YYPURE || defined(YY_NO_LEAKS)
static void yyfreestack(YYSTACKDATA *data)
{
    xfree(data->s_base);
    xfree(data->l_base);
    memset(data, 0, sizeof(*data));
}
#else
#define yyfreestack(data) /* nothing */
#endif

#define YYABORT  goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR  goto yyerrlab

int
YYPARSE_DECL()
{
    int yym, yyn, yystate;
#if YYDEBUG
    const char *yys;

    if ((yys = getenv("YYDEBUG")) != 0)
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = YYEMPTY;
    yystate = 0;

#if YYPURE
    memset(&yystack, 0, sizeof(yystack));
#endif

    if (yystack.s_base == NULL && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
    yystack.s_mark = yystack.s_base;
    yystack.l_mark = yystack.l_base;
    yystate = 0;
    *yystack.s_mark = 0;

yyloop:
    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = YYLEX) < 0) yychar = YYEOF;
#if YYDEBUG
        if (yydebug)
        {
            yys = yyname[YYTRANSLATE(yychar)];
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
        {
            goto yyoverflow;
        }
        yystate = yytable[yyn];
        *++yystack.s_mark = yytable[yyn];
        *++yystack.l_mark = yylval;
        yychar = YYEMPTY;
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;

    YYERROR_CALL("syntax error");

    goto yyerrlab;

yyerrlab:
    ++yynerrs;

yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yystack.s_mark]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yystack.s_mark, yytable[yyn]);
#endif
                if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
                {
                    goto yyoverflow;
                }
                yystate = yytable[yyn];
                *++yystack.s_mark = yytable[yyn];
                *++yystack.l_mark = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yystack.s_mark);
#endif
                if (yystack.s_mark <= yystack.s_base) goto yyabort;
                --yystack.s_mark;
                --yystack.l_mark;
            }
        }
    }
    else
    {
        if (yychar == YYEOF) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = yyname[YYTRANSLATE(yychar)];
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = YYEMPTY;
        goto yyloop;
    }

yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    if (yym)
        yyval = yystack.l_mark[1-yym];
    else
        memset(&yyval, 0, sizeof yyval);
    switch (yyn)
    {
case 5:
#line 245 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_COMMA); }
break;
case 7:
#line 251 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_ASSIGN); }
break;
case 8:
#line 253 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY);
		  write_exp_elt_opcode (pstate, yystack.l_mark[-1].opcode);
		  write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY); }
break;
case 10:
#line 261 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, TERNOP_COND); }
break;
case 12:
#line 267 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_OR); }
break;
case 14:
#line 273 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_AND); }
break;
case 16:
#line 279 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_BITWISE_IOR); }
break;
case 18:
#line 285 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_BITWISE_XOR); }
break;
case 20:
#line 291 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_BITWISE_AND); }
break;
case 25:
#line 303 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_EQUAL); }
break;
case 26:
#line 305 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_NOTEQUAL); }
break;
case 27:
#line 310 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_EQUAL); }
break;
case 28:
#line 312 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_NOTEQUAL); }
break;
case 29:
#line 317 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_LESS); }
break;
case 30:
#line 319 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_LEQ); }
break;
case 31:
#line 321 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_GTR); }
break;
case 32:
#line 323 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_GEQ); }
break;
case 34:
#line 329 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_LSH); }
break;
case 35:
#line 331 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_RSH); }
break;
case 37:
#line 337 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_ADD); }
break;
case 38:
#line 339 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_SUB); }
break;
case 39:
#line 341 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_CONCAT); }
break;
case 41:
#line 347 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_MUL); }
break;
case 42:
#line 349 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_DIV); }
break;
case 43:
#line 351 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_REM); }
break;
case 44:
#line 355 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, UNOP_ADDR); }
break;
case 45:
#line 357 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, UNOP_PREINCREMENT); }
break;
case 46:
#line 359 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, UNOP_PREDECREMENT); }
break;
case 47:
#line 361 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, UNOP_IND); }
break;
case 48:
#line 363 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, UNOP_NEG); }
break;
case 49:
#line 365 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, UNOP_PLUS); }
break;
case 50:
#line 367 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT); }
break;
case 51:
#line 369 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, UNOP_COMPLEMENT); }
break;
case 54:
#line 376 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, UNOP_CAST);
		  write_exp_elt_type (pstate, yystack.l_mark[-2].tval);
		  write_exp_elt_opcode (pstate, UNOP_CAST); }
break;
case 55:
#line 382 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, UNOP_CAST);
		  write_exp_elt_type (pstate, yystack.l_mark[-2].tval);
		  write_exp_elt_opcode (pstate, UNOP_CAST); }
break;
case 57:
#line 390 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, BINOP_EXP); }
break;
case 59:
#line 396 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, UNOP_POSTINCREMENT); }
break;
case 60:
#line 398 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, UNOP_POSTDECREMENT); }
break;
case 64:
#line 406 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ arglist_len = 1; }
break;
case 65:
#line 408 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ arglist_len++; }
break;
case 66:
#line 413 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ arglist_len = 0; }
break;
case 68:
#line 419 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ start_arglist (); }
break;
case 69:
#line 421 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, OP_FUNCALL);
		  write_exp_elt_longcst (pstate, (LONGEST) end_arglist ());
		  write_exp_elt_opcode (pstate, OP_FUNCALL); }
break;
case 70:
#line 428 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ if (arglist_len > 0)
		    {
		      write_exp_elt_opcode (pstate, MULTI_SUBSCRIPT);
		      write_exp_elt_longcst (pstate, (LONGEST) arglist_len);
		      write_exp_elt_opcode (pstate, MULTI_SUBSCRIPT);
		    }
		  else
		    write_exp_elt_opcode (pstate, BINOP_SUBSCRIPT);
		}
break;
case 71:
#line 441 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ /* Do nothing.  */ }
break;
case 72:
#line 443 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, TERNOP_SLICE); }
break;
case 73:
#line 448 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ /* Do nothing.  */ }
break;
case 74:
#line 450 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ push_expression_name (pstate, yystack.l_mark[0].sval); }
break;
case 75:
#line 452 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ struct stoken s;
		  s.ptr = "";
		  s.length = 0;
		  push_expression_name (pstate, yystack.l_mark[-2].sval);
		  mark_struct_expression (pstate);
		  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);
		  write_exp_string (pstate, s);
		  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }
break;
case 76:
#line 461 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ push_expression_name (pstate, yystack.l_mark[-3].sval);
		  mark_struct_expression (pstate);
		  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);
		  write_exp_string (pstate, yystack.l_mark[-1].sval);
		  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }
break;
case 77:
#line 467 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_dollar_variable (pstate, yystack.l_mark[0].sval); }
break;
case 78:
#line 469 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ YYSTYPE val;
                  parse_number (pstate, yystack.l_mark[0].sval.ptr, yystack.l_mark[0].sval.length, 0, &val);
		  write_exp_elt_opcode (pstate, OP_LONG);
		  write_exp_elt_type (pstate, val.typed_val_int.type);
		  write_exp_elt_longcst (pstate,
					 (LONGEST) val.typed_val_int.val);
		  write_exp_elt_opcode (pstate, OP_LONG); }
break;
case 79:
#line 477 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ struct type *type = parse_d_type (pstate)->builtin_void;
		  type = lookup_pointer_type (type);
		  write_exp_elt_opcode (pstate, OP_LONG);
		  write_exp_elt_type (pstate, type);
		  write_exp_elt_longcst (pstate, (LONGEST) 0);
		  write_exp_elt_opcode (pstate, OP_LONG); }
break;
case 80:
#line 484 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, OP_BOOL);
		  write_exp_elt_longcst (pstate, (LONGEST) 1);
		  write_exp_elt_opcode (pstate, OP_BOOL); }
break;
case 81:
#line 488 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, OP_BOOL);
		  write_exp_elt_longcst (pstate, (LONGEST) 0);
		  write_exp_elt_opcode (pstate, OP_BOOL); }
break;
case 82:
#line 492 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, OP_LONG);
		  write_exp_elt_type (pstate, yystack.l_mark[0].typed_val_int.type);
		  write_exp_elt_longcst (pstate, (LONGEST)(yystack.l_mark[0].typed_val_int.val));
		  write_exp_elt_opcode (pstate, OP_LONG); }
break;
case 83:
#line 497 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, OP_DOUBLE);
		  write_exp_elt_type (pstate, yystack.l_mark[0].typed_val_float.type);
		  write_exp_elt_dblcst (pstate, yystack.l_mark[0].typed_val_float.dval);
		  write_exp_elt_opcode (pstate, OP_DOUBLE); }
break;
case 84:
#line 502 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ struct stoken_vector vec;
		  vec.len = 1;
		  vec.tokens = &yystack.l_mark[0].tsval;
		  write_exp_string_vector (pstate, yystack.l_mark[0].tsval.type, &vec); }
break;
case 85:
#line 507 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ int i;
		  write_exp_string_vector (pstate, 0, &yystack.l_mark[0].svec);
		  for (i = 0; i < yystack.l_mark[0].svec.len; ++i)
		    xfree (yystack.l_mark[0].svec.tokens[i].ptr);
		  xfree (yystack.l_mark[0].svec.tokens); }
break;
case 86:
#line 513 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, OP_ARRAY);
		  write_exp_elt_longcst (pstate, (LONGEST) 0);
		  write_exp_elt_longcst (pstate, (LONGEST) yystack.l_mark[0].ival - 1);
		  write_exp_elt_opcode (pstate, OP_ARRAY); }
break;
case 87:
#line 521 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ yyval.ival = arglist_len; }
break;
case 89:
#line 527 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ yyval.sval.length = yystack.l_mark[-2].sval.length + yystack.l_mark[0].sval.length + 1;
		  if (yystack.l_mark[-2].sval.ptr + yystack.l_mark[-2].sval.length + 1 == yystack.l_mark[0].sval.ptr
		      && yystack.l_mark[-2].sval.ptr[yystack.l_mark[-2].sval.length] == '.')
		    yyval.sval.ptr = yystack.l_mark[-2].sval.ptr;  /* Optimization.  */
		  else
		    {
		      char *buf = xmalloc (yyval.sval.length + 1);
		      make_cleanup (xfree, buf);
		      sprintf (buf, "%.*s.%.*s",
		               yystack.l_mark[-2].sval.length, yystack.l_mark[-2].sval.ptr, yystack.l_mark[0].sval.length, yystack.l_mark[0].sval.ptr);
		      yyval.sval.ptr = buf;
		    }
		}
break;
case 90:
#line 544 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ /* We copy the string here, and not in the
		     lexer, to guarantee that we do not leak a
		     string.  Note that we follow the
		     NUL-termination convention of the
		     lexer.  */
		  struct typed_stoken *vec = XNEW (struct typed_stoken);
		  yyval.svec.len = 1;
		  yyval.svec.tokens = vec;

		  vec->type = yystack.l_mark[0].tsval.type;
		  vec->length = yystack.l_mark[0].tsval.length;
		  vec->ptr = xmalloc (yystack.l_mark[0].tsval.length + 1);
		  memcpy (vec->ptr, yystack.l_mark[0].tsval.ptr, yystack.l_mark[0].tsval.length + 1);
		}
break;
case 91:
#line 559 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ /* Note that we NUL-terminate here, but just
		     for convenience.  */
		  char *p;
		  ++yyval.svec.len;
		  yyval.svec.tokens = xrealloc (yyval.svec.tokens,
				       yyval.svec.len * sizeof (struct typed_stoken));

		  p = xmalloc (yystack.l_mark[0].tsval.length + 1);
		  memcpy (p, yystack.l_mark[0].tsval.ptr, yystack.l_mark[0].tsval.length + 1);

		  yyval.svec.tokens[yyval.svec.len - 1].type = yystack.l_mark[0].tsval.type;
		  yyval.svec.tokens[yyval.svec.len - 1].length = yystack.l_mark[0].tsval.length;
		  yyval.svec.tokens[yyval.svec.len - 1].ptr = p;
		}
break;
case 92:
#line 577 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ write_exp_elt_opcode (pstate, OP_TYPE);
		  write_exp_elt_type (pstate, yystack.l_mark[0].tval);
		  write_exp_elt_opcode (pstate, OP_TYPE); }
break;
case 93:
#line 581 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ yyval.tval = follow_types (yystack.l_mark[-1].tval);
		  write_exp_elt_opcode (pstate, OP_TYPE);
		  write_exp_elt_type (pstate, yyval.tval);
		  write_exp_elt_opcode (pstate, OP_TYPE);
		}
break;
case 94:
#line 590 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ push_type (tp_pointer); }
break;
case 95:
#line 592 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ push_type (tp_pointer); }
break;
case 96:
#line 594 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ push_type_int (yystack.l_mark[-1].typed_val_int.val);
		  push_type (tp_array); }
break;
case 97:
#line 597 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ push_type_int (yystack.l_mark[-2].typed_val_int.val);
		  push_type (tp_array); }
break;
case 98:
#line 603 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ yyval.tval = yystack.l_mark[0].tsym.type; }
break;
case 99:
#line 605 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ yyval.tval = lookup_struct (copy_name (yystack.l_mark[0].sval),
				      expression_context_block); }
break;
case 100:
#line 608 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ mark_completion_tag (TYPE_CODE_STRUCT, "", 0);
		  yyval.tval = NULL; }
break;
case 101:
#line 611 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ mark_completion_tag (TYPE_CODE_STRUCT, yystack.l_mark[-1].sval.ptr, yystack.l_mark[-1].sval.length);
		  yyval.tval = NULL; }
break;
case 102:
#line 614 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ yyval.tval = lookup_struct (copy_name (yystack.l_mark[0].sval),
				      expression_context_block); }
break;
case 103:
#line 617 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ mark_completion_tag (TYPE_CODE_STRUCT, "", 0);
		  yyval.tval = NULL; }
break;
case 104:
#line 620 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ mark_completion_tag (TYPE_CODE_STRUCT, yystack.l_mark[-1].sval.ptr, yystack.l_mark[-1].sval.length);
		  yyval.tval = NULL; }
break;
case 105:
#line 623 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ yyval.tval = lookup_union (copy_name (yystack.l_mark[0].sval),
				     expression_context_block); }
break;
case 106:
#line 626 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ mark_completion_tag (TYPE_CODE_UNION, "", 0);
		  yyval.tval = NULL; }
break;
case 107:
#line 629 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ mark_completion_tag (TYPE_CODE_UNION, yystack.l_mark[-1].sval.ptr, yystack.l_mark[-1].sval.length);
		  yyval.tval = NULL; }
break;
case 108:
#line 632 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ yyval.tval = lookup_enum (copy_name (yystack.l_mark[0].sval),
				    expression_context_block); }
break;
case 109:
#line 635 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ mark_completion_tag (TYPE_CODE_ENUM, "", 0);
		  yyval.tval = NULL; }
break;
case 110:
#line 638 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.y"
	{ mark_completion_tag (TYPE_CODE_ENUM, yystack.l_mark[-1].sval.ptr, yystack.l_mark[-1].sval.length);
		  yyval.tval = NULL; }
break;
#line 2633 "/usr/src/tools/gdb/../../external/gpl3/gdb/dist/gdb/d-exp.c"
    }
    yystack.s_mark -= yym;
    yystate = *yystack.s_mark;
    yystack.l_mark -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yystack.s_mark = YYFINAL;
        *++yystack.l_mark = yyval;
        if (yychar < 0)
        {
            if ((yychar = YYLEX) < 0) yychar = YYEOF;
#if YYDEBUG
            if (yydebug)
            {
                yys = yyname[YYTRANSLATE(yychar)];
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == YYEOF) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yystack.s_mark, yystate);
#endif
    if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
    {
        goto yyoverflow;
    }
    *++yystack.s_mark = (YYINT) yystate;
    *++yystack.l_mark = yyval;
    goto yyloop;

yyoverflow:
    YYERROR_CALL("yacc stack overflow");

yyabort:
    yyfreestack(&yystack);
    return (1);

yyaccept:
    yyfreestack(&yystack);
    return (0);
}
