.\" om.tmac
.\"
.\" Mom -- a typesetting/document-processing macro set for groff.
.\"
.\" Copyright (C) 2002, 2003 Free Software Foundation, Inc.
.\"      Written by Peter Schaffter (df191@ncf.ca)
.\"
.\" This file is part of groff.
.\"
.\" groff is free software; you can redistribute it and/or modify it under
.\" the terms of the GNU General Public License as published by the Free
.\" Software Foundation; either version 2, or (at your option) any later
.\" version.
.\"
.\" groff is distributed in the hope that it will be useful, but WITHOUT ANY
.\" WARRANTY; without even the implied warranty of MERCHANTABILITY or
.\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
.\" for more details.
.\"
.\" You should have received a copy of the GNU General Public License along
.\" with groff; see the file COPYING.  If not, write to the Free Software
.\" Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
.\"
.\"
.\"
\# Version 1.1.8
\# -------------
\#
.if (\n[.x]\n[.y] < 118) \
.  ab You need GNU troff version 1.18 or higher to run this version of mom!
\#
\# Inasmuch as possible, macros that turn a feature on or off follow
\# a similar style.  Invoking the macro without an argument turns
\# the feature on.  Invoking it with any other argument turns it off.
\# Use of the argument OFF is recommended, but not required; users
\# may find other conventions preferable (e.g. NO, X, END, QUIT, etc.).
\#
\# "<anything>" in the description of arguments that can be passed
\# to a macro means that any argument turns the feature off.
\#
\# ====================================================================
\#
\# TYPESETTING MACROS, STRINGS, AND ALIASES
\# ========================================
\#
\# +++ALIASES+++
\#
.als      ALIAS           als   \"Alias .als as ALIAS
.als      ALIASN          aln   \"Alias .aln (number registers) as ALIASN
\#
.ALIAS    MAC             de
.ALIAS    BR              br
.ALIAS    SPACE           sp
.ALIAS    SP              sp
.ALIAS    PAGELENGTH      pl
.ALIAS    NEWPAGE         bp
.ALIAS    SPREAD          brp
.ALIAS    ESC_CHAR        ec
\#
\# ALIASES FOR NUMBER REGISTERS
\# ----------------------------
\#
.ALIASN  #PT_SIZE        .ps    \"fractional point size in units
.ALIASN  #DIVER_DEPTH     dn    \"diversion depth
.ALIASN  #DIVER_WIDTH     dl    \"diversion width
.ALIASN  #TRAP_DISTANCE  .t     \"distance to next trap
.ALIASN  #LEAD           .v     \"line space (.vs, not .ls)
.ALIASN  #PAGE_LENGTH    .p     \"page length
.ALIASN  #NUM_ARGS       .$     \"number of arguments passed to a macro
.ALIASN  #INDENT         .i     \"value of current indent
\#
\# ====================================================================
\#
\# MISCELLANEOUS
\# =============
.cflags 4 /\(en      \" So slash and en-dashes get broken
.nr #L_MARGIN \n(.o  \" Tabs, etc require #L_MARGIN
\#
\# ====================================================================
\#
\# END MACRO FOR LETTERS
\# ---------------------
\# *Arguments:
\#   none
\# *Function:
\#   The .em macro executed at the end of letters.  Turns footers
\#   and pagination off, terminates and outputs diversion CLOSING
\#   (indented with the author's name underneath).
\#
.MAC ALL_DONE END
.    br
.    FOOTERS OFF
.    PAGINATION OFF
.    if \\n[#DOC_TYPE]=4 \{\
.       br
.       if !'\\n(.z'' \{ .di \}
.       IQ CLEAR
.       TQ
.       TAB_SET 1 \\n[#DOC_L_LENGTH]u/2u \\n[#DOC_L_LENGTH]u/2u LEFT
.       ALD \\n[#DOC_LEAD]u*2u
.       TAB 1
.       if \\n[#CLOSING] \{\
.          nf
.          CLOSING
.       \}
.       ALD \\n[#DOC_LEAD]u*3u
.       PRINT \\*[$AUTHOR_1]
.    \}
.    DO_FOOTER
.END
\#
\#
\# =====================================================================
\#
\# +++PAGE LAYOUT+++
\#
\# Macros that control the physical layout of the page: paper size
\# and margins.
\#
\# PAGE WIDTH
\# ----------
\# *Argument:
\#   <width of printer sheet>
\# *Function:
\#   Stores user supplied page width in register #PAGE_WIDTH.
\# *Notes:
\#   #PAGE_WIDTH is used to establish the default LL (and right margin).
\#   Requires unit of measure.
\#
.MAC PAGEWIDTH END
.    br
.    nr #PAGE_WIDTH \\$1
.    if !r#L_MARGIN \{ .L_MARGIN \\n(.o \}
.    if !r#R_MARGIN \{ .R_MARGIN 1i \}
.END
\#
\#
\# L_MARGIN
\# --------
\# *Argument:
\#   <offset from page left>
\# *Function:
\#   Stores user supplied page offset in register #L_MARGIN.
\#   Sets .po to user supplied offset.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC L_MARGIN END
.    br
.    nr #L_MARGIN (\\$1)
.    po \\n[#L_MARGIN]u
.END
\#
\#
\# R_MARGIN
\# --------
\# *Argument:
\#   <width of right margin>
\# *Function:
\#   Stores user supplied right margin in register #R_MARGIN.
\# *Notes:
\#   This is a pseudo-margin.  Right margin is actually a function of
\#   line length.  The macro calculates line length from the page offset
\#   and the value plugged into #R_MARGIN.
\#
\#   N.B. -- PAGEWIDTH and L_MARGIN have to be defined before R_MARGIN.
\#
\#   Requires unit of measure.
\#
.MAC R_MARGIN END
.    br
.    nr #R_MARGIN (\\$1)
.    ll \\n[#PAGE_WIDTH]u-\\n[#L_MARGIN]u-\\n[#R_MARGIN]u
.    ta \\n(.lu
.    nr #L_LENGTH \\n(.l
.END
\#
\#
\# T_MARGIN
\# --------
\# *Argument:
\#   <distance to advance from top of page>
\# *Function:
\#   Stores the user supplied top margin in register #T_MARGIN.
\#   Advances user supplied depth from the top of the page.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC T_MARGIN END
.    br
.    nr #T_MARGIN (\\$1)
.    nr #T_MARGIN_SET 1
.    if !\\n[#DOCS] \{\
.       PRINT \&
.       sp |\\n[#T_MARGIN]u-1v
.    \}
.    wh 0i DO_T_MARGIN
.END
\#
\#
\# B_MARGIN
\# --------
\# *Argument:
\#   <space to leave at the bottom of the page>
\# *Function:
\#   Stores the user supplied bottom margin in register #B_MARGIN.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC B_MARGIN END
.    br
.    nr #B_MARGIN (\\$1)
.    wh -\\n[#B_MARGIN]u DO_B_MARGIN
.END
\#
\#
\# PAGE
\# ----
\# *Arguments:
\#   <pagewidth>  [pagelength [leftmargin [rightmargin [topmargin [bottommargin]]]]]
\# *Function:
\#   Page set-up.  Collects arguments and passes them to the appropriate
\#   macros.
\# *Notes:
\#   All arguments after pagewidth are optional, but must appear
\#   in the order given above.  (User can fill in as much or as
\#   little as desired.)
\#
\#   All arguments require a unit of measure.
\#
.MAC PAGE END
.    br
.    PAGEWIDTH                \\$1
.    PAGELENGTH               \\$2
.    ie '\\$3'' \{ .L_MARGIN  \\n(.o \}
.    el \{ .L_MARGIN          \\$3 \}
.    ie '\\$4'' \{ .R_MARGIN  1i \}
.    el \{ .R_MARGIN          \\$4 \}
.    if !'\\$5'' \{ .T_MARGIN \\$5 \}
.    if !'\\$6'' \{ .B_MARGIN \\$6 \}
.END
\#
\# =====================================================================
\#
\# +++PAGE CONTROL+++
\#
\# Generic macros for breaking pages.
\#
\# DO_T_MARGIN
\# -----------
\# *Argument:
\#   <none>
\# *Function:
\#   Plants the top margin (set in .PAGE) at the top of each page.
\# *Notes:
\#   The trap is set in .PAGE
\#
.MAC DO_T_MARGIN END
.    ev 1
.    sp |\\n[#T_MARGIN]u-1v
.    ev
.END
\#
\#
\# DO_B_MARGIN
\# -----------
\# *Argument:
\#   <none>
\# *Function:
\#   Plants the bottom margin (set in .PAGE) at the bottom of each page.
\# *Notes:
\#   The trap is set in .PAGE.
\#
.MAC DO_B_MARGIN END
.    ev 1
.    bp
.    ev
.END
\#
\# =====================================================================
\#
\# +++GENERAL STYLE MACROS+++
\#
\# Macros that are likely to appear together to define general
\# type style: line length, family, font, point size, and line
\# spacing.
\#
\# LINE LENGTH
\# -----------
\# *Argument:
\#   <line length>
\# *Function:
\#   Stores user supplied line length in register #L_LENGTH.
\#   Sets .ll to #L_LENGTHu
\# *Notes:
\#   Requires unit of measure.
\#
.MAC LL END
.    nr #L_LENGTH (\\$1)
.    nr #USER_SET_L_LENGTH 1
.    ll \\n[#L_LENGTH]u
.    ta \\n(.lu
.END
\#
\#
\# FAMILY
\# ------
\# *Argument:
\#   <font family>
\# *Function:
\#   Stores user supplied font family in string $FAMILY.  Sets .fam
\#   to $FAMILY.
\#
.MAC FAMILY END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    if \\n[#IGNORE]        \{ .return \}
.    ds $FAMILY \\$1
.    fam \\*[$FAMILY]
.END
\#
\#
\# FONT
\# ----
\# *Argument:
\#   R | I | B | BI
\# *Function:
\#  Stores user supplied font in $FONT and sets .ft to $FONT.
\#
.MAC FT END
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie '\\$1'I' \{\
.          if \\n[#UNDERLINE_ITALIC]=1 \{\
.             UNDERLINE
.             return
.          \}
.          if \\n[#ITALIC_MEANS_ITALIC]=1 \{\
.             ds $FONT \\$1
.             ft \\*[$FONT]
.             return
.          \}
.       \}
.       el \{ .UNDERLINE OFF \}
.       return
.    \}
.    ds $FONT \\$1
.    ft \\*[$FONT]
.END
\#
\#
\# POINT SIZE
\# ----------
\# *Arguments:
\#   <point size of type>
\# *Function:
\#   Sets point size to user supplied value in scaled points.
\#   If #AUTO_LEAD is on, sets .vs to #AUTOLEAD_VALUE+#PT_SIZE.
\# *Notes:
\#   Must NOT use a unit of measure.
\#
.MAC PT_SIZE END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    if \\n[#IGNORE]        \{ .return \}
.    nr #PT_SIZE_SET 1
.    ps \\$1
.    if \\n[#AUTO_LEAD] \{\
.       ie \\n[#AUTOLEAD_FACTOR] \{ .vs \\n[#PT_SIZE]u*\\n[#AUTOLEAD_VALUE]u/1000u \}
.       el \{ .vs \\n[#PT_SIZE]u+\\n[#AUTOLEAD_VALUE]u \}
.    \}
.    nr #PT_SIZE_IN_UNITS \\n[.ps]
.END
\#
\#
\# SIZE (inline)
\# -------------
\# *Arguments:
\#   <point size of type>
\# *Function:
\#   Sets point size to user supplied value in scaled points.
\#   Intended to be called inline with \*[SIZE <n><unit>]
\# *Notes:
\#   Can be used with a unit of measure or not.
\#
.MAC SIZE END
\c
.ps \\$1
.END
\#
\#
\# LEADING
\# -------
\# *Argument:
\#   <leading between lines of text>
\# *Function:
\#   Turns off #AUTO_LEAD if it's on.
\#   Sets .vs to user supplied value.
\# *Notes:
\#   Does not require unit of measure.  LEAD automatically turns off AUTOLEAD.
\#
.MAC LS END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    if \\n[#IGNORE]        \{ .return \}
.    nr #LEAD_SET 1
.    if \\n[#AUTO_LEAD] \{\
.       rr #AUTO_LEAD
.       rr #AUTOLEAD_FACTOR
.    \}
.    vs \\$1
.    if \\n[#T_MARGIN_SET]=1 \{\
.       sp |\\n[#T_MARGIN]u-1v
.       rr #T_MARGIN_SET
.    \}
.END
\#
\#
\# AUTOLEAD
\# --------
\# *Argument:
\#   <leading value to add to #PT_SIZE> [FACTOR]
\# *Function:
\#   Stores user supplied auto-lead value in register #AUTOLEAD_VALUE.
\#   Adds #AUT0LEAD_VALUE to #PT_SIZE when invoked to set leading.
\#   All subsequent PT_SIZE requests reset the leading in the same way until
\#   AUTOLEAD is turned off.
\# *Notes:
\#   With the optional FACTOR argument, the current point size is
\#   multiplied by #AUTOLEAD_VALUE instead of the two being added
\#   together.
\#
.MAC AUTOLEAD END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    if \\n[#IGNORE]        \{ .return \}
.    nr #AUTO_LEAD 1
.    nr #AUTOLEAD_VALUE (p;\\$1)
.    ie \\n[#NUM_ARGS]=2 \{\
.       if '\\$2'FACTOR' \{\
.          nr #AUTOLEAD_FACTOR 1
.          vs \\n[#PT_SIZE]u*\\n[#AUTOLEAD_VALUE]u/1000u
.       \}
.    \}
.    el \{\
.       vs \\n[#PT_SIZE]u+\\n[#AUTOLEAD_VALUE]u
.    \}
.    if \\n[#T_MARGIN_SET] \{\
.       sp |\\n[#T_MARGIN]u-1v
.       rr #T_MARGIN_SET
.    \}
.END
\#
\#
\# STRINGS FOR INLINE CONTROL OF GENERAL TYPE STYLE
\# ------------------------------------------------
.ds ROM  \EfR
.ds IT   \EfI
.ds BD   \EfB
.ds BDI  \Ef(BI
.ds PREV \EfP
.ds S    \Es
\#
\# =====================================================================
\#
\# +++KERNING+++
\#
\# AUTOMATIC PAIRWISE KERNING
\# --------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns automatic pairwise kerning on or off.
\#
.MAC KERN END
.    ie '\\$1'' \{\
.       kern
.       nr #KERN 1
.    \}
.    el \{\
.       kern 0
.       nr #KERN 0
.    \}
.END
\#
\#
\# INLINE KERNING AND HORIZONTAL MOVEMENT
\# --------------------------------------
\# *Kerning
\#  Inline kerning provides a simple method for users to adjust the
\#  amount of space between any two letters.  It's predicated on a
\#  unit of measure "U", which is 1/36 of the current point size as
\#  returned by \n[.ps].  E.g., if the current point size is 18,
\#  \n[.ps] returns 18000u, therefore U=500u.  Since U remains
\#  proportional relative to the current point size, the amount
\#  of kerning between two letters as expressed in Us remains
\#  visually similar regardless of changes in point size.
\#
\#  N.B.--the amount of inline kerning supplied by \*[BU<n>] or
\#  \*[FU<n>] is added to or subtracted from any kerning that already
\#  takes place between two characters when automatic kerning is
\#  turned on.
\#
\#  In groff v. 1.17.2, it was not possible to pass arguments to macros that
\#  were called with inline escapes, nor thence to evaluate conditional
\#  expressions.  Consequently, each pseudo-escape \[BU<n>] had to be defined
\#  separately with ".char".
\#
\#  As of v. 1.18, one can pass arguments to inline strings/macros,
\#  hence it is now possible to do \*[BU n] where n, inline, is the desired
\#  number of kern units.  The original .char definitions have been left in
\#  for backward compatibility with documents created prior to mom-1.1.3c.
\#
\#
.nr #KERN_UNIT 36
.ds BU   \h'-(\En[#PT_SIZE]u/\n[#KERN_UNIT]u*\\$1u)'
.ds FU   \h'(\En[#PT_SIZE]u/\n[#KERN_UNIT]u*\\$1u)'
\#
\# Initialize strings for pre-1.1.3c-style BU and FU
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<37 \{\
.   ds BU\n[#LOOP]  \h'-(\En[#PT_SIZE]u/\n[#KERN_UNIT]u*\n[#LOOP]u)'
.\}
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<37 \{\
.   ds FU\n[#LOOP]  \h'(\En[#PT_SIZE]u/\n[#KERN_UNIT]u*\n[#LOOP]u)'
.\}
.rr #LOOP
\#
\#
\# *Horizontal movements
\#  BP1...12.75 and FP1...12.75 move backwards or forwards inline by the
\#  specified number of points.
\#  Left in for backward compatibility with mom-1.1.3c, the
\#  preferred methods for inline horizontal movements are now
\#  \*[BCK <n><unit>] and \*[FWD <n><unit>].
\#
.ds BCK  \h'-\\$1\\$2'
.ds FWD  \h'\\$1\\$2'
\#
.ds BP.25    \h'-.25'
.ds BP.5     \h'-.5'
.ds BP.75    \h'-.75'
.ds BP1      \h'-1p'
.ds BP1.25   \h'-1.25p'
.ds BP1.5    \h'-1.5p'
.ds BP1.75   \h'-1.75p'
.ds BP2      \h'-2p'
.ds BP2.25   \h'-2.25p'
.ds BP2.5    \h'-2.5p'
.ds BP2.75   \h'-2.75p'
.ds BP3      \h'-3p'
.ds BP3.25   \h'-3.25p'
.ds BP3.5    \h'-3.5p'
.ds BP3.75   \h'-3.75p'
.ds BP4      \h'-4p'
.ds BP4.25   \h'-4.25p'
.ds BP4.5    \h'-4.5p'
.ds BP4.75   \h'-4.75p'
.ds BP5      \h'-5p'
.ds BP5.25   \h'-5.25p'
.ds BP5.5    \h'-5.5p'
.ds BP5.75   \h'-5.75p'
.ds BP6      \h'-6p'
.ds BP6.25   \h'-6.25p'
.ds BP6.5    \h'-6.5p'
.ds BP6.75   \h'-6.75p'
.ds BP7      \h'-7p'
.ds BP7.25   \h'-7.25p'
.ds BP7.5    \h'-7.5p'
.ds BP7.75   \h'-7.75p'
.ds BP8      \h'-8p'
.ds BP8.25   \h'-8.25p'
.ds BP8.5    \h'-8.5p'
.ds BP8.75   \h'-8.75p'
.ds BP9      \h'-9p'
.ds BP9.25   \h'-9.25p'
.ds BP9.5    \h'-9.5p'
.ds BP9.75   \h'-9.75p'
.ds BP10     \h'-10p'
.ds BP10.25  \h'-10.25p'
.ds BP10.5   \h'-10.5p'
.ds BP10.75  \h'-10.75p'
.ds BP11     \h'-11p'
.ds BP11.25  \h'-11.25p'
.ds BP11.5   \h'-11.5p'
.ds BP11.75  \h'-11.75p'
.ds BP12     \h'-12p'
.ds BP12.25  \h'-12.25p'
.ds BP12.5   \h'-12.5p'
.ds BP12.75  \h'-12.75p'
\#
.ds FP.25    \h'.25'
.ds FP.5     \h'.5'
.ds FP.75    \h'.75'
.ds FP1      \h'1p'
.ds FP1.25   \h'1.25p'
.ds FP1.5    \h'1.5p'
.ds FP1.75   \h'1.75p'
.ds FP2      \h'2p'
.ds FP2.25   \h'2.25p'
.ds FP2.5    \h'2.5p'
.ds FP2.75   \h'2.75p'
.ds FP3      \h'3p'
.ds FP3.25   \h'3.25p'
.ds FP3.5    \h'3.5p'
.ds FP3.75   \h'3.75p'
.ds FP4      \h'4p'
.ds FP4.25   \h'4.25p'
.ds FP4.5    \h'4.5p'
.ds FP4.75   \h'4.75p'
.ds FP5      \h'5p'
.ds FP5.25   \h'5.25p'
.ds FP5.5    \h'5.5p'
.ds FP5.75   \h'5.75p'
.ds FP6      \h'6p'
.ds FP6.25   \h'6.25p'
.ds FP6.5    \h'6.5p'
.ds FP6.75   \h'6.75p'
.ds FP7      \h'7p'
.ds FP7.25   \h'7.25p'
.ds FP7.5    \h'7.5p'
.ds FP7.75   \h'7.75p'
.ds FP8      \h'8p'
.ds FP8.25   \h'8.25p'
.ds FP8.5    \h'8.5p'
.ds FP8.75   \h'8.75p'
.ds FP9      \h'9p'
.ds FP9.25   \h'9.25p'
.ds FP9.5    \h'9.5p'
.ds FP9.75   \h'9.75p'
.ds FP10     \h'10p'
.ds FP10.25  \h'10.25p'
.ds FP10.5   \h'10.5p'
.ds FP10.75  \h'10.75p'
.ds FP11     \h'11p'
.ds FP11.25  \h'11.25p'
.ds FP11.5   \h'11.5p'
.ds FP11.75  \h'11.75p'
.ds FP12     \h'12p'
.ds FP12.25  \h'12.25p'
.ds FP12.5   \h'12.5p'
.ds FP12.75  \h'12.75p'
\#
\#
\# WHOLE LINE KERNING (RW and EW)
\# -----------------------------
\# The line kerning macros are special instances of track kerning,
\# used where a complete line needs to be tightened (or relaxed) in
\# order to accomodate or remove one or two more characters
\# than the default justification permits.
\#
\# *Argument:
\#   <amount of overall "kerning" (letter spacing) to apply to the line>
\# *Function:
\#   Invokes .tkf (track kerning) for the current font with
\#   1 as both the upper and lower point size limits, so that
\#   the value entered by the user applies regardless of point
\#   size.  RW ("Reduce Whitespace") reduces the amount of space
\#   between all characters by an equal amount.  EW ("Extra
\#   Whitespace") increases the amount of space.
\# *Notes:
\#   Decimal values are acceptable.
\#
\#   The groff documentation is a tad confusing about what unit of
\#   measure is used in track kerning, only that the width of each
\#   character is increased or decreased by the amount(s) passed as
\#   arguments to .tkf, and something about linear function of point
\#   size.  In fact, with the way I've put this macro together, it
\#   doesn't matter.  All the user needs to know is that a value
\#   of one will produce an unacceptably tight or loose line at most
\#   text point sizes; therefore, effective use of RW and EW is in
\#   the fractional range below 1 (e.g. .25, .5).  Given that RW
\#   and EW are for massaging type, a certain amount of
\#   experimentation and previewing is expected and necessary.
\#
\#   \n(.f holds the current font number, which is acceptable to .tkf.
\#
\#   RW and EW must be reset to 0 to cancel their effect on
\#   subsequent output lines.
\#
.MAC RW END
.    if \\n[#BR_AT_LINE_KERN] \{ .br \}
.    tkf 1 1 -\\$1 1 -\\$1
.    tkf 2 1 -\\$1 1 -\\$1
.    tkf 3 1 -\\$1 1 -\\$1
.    tkf 4 1 -\\$1 1 -\\$1
.END
\#
\#
.MAC EW END
.    if \\n[#BR_AT_LINE_KERN] \{ .br \}
.    tkf 1 1 \\$1 1 \\$1
.    tkf 2 1 \\$1 1 \\$1
.    tkf 3 1 \\$1 1 \\$1
.    tkf 4 1 \\$1 1 \\$1
.END
\#
\#
\# BREAK AT LINE KERN
\# ------------------
\# *Arguments:
\#   toggle
\# *Function:
\#   Enables/disables .br's before .RW and .EW
\# *Notes:
\#   Mostly, users will want .br's before any kind of line kerning, but
\#   there may be cases where they don't.  BR_BEFORE_LINE_KERN is off by
\#   default and must be invoked explicitly.
\#
.MAC BR_AT_LINE_KERN END
.    ie '\\$1'' \{ .nr #BR_AT_LINE_KERN  1 \}
.    el         \{ .rr #BR_AT_LINE_KERN \}
.END
\#
\# =====================================================================
\#
\# +++HYPHENATION+++
\#
\# AUTO HYPHENATION
\# ----------------
\# *Arguments:
\#   <none> | <anything> | DEFAULT
\#                 or
\#   LINES <n> | MARGIN <n> | SPACE <n>
\# *Function:
\#   Turns auto hyphenation on or off, resets the hyphenation style
\#   to default, or permits the setting of various hyphenation
\#   parameters.
\# *Notes:
\#   HY ON defaults to .hy 14, i.e. no hyphens after the
\#   first two or before the last two characters of a word, and
\#   no hyphenation of the last line prior to a trap (e.g.,
\#   at the bottom of a page).
\#
\#   HY DEFAULT resets the hyphenation style to .hy 14 (see
\#   above) if that behaviour is desired after changes have been
\#   made to LINES, MARGIN, or SPACE.
\#
\#   HY LINES <n> sets the number of allowable consecutive hyphenated lines.
\#
\#   HY MARGIN <n> sets the amount of space (ipPcm) allowed at the end
\#   of a line in QUAD mode before hyphenation is tripped (e.g. if there's
\#   only 6 points left, groff won't try to hyphenate the next word).
\#
\#   HY SPACE sets the amount of extra interword space (ipPcm) that can
\#   be added in JUSTIFY mode to prevent a line from being hyphenated.
\#
.MAC HY END
.    ie '\\$1'' \{\
.       hy 14
.       nr #HYPHENATE 1
.    \}
.    el \{\
.       if !'\\$1'LINES'  \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if !'\\$1'MARGIN' \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if !'\\$1'SPACE'  \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if !'\\$1'DEFAULT'  \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if '\\$1'LINES'   \{ .hlm \\$2 \}
.       if '\\$1'MARGIN'  \{ .hym \\$2 \}
.       if '\\$1'SPACE'   \{ .hys \\$2 \}
.       if '\\$1'DEFAULT' \{\
.          hlm -1
.          hym 0
.          hys 0
.       \}
.    \}
.END
\#
\#
\# HYPHENATION PARAMETERS
\# ----------------------
\# *Arguments:
\#   <# of lines> | <size of margin> | <amount of interword space>
\# *Function:
\#   Allows user to specify .HY LINES, MARGIN, and SPACE with a single command.
\#
.MAC HY_SET END
.    nr #HY_SET 1
.    hlm \\$1
.    hym \\$2
.    hys \\$3
.END
\#
\# =====================================================================
\#
\# +++VERTICAL SPACING+++
\#
\# ADVANCE LEAD
\# ------------
\# *Argument:
\#   <user supplied lead to advance below current baseline>
\# *Function:
\#   Creates or modifies register #ALD.  Adds user supplied lead
\#   below current baseline.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC ALD END
.    nr #ALD (\\$1)
.    sp \\n[#ALD]u
.END
\#
\#
\# REVERSE LEAD
\# ------------
\# *Argument:
\#   <user supplied lead to reverse above current baseline>
\# *Function:
\#   Creates or modifies register #RLD.  Reverses user supplied
\#   lead above current baseline.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC RLD END
.    nr #RLD (\\$1)
.    sp -\\n[#RLD]u
.END
\#
\# ALD/RLD STRINGS
\# ---------------
\# The strings \*[ALD.25]...\*[ALD12.75] and their corresponding
\# \*[RLD] forms have been left in for backward compatibility with
\# documents created using mom-1.1.3c or earlier.  The prefered
\# methods of advancing and reversing on the page inline are \*[UP <n><unit>]
\# and \*[DOWN <n><unit>].
\#
.ds DOWN      \v'\\$1\\$2'
.ds UP        \v'-\\$1\\$2'
\#
.ds ALD.25    \v'.25p'
.ds ALD.5     \v'.5p'
.ds ALD.75    \v'.75p'
.ds ALD1      \v'1p'
.ds ALD1.25   \v'1.25p'
.ds ALD1.5    \v'1.5p'
.ds ALD1.75   \v'1.75p'
.ds ALD2      \v'2p'
.ds ALD2.25   \v'2.25p'
.ds ALD2.5    \v'2.5p'
.ds ALD2.75   \v'2.75p'
.ds ALD3      \v'3p'
.ds ALD3.25   \v'3.25p'
.ds ALD3.5    \v'3.5p'
.ds ALD3.75   \v'3.75p'
.ds ALD4      \v'4p'
.ds ALD4.25   \v'4.25p'
.ds ALD4.5    \v'4.5p'
.ds ALD4.75   \v'4.75p'
.ds ALD5      \v'5p'
.ds ALD5.25   \v'5.25p'
.ds ALD5.5    \v'5.5p'
.ds ALD5.75   \v'5.75p'
.ds ALD6      \v'6p'
.ds ALD6.25   \v'6.25p'
.ds ALD6.5    \v'6.5p'
.ds ALD6.75   \v'6.75p'
.ds ALD7      \v'7p'
.ds ALD7.25   \v'7.25p'
.ds ALD7.5    \v'7.5p'
.ds ALD7.75   \v'7.75p'
.ds ALD8      \v'8p'
.ds ALD8.25   \v'8.25p'
.ds ALD8.5    \v'8.5p'
.ds ALD8.75   \v'8.75p'
.ds ALD9      \v'9p'
.ds ALD9.25   \v'9.25p'
.ds ALD9.5    \v'9.5p'
.ds ALD9.75   \v'9.75p'
.ds ALD10     \v'10p'
.ds ALD10.25  \v'10.25p'
.ds ALD10.5   \v'10.5p'
.ds ALD10.75  \v'10.75p'
.ds ALD11     \v'11p'
.ds ALD11.25  \v'11.25p'
.ds ALD11.5   \v'11.5p'
.ds ALD11.75  \v'11.75p'
.ds ALD12     \v'12p'
.ds ALD12.25  \v'12.5p'
.ds ALD12.5   \v'12.5p'
.ds ALD12.75  \v'12.75p'
\#
.ds RLD.25    \v'-.25p'
.ds RLD.5     \v'-.5p'
.ds RLD.75    \v'-.75p'
.ds RLD1      \v'-1p'
.ds RLD1.25   \v'-1.25p'
.ds RLD1.5    \v'-1.5p'
.ds RLD1.75   \v'-1.75p'
.ds RLD2      \v'-2p'
.ds RLD2.25   \v'-2.25p'
.ds RLD2.5    \v'-2.5p'
.ds RLD2.75   \v'-2.75p'
.ds RLD3      \v'-3p'
.ds RLD3.25   \v'-3.25p'
.ds RLD3.5    \v'-3.5p'
.ds RLD3.75   \v'-3.75p'
.ds RLD4      \v'-4p'
.ds RLD4.25   \v'-4.25p'
.ds RLD4.5    \v'-4.5p'
.ds RLD4.75   \v'-4.75p'
.ds RLD5      \v'-5p'
.ds RLD5.25   \v'-5.25p'
.ds RLD5.5    \v'-5.5p'
.ds RLD5.75   \v'-5.75p'
.ds RLD6      \v'-6p'
.ds RLD6.25   \v'-6.25p'
.ds RLD6.5    \v'-6.5p'
.ds RLD6.75   \v'-6.75p'
.ds RLD7      \v'-7p'
.ds RLD7.25   \v'-7.25p'
.ds RLD7.5    \v'-7.5p'
.ds RLD7.75   \v'-7.75p'
.ds RLD8      \v'-8p'
.ds RLD8.25   \v'-8.25p'
.ds RLD8.5    \v'-8.5p'
.ds RLD8.75   \v'-8.75p'
.ds RLD9      \v'-9p'
.ds RLD9.25   \v'-9.25p'
.ds RLD9.5    \v'-9.5p'
.ds RLD9.75   \v'-9.75p'
.ds RLD10     \v'-10p'
.ds RLD10.25  \v'-10.25p'
.ds RLD10.5   \v'-10.5p'
.ds RLD10.75  \v'-10.75p'
.ds RLD11     \v'-11p'
.ds RLD11.25  \v'-11.25p'
.ds RLD11.5   \v'-11.5p'
.ds RLD11.75  \v'-11.75p'
.ds RLD12     \v'-12p'
.ds RLD12.25  \v'-12.5p'
.ds RLD12.5   \v'-12.5p'
.ds RLD12.75  \v'-12.75p'
\#
\# =====================================================================
\#
\# +++REFINEMENTS+++
\#
\# AUTOMATIC LIGATURES
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns automatic ligature generation on or off.
\# *Notes:
\#   Ligatures may be supplied manually with \(fi, \(fl, etc.
\#
.MAC LIGATURES END
.    ie '\\$1'' \{\
.       lg
.       nr #LIGATURES 1
.    \}
.    el \{\
.       lg 0
.       nr #LIGATURES 0
.    \}
.END
\#
\#
\# SMARTQUOTES
\# -----------
\# *Arguments:
\#   [ ,, ] | [ << ] | [ >> ] | <anything>
\#   or
\#   [ DA | DE | ES | FR | IT | NL | NO | PT | SV ] | <anything>
\# *Function:
\#   Turns smartquotes on (optionally with a quoting style from the
\#   argument list, or off).
\# *Notes:
\#   The " character is read outside the macro when mom is
\#   processed.  The strings for open/close ($QUOTE<n>) are then
\#   defined in the macro.
\#
\#   (Note to myself: ascii code for " is \N'34'.)
\#
.char " \\*[$QUOTE\\n[#OPEN_CLOSE]]\R'#OPEN_CLOSE (1-\\n[#OPEN_CLOSE])'
\#
.MAC SMARTQUOTES END
.    rr #ARGS_TO_SQ
.    ie '\\$1'' \{\
.       nr #OPEN_CLOSE 0
.       ds $QUOTE0 \\[lq]
.       ds $QUOTE1 \\[rq]
.    \}
.    el \{\
.       if '\\$1',,' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Bq]
.          ds $QUOTE1 \\[lq]
.       \}
.       if '\\$1'<<' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fo]
.          ds $QUOTE1 \\[Fc]
.       \}
.       if '\\$1'>>' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fc]
.          ds $QUOTE1 \\[Fo]
.       \}
.       if '\\$1'DA' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fc]
.          ds $QUOTE1 \\[Fo]
.       \}
.       if '\\$1'DE' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Bq]
.          ds $QUOTE1 \\[lq]
.       \}
.       if '\\$1'ES' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[lq]
.          ds $QUOTE1 \\[rq]
.       \}
.       if '\\$1'FR' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fo]\\|
.          ds $QUOTE1 \\|\\[Fc]
.       \}
.       if '\\$1'IT' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fo]\\|
.          ds $QUOTE1 \\|\\[Fc]
.       \}
.       if '\\$1'NL' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[rq]
.          ds $QUOTE1 \\[rq]
.       \}
.       if '\\$1'NO' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fo]
.          ds $QUOTE1 \\[Fc]
.       \}
.       if '\\$1'PT' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fo]
.          ds $QUOTE1 \\[Fc]
.       \}
.       if '\\$1'SV' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fc]
.          ds $QUOTE1 \\[Fc]
.       \}
.       if !r#ARGS_TO_SQ \{\
.          ds $QUOTE0 \\[dq]
.          ds $QUOTE1 \\[dq]
.       \}
.    \}
.END
\#
.ds $QUOTE0 \[dq]
.ds $QUOTE1 \[dq]
\#
\# Strings for foot and inch marks
\#
.ds FOOT \(fm
.ds INCH \(fm\(fm
\#
\# =====================================================================
\#
\# +++LINE BREAKS+++
\#
\# NO-SPACE BREAK
\# --------------
\# *Argument:
\#   <none>
\# *Function:
\#   Breaks a line without advancing.
\# *Notes:
\#   EL is the mnemonic used on older, dedicated typesetting machines
\#   to indicate "process the line, then return to the left margin
\#   without advancing the galley medium."  It stands for End Line.
\#
\#   Sadly, EL is only a fake.  It will work in all instances EXCEPT
\#   when the line to be EL'd is the last line before a footer trap.
\#   Use TRAP OFF/TRAP to circumvent this.
\#
.MAC EL END
.    br
.    sp -1v
.END
\#
\# =====================================================================
\#
\# +++FILLING/QUADDING/JUSTIFYING+++
\#
\# JUSTIFY
\# -------
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill on and sets .ad to b.
\# *Notes:
\#   Justifies text left and right.
\#
.MAC JUSTIFY END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       nr #QUAD 1
.       ds $RESTORE_QUAD_VALUE \\*[$QUAD_VALUE]
.    \}
'    ce 0
.    QUAD J
.    if \\n[#PRINT_STYLE]=1 \{ .QUAD L \}
.    nr #FILL 0
.END
\#
\#
\# QUAD
\# ----
\# *Arguments:
\#   L | LEFT | R | RIGHT | C | CENTER/CENTRE
\# *Function:
\#   Turns fill on and sets .ad to l, r, or c.
\# *Notes:
\#   Terminology is a problem here.  Some people call quad left
\#   left justified, flush left, or flush left/rag right (and the
\#   reverse for quad right).  Quad center is sometimes called rag
\#   both.  For our purposes, all "quad" modes mean that groff fill
\#   mode is enabled.
\#
.MAC QUAD END
.    ds $QUAD_VALUE \\$1
.    if \\n[#TAB_ACTIVE]=0 \{\
.       nr #QUAD 1
.       ds $RESTORE_QUAD_VALUE \\*[$QUAD_VALUE]
.    \}
'    ce 0
'    fi
.    if '\\*[$QUAD_VALUE]'L'       \{ .ad l \}
.    if '\\*[$QUAD_VALUE]'LEFT'    \{ .ad l \}
.    if '\\*[$QUAD_VALUE]'R'       \{ .ad r \}
.    if '\\*[$QUAD_VALUE]'RIGHT'   \{ .ad r \}
.    if '\\*[$QUAD_VALUE]'C'       \{ .ad c \}
.    if '\\*[$QUAD_VALUE]'CENTER'  \{ .ad c \}
.    if '\\*[$QUAD_VALUE]'CENTRE'  \{ .ad c \}
.    if '\\*[$QUAD_VALUE]'J'       \{ .ad b \}
.    if '\\*[$QUAD_VALUE]'JUSTIFY' \{ .ad b \}
.    nr #FILL 0
.END
\#
\#
\# LEFT, RIGHT, AND CENTER
\# -----------------------
\# The purpose of these macros is to allow the user to enter lines
\# of text that will be quadded LRC *without* the user having to
\# enter .BR or .br between lines.  For the sake of consistency,
\# all three appear to behave similarly (from the point of view of the user),
\# although the underlying primitives don't.  For this reason, LEFT,
\# RIGHT, and CENTER must be followed by .QUAD [L R C J] or .JUSTIFY
\# to restore text to groff fill mode.
\#
\# LEFT
\# ----
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill mode off.  Allows user to quad lines left without
\#   requiring the .BR or .br macro.
\# *Notes:
\#   LEFT simply turns fill off.  Lines that exceed the current LL will
\#   not be broken, simply continued (indefinitely) until a return is
\#   encountered.  Note that this behaviour differs from the RIGHT and
\#   CENTER macros.
\#
.MAC LEFT END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       rr #QUAD
.       ds $RESTORE_QUAD_VALUE LEFT
.    \}
.    ce 0
.    nf
.    nr #FILL 1
.    if '\\n(.z'LETTERHEAD1' \{ .rr #DATE_FIRST \}
.END
\#
\#
\# RIGHT
\# -----
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill on.  Allows user to quad lines right without
\#   requiring the .BR or .br macro.
\# *Notes:
\#   Lines that exceed the current LL will be broken, with the excess
\#   text quadded right.
\#
.MAC RIGHT END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       rr #QUAD
.       ds $RESTORE_QUAD_VALUE RIGHT
.    \}
.    fi
.    rj 100000
.    nr #FILL 1
.END
\#
\#
\# CENTER
\# ------
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill on.  Allows user to center lines without
\#   requiring the .BR or .br macro.
\# *Notes:
\#   Lines that exceed the current LL will be broken, with the excess
\#   text centered.
\#
.MAC CENTER END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       ds $RESTORE_QUAD_VALUE CENTER
.    \}
.    fi
.    ce 100000
.    nr #FILL 1
.END
\#
\# =====================================================================
\#
\# +++TABS+++
\#
\#   There are two different kinds of tabs available: typesetting tabs
\#   and string tabs.
\#
\#   Typesetting tabs are set with TAB_SET, which requires a tab number,
\#   an indent (offset) from the left margin and a length (optionally
\#   with a quad direction and an instruction to fill lines).  After tabs
\#   are set with TS, they are called with .TAB n, where "n"
\#   corresponds to the number passed to TAB_SET as a valid tab number.
\#
\#   String tabs allow the user to mark off tab positions inline.  Tab
\#   indents and lengths are calculated from the beginning and end
\#   positions of the marks.  Up to 19 string tabs may be created,
\#   numbered 1-19.  Once created, they are called with .TAB n,
\#   just like typesetting tabs.
\#
\#   Setting up string tabs is a two-step procedure.  First, the user
\#   enters an input line in which s/he wants to mark off string tabs.
\#   The beginning of a tab is marked with \*[STn], where "n" is
\#   the desired number of the tab.  The end of the the tab is marked
\#   with \*[STnX].  All ST's must have a matching STX.  String tabs
\#   may be nested.
\#
\#   Next, the user invokes .ST n for every string tab defined, and
\#   optionally passes quad information to it.  That done, string tabs
\#   can be called just like typesetting tabs.
\#
\#   String tabs don't preview properly with gxditview.  Use gv instead.
\#
\# Strings for string tab inlines
\# ------------------------------
\#
\# Initialize string tab markers numbered 1 to 19.
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<20 \{\
.   ds ST\n[#LOOP] \Ek[#ST\n[#LOOP]_OFFSET]
.\}
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<20 \{\
.   ds ST\n[#LOOP]X \Ek[#ST\n[#LOOP]_MARK]
.\}
.rr #LOOP
\#
\#
\# These are reserved ST numbers for internal use
.ds ST100  \Ek[#ST100_OFFSET]
.ds ST100X \Ek[#ST100_MARK]
.ds ST101  \Ek[#ST101_OFFSET]
.ds ST101X \Ek[#ST101_MARK]
\#
\#
\# QUAD AND SET STRING TABS
\# ------------------------
\# *Arguments:
\#   <stringtab number>  L | R | C | J  [QUAD]
\# *Function:
\#   Creates strings $ST<#>_QUAD_DIR and $ST<#>_FILL, then sets up a
\#   tab based on the collected information.
\# *Notes:
\#   Like TS, ST invoked without a quad direction will default to LEFT.
\#   If lines should be filled and quadded, use the optional argument QUAD.
\#   N.B. -- indents *must* be turned off before setting string tabs
\#   inside .PAD
\#
.MAC ST END
.    ds $ST\\$1_QUAD_DIR \\$2
.    if \\n[#NUM_ARGS]=3 \{\
.       ds $ST\\$1_FILL QUAD
.    \}
.    nr #ST\\$1_LENGTH \\n[#ST\\$1_MARK]-\\n[#ST\\$1_OFFSET]
.    ie \\n[#IN_TAB] \{\
.       TAB_SET \\$1 \\n[#ST\\$1_OFFSET]u+\\n[#ST_OFFSET]u \\n[#ST\\$1_LENGTH]u \\*[$ST\\$1_QUAD_DIR] \\*[$ST\\$1_FILL]
.    \}
.    el \{\
.       TAB_SET \\$1 \\n[#ST\\$1_OFFSET]u \\n[#ST\\$1_LENGTH]u \\*[$ST\\$1_QUAD_DIR] \\*[$ST\\$1_FILL]
.    \}
.END
\#
\#
\# TAB SET
\# -------
\# *Arguments:
\#   <n>  ident(ipPcm)  length(ipPcm)  [L | R | C | J [QUAD]]
\# *Function:
\#   Creates macros TABn and TAB n, where "n" is any arbitrary number.
\#   TABn is a typesetting tab (i.e. a tab defined as an indent
\#   from the page left offset plus a line length.)
\# *Notes:
\#   n      = arbitrary digit to identify the tab
\#   indent = indent from left margin; unit of measure required
\#   length = length of tab (unit of measure required; can be
\#            \w'<string>'u--if more than one word in string, surround
\#            with double quotes "\w'<three word string>'"
\#   LRCJ   = quad for tab (left, right, center, justified)
\#            If option QUAD afterwards is not given, quad is line for line
\#            (no fill mode), meaning that there's no need for .BR or .br
\#            between lines.
\#   QUAD   = fill tab (so it behaves as if .QUAD LRC or .JUSTIFY
\#            had been given).
\#
\#   N.B. -- indents *must* be turned off before setting tabs
\#
\#   Examples:
\#
\#     .TAB_SET 1 2P+6p 12P C
\#
\#   means "create a tab numbered 1 that starts 2 picas and 6 points from
\#   the left margin, is 12 picas long, and centre each input line."
\#
\#     .TAB_SET 1 2P+6P 12P C QUAD
\#
\#   means exactly the same thing, except that input lines are joined and
\#   the area delimted by the tab filled with centered text.
\#
\#   TAB n can be called at any time after being set.
\#
\#   Tabs are NOT columnar in behaviour.  If the text inside a
\#   tab runs to several lines, when you call the next tab a break
\#   occurs, meaning that the new tab starts one line below the last
\#   line in the previous tab.  For columnar behaviour, you must
\#   use the multi-column macros in addition to tabs.
\#
\#   If you want tabs to line up bottom-line to bottom-line (most likely
\#   single line tabs), use .TN (provided the tabs are numbered sequentially).
\#   Otherwise, you must use .EL then .TAB <n> if you want them to align.
\#
\#   If you want to reset tabs, you must use .TQ before .TAB_SET.
\#
\#   Note that indents are turned off automatically whenever a new
\#   tab is called with TAB <n>.
\#
\#   Tabs themselves are user-invoked using the TAB macro with a numeric
\#   argument, e.g. TAB 1.
\#
\#   Generally, in order not to get confused, it's a good idea
\#   to make sure all indents are off before setting tabs.
\#
.MAC TAB_SET END
.    br
.    nr #TAB_NUMBER \\$1
.    ds $CURRENT_TAB \\n[#TAB_NUMBER]
.    nr #TAB_OFFSET (\\$2)
.    nr #TAB_LENGTH (\\$3)
.    MAC TAB\\n[#TAB_NUMBER] DONE \"Define TAB macro
.        br
.        in 0
.        nr #TAB_ACTIVE 1
.        nr #CURRENT_TAB \\n[#TAB_NUMBER]
.        ds $CURRENT_TAB \\*[$CURRENT_TAB]
.        nr #TAB_OFFSET\\*[$CURRENT_TAB] \\n[#TAB_OFFSET]
.        nr #ST_OFFSET \\n[#TAB_OFFSET]
.        po \\\\n[#L_MARGIN]u+\\\\n[#TAB_OFFSET\\\\*[$CURRENT_TAB]]u
.        ll \\n[#TAB_LENGTH]u
.        ta \En(.lu
.        ie '\\$5'QUAD' \{\
.           if '\\$4'L' \{ .QUAD L  \}
.           if '\\$4'R' \{ .QUAD R  \}
.           if '\\$4'C' \{ .QUAD C  \}
.           if '\\$4'J' \{ .JUSTIFY \}
.        \}
.        el \{\
.           if '\\$4''  \{ .LEFT    \}
.           if '\\$4'L' \{ .LEFT    \}
.           if '\\$4'R' \{ .RIGHT   \}
.           if '\\$4'C' \{ .CENTER  \}
.           if '\\$4'J' \{ .JUSTIFY \}
.        \}
.DONE
.    rr #TAB_ACTIVE
.END
\#
\#
\# TAB
\# ---
\# *Arguments:
\#   <tab number to tab into>
\# *Function:
\#   Moves to tab number passed as an argument.
\#
.MAC TAB END
.    ds $TAB_NUMBER \\$1
.    TAB\\*[$TAB_NUMBER]
.    nr #IN_TAB 1
.END
\#
\#
\# TAB NEXT
\# --------
\# *Argument:
\#   <none>
\# *Function:
\#   Automagically moves to TAB<n+1> on the same line as the last
\#   line of the previous tab.
\# *Notes:
\#   If the tabs being aligned fall too close to the footer
\#   trap, the line entered after .TN will appear on the next page,
\#   unless TRAP...TRAP OFF is used.
\#
.MAC TN END
.    EL
.    nr #NEXT_TAB \\n[#CURRENT_TAB]+1
.    TAB\\n[#NEXT_TAB]
.END
\#
\#
\# TAB QUIT
\# --------
\# *Argument:
\#   <none>
\# *Function:
\#   Sets #TAB_ACTIVE to "0" (off).
\#   Resets left margin to value in effect prior to tabs.
\#   Resets line length to value in effect prior to tabs.
\#   Checks #QUAD to see if we were in flush or quad mode
\#   prior to tabs (0=off, 1=on).
\#   Resets QUAD [ L|R|C ], LEFT, RIGHT, CENTER, or JUSTIFY
\#   in effect prior to tabs.
\# *Notes:
\#   TQ *must* come before setting any new tabs if you want the
\#   tabs' indents measured from page left.  Otherwise, the tabs'
\#   indents are measured from the left margin of the tab you're
\#   currently in.
\#
.MAC TQ END
.    br
.    rr #TAB_ACTIVE
.    rr #IN_TAB
.    po \\n[#L_MARGIN]u
.    ll \\n[#L_LENGTH]u
.    ta \\n(.lu
.    ie \\n[#QUAD] \{\
.       ie '\\*[$RESTORE_QUAD_VALUE]'J' \{ .JUSTIFY \}
.       el                              \{ .QUAD \\*[$RESTORE_QUAD_VALUE] \}
.    \}
.    el \{\
.       if '\\*[$RESTORE_QUAD_VALUE]'LEFT'   \{ .LEFT \}
.       if '\\*[$RESTORE_QUAD_VALUE]'RIGHT'  \{ .RIGHT \}
.       if '\\*[$RESTORE_QUAD_VALUE]'CENTER' \{ .CENTER \}
.    \}
.END
\#
\# ====================================================================
\#
\# COLOR HANDLING
\# ==============
\#
\# COLOR
\# -----
\# *Arguments:
\#   <pre-defined NEWCOLOR or XCOLOR>
\# *Function:
\#   Allows the inline escape for setting color to be called
\#   as a macro.
\#
.MAC COLOR END
.ie \\n(.u=1 \{\
\c
\\*[\\$1]\c
.   \}
.el \{ \\*[\\$1] \}
.END
\#
\#
\# NEWCOLOR
\# --------
\# *Arguments:
\#   <color name> [<color scheme>] <color definition>
\# *Function:
\#   Based on .defcolor, allows users to name and define colors using
\#   one of the four color schemes rgb, cmy, cmyk and grey.  The new
\#   color is then defined as a string so that it can be called inline
\#   with \*[COLORNAME] or with .COLOR.
\# *Notes:
\#   With only two args, the default color scheme is rgb.
\#
\#   It is highly recommended that users define new colors as
\#   all-cap strings, to differentiate them from x colors, which must
\#   be in lower case.
\#
.MAC NEWCOLOR END
.    if \\n[#NUM_ARGS]=2 \{\
.       defcolor \\$1 rgb \\$2
.    \}
.    if \\n[#NUM_ARGS]=3 \{\
.       if '\\$2'RGB'  .ds $COLOR_SCHEME rgb
.       if '\\$2'CYM'  .ds $COLOR_SCHEME cym
.       if '\\$2'CMYK' .ds $COLOR_SCHEME cmyk
.       if '\\$2'GRAY' .ds $COLOR_SCHEME gray
.       if '\\$2'GREY' .ds $COLOR_SCHEME gray
.       defcolor \\$1  \\*[$COLOR_SCHEME] \\$3
.    \}
.    ds \\$1 \\m[\\$1]
.END
\#
\#
\# XCOLOR
\# ------
\# *Arguments:
\#   <x color name> [<alias>]
\# *Function:
\#   Defines a string of x color name (i.e. a predefined x
\#   color).  If <alias> is given, creates a string of <alias name>
\#   that references the x color name of the first argument.
\# *Notes:
\#   The color name must be a legal color name from rgb.txt, and
\#   must be given entirely in lower case, all one word.
\#
.MAC XCOLOR END
.    ds \\$1 \m[\\$1]
.    if \\n[#NUM_ARGS]=2 .ds \\$2 \m[\\$1]
.END
\#
\#
\# Pre-define xcolors black and white
\#
.ds black \m[black]
.ds BLACK \m[black]
.ds white \m[white]
.ds WHITE \m[WHITE]
\#
\# =====================================================================
\#
\# +++MISCELLANEOUS USEFUL MACROS AND STRINGS+++
\#
\# UNDERLINE
\# ---------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   When on, underlines all letters, words, and digits in a passage,
\#   ignoring punctuation and spaces.
\# *Notes:
\#   Only for use when the font family is COURIER, to simulate
\#   typewriter-style underlining of italic  passages.
\#
.MAC UNDERLINE END
.    ie '\\$1'' \{\
.       nr #UNDERLINE_ON 1
.       char A _A
.       char B _B
.       char C _C
.       char D _D
.       char E _E
.       char F _F
.       char G _G
.       char H _H
.       char I _I
.       char J _J
.       char K _K
.       char L _L
.       char M _M
.       char N _N
.       char O _O
.       char P _P
.       char Q _Q
.       char R _R
.       char S _S
.       char T _T
.       char U _U
.       char V _V
.       char W _W
.       char X _X
.       char Y _Y
.       char Z _Z
.       char \[`A] _\[`A]
.       char \[^A] _\[^A]
.       char \['A] _\['A]
.       char \[:A] _\[:A]
.       char \[oA] _\[oA]
.       char \[~A] _\[~A]
.       char \[AE] _\[AE]
.       char \[`E] _\[`E]
.       char \[^E] _\[^E]
.       char \['E] _\['E]
.       char \[:E] _\[:E]
.       char \[`I] _\[`I]
.       char \[^I] _\[^I]
.       char \['I] _\['I]
.       char \[:I] _\[:I]
.       char \[`O] _\[`O]
.       char \[^O] _\[^O]
.       char \['O] _\['O]
.       char \[:O] _\[:O]
.       char \[~O] _\[~O]
.       char \[/O] _\[/O]
.       char \[`U] _\[`U]
.       char \[^U] _\[^U]
.       char \['U] _\['U]
.       char \[:U] _\[:U]
.       char \[,C] _\[,C]
.       char \[-D] _\[-D]
.       char \[~N] _\[~N]
.       char \[TP] _\[TP]
.       char \['Y] _\['Y]
.       char \[:Y] _\[:Y]
.       char a _a
.       char b _b
.       char c _c
.       char d _d
.       char e _e
.       char f _f
.       char g _g
.       char h _h
.       char i _i
.       char j _j
.       char k _k
.       char l _l
.       char m _m
.       char n _n
.       char o _o
.       char p _p
.       char q _q
.       char r _r
.       char s _s
.       char t _t
.       char u _u
.       char v _v
.       char w _w
.       char x _x
.       char y _y
.       char z _z
.       char \[`a] _\[`a]
.       char \[^a] _\[^a]
.       char \['a] _\['a]
.       char \[:a] _\[:a]
.       char \[oa] _\[oa]
.       char \[~a] _\[~a]
.       char \[ae] _\[ae]
.       char \[`e] _\[`e]
.       char \[^e] _\[^e]
.       char \['e] _\['e]
.       char \[:e] _\[:e]
.       char \[`i] _\[`i]
.       char \[^i] _\[^i]
.       char \['i] _\['i]
.       char \[:i] _\[:i]
.       char \[`o] _\[`o]
.       char \[^o] _\[^o]
.       char \['o] _\['o]
.       char \[:o] _\[:o]
.       char \[~o] _\[~o]
.       char \[/o] _\[/o]
.       char \[`u] _\[`u]
.       char \[^u] _\[^u]
.       char \['u] _\['u]
.       char \[:u] _\[:u]
.       char \[,c] _\[,c]
.       char \[Sd] _\[Sd]
.       char \[~n] _\[~n]
.       char \[Tp] _\[Tp]
.       char \['y] _\['y]
.       char \[:y] _\[:y]
.       char \[ss] _\[ss]
.       char ' _'
.       char 1 _1
.       char 2 _2
.       char 3 _3
.       char 4 _4
.       char 5 _5
.       char 6 _6
.       char 7 _7
.       char 8 _8
.       char 9 _9
.       char 0 _0
.    \}
.    el \{\
.       nr #UNDERLINE_ON 0
.       rchar A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
        a b c d e f g h i j k l m n o p q r s t u v w x y z \
        \[`A] \[^A] \['A] \[:A] \[oA] \[~A] \[AE] \[`E] \[^E] \['E] \[:E] \
        \[`I] \[^I] \['I] \[:I] \[`O] \[^O] \['O] \[:O] \[~O] \[/O] \[`U] \
        \[^U] \['U] \[:U] \[,C] \[-D] \[~N] \[TP] \['Y] \[:Y] \
        \[`a] \[^a] \['a] \[:a] \[oa] \[~a] \[ae] \[`e] \[^e] \['e] \[:e] \[`i] \
        \[^i] \['i] \[:i] \[`o] \[^o] \['o] \[:o] \[~o] \[/o] \[`u] \[^u] \['u] \
        \[:u] \[,c] \[Sd] \[~n] \[Tp] \['y] \[:y] \[ss] \
        ' 1 2 3 4 5 6 7 8 9 0
.    \}
.END
\#
\#
\# UL/ULX
\# ------
\# *Arguments:
\#   <none>
\# *Function:
\#   Underscores all letters, words, and digits in a passage,
\#   ignoring punctuation and spaces.
\# *Notes:
\#   Intended to be called with inline escapes \*[UL] (underline
\#   on) and \*[ULX] (underline off).  Only works when the font family
\#   is COURIER, to simulate typewriter-style underlining of italic
\#   passages.
\#
.MAC UL END
\c\R'#UNDERLINE_ON 1'
.       char A _A
.       char B _B
.       char C _C
.       char D _D
.       char E _E
.       char F _F
.       char G _G
.       char H _H
.       char I _I
.       char J _J
.       char K _K
.       char L _L
.       char M _M
.       char N _N
.       char O _O
.       char P _P
.       char Q _Q
.       char R _R
.       char S _S
.       char T _T
.       char U _U
.       char V _V
.       char W _W
.       char X _X
.       char Y _Y
.       char Z _Z
.       char \[`A] _\[`A]
.       char \[^A] _\[^A]
.       char \['A] _\['A]
.       char \[:A] _\[:A]
.       char \[oA] _\[oA]
.       char \[~A] _\[~A]
.       char \[AE] _\[AE]
.       char \[`E] _\[`E]
.       char \[^E] _\[^E]
.       char \['E] _\['E]
.       char \[:E] _\[:E]
.       char \[`I] _\[`I]
.       char \[^I] _\[^I]
.       char \['I] _\['I]
.       char \[:I] _\[:I]
.       char \[`O] _\[`O]
.       char \[^O] _\[^O]
.       char \['O] _\['O]
.       char \[:O] _\[:O]
.       char \[~O] _\[~O]
.       char \[/O] _\[/O]
.       char \[`U] _\[`U]
.       char \[^U] _\[^U]
.       char \['U] _\['U]
.       char \[:U] _\[:U]
.       char \[,C] _\[,C]
.       char \[-D] _\[-D]
.       char \[~N] _\[~N]
.       char \[TP] _\[TP]
.       char \['Y] _\['Y]
.       char \[:Y] _\[:Y]
.       char a _a
.       char b _b
.       char c _c
.       char d _d
.       char e _e
.       char f _f
.       char g _g
.       char h _h
.       char i _i
.       char j _j
.       char k _k
.       char l _l
.       char m _m
.       char n _n
.       char o _o
.       char p _p
.       char q _q
.       char r _r
.       char s _s
.       char t _t
.       char u _u
.       char v _v
.       char w _w
.       char x _x
.       char y _y
.       char z _z
.       char \[`a] _\[`a]
.       char \[^a] _\[^a]
.       char \['a] _\['a]
.       char \[:a] _\[:a]
.       char \[oa] _\[oa]
.       char \[~a] _\[~a]
.       char \[ae] _\[ae]
.       char \[`e] _\[`e]
.       char \[^e] _\[^e]
.       char \['e] _\['e]
.       char \[:e] _\[:e]
.       char \[`i] _\[`i]
.       char \[^i] _\[^i]
.       char \['i] _\['i]
.       char \[:i] _\[:i]
.       char \[`o] _\[`o]
.       char \[^o] _\[^o]
.       char \['o] _\['o]
.       char \[:o] _\[:o]
.       char \[~o] _\[~o]
.       char \[/o] _\[/o]
.       char \[`u] _\[`u]
.       char \[^u] _\[^u]
.       char \['u] _\['u]
.       char \[:u] _\[:u]
.       char \[,c] _\[,c]
.       char \[Sd] _\[Sd]
.       char \[~n] _\[~n]
.       char \[Tp] _\[Tp]
.       char \['y] _\['y]
.       char \[:y] _\[:y]
.       char \[ss] _\[ss]
.       char ' _'
.       char 1 _1
.       char 2 _2
.       char 3 _3
.       char 4 _4
.       char 5 _5
.       char 6 _6
.       char 7 _7
.       char 8 _8
.       char 9 _9
.       char 0 _0
.END
\#
\#
.MAC ULX END
\c\R'#UNDERLINE_ON 0'
.    rchar A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
     a b c d e f g h i j k l m n o p q r s t u v w x y z \
     \[`A] \[^A] \['A] \[:A] \[oA] \[~A] \[AE] \[`E] \[^E] \['E] \[:E] \
     \[`I] \[^I] \['I] \[:I] \[`O] \[^O] \['O] \[:O] \[~O] \[/O] \[`U] \
     \[^U] \['U] \[:U] \[,C] \[-D] \[~N] \[TP] \['Y] \[:Y] \
     \[`a] \[^a] \['a] \[:a] \[oa] \[~a] \[ae] \[`e] \[^e] \['e] \[:e] \[`i] \
     \[^i] \['i] \[:i] \[`o] \[^o] \['o] \[:o] \[~o] \[/o] \[`u] \[^u] \['u] \
     \[:u] \[,c] \[Sd] \[~n] \[Tp] \['y] \[:y] \[ss] \
     ' 1 2 3 4 5 6 7 8 9 0
.END
\#
\#
\# UNDERSCORE
\# ----------
\# *Arguments:
\#   [points below baseline] "text"
\# *Function:
\#   Places an underscore 2 points under the string if no lead given,
\#   otherwise places underscore under string by user specified amount.
\# *Notes:
\#   When using this macro, the string to be underscored must begin
\#   with double-quotes ("), regardless of whether it's the sole
\#   argument or the second.
\#   E.g.:
\#      .UNDERSCORE "Text to be underscored
\#         or
\#      .UNDERSCORE 2p "Text to be underscored
\#
\#   All text is underscored (including punctuation and spaces).
\#   This is the primary difference between UNDERLINE and UNDERSCORE,
\#   aside from the fact the UNDERLINE only works with Courier.
\#
\#   UNDERSCORE does not work across line breaks.  Each line of
\#   text must be entered separately with UNDERSCORE.  If the
\#   UNDERSCORE begins in the middle of a line and crosses over a
\#   break, the portion before the break must be entered in its own
\#   UNDERSCORE, as must the portion that comes after the break.
\#
.MAC UNDERSCORE END
.    nr #RESTORE_PT_SIZE \\n[#PT_SIZE]
.    ie \\n[#NUM_ARGS]=1 \{ \\$1\\s(12\\v'+2p'\\l'|0'\\v'-2p'\\s[\\n[#RESTORE_PT_SIZE]u] \}
.    el                  \{ \\$2\\s(12\\v'+(\\$1)'\\l'|0'\\v'-(\\$1)'\\s[\\n[#RESTORE_PT_SIZE]u] \}
.    rr #RESTORE_PT_SIZE
.END
\#
\#
\# DOUBLE UNDERSCORE
\# -----------------
\# *Arguments:
\#   [points below baseline] [points distance between rules] "text"
\# *Function:
\#   Same as UNDERSCORE, except it produces a double underscore.  The default
\#   distance between the rules is 2 points.
\# *Notes:
\#   The same double-quote requirement as UNDERSCORE.
\#
.MAC UNDERSCORE2 END
.    nr #RESTORE_PT_SIZE \\n[#PT_SIZE]
.    if \\n[#NUM_ARGS]=1 \{\
.       PRINT \\$1\\s(12\\v'+2p'\\l'|0'\\v'+2p'\\l'|0'\\v'-4p'\\s[\\n[#RESTORE_PT_SIZE]u]
.    \}
.    if \\n[#NUM_ARGS]=2 \{\
.       PRINT \\$2\\s(12\\v'+\\$1'\\l'|0'\\v'+2p'\\l'|0'\\v'-(2p+\\$1)'\\s[\\n[#RESTORE_PT_SIZE]u]
.    \}
.    if \\n[#NUM_ARGS]=3 \{\
.       PRINT \\$3\\s(12\\v'+\\$1'\\l'|0'\\v'+\\$2'\\l'|0'\\v'-(\\$2+\\$1)'\\s[\\n[#RESTORE_PT_SIZE]u]
.    \}
.    rr #RESTORE_PT_SIZE
.END
\#
\#
\# SUPERSCRIPT INLINES
\# -------------------
\# *Function:
\#   Prints everything after invocation as superscript.
\# *Notes:
\#   \*[SUP] and \*[SUPX] turn superscript on and off respectively.
\#   If running type is pseudo-condensed/expanded, invoke the superscript
\#   strings as \*[CONDSUP] or \*[EXTSUP] and turn off with \*[CONDSUPX]
\#   and \*[EXTSUPX] respectively.
\#
.ds SUP \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#SUP_PT_SIZE \En[#PT_SIZE_IN_UNITS]u*6u/10u'\
\s[\En[#PT_SIZE_IN_UNITS]u]\v'-.3m'\s[\En[#SUP_PT_SIZE]u]
\#
.ds SUPX \s[\En[#PT_SIZE_IN_UNITS]u]\v'.3m'
\#
.ds CONDSUP \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#SUP_PT_SIZE \En[#PT_SIZE_IN_UNITS]u*6u/10u'\
\s[\En[#PT_SIZE_IN_UNITS]u]\v'-.3m'\s[\En[#SUP_PT_SIZE]u]\E*[COND_FOR_SUP]
\#
.ds CONDSUPX \s[\En[#PT_SIZE_IN_UNITS]u]\v'.3m'\E*[COND]
\#
.ds EXTSUP \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#SUP_PT_SIZE \En[#PT_SIZE_IN_UNITS]u*6u/10u'\
\s[\En[#PT_SIZE_IN_UNITS]u]\v'-.3m'\s[\En[#SUP_PT_SIZE]u]\E*[EXT_FOR_SUP]
\#
.ds EXTSUPX \s[\En[#PT_SIZE_IN_UNITS]u]\v'.3m'\E*[EXT]
\#
\#
\# SLANT
\# -----
\#
\# SETSLANT
\# --------
\# *Arguments:
\#   <number of degrees> | RESET
\# *Function:
\#   Modifies register #DEGREES for use with \*[SLANT], or resets
\#   it to the default.  Defines string \*[SLANTX]
\# *Notes:
\#   \*[SLANT] permits pseudo-italicizing of a font in cases where
\#   no italic font exists in a particular family.
\#
\#   Default # of degrees is 15.
\#
\#   Do not use unit of measure with arg to SETSLANT.
\#
\#   It may be necessary to adjust the spacing on either side of
\#   [SLANT] and [SLANTX].
\#
\#   In docs, SLANT carries over from para to para.
\#
.nr #DEGREES 15
.ds SLANT \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.ds SLANTX \ER'#SLANT_ON 0'\ES'0'
\#
.MAC SETSLANT END
.    ie '\\$1'RESET' \{\
.       nr #DEGREES 15
.       if \\n[#PRINT_STYLE]=1 \{\
.          if \\n[#UNDERLINE_SLANT] \{ .return \}
.       \}
.       ds SLANT \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.    \}
.    el \{\
.       nr #DEGREES \\$1
.       if \\n[#PRINT_STYLE]=1 \{\
.          if \\n[#UNDERLINE_SLANT] \{ .return \}
.       \}
.       ds SLANT \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.    \}
.    ds SLANTX \ER'#SLANT_ON 0'\ES'0'
.END
\#
\#
\# BOLDER
\# ------
\#
\# SETBOLDER
\# ---------
\# *Arguments:
\#   <amount of emboldening> | RESET
\# *Function:
\#   Modifies register #BOLDER_UNITS for use with \*[BOLDER], or resets
\#   it to the default 700 units.
\# *Notes:
\#   \*[BOLDER] allows pseudo-emboldening of a font where no bold
\#   font exists in a particular family.
\#
\#   Default for SETBOLDER is 700 units.  Do not use unit of measure
\#   with arg to SETBOLDER.
\#
.nr #BOLDER_UNITS 700
\#
.MAC SETBOLDER END
.    if \\n[#IGNORE]=1 \{ .return \}
.    ie '\\$1'RESET' \{ .nr #BOLDER_UNITS 700 \}
.    el \{ .nr #BOLDER_UNITS \\$1 \}
.END
\#
\#
.MAC BOLDER END
\c
.bd \\n(.f \\n[#BOLDER_UNITS]
.END
\#
\#
.MAC BOLDERX END
\c
.bd \\n(.f
.END
\#
\# +++CONDENSE/EXTEND+++
\#
\# CONDENSE/EXTEND
\# ---------------
\# *Arguments:
\#   <percentage to condense/expand type size>
\# *Function:
\#   Stores current point size in z's in #PT_SIZE_IN_UNITS, figures out
\#   new point size (for character width) from arg, and defines string
\#   COND or EXT, which set the type size to the new character width,
\#   and sets the height of type to the value stored in CURRENT_PT_SIZE
\# *Notes:
\#   CONDENSE_OR_EXTEND is invoked from the aliases
\#   CONDENSE and EXTEND.  CONDENSE implies <100, EXTEND
\#   implies >100.  Do not use a percent sign in the argument.
\#
\#   There is no default setting for CONDENSE or EXTEND.
\#   80 is a good approximation of condensed type, 120 is okay
\#   for extended.
\#
\#   The value set by CONDENSE or EXTEND applies to all
\#   subsequent \*[COND] or \*[EXT] escapes until a new value is set.
\#
\#  \*[COND] or \*[EXT] must be turned off before all changes of point
\#  size and reinvoked afterwards (if so desired).  This refers to
\#  changes of point size via control lines AND with via inlines.
\#
.MAC CONDENSE_OR_EXTEND END
.    if '\\$0'CONDENSE' \{\
.       ds $COND_PERCENT \\$1
.       if \\n[#PRINT_STYLE]=1 \{\
.          rm $COND_PERCENT
.          ds $COND_PERCENT 100
.       \}
.       ds COND \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#CONDENSE 1'\
\R'#COND_WIDTH (\En[#PT_SIZE_IN_UNITS]u*\E*[$COND_PERCENT]u)/100'\
\Es[\En[#COND_WIDTH]u]\EH'\En[#PT_SIZE_IN_UNITS]u'
.       ds COND_FOR_SUP \
\R'#COND_WIDTH (\En[#SUP_PT_SIZE]u*\E*[$COND_PERCENT]u)/100'\
\Es[\En[#COND_WIDTH]u]\H'\En[#SUP_PT_SIZE]u'
.    \}
.    if '\\$0'EXTEND' \{\
.       ds $EXT_PERCENT \\$1
.       if \\n[#PRINT_STYLE]=1 \{\
.          rm $EXT_PERCENT
.          ds $EXT_PERCENT 100
.       \}
.       ds EXT \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#EXTEND 1'\
\R'#EXT_WIDTH (\En[#PT_SIZE_IN_UNITS]u*\E*[$EXT_PERCENT]u)/100'\
\Es[\En[#EXT_WIDTH]u]\EH'\En[#PT_SIZE_IN_UNITS]u'
.       ds EXT_FOR_SUP \
\R'#EXT_WIDTH (\En[#SUP_PT_SIZE]u*\E*[$EXT_PERCENT]u)/100'\
\Es[\En[#EXT_WIDTH]u]\H'\En[#EXT_PT_SIZE]u'
.    \}
.END
\#
.ds CONDX \ER'#CONDENSE 0'\Es0\R'#PT_SIZE_IN_UNITS \En[.ps]'\H'\En[#PT_SIZE_IN_UNITS]u'
.ds EXTX  \ER'#EXTEND   0'\Es0\R'#PT_SIZE_IN_UNITS \En[.ps]'\H'\En[#PT_SIZE_IN_UNITS]u'
\#
\#
\# +++PAD LINES+++ (insert space)
\#
\# PAD MARKER
\# ----------
\# *Arguments:
\#   <character to use for marking pad points>
\# *Function:
\#   Defines string $PAD_MARKER, used in PAD
\# *Notes:
\#   $PAD_MARKER is normally # (the pound sign).
\#
.MAC PAD_MARKER END
.    ds $PAD_MARKER \\$1
.END
\#
\#
\# PAD
\# ---
\# *Argments:
\#   "<string of text with padding markers inserted>"
\# *Function:
\#   Defines and redefines padding character (default=pound sign
\#   unless padding character has been set with PAD_MARKER)
\#   several times so that when the string is output at the end
\#   of the macro, every # has been converted to an equal-sized
\#   amount of padding (blank space) on a line. # is equivalent to
\#   CompuGraphic's old <IS>.
\# *Notes:
\#   String tabs may be marked off during PAD.
\#
.MAC PAD END
.    if \\n(.u=1 \{ .nr #FILL_MODE 1 \}
.    nf
.    if !d$PAD_MARKER \{ .ds $PAD_MARKER # \}
.    char \\*[$PAD_MARKER] \R'#PAD_COUNT \En[#PAD_COUNT]+1'
.    ds $FAMILY_FOR_PAD \\n[.fam]
.    nr #FONT_FOR_PAD   \\n(.f
.    nr #SIZE_FOR_PAD   \\n[.ps]
.    ds $PAD_STRING \\$1
.    as $PAD_STRING \Ekp
.    di PAD_STRING
.    fam \\*[$FAMILY_FOR_PAD]
\\f\\n[#FONT_FOR_PAD]\\s[\\n[#SIZE_FOR_PAD]u]\\*[$PAD_STRING]
.    br
.    di
.    char \\*[$PAD_MARKER] \R'#SPACE_TO_END \En(.l-\Enp'\R'#PAD_SPACE \En[#SPACE_TO_END]/\En[#PAD_COUNT]'
.    di PAD_STRING
.    fam \\*[$FAMILY_FOR_PAD]
\\f\\n[#FONT_FOR_PAD]\\s[\\n[#SIZE_FOR_PAD]u]\\*[$PAD_STRING]
.    br
.    di
.    char \\*[$PAD_MARKER] \h'\En[#PAD_SPACE]u'
.    ie \\n[#SILENT] \{\
.       SILENT
.       fam \\*[$FAMILY_FOR_PAD]
\\f\\n[#FONT_FOR_PAD]\\s[\\n[#SIZE_FOR_PAD]u]\\*[$PAD_STRING]
.       br
.       SILENT OFF
.    \}
.    el \{\
.       fam \\*[$FAMILY_FOR_PAD]
\\f\\n[#FONT_FOR_PAD]\\s[\\n[#SIZE_FOR_PAD]u]\\*[$PAD_STRING]
.       br
.    \}
.    if \\n[#FILL_MODE]=1 \{\
.       fi
.       rr #FILL_MODE
.    \}
.    rr #PAD_COUNT
.    rr #SPACE_TO_END
.    rr #PAD_SPACE
.    rm $PAD_STRING
.    rm PAD_STRING
.    rchar #
.END
\#
\#
\# +++LEADERS+++
\#
\#  The leader mechanism is primitive, but it works.  Basically,
\#  every macro in this set that includes a line length also sets
\#  a single groff tab stop at the right hand end of the line.
\#  That way, whenever Ctrl-A is invoked (always at the end of
\#  an input line), leader of the correct length gets deposited.
\#  Ctrl-A is accessed by the string LEADER (i.e. inline, as
\#  \*[LEADER]).  Leaders within tabs get their length from the
\#  tab line length.
\#
\# SET LEADER CHARACTER
\# --------------------
\# *Arguments:
\#   <character to use whenever \*[LEADER] is invoked>
\# *Function:
\#   Set leader character.
\#
.MAC LEADER_CHARACTER END
.    lc \\$1
.END
\#
.ds LEADER 
\#
\# +++DROP CAPS+++
\#
\# DROP CAP FAMILY
\# ---------------
\# *Argument:
\#   <family of drop cap>
\# *Function:
\#   Creates or modifies string $DC_FAM.
\#
.MAC DROPCAP_FAMILY END
.    ds $DC_FAM \\$1
.END
\#
\#
\# DROP CAP FONT
\# -------------
\# *Argument:
\#   <font of drop cap>
\# *Function:
\#   Creates or modifies string $DC_FT.
\#
.MAC DROPCAP_FONT END
.    ds $DC_FT \\$1
.END
\#
\#
\# DROPCAP COLOR
\# -------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Defines string $DC_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   DC_COLOR.
\#
.MAC DROPCAP_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    nr #DC_COLOR 1
.    ds $DC_COLOR \\$1
.END
\#
\#
\# DROP CAP GUTTER
\# ---------------
\# *Argument:
\#   <width of gutter between drop cap and indented text>
\# *Function:
\#   Creates or modifies register #DC_GUT.
\# *Notes:
\#   Requires unit of measure.  Default is 3p.
\#
.MAC DROPCAP_GUTTER END
.    nr #DC_GUT (\\$1)
.END
\#
\#
\# DROP CAP ADJUST
\# ---------------
\# *Argument:
\#   <+|- # of points to in/decrease point size of drop cap letter>
\# *Function:
\#   Creates or modifies string $DC_ADJUST.
\# *Notes:
\#   Despite its best efforts, DROPCAP doesn't always get the point
\#   size of the drop cap critically perfect.  DROPCAP_ADJUST lets
\#   the user add or subtract points (or fractions of points) to
\#   get the size right.
\#
\#   Requires the + or - sign.
\#
.MAC DROPCAP_ADJUST END
.    ds $DC_ADJUST \\$1
.END
\#
\#
\# DROP CAP
\# --------
\# *Arguments:
\#   <dropcap letter> <# of lines> [COND <% to condense> | EXT <% to extend>]
\# *Function:
\#   Calculates point size of dropcap based on # of lines passed as
\#   arg 2.  Sets indent for text based on dropcap width+gutter.
\#   Advances and prints dropcap; reverses and prints indented text
\#   to bottom of dropcap, then resets indent to left margin (plus
\#   any indent that was in effect prior to invoking DROPCAP).
\# *Notes:
\#   Drop caps put a strain on on resource-challenged systems.
\#
\#   Drop caps when using the doc processing macro PP only work with
\#   initial paragraphs (i.e. at doc start, or after heads), only when
\#   DROPCAPS comes immediately after PP, and only when the PRINTSTYLE
\#   is TYPESET.  If these conditions aren't met, DROPCAPS is silently
\#   ignored.
\#
\#   The COND or EXT argument are processed separately from all
\#   other COND or EXT inlines or macros, hence passing COND or
\#   EXT has no effect on running type.
\#
.MAC DROPCAP END
.    if #IGNORE \{ .return \}
.    br
.    if \\n[#DOCS] \{\
.       if \\n[#PRINT_STYLE]=1 \{ .return \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          if \\n[#PP_STYLE]=2 \{ .return \}
.          if \\n[#PP]>1 \{ .return \}
.          ti 0
.       \}
.    \}
.    ds $DROPCAP         \\$1
.    nr #DC_LINES        \\$2-1
.    ds $RESTORE_COND    \\*[$COND_PERCENT]
.    if '\\$3'COND'      \{ .CONDENSE \\$4 \}
.    if '\\$3'EXT'       \{ .EXTEND \\$4 \}
.    if !r#DC_GUT        \{ .nr #DC_GUT (3p) \}
.    ds $RESTORE_FAM     \\n[.fam]
.    nr #RESTORE_FT      \\n(.f
.    nr #RESTORE_PT_SIZE \\n[#PT_SIZE]
.    nr #RESTORE_INDENT  \\n(.i
.    SIZESPECS
.    nr #DC_HEIGHT \\n[#DC_LINES]*\\n[#LEAD]+\\n[#CAP_HEIGHT]
.    ie !d$DC_FAM \{ .FAM \\n[.fam] \}
.    el \{ .FAM \\*[$DC_FAM] \}
.    ie !d$DC_FT \{ .FT \\n(.f \}
.    el \{ .FT \\*[$DC_FT] \}
.    while \\n[#GET_DC_HEIGHT]<\\n[#DC_HEIGHT] \{\
.       ps \\n[#PT_SIZE]u+100u
.       SIZESPECS
.       nr #GET_DC_HEIGHT \\n[#CAP_HEIGHT]
.    \}
.    if d$DC_ADJUST \{ .ps \\*[$DC_ADJUST]p \}
.    mk x
.    sp \\n[#DC_LINES]v
.    ie \\n[#DC_COLOR]=1 \{\
.       ie !'\\$3'' \{\
.          ie '\\$3'COND' \{ .PRINT \m[\\*[$DC_COLOR]]\\*[COND]\\*[$DROPCAP]\\*[CONDX]\m[] \}
.          el \{ .PRINT \m[\\*[$DC_COLOR]]\\*[EXT]\\*[$DROPCAP]\\*[EXTX]\m[] \}
.       \}
.       el \{ .PRINT \m[\\*[$DC_COLOR]]\\*[$DROPCAP]\m[] \}
.    \}
.    el \{\
.       ie !'\\$3'' \{\
.          ie '\\$3'COND' \{ .PRINT \\*[COND]\\*[$DROPCAP]\\*[CONDX] \}
.          el \{ .PRINT \\*[EXT]\\*[$DROPCAP]\\*[EXTX] \}
.       \}
.       el \{ .PRINT \m[\\*[$DC_COLOR]]\\*[$DROPCAP]\m[] \}
.    \}
.    if '\\$3'COND' \{ \E*[COND] \}
.    if '\\$3'EXT'  \{ \E*[EXT]  \}
.    ie \\n(.i \{ .in +\w'\\*[$DROPCAP]'u+\\n[#DC_GUT]u \}
.    el \{ .in \w'\\*[$DROPCAP]'u+\\n[#DC_GUT]u \}
.    if '\\$3'COND' \{ \E*[CONDX]\c \}
.    if '\\$3'EXT'  \{ \E*[EXTX]\c \}
.    rt \\nxu
.    FAM \\*[$RESTORE_FAM]
.    FT  \\n[#RESTORE_FT]
.    ps \\n[#RESTORE_PT_SIZE]u
.    CONDENSE \\*[$RESTORE_COND]
.    EXTEND   \\*[$RESTORE_EXT]
.    ie \\n(.u \{ .wh \\n(.du+\\n[#DC_HEIGHT]u-1v DROPCAP_OFF \}
.    el \{ .wh \\n(.du+\\n[#DC_HEIGHT]u DROPCAP_OFF \}
.    rm $DROPCAP
.    rr #DC_LINES
.    rm $RESTORE_COND
.    rm $RESTORE_EXT
.    rm $RESTORE_FAM
.    rr #RESTORE_FT
.    rr #RESTORE_PT_SIZE
.    rr #RESTORE_INDENT
.    rr #DC_HEIGHT
.    rr #GET_DC_HEIGHT
.    rr x
.END
\#
.MAC DROPCAP_OFF END
'    in \\n[#RESTORE_INDENT]u
.END
\#
\#
\# RULE
\# ----
\# *Argument:
\#   <none>
\# *Function:
\#   Draws a rule the length of the current measure.
\# *Notes:
\#
.MAC RULE END
\c
.    EL
.    if \\n(.u=1 \{\
.       ds $CURRENT_QUAD \\*[$QUAD_VALUE]
.       nf
.    \}
.    ie \\n[#INDENT_ACTIVE] \{\
.       nr #RESTORE_L_LENGTH \\n(.l
.       if \\n[#INDENT_BOTH_ACTIVE] \{ .ll \\n(.lu-\\n[#BL_INDENT]u \}
.       if \\n[#INDENT_LEFT_ACTIVE] \{ .ll \\n(.lu-\\n[#L_INDENT]u \}
.       PRINT \El'\En(.lu'
.       ll \\n[#RESTORE_L_LENGTH]u
.       rr #RESTORE_L_LENGTH
.    \}
.    el \{\
.       PRINT \El'\En(.lu'
.    \}
.    QUAD \\*[$CURRENT_QUAD]
.    rm $CURRENT_QUAD
.    EL
.END
\#
\# =====================================================================
\#
\# +++WORD AND SENTENCE SPACING+++
\#
\# WORD SPACE CONTROL
\# ------------------
\# *Argument:
\#   <+|->wordspace | DEFAULT
\# *Function:
\#   Increases or decreases interword space by user supplied amount.
\#   If DEFAULT, value is set to 12 (groff default).
\# *Notes:
\#   $WS_CONSTANT is the groff default word space.
\#   $WS_VAR is the user supplied amount by which to in/decrease word space.
\#   $WS is a concatenation of WS_CONSTANT and WS_VAR.
\#
\#   Because the user supplied value requires a literal + or - sign,
\#   the macro argument is stored in a string.
\#
\#   \n[.sss] holds the current sentence space value.
\#
.MAC WS END
.    ds $WS_CONSTANT 12
.    ds $WS_VAR \\$1
.    ie '\\$1'DEFAULT' \{ .ds $WS_VAR +0 \}
.    el                \{ .ds $WS (\\*[$WS_CONSTANT]\\*[$WS_VAR]) \}
.    ie \\n[.sss]=12   \{ .ss \\*[$WS] 12 \}
.    el \{\
.       ss \\*[$WS] (\\*[$WS]\\*[$SS_VAR])
.       SS \\*[$SS_VAR]
.    \}
.END
\#
\#
\# SENTENCE SPACE CONTROL
\# ----------------------
\# *Argument:
\#   <+-sentencespace> | 0 | DEFAULT
\# *Function:
\#   Increases or decreases sentence space by user supplied amount.
\#   If 0, sentence spaces are ignored.  If DEFAULT, value is
\#   set to 12 (groff default).
\# *Notes:
\#   Because the user supplied value requires a literal + or - sign,
\#   the macro argument is stored in a string.
\#
\#   Sentence space applies only to input where sentences are separated
\#   by two spaces (and/or, in fill mode [FLUSH L|R|C or JUSTIFY], an EOL).
\#   Changing .SS when sentences are separated by only one space has
\#   no effect on the space between sentences.
\#
\#   \n[.ss] holds the current wordspace value.
\#   \n[.sss] holds the current sentence space value.
\#
.MAC SS END
.    ie '\\$1'0' \{ .ss \\n[.ss] (\\n[.ss]-\\n[.ss]) \}
.    el \{\
.       ie '\\$1'DEFAULT' \{ .ss \\n[.ss] \}
.       el \{\
.          ds $SS_VAR \\$1
.          ss \\n[.ss] (0\\*[$SS_VAR])
.       \}
.    \}
.END
\#
\#
\# =====================================================================
\#
\# +++INDENTS+++
\#
\# There are five styles of indents: left, right, both, temporary,
\# and hanging.  Each is set/invoked with a different macro.
\# Indent macros begin with the letter "I", hence .IL means "indent left,"
\# .IR means "indent right," and so on.
\#
\# The first time any of the indent macros is used, it requires an
\# argument--the size of the indent (with a unit of measure).  The
\# size may also be entered using the \w escape--very useful
\# for numbered lists using HI.  The unit of measure is required.
\# Subsequent invocations don't require the argument; the indent
\# measure remains the same until it's changed by invoking the macro
\# with an argument again.
\#
\# If no indents are in effect, the arguments passed to indent macros are
\# measured from the left and right margins of the page.  If a left indent
\# or a right indent is already in effect, the arguments passed to
\# the indent macros are calculated from the current values; in other words,
\# the arguments are additive.  If you quit an indent and later return
\# to it, its value will be the value last in effect, unless you pass
\# it an argument.  If you do pass an argument, it is added to the last
\# value in effect, unless you cleared the indent with one of
\# .I<LRB>X/Q macros.
\#
\# Example
\# -------
\#
\# .IL 2P
\# ...some text...
\# .IL 2P
\# ...some text...
\# .IQ
\# ...some text...
\# .IL
\# ...some text...
\#
\# The first .IL 2P indents text 2P from the left margin.  The second
\# .IL 2P indents text by an additional 2P, i.e. 4P from the left margin.
\# .IQ turns the indent off.  The last .IL (which has no argument)
\# takes its value from the total of all arguments passed to .IL (in
\# this case, 2P and 2P), therefore it indents 2P+2P from the left
\# margin, i.e. 4P.  If you wanted the last .IL to indent just 2P,
\# you'd either have to reset the .IL prior to .IQ (.IL -2P), or pass
\# the last .IL the argument 2P.
\#
\# To reverse the sense of an indent added to an indent, you may use
\# negative values.
\#
\# Indents can be turned off individually with ILX, IRX, and IBX.
\# LEFT and RIGHT indents may be combined and manipulated
\# separately, (e.g. you can have an IL of 2P and an IR of 4P
\# operative at the same time, and then change, say, the IL to
\# 4P--thereby left indenting 6P--while the IR remains at 4P.
\#
\# IB automatically turns off IL and IR.  They have to be reinvoked
\# again when needed. IL and IR automatically turn IB off; it, too,
\# has to be reinvoked with needed.
\#
\# All indents can be turned off at once with IQ.  The ILX, IRX, IBX,
\# and IQ macros simply turn the indents off; the values stored in
\# the respective indent macros (IL, IR, IB) remain in effect.  If
\# the user wishes to clear the values, the I<LRB>X macros should be
\# invoked with the single argument CLEAR.  IQ CLEAR clears out
\# the values stored for all indent styles.
\#
\# Indents *must* be turned off before settting string tabs
\# inside PAD.  Generally, in order not to get confused, it's a
\# good idea to turn all indents off before setting any tabs.
\#
\# TI and HI are special cases.  There's no need to turn them off,
\# since they affect only one line--the first after their
\# invocation.  Like the other indent styles, the first time
\# they're invoked, they require a value in iPpcm; each subsequent
\# invocation without an argument will use the same value.  To
\# change the value, simply pass a new value.  Values for TI and HI
\# are *not* additive.
\#
\# HI presupposes that you already have a left or both indent on.
\# HI will never hang a line outside the left margin of a document
\# or column.  In other words, you must have IL or IB on before you
\# can use HI.
\#
\# INDENT LEFT
\# -----------
\#
.MAC IL END
.    if \\n[#INDENT_STYLE_BOTH] \{ .IBX \}
.    nr #INDENT_STYLE_LEFT  1
.    nr #INDENT_ACTIVE      1
.    nr #INDENT_LEFT_ACTIVE 1
.    ie '\\$1'' \{\
.       br
.       in \\n[#L_INDENT]u
.       ta \\n(.lu-\\n[#L_INDENT]u
.    \}
.    el \{\
.       br
.       nr #L_INDENT +(\\$1)
.       in \\n[#L_INDENT]u
.       ta \\n(.lu-\\n[#L_INDENT]u
.    \}
.END
\#
\#
\# +++INDENT RIGHT+++
\#
.MAC IR END
.    if \\n[#INDENT_STYLE_BOTH] \{ .IBX \}
.    nr #INDENT_STYLE_RIGHT   1
.    nr #INDENT_ACTIVE        1
.    nr #INDENT_RIGHT_ACTIVE 1
.    ie '\\$1'' \{\
.       br
.       ie \\n[#TAB_ACTIVE] \{\
.          ll \\n(.lu-\\n[#R_INDENT]u
.          ta \\n(.lu-\\n[#L_INDENT]u
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u-\\n[#R_INDENT]u
.          ta \\n(.lu-\\n[#L_INDENT]u
.       \}
.    \}
.    el \{\
.       br
.       nr #R_INDENT +(\\$1)
.       ie \\n[#TAB_ACTIVE] \{\
.          ll \\n(.lu-\\n[#R_INDENT]u
.          ta \\n(.lu-\\n[#L_INDENT]u
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u-\\n[#R_INDENT]u
.          ta \\n(.lu-\\n[#L_INDENT]u
.       \}
.    \}
.END
\#
\#
\# +++INDENT BOTH+++
\#
.MAC IB END
.    if \\n[#INDENT_STYLE_LEFT]  \{ .ILX \}
.    if \\n[#INDENT_STYLE_RIGHT] \{ .IRX \}
.    nr #INDENT_STYLE_BOTH  1
.    nr #INDENT_ACTIVE      1
.    nr #INDENT_BOTH_ACTIVE 1
.    ie '\\$1'' \{\
.       br
.       in \\n[#BL_INDENT]u
.       ie \\n[#TAB_ACTIVE] \{\
.          ll \\n(.lu-\\n[#BR_INDENT]u
.          ta \\n(.lu-\\n[#BR_INDENT]u
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u-\\n[#BR_INDENT]u
.          ta \\n(.lu-\\n[#BR_INDENT]u
.       \}
.    \}
.    el \{\
.       br
.       nr #BL_INDENT (\\n[#INDENT]+\\$1)
.       ie \\n[#NUM_ARGS]=2 \{ .nr #BR_INDENT +(\\$2) \}
.       el                  \{ .nr #BR_INDENT \\n[#BL_INDENT] \}
.       ie \\n[#TAB_ACTIVE] \{\
.          in \\n[#BL_INDENT]u
.          ll \\n(.lu-\\n[#BR_INDENT]u
.          ta \\n(.lu-\\n[#BL_INDENT]u
.       \}
.       el \{\
.          in \\n[#BL_INDENT]u
.          ll \\n[#L_LENGTH]u-\\n[#BR_INDENT]u
.          ta \\n(.lu-\\n[#BR_INDENT]u
.       \}
.    \}
.END
\#
\#
\# +++TEMPORARY INDENT+++
\#
.MAC TI END
.    br
.    ie '\\$1'' \{\
.       ti \\n[#T_INDENT]u
.       if \\n[#INDENT_LEFT_ACTIVE] \{\
.          ti \\n[#T_INDENT]u+\\n[#L_INDENT]u
.       \}
.       if \\n[#INDENT_BOTH_ACTIVE] \{\
.          ti \\n[#T_INDENT]u+\\n[#BL_INDENT]u
.       \}
.    \}
.    el \{\
.       nr #T_INDENT (\\$1)
.       ti \\n[#T_INDENT]u
.    \}
.END
\#
\#
\# +++HANGING INDENT+++
\#
.MAC HI END
.    ie '\\$1'' \{ .ti -\\n[#HL_INDENT]u \}
.    el \{\
.       nr #HL_INDENT (\\$1)
.       ti -\\n[#HL_INDENT]u
.    \}
.END
\#
\#
\# +++INDENTS OFF+++
\#
.MAC ILX END
.    br
.    in 0
.    rr #INDENT_LEFT_ACTIVE
.    if '\\$1'CLEAR' \{\
.       rr #L_INDENT
.       rr #INDENT_STYLE_LEFT
.    \}
.END
\#
\#
.MAC IRX END
.    br
.    rr #INDENT_RIGHT_ACTIVE
.    ie \\n[#TAB_ACTIVE] \{ .TAB\\n[#CURRENT_TAB] \}
.    el \{\
.       ie \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u
.          ta \\n(.lu
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u
.          ta \\n(.lu
.       \}
.    \}
.    if '\\$1'CLEAR' \{\
.       rr #R_INDENT
.       rr #INDENT_STYLE_RIGHT
.    \}
.END
\#
\#
.MAC IBX END
.    br
.    in 0
.    rr #INDENT_BOTH_ACTIVE
.    ie \\n[#TAB_ACTIVE] \{ .TAB\\n[#CURRENT_TAB] \}
.    el \{\
.       ie \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u
.          ta \\n(.lu
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u
.          ta \\n(.lu
.       \}
.    \}
.    if '\\$1'CLEAR' \{\
.       rr #BL_INDENT
.       rr #BR_INDENT
.       rr #INDENT_STYLE_BOTH
.    \}
.END
\#
\#
.MAC IX END
.    if '\\$0'IX' \{\
.       if !\\n[#IX_WARN] \{\
.          tm1 "[mom]: Use of .IX is now deprecated.  Use .IQ instead.
.          tm1 "      .IX will continue to behave as before, but to
.          tm1 "       avoid this message, please update your document.
.          nr #IX_WARN 1
.       \}
.    \}
.    br
.    in 0
.    rr #INDENT_LEFT_ACTIVE
.    rr #INDENT_RIGHT_ACTIVE
.    rr #INDENT_BOTH_ACTIVE
.    if \\n[#INDENT_STYLE_RIGHT] \{\
.       ie \\n[#TAB_ACTIVE] \{ .TAB\\n[#CURRENT_TAB] \}
.       el \{\
.          ie \\n[#COLUMNS] \{\
.             ll \\n[#COL_L_LENGTH]u
.             ta \\n(.lu
.          \}
.          el \{\
.             ll \\n[#L_LENGTH]u
.             ta \\n(.lu
.          \}
.       \}
.    \}
.    if \\n[#INDENT_STYLE_BOTH] \{\
.       ie \\n[#TAB_ACTIVE] \{ .TAB\\n[#CURRENT_TAB] \}
.       el \{\
.          ie \\n[#COLUMNS] \{\
.             ll \\n[#COL_L_LENGTH]u
.             ta \\n(.lu
.          \}
.          el \{\
.             ll \\n[#L_LENGTH]u
.             ta \\n(.lu
.          \}
.       \}
.    \}
.    if '\\$1'CLEAR' \{\
.       if \\n[#INDENT_STYLE_RIGHT] \{\
.          ie \\n[#TAB_ACTIVE] \{ .TAB\\n[#CURRENT_TAB] \}
.          el \{\
.             ie \\n[#COLUMNS] \{\
.                ll \\n[#COL_L_LENGTH]u
.                ta \\n(.lu
.             \}
.             el \{\
.                ll \\n[#L_LENGTH]u
.                ta \\n(.lu
.             \}
.          \}
.       \}
.       if \\n[#INDENT_STYLE_BOTH] \{\
.          ie \\n[#TAB_ACTIVE] \{ .TAB\\n[#CURRENT_TAB] \}
.          el \{\
.             ie \\n[#COLUMNS] \{\
.                ll \\n[#COL_L_LENGTH]u
.                ta \\n(.lu
.             \}
.             el \{\
.                ll \\n[#L_LENGTH]u
.                ta \\n(.lu
.             \}
.          \}
.       \}
.       rr #L_INDENT
.       rr #R_INDENT
.       rr #BL_INDENT
.       rr #BR_INDENT
.       rr #T_INDENT
.       rr #H_INDENT
.       rr #INDENT_STYLE_LEFT
.       rr #INDENT_STYLE_RIGHT
.       rr #INDENT_STYLE_BOTH
.    \}
.    rr #INDENT_ACTIVE
.END
\#
\# =====================================================================
\#
\# +++MULTIPLE COLUMNS+++
\#
\# MULTIPLE COLUMNS ON
\# -------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Marks the top of a column set
\#
.MAC MCO END
.mk c
.END
\#
\# MULTIPLE COLUMN RETURN
\# ----------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Returns to the top of a column set
\#
.MAC MCR END
.    sp |\\ncu
.END
\#
\# MULTIPLE COLUMNS OFF
\# --------------------
\# *Arguments:
\#   <none> | <lead to advance beneath bottom of deepest column>
\# *Function:
\#   Advances to the end of a column set
\# *Notes:
\#   With no argument, advances to the next baseline (at the current
\#   leading value) beneath the longest column.  With an argument
\#   (which requires a unit of measure), advances arg distance
\#   beneath the baseline of the deepest column.  If the argument
\#   is zero, advances to the baseline of the deepest column.
\#
.MAC MCX END
.    ie '\\$1'' \{\
.       TQ
.       sp |\\n(.hu
.    \}
.    el \{\
.       nr #MCX_ALD (\\$1)
.       TQ
.       ie \\n[#MCX_ALD]=0 \{ .sp |\\n(.hu-1v \}
.       el \{ .sp |\\n(.hu+\\n[#MCX_ALD]u \}
.       rr #MCX_ALD (\\$1)
.    \}
.END
\#
\# =====================================================================
\#
\# +++TYPESETTING SUPPORT MACROS+++
\#
\# TRAP
\# ----
\# *Arguments:
\#   toggle
\# *Function:
\#   Enables/disables traps.
\# *Notes:
\#   EL and TN don't function as advertised on the last line before
\#   a trap (when they break the preceding line, they spring the
\#   trap, and groff won't back up to the line preceding the trap).
\#   TRAP is a kludge to get EL and TN work properly on last lines.
\#   The user simply enloses the offending lines in TRAP OFF/TRAP.
\#
.MAC TRAP END
.    ie '\\$1'' \{ .vpt 1 \}
.    el \{ .vpt 0 \}
.END
\#
\#
\# SILENT
\# ------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Diverts text so that it doesn't print, or turns the function off.
\# *Notes:
\#   Useful for setting up autotabs where you don't want the line with
\#   the tab marks to print.
\#
\#   Also aliased as COMMENT, in case user wants to input a batch of
\#   text that doesn't print.
\#
.MAC SILENT END
.    nr #SILENT 1
.    if \\n[#QUAD] \{ .br \}
.    ie '\\$1'' \{ .di NO_FLASH \}
.    el \{\
.       br
.       di
.       rm NO_FLASH
.       rr #SILENT
.    \}
.END
\#
\#
\# PRINT
\# -----
\# *Arguments:
\#   <anything>
\# *Function:
\#   Prints anything.  A macro that helps keep my code nicely indented.
\#
.MAC PRINT END
\\$*
.END
\#
\#
\# CAPS
\# ----
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Converts text to caps, or, if OFF, reverts to normal caps/lc.
\#
.MAC CAPS END
.    ie '\\$1'' \{\
.       tr aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
.       tr \[`A]
.       tr \[^A]
.       tr \['A]
.       tr \[:A]
.       tr \[oA]
.       tr \[~A]
.       tr \[AE]
.       tr \[`E]
.       tr \[^E]
.       tr \['E]
.       tr \[:E]
.       tr \[`I]
.       tr \[^I]
.       tr \['I]
.       tr \[:I]
.       tr \[`O]
.       tr \[^O]
.       tr \['O]
.       tr \[:O]
.       tr \[~O]
.       tr \[/O]
.       tr \[`U]
.       tr \[^U]
.       tr \['U]
.       tr \[:U]
.       tr \[,C]
.       tr \[-D]
.       tr \[~N]
.       tr \[TP]
.       tr \['Y]
.       tr \[:Y]
.       nr #CAPS_ON 1
.    \}
.    el \{\
.       tr aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz
.       tr \[`a]
.       tr \[^a]
.       tr \['a]
.       tr \[:a]
.       tr \[oa]
.       tr \[~a]
.       tr \[ae]
.       tr \[`e]
.       tr \[^e]
.       tr \['e]
.       tr \[:e]
.       tr \[`i]
.       tr \[^i]
.       tr \['i]
.       tr \[:i]
.       tr \[`o]
.       tr \[^o]
.       tr \['o]
.       tr \[:o]
.       tr \[~o]
.       tr \[/o]
.       tr \[`u]
.       tr \[^u]
.       tr \['u]
.       tr \[:u]
.       tr \[,c]
.       tr \[Sd]
.       tr \[~n]
.       tr \[Tp]
.       tr \['y]
.       tr \[:y]
.       rr #CAPS_ON
.    \}
.END
\#
\# SIZESPECS
\# ---------
\# Argument:
\#   <none>
\# Function:
\#   Gets cap-height, x-height, and descender depth of the
\#   current font at the current point size.
\# *Notes:
\#   The routine is diverted so it remains invisible to output.
\#
.MAC SIZESPECS END
.    di TYPESIZE
E\\R'#CAP_HEIGHT \\n[.cht]'
e\\R'#X_HEIGHT \\n[.cht]'
y\\R'#DESCENDER \\n[.cdp]'
.    br
.    di
.END
\#
\# =====================================================================
\#
\# +++TYPESETTING ALIASES+++
\#
.ALIAS    CENTRE          CENTER
.ALIAS    COLOUR          COLOR
.ALIAS    COMMENT         SILENT
.ALIAS    CONDENSE        CONDENSE_OR_EXTEND
.ALIAS    EXTEND          CONDENSE_OR_EXTEND
.ALIAS    FAM             FAMILY
.ALIAS    HYPHENATE       HY
.ALIAS    HYPHENATION     HY
.ALIAS    HYSET           HY_SET
.ALIAS    IBQ             IBX
.ALIAS    ILQ             ILX
.ALIAS    IQ              IX
.ALIAS    IRQ             IRX
.ALIAS    LIG             LIGATURES
.ALIAS    NEWCOLOUR       NEWCOLOR
.ALIAS    PADMARKER       PAD_MARKER
.ALIAS    TABSET          TAB_SET
.ALIAS    TB              TAB
.ALIAS    UNDERSCORE_2    UNDERSCORE2
.ALIAS    XCOLOUR         XCOLOUR
\#
\#
\# ====================================================================
\#
\# DOCUMENT PROCESSING MACROS, STRINGS AND ALIASES
\# ===============================================
\#
\# +++PAGE DIMENSIONS+++
\#
\# PAPER SIZE
\# ----------
\# *Arguments:
\#   LETTER | LEGAL | STATEMENT | TABLOID | LEDGER | FOLIO | QUARTO | 10x14 | EXECUTIVE | A3 | A4 | A5 | B4 | B5
\# *Function:
\#   Sets up margins for different paper sizes.
\#
.MAC PAPER END
.    ds $PAPER \\$1
.    if '\\*[$PAPER]'LETTER' \{\
.       PAGEWIDTH  8.5i
.       PAGELENGTH 11i
.    \}
.    if '\\*[$PAPER]'LEGAL' \{\
.       PAGEWIDTH  8.5i
.       PAGELENGTH 14i
.    \}
.    if '\\*[$PAPER]'STATEMENT' \{\
.       PAGEWIDTH  5.5i
.       PAGELENGTH 8.5i
.    \}
.    if '\\*[$PAPER]'TABLOID' \{\
.       PAGEWIDTH  11i
.       PAGELENGTH 17i
.    \}
.    if '\\*[$PAPER]'LEDGER' \{\
.       PAGEWIDTH  17i
.       PAGELENGTH 11i
.    \}
.    if '\\*[$PAPER]'FOLIO' \{\
.       PAGEWIDTH  8.5i
.       PAGELENGTH 13i
.    \}
.    if '\\*[$PAPER]'QUARTO' \{\
.       PAGEWIDTH  610p
.       PAGELENGTH 780p
.    \}
.    if '\\*[$PAPER]'10x14' \{\
.       PAGEWIDTH  10i
.       PAGELENGTH 14i
.    \}
.    if '\\*[$PAPER]'EXECUTIVE' \{\
.       PAGEWIDTH  7.25i
.       PAGELENGTH 10.5i
.    \}
.    if '\\*[$PAPER]'A3' \{\
.       PAGEWIDTH  842p
.       PAGELENGTH 1190p
.    \}
.    if '\\*[$PAPER]'A4' \{\
.       PAGEWIDTH  595p
.       PAGELENGTH 842p
.    \}
.    if '\\*[$PAPER]'A5' \{\
.       PAGEWIDTH  421p
.       PAGELENGTH 595p
.    \}
.    if '\\*[$PAPER]'B4' \{\
.       PAGEWIDTH  709p
.       PAGELENGTH 1002p
.    \}
.    if '\\*[$PAPER]'B5' \{\
.       PAGEWIDTH  501p
.       PAGELENGTH 709p
.    \}
.    if !r#L_MARGIN \{ .L_MARGIN \\n(.o \}
.    if !r#R_MARGIN \{ .R_MARGIN 1i \}
.END
\#
\#
\# ====================================================================
\#
\# +++PRINTSTYLE -- TYPEWRITE OR TYPESET+++
\#
\# PRINTSTYLE
\# ----------
\# *Arguments:
\#   TYPESET | TYPEWRITE [SINGLESPACE]
\# *Function:
\#   Sets type specs for typewriter-style or typeset output.
\# *Notes:
\#   Number registers: TYPEWRITE=1, TYPESET=2.
\#
.MAC PRINTSTYLE END
.    if !d$PAPER \{ .PAPER LETTER \}
.    if '\\$1'TYPEWRITE' \{\
.       nr #PRINT_STYLE 1
.       if !\\n[#DOC_TYPE]=4 \{ .L_MARGIN 6P \}
.       if !\\n[#DOC_TYPE]=4 \{ .R_MARGIN 6P \}
.       fam  C
.       ft   R
.       ps   12
.       color 0
.       ie '\\$2'SINGLESPACE' \{\
.           nr #SINGLE_SPACE 1
.           vs 12
.       \}
.       el \{ .vs 24 \}
.       QUAD    L
.       HY      OFF
.       SMARTQUOTES OFF
.       if !\\n[#PP_INDENT] \{\
.          in 3P                 \"Set indent
.          nr #PP_INDENT \\n(.i  \"Read into #PP_INDENT
.          in 0                  \"Remove indent
.       \}
.       HDRFTR_RIGHT_CAPS
.       nr #BOLDER_UNITS 0
.       nr #CONDENSE 0
.       nr #EXTEND 0
.       rm IT
.       rm BD
.       rm BDI
.       rm PREV
.       UNDERLINE_SLANT
.       UNDERLINE_ITALIC
.       UNDERLINE_QUOTES
.       nr #IGNORE_COLUMNS 1
.       char \(em --
.    \}
.    if '\\$1'TYPESET' \{\
.       nr #PRINT_STYLE 2
.       if !\\n[#DOC_TYPE]=4 \{ .L_MARGIN 6P \}
.       if !\\n[#DOC_TYPE]=4 \{ .R_MARGIN 6P \}
.       FAMILY  T
.       FT      R
.       if !\\n[#DOC_TYPE]=4 \{ .PT_SIZE 12.5 \}
.       if !\\n[#DOC_TYPE]=4 \{ .LS 16 \}
.       JUSTIFY
.       HY
.       HY_SET 2 36p 1p
.       KERN
.       LIG
.       SS 0
.       SMARTQUOTES
.       if !\\n[#PP_INDENT] \{\
.          in 2m                 \"Set indent
.          nr #PP_INDENT \\n(.i  \"Read into #PP_INDENT
.          in 0                  \"Remove indent
.       \}
.       HDRFTR_RIGHT_CAPS
.       rr #IGNORE_COLUMNS
.    \}
.END
\#
\#
\# Macros to control behaviour of PRINTSTYLE TYPEWRITE
\#
\# ITALIC MEANS ITALIC
\# -------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Instructs TYPEWRITE to treat italics as italics, whether
\#   invoked via control lines or inline.
\# *Notes:
\#   ITALIC_MEANS_ITALIC and UNDERLINE_ITALIC are mututally exclusive,
\#   hence invoking the one automatically turns off the other.
\#
.MAC ITALIC_MEANS_ITALIC END
.    if \\n[#PRINT_STYLE]=1 \{\
.       nr #ITALIC_MEANS_ITALIC 1
.       rr #UNDERLINE_ITALIC
.       rm ROM
.       rm IT
.       rm PREV
.       ds ROM  \EfR
.       ds IT   \EfI
.       ds PREV \EfR
.    \}
.END
\#
\#
\# UNDERLINE ITALIC
\# ----------------
\# *Argument:
\#   <none>
\# *Function:
\#   Instructs TYPEWRITE to underline italics, whether invoked
\#   via control lines or inline.
\# *Notes:
\#   UNDERLINE_ITALIC and ITALIC_MEANS_ITALIC are mututally exclusive,
\#   hence invoking the one automatically turns off the other.
\#
\#   UNDERLINE_ITALIC is the default for TYPEWRITE.
\#
.MAC UNDERLINE_ITALIC END
.    if \\n[#PRINT_STYLE]=1 \{\
.       nr #UNDERLINE_ITALIC 1
.       rr #ITALIC_MEANS_ITALIC
.       rm ROM
.       rm IT
.       rm PREV
.       ds ROM  \E*[ULX]
.       ds IT   \E*[UL]
.       ds PREV \E*[ULX]
.    \}
.END
\#
\#
\# UNDERLINE SLANT
\# ---------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Instructs TYPEWRITE to underline occurences of \*[SLANT], or
\#   turns feature off.
\# *Notes:
\#   Users may want \*[SLANT] to mean slant in TYPEWRITE, although
\#   most of the time, \*[SLANT] most likely means the user wanted
\#   italic but didn't have it, ergo the need to tell TYPEWRITE to
\#   treat \*[SLANT] as italic (i.e. underlined).
\#
\#   UNDERLINE_SLANT and SLANT_MEANS_SLANT are mututally exclusive,
\#   hence invoking the one automatically turns off the other.
\#
\#   UNDERLINE_SLANT is the default for TYPEWRITE.
\#
.MAC UNDERLINE_SLANT END
.    if \\n[#PRINT_STYLE]=1 \{\
.       rr #SLANT_MEANS_SLANT
.       nr #UNDERLINE_SLANT 1
.       rm SLANT
.       rm SLANTX
.       ds SLANT  \ER'#SLANT_ON 1'\E*[UL]
.       ds SLANTX \ER'#SLANT_ON 0'\E*[ULX]
.    \}
.END
\#
\#
.MAC SLANT_MEANS_SLANT END
.    if \\n[#PRINT_STYLE]=1 \{\
.       rr #UNDERLINE_SLANT
.       nr #SLANT_MEANS_SLANT 1
.       rm SLANT
.       rm SLANTX
.       ds SLANT  \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.       ds SLANTX \ER'#SLANT_ON 0'\ES'0'
.    \}
.END
\#
\#
.MAC IGNORE_COLUMNS END
.    if \\n[#PRINT_STYLE]=1 \{ .nr #NO_COLUMNS 1 \}
.END
\#
\#
\# ====================================================================
\#
\# +++COPY STYLE -- DRAFT OR FINAL+++
\#
\# COPY STYLE
\# ----------
\# *Arguments:
\#   DRAFT | FINAL
\# *Function:
\#   Sets registers that are used to determine what to put
\#   in the default header, and how to number pages.
\# *Notes:
\#   DOCTYPE must come before COPYSTYLE.
\#
.MAC COPYSTYLE END
.    ds $COPY_STYLE \\$1
.    if '\\*[$COPY_STYLE]'DRAFT' \{\
.       nr #COPY_STYLE 1
.       if !d$DRAFT \{ .DRAFT 1 \}
.    \}
.    if '\\*[$COPY_STYLE]'FINAL' \{ .nr #COPY_STYLE 2         \}
.    if !d$CHAPTER_STRING        \{ .CHAPTER_STRING "Chapter" \}
.    if !d$DRAFT_STRING          \{ .DRAFT_STRING "Draft"     \}
.    if !d$REVISION_STRING       \{ .REVISION_STRING "Rev."   \}
\# Default
.    if \\n[#DOC_TYPE]=1 \{\
.       ie \\n[#COPY_STYLE]=1 \{\
.          ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.          el \{ .PAGENUM_STYLE roman \}
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#DRAFT_WITH_PAGENUM] \{\
.                ds $HDRFTR_CENTER
.             \}
.             el \{\
.                ie '\\*[$REVISION]'' \{\
.                   ds $HDRFTR_CENTER \
                    \\*[$DRAFT_STRING]\\*[$DRAFT]
.                \}
.                el \{\
.                   ds $HDRFTR_CENTER \
                    \\*[$DRAFT_STRING]\\*[$DRAFT], \
                    \\*[$REVISION_STRING] \\*[$REVISION]
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.          el \{ .PAGENUM_STYLE DIGIT \}
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ds $HDRFTR_CENTER
.             rr #USER_DEF_HDRFTR_CENTER
.          \}
.       \}
.    \}
\# Chapter
.    if \\n[#DOC_TYPE]=2 \{\
\# Copystyle DRAFT
.       ie \\n[#COPY_STYLE]=1 \{\
.          ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.          el \{ .PAGENUM_STYLE roman \}
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#DRAFT_WITH_PAGENUM] \{\
.                ie '\\*[$CHAPTER]'' \{\
.                   ie !'\\*[$CHAPTER_TITLE]'' \{\
.                      ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                   \}
.                   el \{ .ds $HDRFTR_CENTER \\*[$CHAPTER_STRING] \}
.                \}
.                el \{\
.                   ie !'\\*[$CHAPTER_TITLE]'' \{\
.                      ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                   \}
.                   el \{ .ds $HDRFTR_CENTER \\*[$CHAPTER_STRING] \\*[$CHAPTER] \}
.                \}
.             \}
.             el \{\
.                ie '\\*[$REVISION]'' \{\
.                   ie '\\*[$CHAPTER]'' \{\
.                      ie !'\\*[$CHAPTER_TITLE]'' \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                   \}
.                   el \{\
.                      ie !'\\*[$CHAPTER_TITLE]'' \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                   \}
.                \}
.                el \{\
.                   ie '\\*[$CHAPTER]'' \{\
.                      ie !'\\*[$CHAPTER_TITLE]'' \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                      \}
.                   \}
.                   el \{\
.                      ie !'\\*[$CHAPTER_TITLE]'' \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                      \}
.                   \}
.                \}
.             \}
.          \}
.       \}
\# Copystyle FINAL
.       el \{\
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.             el \{ .PAGENUM_STYLE DIGIT \}
.             ie '\\*[$CHAPTER]'' \{\
.                ie !'\\*[$CHAPTER_TITLE]'' \{\
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                \}
.                el \{\
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_STRING]
.                \}
.             \}
.             el \{\
.                ie !'\\*[$CHAPTER_TITLE]'' \{\
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                \}
.                el \{\
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.                \}
.             \}
.          \}
.       \}
.    \}
\# Named
.    if \\n[#DOC_TYPE]=3 \{\
.       ie \\n[#COPY_STYLE]=1 \{\
.          ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.          el \{ .PAGENUM_STYLE roman \}
.          ie \\n[#DRAFT_WITH_PAGENUM] \{\
.             ds $HDRFTR_CENTER \\*[$DOC_TYPE]
.          \}
.          el \{\
.             if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.                ie '\\*[$REVISION]'' \{\
.                   ie '\\*[$DRAFT]'' \{\
.                      ds $HDRFTR_CENTER \\*[$DOC_TYPE]
.                   \}
.                   el \{\
.                      ds $HDRFTR_CENTER \
                       \\*[$DOC_TYPE], \
                       \\*[$DRAFT_STRING]\\*[$DRAFT]
.                   \}
.                \}
.                el \{\
.                   ie '\\*[$DRAFT]'' \{\
.                      ds $HDRFTR_CENTER \
                       \\*[$DOC_TYPE], \
                       \\*[$REVISION_STRING] \\*[$REVISION]
.                   \}
.                   el \{\
.                      ds $HDRFTR_CENTER \
                       \\*[$DOC_TYPE], \
                       \\*[$DRAFT_STRING]\\*[$DRAFT], \
                       \\*[$REVISION_STRING] \\*[$REVISION]
.                   \}
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.             el \{ .PAGENUM_STYLE DIGIT \}
.             ds $HDRFTR_CENTER \\*[$DOC_TYPE]
.          \}
.       \}
.    \}
.END
\#
\# ====================================================================
\#
\# +++COLLECT DOC INFO -- STRINGS AND NUMBER REGISTERS+++
\#
\# *Arguments:
\#   various string/register arguments
\# *Function:
\#   Collect information about documents.
\#
\#
.MAC DOC_TITLE END
.    ds $DOC_TITLE \\$1
.END
\#
.MAC TITLE END \"Document title
.    ds $TITLE \\$1
.END
\#
\#
.MAC SUBTITLE END \"Document sub-title
.    ds $SUBTITLE \\$1
.END
\#
\#
.MAC CHAPTER END \"If document is a chapter, the chapter number
.    ds $CHAPTER \\$1
.END
\#
\#
.MAC CHAPTER_TITLE END \" This defines what comes after Chapter #
.    ds $CHAPTER_TITLE \\$1
.END
\#
\#
.MAC DRAFT END \"Draft number
.    ie '\\$1'' \{ .ds $DRAFT \}
.    el         \{ .ds $DRAFT " \\$1\}
.END
\#
\#
.MAC REVISION END \"Revision number
.    ds $REVISION \\$1
.END
\#
\#
.MAC DRAFT_WITH_PAGENUMBER END \"Attach draft/revision strings to page number
.    nr #DRAFT_WITH_PAGENUM 1
.END
\#
\#
.MAC AUTHOR END \"Author.  Enclose all args fully in double quotes.
.    nr #AUTHOR_NUM -1 1
.    while \\n[#NUM_ARGS]>\\n[#AUTHOR_NUM] \{\
.       ds $AUTHOR_\\n+[#AUTHOR_NUM] \\$\\n[#AUTHOR_NUM]
.    \}
.    nr #NUM_AUTHORS \\n[#NUM_ARGS]%2 \"Use mod 2 to test if odd or even # of authors
.    ie \\n[#NUM_AUTHORS]=1 \{ .nr #AUTHOR_LINES 0  \}
.    el \{ .nr #AUTHOR_LINES 1 \}
.END
\#
\#
.MAC PAGENUMBER END \"Page # that appears on page one.
.    nr #n%_AT_PAGENUM_SET \\n%
.    nr #PAGE_NUM_ADJ \\$1-\\n[#n%_AT_PAGENUM_SET]
.    rr #n%_AT_PAGENUM_SET
.    nr #PAGE_NUM_SET 1
.END
\#
\# ====================================================================
\#
\# +++TYPE OF DOCUMENT+++
\#
\# DOCUMENT TYPE
\# -------------
\# *Argument:
\#   DEFAULT | CHAPTER | NAMED "<whatever> | LETTER
\# *Function:
\#   Creates strings and sets registers for document types.
\# *Notes:
\#   Number registers: DEFAULT=1, CHAPTER=2, NAMED=3, LETTER=4
\#
.MAC DOCTYPE END
.    if '\\$1'DEFAULT' \{\
.       nr #DOC_TYPE 1
.    \}
.    if '\\$1'CHAPTER' \{\
.       nr #DOC_TYPE 2
.    \}
.    if '\\$1'NAMED' \{\
.       ds $DOC_TYPE \\$2
.       nr #DOC_TYPE 3
.    \}
.    if '\\$1'LETTER' \{\
.       nr #DOC_TYPE 4
.       L_MARGIN 1.125i
.       R_MARGIN 1.125i
.       PT_SIZE 12
.       LS 13.5
.       DOCHEADER OFF
.       PARA_INDENT 3m
.       INDENT_FIRST_PARAS
.       PARA_SPACE
.       ds $SUITE \En[#SUITE]
.       HEADER_MARGIN 3P+6p
.       HEADER_GAP 3P
.       FOOTERS
.       FOOTER_RULE OFF
.       FOOTER_LEFT ""
.       FOOTER_CENTER ""
.       FOOTER_RIGHT_SIZE +0
.       FOOTER_RIGHT "\&.../\E*[$SUITE]
.       FOOTER_ON_FIRST_PAGE
.       em ALL_DONE
.    \}
.END
\#
\# +++LETTER MACROS+++
\#
\# First, create a register to hold incrementing numbers to be
\# appended to LETTERHEAD.
\#
.nr #FIELD 0 1
\#
\# DATE
\# ----
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores date (entered on the line after .DATE) in diversion
\#   LETTERHEAD<n>
\#
.MAC DATE END
.    if !'\\n(.z'' \{ .di \}
.    di LETTERHEAD\\n+[#FIELD]
.    ie \\n[#FIELD]=1 \{\
.       nr #DATE_FIRST 1
.       RIGHT
.    \}
.    el \{\
.       LEFT
.    \}
.END
\#
\#
\# TO
\# --
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores addressee address (entered on the line after .TO) in
\#   diversion LETTERHEAD<n>
\#
.MAC TO END
.    if !'\\n(.z'' \{ .di \}
.    di LETTERHEAD\\n+[#FIELD]
.    LEFT
.END
\#
\#
\# FROM
\# ----
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores addresser address (entered on the line after .FROM) in
\#   diversion LETTERHEAD<n>
\#
.MAC FROM END
.    if !'\\n(.z'' \{ .di \}
.    di LETTERHEAD\\n+[#FIELD]
.    LEFT
.END
\#
\#
\# GREETING
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores greeting (entered on the line after .GREETING) in
\#   diversion LETTERHEAD<n>
\#
.MAC GREETING END
.    if !'\\n(.z'' \{ .di \}
.    di LETTERHEAD\\n+[#FIELD]
.    LEFT
.END
\#
\#
\# CLOSING
\# -------
\# *Arguments:
\#   <closing string>
\# *Function:
\#   Stores greeting in diversion CLOSING.
\#
.MAC CLOSING END
.    br
.    nr #CLOSING 1
.    di CLOSING
.    LEFT
.END
\#
\#
\# NO SUITE
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Redefines $FOOTER_RIGHT to blank so that a suite number doesn't
\#   appear at the bottom of letter pages.
\#
.MAC NO_SUITE END
.    FOOTER_RIGHT ""
.END
\#
\# ====================================================================
\#
\# +++DEFAULTS+++
\#
\# DEFAULTS
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Sets up defaults if no values are entered prior to START.
\# *Notes:
\#   The defaults for $CHAPTER_STRING, $DRAFT_STRING, and
\#   $REVISION_STRING are in the COPYSTYLE macro.
\#
.MAC DEFAULTS END
.    if !d$PAPER \{ .PAPER LETTER \}
.    if !\\n[#DOC_TYPE]   \{ .DOCTYPE DEFAULT \}
.    ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.    el \{\
.       if !\\n[#COPY_STYLE]=1 \{ .PAGENUM_STYLE DIGIT \}
.    \}
.    if !\\n[#COPY_STYLE] \{ .COPYSTYLE FINAL \}
.    if \\n[#DRAFT_WITH_PAGENUM] \{ .COPYSTYLE \\*[$COPY_STYLE] \}
.    if \\n[#DOC_TYPE]=4 \{\
.       if !\\n[#USER_SET_L_LENGTH] \{\
.          R_MARGIN \\n[#R_MARGIN]u
.          rr #USER_SET_L_LENGTH
.       \}
.       if \\n[#PRINT_STYLE]=1 \{ .PRINTSTYLE TYPEWRITE SINGLESPACE \}
.    \}
.    if \\n[#COPY_STYLE]=1 \{\
.       COPYSTYLE DRAFT
.       PAGENUMBER 1
.    \}
.    if !r#DOC_HEADER \{ .DOCHEADER  \}
.    if !r#HEADERS_ON \{ .HEADERS    \}
.    if !r#PAGINATE   \{ .PAGINATE   \}
.    if \\n[#FOOTERS_ON] \{\
.       HEADERS OFF
.       if \\n[#PAGE_NUM_POS_SET]=0 \{ .PAGENUM_POS TOP CENTER \}
.    \}
.    if !r#HEADER_MARGIN \{ .HEADER_MARGIN 4P+6p \}
.    if !r#HEADER_GAP    \{ .HEADER_GAP    3P    \}
.    if \\n[#FOOTERS_ON] \{\
.       if \\n[#PAGINATE]=0 \{\
.          if !r#T_MARGIN \{ .T_MARGIN 6P \}
.       \}
.    \}
.    if \\n[#HEADERS_ON]=0    \{\
.       if \\n[#FOOTERS_ON]=0 \{\
.          if !r#T_MARGIN \{ .T_MARGIN 6P \}
.       \}
.    \}
.    if !r#T_MARGIN          \{ .T_MARGIN \\n[#HEADER_MARGIN]+\\n[#HEADER_GAP] \}
.    if !r#DOCHEADER_ADVANCE \{ .DOCHEADER_ADVANCE \\n[#T_MARGIN] \}
.    if !r#FOOTER_MARGIN     \{ .FOOTER_MARGIN 3P \}
.    if !r#FOOTER_GAP        \{ .FOOTER_GAP    3P \}
.    if !r#B_MARGIN          \{ .B_MARGIN \\n[#FOOTER_MARGIN]u+\\n[#FOOTER_GAP]u \}
.    if (\\n[#FOOTER_MARGIN]+\\n(.v)>\\n[#B_MARGIN] \{\
.       tm1 "[mom]: Your chosen bottom margin for running text is too close to the footer margin.
.       tm1 "       No footers or bottom-of-page page numbers will be printed.
.       tm1 "       Please reset B_MARGIN or FOOTER_MARGIN to allow enough space.
.       tm1 "       If no footers or bottom-of-page page numbers are required,
.       tm1 "       place .FOOTER_MARGIN 0 before .START
.    \}
.    if !r#HDRFTR_RULE_GAP   \{\
.       if \\n[#HEADERS_ON]  \{ .HDRFTR_RULE_GAP 4p \}
.       if \\n[#FOOTERS_ON]  \{ .HDRFTR_RULE_GAP 4p \}
.    \}
.    if !r#HDRFTR_RULE       \{ .HDRFTR_RULE        \}
.    if !r#PAGE_NUM_SET      \{ .PAGENUMBER 1       \}
.    ie r#ADJ_DOC_LEAD \{ . \}
.    el \{ .DOC_LEAD_ADJUST \}
\# Read in number registers and strings for type parameters
.    nr #DOC_L_MARGIN \\n[#L_MARGIN]
.    nr #DOC_L_LENGTH \\n[#L_LENGTH]
.    nr #DOC_R_MARGIN \\n[#PAGE_WIDTH]-(\\n[#DOC_L_MARGIN]+\\n[#L_LENGTH])
.    ds $DOC_FAM      \\*[$FAMILY]
.    nr #DOC_PT_SIZE  \\n[#PT_SIZE]
.    nr #DOC_LEAD     \\n[#LEAD]
.    ds $DOC_QUAD     \\*[$QUAD_VALUE]
.    ds $PP_FT        \\*[$FONT]
\# Counters
.    nr #PP 0
.    nr #FN_NUMBER 0 1
.    nr #EN_NUMBER 0 1
.    nr #FN_COUNT_FOR_COLS 0 1
.    RESET_HEAD_NUMBER
.    RESET_SUBHEAD_NUMBER
.    RESET_PARAHEAD_NUMBER
\# General style defaults for both PRINTSTYLEs
.    nr #PP_STYLE 1
.    PARA_INDENT \\n[#PP_INDENT]u
.    if !d$HDRFTR_FAM           \{ .HDRFTR_FAMILY  \\*[$DOC_FAM] \}
.    if !d$HDRFTR_SIZE_CHANGE   \{ .HDRFTR_SIZE    +0            \}
.    if !d$PAGE_NUM_FAM         \{ .PAGENUM_FAMILY \\*[$DOC_FAM] \}
.    if !d$PAGE_NUM_FT          \{ .PAGENUM_FONT   R             \}
.    if !d$PAGE_NUM_SIZE_CHANGE \{ .PAGENUM_SIZE   +0            \}
.    if !r#PAGE_NUM_POS_SET     \{ .PAGENUM_POS BOTTOM CENTER    \}
.    ie \\n[#PAGE_NUM_HYPHENS_SET] \{\
.       if \\n[#PAGE_NUM_HYPHENS]=0  \{ .PAGENUM_HYPHENS OFF \}
.       if \\n[#PAGE_NUM_HYPHENS]=1  \{ .PAGENUM_HYPHENS     \}
.    \}
.    el \{ .PAGENUM_HYPHENS \}
.    if !d$HEAD_QUAD         \{ .HEAD_QUAD CENTER  \}
.    if !r#HEAD_CAPS         \{ .HEAD_CAPS         \}
.    if !r#HEAD_UNDERLINE    \{ .HEAD_UNDERLINE    \}
.    if !d$SH_QUAD           \{ .SUBHEAD_QUAD LEFT \}
.    if !r#HDRFTR_RIGHT_CAPS \{ .HDRFTR_RIGHT_CAPS \}
.    if \\n[#HDRFTR_RIGHT_CAPS]=0 \{\
.       if !d$HDRFTR_RIGHT_SIZE_CHANGE \{ .HDRFTR_RIGHT_SIZE +0 \}
.    \}
.    if !d$FN_FAM          \{ .FOOTNOTE_FAMILY \\*[$DOC_FAM] \}
.    if !d$FN_FT           \{ .FOOTNOTE_FONT R               \}
.    if !d$FN_QUAD         \{ .FOOTNOTE_QUAD \\*[$DOC_QUAD]  \}
.    if !r#FN_RULE         \{ .FOOTNOTE_RULE                 \}
.    if !r#FN_MARKERS      \{ .FOOTNOTE_MARKERS              \}
.    if !r#FN_MARKER_STYLE \{ .FOOTNOTE_MARKER_STYLE STAR    \}
.    if !d$EN_PN_STYLE          \{ .ENDNOTES_PAGENUM_STYLE digit        \}
.    if !d$EN_FAM               \{ .ENDNOTE_FAMILY \\*[$DOC_FAM]        \}
.    if !d$EN_FN                \{ .ENDNOTE_FONT R                      \}
.    if !d$EN_QUAD              \{ .ENDNOTE_QUAD \\*[$DOC_QUAD]         \}
.    if !d$EN_STRING            \{ .ENDNOTE_STRING "Endnotes"           \}
.    if !d$EN_STRING_FAM        \{ .ENDNOTE_STRING_FAMILY \\*[$EN_FAM]  \}
.    if !d$EN_STRING_QUAD       \{ .ENDNOTE_STRING_QUAD CENTER          \}
.    if !r#EN_STRING_UNDERSCORE \{ .ENDNOTE_STRING_UNDERSCORE 2         \}
.    if !r#EN_STRING_CAPS       \{ .ENDNOTE_STRING_CAPS                 \}
.    if !d$EN_TITLE \{\
.       ie \\n[#DOC_TYPE]=2 \{\
.          ie '\\*[$CHAPTER]'' \{ .ENDNOTE_TITLE "\\*[$CHAPTER_STRING]" \}
.          el \{ .ENDNOTE_TITLE "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"    \}
.       \}
.       el \{ .ENDNOTE_TITLE "\\*[$TITLE]" \}
.    \}
.    if !d$EN_TITLE_FAM          \{ .ENDNOTE_TITLE_FAMILY \\*[$EN_FAM]  \}
.    if !d$EN_TITLE_QUAD         \{ .ENDNOTE_TITLE_QUAD LEFT            \}
.    if !r#EN_TITLE_UNDERSCORE   \{ .ENDNOTE_TITLE_UNDERSCORE           \}
.    if !d$EN_NUMBER_FAM         \{ .ENDNOTE_NUMBER_FAMILY \\*[$EN_FAM] \}
.    if !r#EN_NUMBERS_ALIGN_LEFT  \{\
.       if !r#EN_NUMBERS_ALIGN_RIGHT \{ .ENDNOTE_NUMBERS_ALIGN_RIGHT 2  \}
.    \}
.    if !d$TOC_HEADER_STRING         \{ .TOC_HEADER_STRING "Contents"  \}
.    if !d$TOC_HEADER_QUAD           \{ .TOC_HEADER_QUAD LEFT          \}
.    if !d$TOC_PN_STYLE              \{ .TOC_PAGENUM_STYLE roman       \}
.    if !r#TOC_PN_PADDING            \{ .TOC_PADDING   3               \}
.    if !r#TOC_TITLE_INDENT          \{ .TOC_TITLE_INDENT    0         \}
.    if !r#TOC_HEAD_INDENT           \{ .TOC_HEAD_INDENT     18p       \}
.    if !r#TOC_SH_INDENT             \{ .TOC_SUBHEAD_INDENT  30p       \}
.    if !r#TOC_PH_INDENT             \{ .TOC_PARAHEAD_INDENT 42p       \}
\# String defaults for both PRINTSTYLEs
.    ie \\n[#DOC_TYPE]=1 \{\
.       ie '\\*[$DOC_TITLE]'' \{\
.          if \\n[#USER_DEF_HDRFTR_LEFT]=0   \{ .ds $HDRFTR_LEFT  \\*[$AUTHOR_1]  \}
.          rr #USER_DEF_HDRFTR_LEFT
.          if \\n[#USER_DEF_HDRFTR_RIGHT]=0  \{ .ds $HDRFTR_RIGHT \\*[$TITLE]     \}
.          rr #USER_DEF_HDRFTR_RIGHT
.       \}
.       el \{\
.          if \\n[#COPY_STYLE]=1 \{ .DRAFT_WITH_PAGENUMBER \}
.          if \\n[#USER_DEF_HDRFTR_LEFT]=0   \{ .ds $HDRFTR_LEFT  \\*[$AUTHOR_1]  \}
.          rr #USER_DEF_HDRFTR_LEFT
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{ .ds $HDRFTR_CENTER \\*[$TITLE]    \}
.          rr #USER_DEF_HDRFTR_CENTER
.          if \\n[#USER_DEF_HDRFTR_RIGHT]=0  \{ .ds $HDRFTR_RIGHT \\*[$DOC_TITLE] \}
.          rr #USER_DEF_HDRFTR_RIGHT
.       \}
.    \}
.    el \{\
.       if \\n[#USER_DEF_HDRFTR_LEFT]=0   \{ .ds $HDRFTR_LEFT  \\*[$AUTHOR_1]  \}
.       rr #USER_DEF_HDRFTR_LEFT
.       if \\n[#USER_DEF_HDRFTR_RIGHT]=0  \{ .ds $HDRFTR_RIGHT \\*[$TITLE]     \}
.       rr #USER_DEF_HDRFTR_RIGHT
.    \}
.    if !d$ATTRIBUTE_STRING           \{ .ATTRIBUTE_STRING "by"            \}
.    if !d$FINIS_STRING               \{ .FINIS_STRING "END"               \}
\# Defaults for printstyle TYPEWRITE
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#UNDERLINE_QUOTES]=1 \{ .UNDERLINE_QUOTES         \}
.       if \\n[#UNDERLINE_QUOTES]=0 \{ .UNDERLINE_QUOTES OFF     \}
.       if !r#Q_OFFSET_VALUE        \{ .QUOTE_INDENT      2      \}
.       if !r#EPI_OFFSET_VALUE      \{ .EPIGRAPH_INDENT   2      \}
.       if !d$LINEBREAK_CHAR        \{ .LINEBREAK_CHAR    * 3 2p \}
.       if !d$FN_SIZE_CHANGE        \{ .FOOTNOTE_SIZE     +0     \}
.       if !r#FN_RULE_LENGTH        \{ .FOOTNOTE_RULE_LENGTH 2i  \}
.       if !r#FN_RULE_ADJ           \{ .FOOTNOTE_RULE_ADJ  6p    \}
.       if !r#SLANT_MEANS_SLANT \{\
.          ie \\n[#UNDERLINE_SLANT]=1 \{ .UNDERLINE_SLANT \}
.          el \{ .UNDERLINE_SLANT OFF \}
.       \}
.       if !r#PH_INDENT    \{ .PARAHEAD_INDENT \\n[#PP_INDENT]u/2u \}
.       if !r#EN_PP_INDENT \{ .ENDNOTE_PARA_INDENT \\n[#PP_INDENT] \}
.    \}
\# Defaults for printstyle TYPESET
.    if \\n[#PRINT_STYLE]=2 \{\
.       if !d$DOCHEADER_LEAD_ADJ \{\
.          ie !'\\*[$CHAPTER_TITLE]'' \{\
.             ie !'\\*[$CHAPTER_STRING]'' \{\
.                DOCHEADER_LEAD +4
.             \}
.             el \{ .DOCHEADER_LEAD +0 \}
.          \}
.          el \{ .DOCHEADER_LEAD +0 \}
.       \}
.       if !d$TITLE_FAM     \{ .TITLE_FAMILY   \\*[$DOC_FAM] \}
.       if !d$TITLE_FT      \{ .TITLE_FONT     B             \}
.       if !d$TITLE_SIZE_CHANGE \{\
.          ie \\n[#DOC_TYPE]=2 \{ .TITLE_SIZE +4 \}
.          el \{ .TITLE_SIZE +3.5 \}
.       \}
.       if !d$CHAPTER_TITLE_FAM         \{ .CHAPTER_TITLE_FAMILY \\*[$DOC_FAM] \}
.       if !d$CHAPTER_TITLE_FT          \{ .CHAPTER_TITLE_FONT   BI            \}
.       if !d$CHAPTER_TITLE_SIZE_CHANGE \{ .CHAPTER_TITLE_SIZE  +4             \}
.       if !d$SUBTITLE_FAM         \{ .SUBTITLE_FAMILY    \\*[$DOC_FAM] \}
.       if !d$SUBTITLE_FT          \{ .SUBTITLE_FONT      R             \}
.       if !d$SUBTITLE_SIZE_CHANGE \{ .SUBTITLE_SIZE      +0            \}
.       if !d$AUTHOR_FAM           \{ .AUTHOR_FAMILY      \\*[$DOC_FAM] \}
.       if !d$AUTHOR_FT            \{ .AUTHOR_FONT        I             \}
.       if !d$AUTHOR_SIZE_CHANGE   \{ .AUTHOR_SIZE        +0            \}
.       if !d$DOCTYPE_FAM          \{ .DOCTYPE_FAMILY     \\*[$DOC_FAM] \}
.       if !d$DOCTYPE_FT           \{ .DOCTYPE_FONT       BI            \}
.       if !d$DOCTYPE_SIZE_CHANGE  \{ .DOCTYPE_SIZE       +3            \}
.       if !d$HDRFTR_LEFT_FAM      \{ .HDRFTR_LEFT_FAMILY \\*[$DOC_FAM] \}
.       if !d$HDRFTR_LEFT_FT       \{ .HDRFTR_LEFT_FONT   R             \}
.       if \\n[#HDRFTR_LEFT_CAPS]  \{\
.          if !d$HDRFTR_LEFT_SIZE_CHANGE \{ .HDRFTR_LEFT_SIZE  -2 \}
.       \}
.       if !d$HDRFTR_LEFT_SIZE_CHANGE \{ .HDRFTR_LEFT_SIZE     -.5           \}
.       if !d$HDRFTR_CENTER_FAM       \{ .HDRFTR_CENTER_FAMILY \\*[$DOC_FAM] \}
.       if !d$HDRFTR_CENTER_FT        \{ .HDRFTR_CENTER_FONT   I             \}
.       if \\n[#HDRFTR_CENTER_CAPS] \{\
.          if !d$HDRFTR_CENTER_SIZE_CHANGE \{ .HDRFTR_CENTER_SIZE -2 \}
.       \}
.       if !d$HDRFTR_CENTER_SIZE_CHANGE \{ .HDRFTR_CENTER_SIZE -.5              \}
.       if !d$HDRFTR_RIGHT_FAM          \{ .HDRFTR_RIGHT_FAMILY \\*[$DOC_FAM]   \}
.       if !d$HDRFTR_RIGHT_FT           \{ .HDRFTR_RIGHT_FONT   R               \}
.       if \\n[#HDRFTR_RIGHT_CAPS] \{\
.          if !d$HDRFTR_RIGHT_SIZE_CHANGE \{ .HDRFTR_RIGHT_SIZE -2 \}
.       \}
.       if !d$HDRFTR_RIGHT_SIZE_CHANGE  \{ .HDRFTR_RIGHT_SIZE  -.5              \}
.       if !d$HEAD_FAM                  \{ .HEAD_FAMILY        \\*[$DOC_FAM]    \}
.       if !d$HEAD_FT                   \{ .HEAD_FONT          B                \}
.       if !d$HEAD_SIZE_CHANGE          \{ .HEAD_SIZE          +1               \}
.       if !r#HEAD_SPACE                \{ .HEAD_SPACE                          \}
.       if !d$SH_FAM                    \{ .SUBHEAD_FAMILY     \\*[$DOC_FAM]    \}
.       if !d$SH_FT                     \{ .SUBHEAD_FONT       B                \}
.       if !d$SH_SIZE_CHANGE            \{ .SUBHEAD_SIZE       +.5              \}
.       if !d$PH_FAM                    \{ .PARAHEAD_FAMILY    \\*[$DOC_FAM]    \}
.       if !d$PH_FT                     \{ .PARAHEAD_FONT      BI               \}
.       if !d$PH_SIZE_CHANGE            \{ .PARAHEAD_SIZE      -.25             \}
.       if !r#PH_INDENT                 \{ .PARAHEAD_INDENT \\n[#PP_INDENT]u/2u \}
.       if !d$QUOTE_FAM                 \{ .QUOTE_FAMILY       \\*[$DOC_FAM]    \}
.       if !d$QUOTE_FT                  \{ .QUOTE_FONT         I                \}
.       if !d$QUOTE_SIZE_CHANGE         \{ .QUOTE_SIZE         +0               \}
.       if !r#Q_OFFSET_VALUE            \{ .QUOTE_INDENT       3                \}
.       if !d$BQUOTE_FAM                \{ .BLOCKQUOTE_FAMILY  \\*[$DOC_FAM]    \}
.       if !d$BQUOTE_FT                 \{ .BLOCKQUOTE_FONT    R                \}
.       if !d$BQUOTE_SIZE_CHANGE        \{ .BLOCKQUOTE_SIZE    -1               \}
.       if !d$BQUOTE_QUAD               \{ .BLOCKQUOTE_QUAD    LEFT             \}
.       if !d$EPI_FAM                   \{ .EPIGRAPH_FAMILY    \\*[$DOC_FAM]    \}
.       if !d$EPI_FT                    \{ .EPIGRAPH_FONT      R                \}
.       if !d$EPI_SIZE_CHANGE           \{ .EPIGRAPH_SIZE      -1.5             \}
.       if !r#EPI_AUTOLEAD              \{ .EPIGRAPH_AUTOLEAD  2                \}
.       if !d$EPI_QUAD                  \{ .EPIGRAPH_QUAD      \\*[$DOC_QUAD]   \}
.       if !r#EPI_OFFSET_VALUE          \{ .EPIGRAPH_INDENT    3                \}
.       if !d$LINEBREAK_CHAR            \{ .LINEBREAK_CHAR     * 3 3p           \}
.       if !r#FN_RULE_LENGTH            \{ .FOOTNOTE_RULE_LENGTH 4P             \}
.       if !r#FN_RULE_ADJ               \{ .FOOTNOTE_RULE_ADJ  3p               \}
.       if !d$FN_SIZE_CHANGE            \{ .FOOTNOTE_SIZE      -2               \}
.       if !r#FN_AUTOLEAD               \{ .FOOTNOTE_AUTOLEAD  2                \}
.       if !r#EN_PS                     \{ .ENDNOTE_PT_SIZE \\n[#DOC_PT_SIZE]u  \}
.       if !d$EN_LEAD                   \{ .ENDNOTE_LEAD        14 ADJUST       \}
.       if !d$EN_STRING_FT              \{ .ENDNOTE_STRING_FONT B               \}
.       if !d$EN_STRING_SIZE_CHANGE     \{ .ENDNOTE_STRING_SIZE +1              \}
.       if !d$EN_TITLE_FT               \{ .ENDNOTE_TITLE_FONT  B               \}
.       if !d$EN_TITLE_SIZE_CHANGE      \{ .ENDNOTE_TITLE_SIZE  +0              \}
.       if !d$EN_NUMBER_FT              \{ .ENDNOTE_NUMBER_FONT B               \}
.       if !d$EN_NUMBER_SIZE_CHANGE      \{ .ENDNOTE_NUMBER_SIZE +0              \}
.       if !r#EN_PP_INDENT              \{ .ENDNOTE_PARA_INDENT 1.5m            \}
.       if !d$TOC_FAM                   \{ .TOC_FAMILY  \\*[$DOC_FAM]           \}
.       if !r#TOC_PS                    \{ .TOC_PT_SIZE \\n[#DOC_PT_SIZE]u      \}
.       if !r#TOC_LEAD                  \{ .TOC_LEAD    \\n[#DOC_LEAD]u ADJUST  \}
.       if !d$TOC_HEADER_FAM            \{ .TOC_HEADER_FAMILY \\*[$TOC_FAM]     \}
.       if !d$TOC_HEADER_SIZE_CHANGE    \{ .TOC_HEADER_SIZE  +4                 \}
.       if !d$TOC_HEADER_FT             \{ .TOC_HEADER_FONT   B                 \}
.       if !d$TOC_TITLE_FAM             \{ .TOC_TITLE_FAMILY \\*[$TOC_FAM]      \}
.       if !d$TOC_PN_FAM                \{ .TOC_PN_FAMILY \\*[$TOC_FAM]         \}
.       if !d$TOC_HEAD_FAM              \{ .TOC_HEAD_FAMILY \\*[$TOC_FAM]       \}
.       if !d$TOC_SH_FAM                \{ .TOC_SUBHEAD_FAMILY \\*[$TOC_FAM]    \}
.       if !d$TOC_PH_FAM                \{ .TOC_PARAHEAD_FAMILY \\*[$TOC_FAM]   \}
.       if !d$TOC_TITLE_FT              \{ .TOC_TITLE_FONT   BI                 \}
.       if !d$TOC_PN_FT                 \{ .TOC_PN_FONT   R                     \}
.       if !d$TOC_HEAD_FT               \{ .TOC_HEAD_FONT   B                   \}
.       if !d$TOC_SH_FT                 \{ .TOC_SUBHEAD_FONT   R                \}
.       if !d$TOC_PH_FT                 \{ .TOC_PARAHEAD_FONT   I               \}
.       if !d$TOC_TITLE_SIZE_CHANGE     \{ .TOC_TITLE_SIZE   +.5                \}
.       if !d$TOC_PN_SIZE_CHANGE        \{ .TOC_PN_SIZE  +0                     \}
.       if !d$TOC_HEAD_SIZE_CHANGE      \{ .TOC_HEAD_SIZE  +.5                  \}
.       if !d$TOC_SH_SIZE_CHANGE        \{ .TOC_SUBHEAD_SIZE  +0                \}
.       if !d$TOC_PH_SIZE_CHANGE        \{ .TOC_PARAHEAD_SIZE  +0               \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#ADJ_DOC_LEAD]=1 \{ .DOC_LEAD_ADJUST \}
.       el \{ . \}
.    \}
.    if !\\n[#COLLATE] \{\
.       TRAPS
\# Endnote and toc leading
.       nr #OK_PROCESS_LEAD 1
.       nr #RESTORE_DOC_LEAD \\n(.v
.       if \\n[#PRINT_STYLE]=1 \{\
.          ie \\n[#SINGLE_SPACE] \{\
.             ENDNOTE_LEAD 12 ADJUST
.          \}
.          el \{\
.             ie \\n[#EN_SINGLESPACE] \{ .ENDNOTE_LEAD 12 ADJUST \}
.             el \{ .ENDNOTE_LEAD 24 ADJUST \}
.          \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          ie !d$EN_LEAD \{ .ENDNOTE_LEAD 14 ADJUST \}
.          el \{ .ENDNOTE_LEAD \\*[$EN_LEAD] \\*[$ADJUST_EN_LEAD] \}
.          ie !d$TOC_LEAD \{ .TOC_LEAD \\n[#RESTORE_DOC_LEAD]u \}
.          el \{ .TOC_LEAD \\*[$TOC_LEAD] \\*[$ADJUST_TOC_LEAD] \}
.          rm $ADJUST_EN_LEAD
.          rm $ADJUST_TOC_LEAD
.       \}
.       DOC_LEAD \\n[#RESTORE_DOC_LEAD]u
.    \}
.    if \\n[#PRINT_STYLE]=1 \{ .nr #IGNORE 1 \}
.END
\#
\# ====================================================================
\#
\# +++START THE DOCUMENT+++
\#
\# THE START MACRO
\# ---------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Reads in default document style parameters and any parameter
\#   the user has changed before issuing START.
\#   Using the information gathered in the opening macros,
\#   prints appropriate title (or chapter #), subtitle, author
\#   and document type (if appropriate).
\# *Notes:
\#   The .PRINT \& (zero-width character) is required to get the
\#   subsequent .sp request to work as advertised.
\#
\#   The overall document line length, family, and point-size
\#   are stored in #DOC_L_LENGTH, $DOC_FAM, and #DOC_PT_SIZE for
\#   use in the HEADER and FOOTER macros.
\#
\#  First, define some strings for point sizes
\#
.ds $TITLE_PT_SIZE         \\n[#DOC_PT_SIZE]u\\*[$TITLE_SIZE_CHANGE]
.ds $CHAPTER_TITLE_PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$CHAPTER_TITLE_SIZE_CHANGE]
.ds $SUBTITLE_PT_SIZE      \\n[#DOC_PT_SIZE]u\\*[$SUBTITLE_SIZE_CHANGE]
.ds $AUTHOR_PT_SIZE        \\n[#DOC_PT_SIZE]u\\*[$AUTHOR_SIZE_CHANGE]
.ds $DOCTYPE_PT_SIZE       \\n[#DOC_PT_SIZE]u\\*[$DOCTYPE_SIZE_CHANGE]
\#
\# Next, some utility macros for various routines to prevent repetition
\#
.MAC PRINT_AUTHORS END
.    nr #AUTHORS \\n[#AUTHOR_NUM]
.    nr #NEXT_AUTHOR 0 1
.    while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.       ie \\n[#AUTHOR_COLOR]=1 \{\
.          PRINT \m[\\*[$AUTHOR_COLOR]]\\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]\m[]
.       \}
.       el \{ .PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]] \}
.    \}
.END
\#
.MAC DEFAULT_DOCHEADER END
.    CENTER
.    FAMILY  \\*[$TITLE_FAM]
.    FT      \\*[$TITLE_FT]
.    PT_SIZE \\*[$TITLE_PT_SIZE]
.    LS      \\n[#DOCHEADER_LEAD]u
.    ie \\n[#TITLE_COLOR]=1 \{\
.       PRINT \m[\\*[$TITLE_COLOR]]\\*[$TITLE]\m[]
.    \}
.    el \{ .PRINT \\*[$TITLE] \}
.    if !'\\*[$SUBTITLE]'' \{\
.       FAMILY  \\*[$SUBTITLE_FAM]
.       FT      \\*[$SUBTITLE_FT]
.       PT_SIZE \\*[$SUBTITLE_PT_SIZE]
.       ie \\n[#SUBTITLE_COLOR]=1 \{\
.          PRINT \m[\\*[$SUBTITLE_COLOR]]\\*[$TITLE]\m[]
.       \}
.       el \{ .PRINT \\*[$SUBTITLE] \}
.    \}
.    if !'\\*[$AUTHOR_1]'' \{\
.       FAMILY  \\*[$AUTHOR_FAM]
.       FT      \\*[$AUTHOR_FT]
.       PT_SIZE \\*[$AUTHOR_PT_SIZE]
.       if !'\\*[$ATTRIBUTE_STRING]'' \{\
.          ie \\n[#ATTRIBUTE_COLOR]=1 \{\
.             PRINT \m[\\*[$ATTRIBUTE_COLOR]]\\*[$ATTRIBUTE_STRING]\m[]
.          \}
.          el \{ .PRINT \\*[$ATTRIBUTE_STRING] \}
.       \}
.       PRINT_AUTHORS
.    \}
.END
\#
\#
.MAC CHAPTER_DOCHEADER END
.    CENTER
.    FAMILY  \\*[$TITLE_FAM]
.    FT      \\*[$TITLE_FT]
.    PT_SIZE \\*[$TITLE_PT_SIZE]
.    LS      \\n[#DOCHEADER_LEAD]u
\# Chapter title only
.    ie '\\*[$CHAPTER]'' \{\
.       ie !'\\*[$CHAPTER_TITLE]'' \{\
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$CHAPTER_TITLE_FAM]
.             FT      \\*[$CHAPTER_TITLE_FT]
.             PT_SIZE \\*[$CHAPTER_TITLE_PT_SIZE]
.             LS      \\n[#DOCHEADER_LEAD]u
.          \}
.          ie \\n[#TITLE_COLOR]=1 \{\
.             PRINT \m[\\*[$TITLE_COLOR]]\\*[$CHAPTER_TITLE]\m[]
.          \}
.          el \{ .PRINT \\*[$CHAPTER_TITLE] \}
.       \}
.       el \{\
.          ie \\n[#TITLE_COLOR]=1 \{\
.             PRINT \m[\\*[$TITLE_COLOR]]\\*[$CHAPTER_STRING]\m[]
.          \}
.          el \{ .PRINT \\*[$CHAPTER_STRING] \}
.       \}
.    \}
\# Chapter string, possibly with a chapter title
.    el \{\
.       ie \\n[#TITLE_COLOR]=1 \{\
.          PRINT \m[\\*[$TITLE_COLOR]]\\*[$CHAPTER_STRING] \\*[$CHAPTER]\m[]
.       \}
.       el \{ .PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER] \}
.       if !'\\*[$CHAPTER_TITLE]'' \{\
.          if \\n[#PRINT_STYLE]=1 \{ .PRINT \\*[$CHAPTER_TITLE] \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$CHAPTER_TITLE_FAM]
.             FT      \\*[$CHAPTER_TITLE_FT]
.             PT_SIZE \\*[$CHAPTER_TITLE_PT_SIZE]
.             LS      \\n[#DOCHEADER_LEAD]u
.             ie \\n[#TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$TITLE_COLOR]]\\*[$CHAPTER_TITLE]\m[]
.             \}
.             el \{ .PRINT \\*[$CHAPTER_TITLE] \}
.             RLD \\n[#DOC_LEAD]u \" Just looks better this way
.          \}
.       \}
.    \}
.END
\#
\#
.MAC NAMED_DOCHEADER END
.    CENTER
.    FAMILY  \\*[$TITLE_FAM]
.    FT      \\*[$TITLE_FT]
.    PT_SIZE \\*[$TITLE_PT_SIZE]
.    LS      \\n[#DOCHEADER_LEAD]u
.    ie \\n[#TITLE_COLOR]=1 \{\
.       PRINT \m[\\*[$TITLE_COLOR]]\\*[$TITLE]\m[]
.    \}
.    el \{ .PRINT \\*[$TITLE] \}
.    if !'\\*[$SUBTITLE]'' \{\
.       FAMILY  \\*[$SUBTITLE_FAM]
.       FT      \\*[$SUBTITLE_FT]
.       PT_SIZE \\*[$SUBTITLE_PT_SIZE]
.       ie \\n[#SUBTITLE_COLOR]=1 \{\
.          PRINT \m[\\*[$SUBTITLE_COLOR]]\\*[$TITLE]\m[]
.       \}
.       el \{ .PRINT \\*[$SUBTITLE] \}
.    \}
.    if !'\\*[$AUTHOR_1]'' \{\
.       FAMILY  \\*[$AUTHOR_FAM]
.       FT      \\*[$AUTHOR_FT]
.       PT_SIZE \\*[$AUTHOR_PT_SIZE]
.       if !'\\*[$ATTRIBUTE_STRING]'' \{\
.          ie \\n[#ATTRIBUTE_COLOR]=1 \{\
.             PRINT \m[\\*[$ATTRIBUTE_COLOR]]\\*[$ATTRIBUTE_STRING]\m[]
.          \}
.          el \{ .PRINT \\*[$ATTRIBUTE_STRING] \}
.       \}
.       \}
.       PRINT_AUTHORS
.    \}
.    FAMILY  \\*[$DOCTYPE_FAM]
.    FT      \\*[$DOCTYPE_FT]
.    PT_SIZE \\*[$DOCTYPE_PT_SIZE]
.    LS      \\n[#DOCHEADER_LEAD]u
.    ALD     \\n[#DOCHEADER_LEAD]u
.    ie \\n[#DOCTYPE_COLOR]=1 \{\
.       COLOR \\*[$DOCTYPE_COLOR]
.       UNDERSCORE "\\*[$DOC_TYPE]
.    \}
.    el .UNDERSCORE "\\*[$DOC_TYPE]
.END
\#
\#
.MAC START END
.    if !\\n[#PRINT_STYLE] \{\
.       PRINTSTYLE TYPEWRITE
.       PRINT \&
.       po 6P
.       ll 39P
.       ta \\n(.lu
.       sp |1i-1v
.       CENTER
.       PRINT "You neglected to enter a PRINTSTYLE"
.       fl
.       ab PRINTSTYLE missing
.    \}
.    nr #DOCS 1
.    if \\n[#COLLATE] \{\
.       COPYSTYLE \\*[$COPY_STYLE]
.       nr #HEADERS_ON \\n[#HEADER_STATE]
.       if \\n[#PAGE_NUM_V_POS]=1 \{ .nr #PAGINATE \\n[#PAGINATION_STATE] \}
.       sp |\\n[#HEADER_MARGIN]u
.       PRINT \&
.       if !'\\*[$RESTORE_PAGENUM_STYLE]'' \{\
.          PAGENUM_STYLE \\*[$RESTORE_PAGENUM_STYLE]
.          rm $RESTORE_PAGENUM_STYLE
.       \}
.    \}
.    DEFAULTS
\# Collate stuff
.    ie \\n[#COLLATED_DOC]=1 \{\
\# Collect TITLE for TOC.
.       nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.       af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.       ie \\n[#USER_SET_TITLE_ITEM] \{\
.          ds $TOC_TITLE_ITEM \\*[$USER_SET_TITLE_ITEM]\\|
.          rr #USER_SET_TITLE_ITEM
.          rm $USER_SET_TITLE_ITEM
.       \}
.       el \{\
.          ie \\n[#DOC_TYPE]=2 \{\
.             ie '\\*[$CHAPTER_TITLE]'' \{\
.                ds $TOC_TITLE_ITEM \\*[$CHAPTER_STRING] \\*[$CHAPTER]\\|
.             \}
.             el \{\
.                ie '\\*[$CHAPTER]'' \{\
.                   ds $TOC_TITLE_ITEM \\*[$CHAPTER_TITLE]\\|
.                \}
.                el \{\
.                   ds $TOC_TITLE_ITEM \\*[$CHAPTER_STRING] \\*[$CHAPTER]: \\*[$CHAPTER_TITLE]\\|
.                \}
.             \}
.          \}
.          el \{\
.             ds $TOC_TITLE_ITEM \\*[$TITLE]\\|
.          \}
.       \}
.       if \\n[#TOC_AUTHORS]=1 \{\
.          ie '\\*[$TOC_AUTHORS]'' \{\
.             as $TOC_TITLE_ITEM /\\|\\*[$AUTHOR_1]\\|
.          \}
.          el \{\
.             as $TOC_TITLE_ITEM /\\|\\*[$TOC_AUTHORS]\\|
.             rm $TOC_AUTHORS
.          \}
.       \}
\# Note the use of \!, which transparently embeds the macros used
\# in the TOC_ENTRIES diversion.  The elements they control must be
\# processed literally when the diversion is output.
.       ev TOC_EV
.       da TOC_ENTRIES
.       if \\n[#PRINT_STYLE]=1 \{\
\!.        fam C
\!.        ft  R
\!.        ps  12
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
\!.        FAMILY  \\*[$TOC_TITLE_FAM]
\!.        FT      \\*[$TOC_TITLE_FT]
\!.        PT_SIZE \\n[#TOC_PS]u\\*[$TOC_TITLE_SIZE_CHANGE]
.       \}
\!.     TRAP OFF
.       ie \\n[#PRINT_STYLE]=1 \{\
\!.        PAD "\\*[$TOC_TITLE_ITEM]\\*[$TOC_PN_TYPEWRITE]" 
.       \}
.       el \{\
\!.        PAD "\\h'\\n[#TOC_TITLE_INDENT]u'\\*[$TOC_TITLE_ITEM]\\*[$TOC_PN]"
.       \}
\!.    EL
\!.    ST 100 L
\!.    ST 101 R
.      if \\n[#PRINT_STYLE]=2 \{\
\!.       FAMILY  \\*[$TOC_PN_FAM]
\!.       FT      \\*[$TOC_PN_FT]
\!.       PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.      \}
\!.    TAB 100
\!.    PRINT \\*[LEADER]
\!.    TN
\!.    TRAP
\!.    PRINT \\n[#TOC_ENTRY_PN]
\!.    TQ
.      di       
.      ev
.    \}
.    el \{\
.       nr #FIRST_DOC_TITLE_PN \\n%+\\n[#PAGE_NUM_ADJ]
.       af #FIRST_DOC_TITLE_PN \\g[#PAGENUMBER]
.       nr #FIRST_DOC_TOC_PN_PADDING \\n[#TOC_PN_PADDING]
.    \}
\# End TITLE collection
.    if \\n[#PRINT_PAGENUM_ON_PAGE_1] \{\
.       sp |\\n[#HEADER_MARGIN]u
.       PRINT_PAGE_NUMBER
.    \}
.    rr #COLLATE
.    rr #PAGINATION_STATE
\# End collate stuff
.    ie \\n[#DOC_HEADER]=0 \{\
.       PRINT \&
.       if \\n[#DOC_TYPE]=4 \{\
.          if !'\\n(.z'' \{ .di \}
.       \}
.       nr #STORED_PP_INDENT \\n[#PP_INDENT]
.       PARA_INDENT 0
.       PP
.       PARA_INDENT \\n[#STORED_PP_INDENT]u
.       rr #STORED_PP_INDENT
.       ie r#ADVANCE_FROM_TOP \{\
.          sp |\\n[#ADVANCE_FROM_TOP]u-1v
.          SHIM
.       \}
.       el \{ .sp |\\n[#T_MARGIN]u-1v \}
.       if \\n[#COLUMNS] \{\
.          mk dc
.          nr #COL_NUM 0 1
.          po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n(.o
.          ll \\n[#COL_L_LENGTH]u
.       \}
.       nr #PP 0
.       rr #DOC_HEADER
.       if r#ADVANCE_FROM_TOP \{ .rr #ADVANCE_FROM_TOP \}
.    \}
.    el \{\
.       if \\n[#PRINT_STYLE]=2 \{ .LS \\n[#DOC_LEAD]u\\*[$DOCHEADER_LEAD_ADJ] \}
.       nr #DOCHEADER_LEAD \\n[#LEAD]
\# Default
.       if \\n[#DOC_TYPE]=1 \{\
.          PRINT \&
.          sp |\\n[#DOCHEADER_ADVANCE]u-1v
.          ev DOCHEADER
.          if \\n[#DOCHEADER_COLOR]=1 \{\
.             nf
\m[\\*[$DOCHEADER_COLOR]]
.             EL
.          \}
.          L_MARGIN \\n[#DOC_L_MARGIN]u
.          LL       \\n[#DOC_L_LENGTH]u
.          ta \\n(.lu
.          if \\n[#PRINT_STYLE]=1 \{\
.             CENTER
.             fam C
.             ft  R
.             ps  12
.             ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u*2u \}
.             el \{ .vs \\n[#DOC_LEAD]u \}
.             CAPS
.             if !'\\*[$TITLE]'' \{ .UNDERSCORE "\\*[$TITLE]\}
.             CAPS OFF
.             if !'\\*[$SUBTITLE]'' \{\
.                ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u*2u \}
.                el \{ .vs \\n[#DOC_LEAD]u \}
.             PRINT \\*[$SUBTITLE]
.             \}
.             if '\\*[$SUBTITLE]'' \{\
.                ALD \\n[#DOC_LEAD]u
.             \}
.             ie !'\\*[$AUTHOR_1]'' \{\
.                ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u \}
.                el \{ .vs \\n[#DOC_LEAD]u/2u \}
.                if !d$SUBTITLE \{\
.                   ie \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.                   el \{ .ALD \\n[#DOC_LEAD]u*2u \}
.                \}
.                PRINT \\*[$ATTRIBUTE_STRING]
.                nr #AUTHORS \\n[#AUTHOR_NUM]
.                nr #NEXT_AUTHOR 0 1
.                while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.                   PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]
.                \}
.                if \\n[#AUTHOR_LINES]=1 \{\
.                    ie \\n[#SINGLE_SPACE] \{ .RLD \\n[#DOC_LEAD]u \}
.                    el \{ .ALD \\n[#DOC_LEAD]u/2u \}
.                \}
.             \}
.             el \{\
.                ie !d$SUBTITLE \{\
.                   ie \\n[#SINGLE_SPACE] \{ .RLD \\n[#DOC_LEAD]u*2u \}
.                   el \{ .RLD \\n[#DOC_LEAD]u \}
.                \}
.                el \{\
.                   ie \\n[#SINGLE_SPACE] \{ .RLD \\n[#DOC_LEAD]u*2u \}
.                   el \{ .ALD \\n[#DOC_LEAD]u \}
.                \}
.             \}
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             DEFAULT_DOCHEADER
.             di DOCHEADER_DIVERSION \" This diversion is only
.             br                     \" necessary to find the depth of the
.             DEFAULT_DOCHEADER      \" docheader
.             br
.             di
.             nr #DOCHEADER_DEPTH \\n(dn-\\n[#DOCHEADER_LEAD] \"Storing the depth (height) of the diversion
.                                                             \"in #DOCHEADER_DEPTH
.             rm DOCHEADER_DIVERSION                          \" Removing the diversion macro
.          \}
.          ev
.       \}
\# Chapter
.       if \\n[#DOC_TYPE]=2 \{\
.          PRINT \&
.          sp |\\n[#DOCHEADER_ADVANCE]u-1v
.          ev DOCHEADER
.          if \\n[#DOCHEADER_COLOR]=1 \{\
.             nf
\m[\\*[$DOCHEADER_COLOR]]
.             EL
.          \}
.          L_MARGIN \\n[#DOC_L_MARGIN]u
.          LL       \\n[#DOC_L_LENGTH]u
.          ta \\n(.lu
.          if \\n[#PRINT_STYLE]=1 \{\
.             CENTER
.             fam C
.             ft  R
.             ps  12
.             vs \\n[#DOC_LEAD]u
.             ie '\\*[$CHAPTER]'' \{\
.                CAPS
.                ie !'\\*[$CHAPTER_TITLE]'' \{\
.                   PRINT \\*[$CHAPTER_TITLE]
.                \}
.                el \{\
.                   CAPS
.                   PRINT \\*[$CHAPTER_STRING]
.                \}
.                CAPS OFF
.             \}
.             el \{\
.                CAPS
.                PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.                CAPS OFF
.                if !'\\*[$CHAPTER_TITLE]'' \{\
.                   if \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.                   UNDERSCORE "\\*[$CHAPTER_TITLE]
.                \}
.             \}
.             if \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             CHAPTER_DOCHEADER
.             di DOCHEADER_DIVERSION \" This diversion is only
.             br                     \" necessary to find the depth of the
.             CHAPTER_DOCHEADER      \" docheader
.             br
.             di
.             nr #DOCHEADER_DEPTH \\n(dn-\\n[#DOCHEADER_LEAD] \" Storing the depth (height) of the diversion
.                                                             \" in #DOCHEADER_DEPTH
.             rm DOCHEADER_DIVERSION                          \" Removing the diversion macro
.          \}
.          ev
.       \}
\# Named
.       if \\n[#DOC_TYPE]=3 \{\
.          PRINT \&
.          sp |\\n[#DOCHEADER_ADVANCE]u-1v
.          ev DOCHEADER
.          if \\n[#DOCHEADER_COLOR]=1 \{\
.             nf
\m[\\*[$DOCHEADER_COLOR]]
.             EL
.          \}
.          L_MARGIN \\n[#DOC_L_MARGIN]u
.          LL       \\n[#DOC_L_LENGTH]u
.          ta \\n(.lu
.          if \\n[#PRINT_STYLE]=1 \{\
.             CENTER
.             fam C
.             ft  R
.             ps  12
.             ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u*2u \}
.             el \{ .vs \\n[#DOC_LEAD]u \}
.             CAPS
.             if !'\\*[$TITLE]'' \{ .UNDERSCORE "\\*[$TITLE]\}
.             CAPS OFF
.             if !'\\*[$SUBTITLE]'' \{\
.                ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u*2u \}
.                el \{ .vs \\n[#DOC_LEAD]u \}
.                PRINT \\*[$SUBTITLE]
.             \}
.             if '\\*[$SUBTITLE]'' \{\
.                ALD \\n[#DOC_LEAD]u
.             \}
.             ie !'\\*[$AUTHOR_1]'' \{\
.                ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u \}
.                el \{ .vs \\n[#DOC_LEAD]u/2u \}
.                if !d$SUBTITLE \{\
.                   ie \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.                   el \{ .ALD \\n[#DOC_LEAD]u*2u \}
.                \}
.                PRINT \\*[$ATTRIBUTE_STRING]
.                nr #AUTHORS \\n[#AUTHOR_NUM]
.                nr #NEXT_AUTHOR 0 1
.                while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.                   PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]
.                \}
.                if \\n[#AUTHOR_LINES]=1 \{\
.                    ie \\n[#SINGLE_SPACE] \{ .RLD \\n[#DOC_LEAD]u \}
.                    el \{ .ALD \\n[#DOC_LEAD]u/2u \}
.                 \}
.             vs  \\n[#DOC_LEAD]u
.             \}
.             el \{\
.                ie !d$SUBTITLE \{\
.                   ie \\n[#SINGLE_SPACE] \{ .RLD \\n[#DOC_LEAD]u*2u \}
.                   el \{ .RLD \\n[#DOC_LEAD]u \}
.                \}
.                el \{\
.                   ie \\n[#SINGLE_SPACE] \{ . \}
.                   el \{ .RLD \\n[#DOC_LEAD]u \}
.                \}
.             \}
.             ie \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u*2u \}
.             el \{ .ALD \\n[#DOC_LEAD]u \}
.             UNDERSCORE2 "\\*[$DOC_TYPE]
.             if \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             NAMED_DOCHEADER
.             di DOCHEADER_DIVERSION \" This diversion is only
.             br                     \" necessary to find the depth of the
.             NAMED_DOCHEADER        \" docheader
.             br
.             di
.             nr #DOCHEADER_DEPTH \\n(dn-\\n[#DOCHEADER_LEAD] \"Storing the depth (height) of the diversion
.                                                             \"in #DOCHEADER_DEPTH
.             rm DOCHEADER_DIVERSION                          \" Removing the diversion macro
.          \}
.          ev
.       \}
.       if !\\n[#DOC_TYPE]=4 \{\
.          if \\n[#PRINT_STYLE]=1 \{ .ALD \\n[#DOC_LEAD]u \}
.          nr #DOCHEADER_SPACE_ADJ \\n[#DOCHEADER_DEPTH]%\\n[#DOC_LEAD]
.          ie !\\n[#DOCHEADER_SPACE_ADJ]=0 \{ .nr #DOCHEADER_EXTRA_SPACE \\n[#DOC_LEAD]-\\n[#DOCHEADER_SPACE_ADJ] \}
.          el \{ .nr #DOCHEADER_EXTRA_SPACE 0 \}
.          if \\n[#PRINT_STYLE]=2 \{ .ALD (\\n[#DOC_LEAD]u*2u)+\\n[#DOCHEADER_EXTRA_SPACE]u \}
.          if \\n[#COLUMNS] \{\
.             nr #COL_NUM 0 1
.             nr #L_LENGTH_FOR_EPI \\n[#L_LENGTH]
.             po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.             nr #L_MARGIN \\n(.o
.             LL \\n[#COL_L_LENGTH]u
.             ta \\n(.lu
.             mk dc
.          \}
.       \}
.    \}
.    QUAD \\*[$DOC_QUAD]
.    rr #DOCHEADER_LEAD
.    rr #DOCHEADER_LEAD_ADJ
.    rr #DEPTH_1
.    rr #DEPTH_2
.    rr #DOCHEADER_ADVANCE
.    rr #ADVANCE_FROM_TOP
.    rr #DOCHEADER_SPACE_ADJ
.    rr #DOCHEADER_EXTRA_SPACE
.    rr #AUTHORS
.    rr #NEXT_AUTHOR
.    rr #AUTHOR_NUM
.    rr #NUM_AUTHORS
.    rm $TOC_TITLE_ITEM
.    nr #START 1
.    nr #START_FOR_FOOTERS 1
.END
\#
\# ====================================================================
\#
\# +++MACROS TO CHANGE SOME DEFAULTS+++
\#
\# DOCUMENT HEADER
\# ---------------
\# *Argument:
\#   <none> | <anything> [distance to advance from top of page]
\# *Function:
\#   Turns printing of document header on or off.  If a second argument
\#   in units of measure is given, advances that distance from the
\#   top of the page without printing the document header.
\# *Notes:
\#   Default is on.  If the 1st argument is <anything> (which turns
\#   document headers off), the optional 2nd argument may be given
\#   (with a unit of measure).
\#
.MAC DOCHEADER END
.    ie '\\$1'' \{ .nr #DOC_HEADER 1 \}
.    el \{\
.       if !'\\$2'' \{ .nr #ADVANCE_FROM_TOP (\\$2) \}
.       nr #DOC_HEADER 0
.    \}
.END
\#
\#
\# DOCUMENT HEADER LEADING
\# -----------------------
\# *Arguments:
\#   <+|- amount by which to in/decrease leading of doc header>
\# *Function:
\#   Stores user supplied lead in/decrease in string $DOCHEADER_LEAD_ADJ.
\# *Notes:
\#   A unit of measure must be supplied.  Decimal fractions OK.
\#   Default is +0, i.e. same as DOC_LEAD.
\#
.MAC DOCHEADER_LEAD END
.    ds $DOCHEADER_LEAD_ADJ \\$1
.END
\#
\#
\# DOCHEADER ADVANCE
\# -----------------
\# *Arguments:
\#   <docheader start position>
\# *Function:
\#   Creates register #DOCHEADER_ADVANCE, used in START.
\# *Notes:
\#   Unit of measure required.
\#   Default is same as T_MARGIN.
\#
.MAC DOCHEADER_ADVANCE END
.    nr #DOCHEADER_ADVANCE (\\$1)
.END
\#
\#
\# DOCHEADER COLOR
\# ---------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Sets register #DOCHEADER_COLOR to 1; defines string
\#   $DOCHEADER_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   DOCHEADER_COLOR.
\#
.MAC DOCHEADER_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    nr #DOCHEADER_COLOR 1
.    ds $DOCHEADER_COLOR \\$1
.END
\#
\#
\# TITLE FAMILY
\# ------------
\# *Argument:
\#   <family to use for the document header title>
\# *Function:
\#   Creates or modifies string $TITLE_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC TITLE_FAMILY END
.    ds $TITLE_FAM \\$1
.END
\#
\#
\# TITLE FONT
\# ----------
\# *Argument:
\#   <font to use for the document header title>
\# *Function:
\#   Creates or modifies string $TITLE_FT.
\# *Notes:
\#   Default is bold.
\#
.MAC TITLE_FONT END
.    ds $TITLE_FT \\$1
.END
\#
\#
\# TITLE SIZE
\# ----------
\# *Argument:
\#   <+|- number of points by which to in/decrease title at start
\#   of the document (relative to running text)>
\# *Function:
\#   Creates string $TITLE_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign, with no space afterwards.
\#   Fractional point sizes are allowed.
\#   Default is +3.5 for printstyle TYPESET DEFAULT | STORY | NAMED;
\#   4 for TYPESET CHAPTER; +0 for TYPEWRITE.
\#
.MAC TITLE_SIZE END
.    ds $TITLE_SIZE_CHANGE \\$1
.END
\#
\#
\# TITLE COLOR
\# -----------
\# *Argument:
\#   <pre-defined color name>
\# *Function:
\#   Sets register #TITLE_COLOR to 1; creates string $TITLE_COLOR 
\# *Notes:
\#   The color name must be pre-defined with NEWCOLOR or XCOLOR.
\#
.MAC TITLE_COLOR END
.    nr #TITLE_COLOR 1
.    ds $TITLE_COLOR \\$1
.END
\#
\#
\# CHAPTER TITLE FAMILY
\# --------------------
\# *Argument:
\#   <family to use for the chapter title, if there is one>
\# *Function:
\#   Creates or modifies string $CHAPTER_TITLE_FAM.
\# *Notes:
\#   Default isame as running text.
\#
.MAC CHAPTER_TITLE_FAMILY END
.    ds $CHAPTER_TITLE_FAM \\$1
.END
\#
\#
\# CHAPTER TITLE FONT
\# ------------------
\# *Argument:
\#   <font to use for the chapter title, if there is one>
\# *Function:
\#   Creates or modifies string $CHAPTER_TITLE_FT.
\# *Notes:
\#   Default is bold italic for TYPESET; varies in TYPEWRITE between
\#   caps and underscored, depending on whether chapter title stands
\#   alone or has CHAPTER # above it.
\#
.MAC CHAPTER_TITLE_FONT END
.    ds $CHAPTER_TITLE_FT \\$1
.END
\#
\#
\# CHAPTER TITLE SIZE
\# ------------------
\# *Argument:
\#   <+|- number of points by which to in/decrease title at start
\#   of the document (relative to running text)>
\# *Function:
\#   Creates string $CHAPTER_TITLE_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign, with no space afterwards.
\#   Fractional point sizes are allowed.
\#   Default is +4 for printstyle TYPESET
\#
.MAC CHAPTER_TITLE_SIZE END
.    ds $CHAPTER_TITLE_SIZE_CHANGE \\$1
.END
\#
\#
\# SUBTITLE FAMILY
\# ---------------
\# *Argument:
\#   <family to use for the document header title>
\# *Function:
\#   Creates or modifies string $SUBTITLE_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC SUBTITLE_FAMILY END
.    ds $SUBTITLE_FAM \\$1
.END
\#
\#
\# SUBTITLE FONT
\# -------------
\# *Argument:
\#   <font to use for the document header title>
\# *Function:
\#   Creates or modifies string $SUBTITLE_FT.
\# *Notes:
\#   Default is same as running text.
\#
.MAC SUBTITLE_FONT END
.    ds $SUBTITLE_FT \\$1
.END
\#
\#
\# SUBTITLE SIZE
\# -------------
\# *Argument:
\#   <+|- number of points by which to in/decrease subtitle at start
\#   of the document (relative to running text)>
\# *Function:
\#   Creates or modifies string $SUBTITLE_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign with no space afterwards.
\#   Fractional point sizes are allowed.
\#   Default is +0.
\#
.MAC SUBTITLE_SIZE END
.    ds $SUBTITLE_SIZE_CHANGE \\$1
.END
\#
\#
\# SUBTITLE COLOR
\# --------------
\# *Argument:
\#   <pre-defined color name>
\# *Function:
\#   Sets register #SUBTITLE_COLOR to 1; creates string
\#   $SUBTITLE_COLOR.
\# *Notes:
\#   The color name must be pre-defined with NEWCOLOR or XCOLOR.
\#
.MAC SUBTITLE_COLOR END
.    nr #SUBTITLE_COLOR 1
.    ds $SUBTITLE_COLOR \\$1
.END
\#
\#
\# ATTRIBUTE COLOR
\# ---------------
\# *Argument:
\#   <pre-defined color name>
\# *Function:
\#   Sets register #ATTRIBUTE_COLOR to 1; creates string $ATTRIBUTE_COLOR 
\# *Notes:
\#   The color name must be pre-defined with NEWCOLOR or XCOLOR.
\#
.MAC ATTRIBUTE_COLOR END
.    nr #ATTRIBUTE_COLOR 1
.    ds $ATTRIBUTE_COLOR \\$1
.END
\#
\#
\# AUTHOR FAMILY
\# -------------
\# *Argument:
\#   <family to use for author in document header>
\# *Function:
\#   Creates or modifies string $AUTHOR_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC AUTHOR_FAMILY END
.    ds $AUTHOR_FAM \\$1
.END
\#
\#
\# AUTHOR FONT
\# -----------
\# *Argument:
\#   <font to use for author in document header>
\# *Function:
\#   Creates or modifies string $AUTHOR_FT.
\# *Notes:
\#   Default is italic.
\#
.MAC AUTHOR_FONT END
.    ds $AUTHOR_FT \\$1
.END
\#
\#
\# AUTHOR SIZE
\# -----------
\# *Argument:
\#   <+|- number of points by which to in/decrease author at start
\#   of the document>
\# *Function:
\#   Creates or modifies string $AUTHOR_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign with no space afterwards.
\#   Fractional point sizes are allowed.
\#   Default is same as running text.
\#
.MAC AUTHOR_SIZE END
.    ds $AUTHOR_SIZE_CHANGE \\$1
.END
\#
\#
\# AUTHOR COLOR
\# ------------
\# *Argument:
\#   <pre-defined color name>
\# *Function:
\#   Sets register #AUTHOR_COLOR to 1; creates string $AUTHOR_COLOR 
\# *Notes:
\#   The color name must be pre-defined with NEWCOLOR or XCOLOR.
\#
.MAC AUTHOR_COLOR END
.    nr #AUTHOR_COLOR 1
.    ds $AUTHOR_COLOR \\$1
.END
\#
\#
\# DOCTYPE FAMILY
\# --------------
\# *Argument:
\#   <family to use for the document type string>
\# *Function:
\#   Creates or modifies string $DOCTYPE_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC DOCTYPE_FAMILY END
.    ds $DOCTYPE_FAM \\$1
.END
\#
\#
\# DOCTYPE FONT
\# ------------
\# *Argument:
\#   <font to use for the document type string>
\# *Function:
\#   Creates or modifies string $DOCTYPE_FT.
\# *Notes:
\#   Default is bold italic.
\#
.MAC DOCTYPE_FONT END
.    ds $DOCTYPE_FT \\$1
.END
\#
\#
\# DOCTYPE SIZE
\# -------------
\# *Argument:
\#   <+|- number of points by which to in/decrease the document
\#   type string (relative to running text)>
\# *Function:
\#   Creates or modifies string $DOCTYPE_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign with no space afterwards.
\#   Fractional point sizes are allowed.
\#   Default is +3 for TYPESET; 0 for TYPEWRITE.
\#
.MAC DOCTYPE_SIZE END
.    ds $DOCTYPE_SIZE_CHANGE \\$1
.END
\#
\#
\# DOCTYPE COLOR
\# -------------
\# *Argument:
\#   <pre-defined color name>
\# *Function:
\#   Sets register #DOCTYPE_COLOR to 1; creates string $DOCTYPE_COLOR 
\# *Notes:
\#   The color name must be pre-defined with NEWCOLOR or XCOLOR.
\#
.MAC DOCTYPE_COLOR END
.    nr #DOCTYPE_COLOR 1
.    ds $DOCTYPE_COLOR \\$1
.END
\#
\#
\# DOCUMENT LEFT MARGIN
\# --------------------
\# *Argument:
\#   <left margin of document>
\# *Function:
\#   Creates or modifies register #DOC_L_MARGIN.
\# *Notes:
\#   Affects EVERYTHING on the page.
\#
.MAC DOC_LEFT_MARGIN END
.    br
.    nr #DOC_L_MARGIN (\\$1)
.    L_MARGIN \\n[#DOC_L_MARGIN]u
.END
\#
\#
\# DOCUMENT RIGHT MARGIN
\# ---------------------
\# *Argument:
\#   <right margin of document>
\# *Function:
\#   Creates or modifies register #DOC_R_MARGIN.
\# *Notes:
\#   Affects EVERYTHING on the page.
\#
.MAC DOC_RIGHT_MARGIN END
.    br
.    nr #DOC_R_MARGIN (\\$1)
.    R_MARGIN \\n[#DOC_R_MARGIN]
.    nr #DOC_L_LENGTH \\n[#L_LENGTH]
.END
\#
\#
\# DOCUMENT LINE LENGTH
\# --------------------
\# *Argument:
\#   <line length of document>
\# *Function:
\#   Creates or modifies string $DOC_L_LENGTH.
\# *Notes:
\#   Affects EVERYTHING on the page.
\#
.MAC DOC_LINE_LENGTH END
.    br
.    nr #DOC_L_LENGTH (\\$1)
.    LL \\n[#DOC_L_LENGTH]u
.    ta \\n(.lu
.END
\#
\#
\# DOCUMENT FAMILY
\# ---------------
\# *Argument:
\#   <family of running text>
\# *Function:
\#   Creates or modifies string $DOC_FAM.
\# *Notes:
\#   Affects everything EXCEPT headers and footers.
\#
.MAC DOC_FAMILY END
.    br
.    ds $DOC_FAM \\$1
.    FAMILY            \\*[$DOC_FAM]
.    TITLE_FAMILY      \\*[$DOC_FAM]
.    SUBTITLE_FAMILY   \\*[$DOC_FAM]
.    AUTHOR_FAMILY     \\*[$DOC_FAM]
.    DOCTYPE_FAMILY    \\*[$DOC_FAM]
.    HEAD_FAMILY       \\*[$DOC_FAM]
.    SUBHEAD_FAMILY    \\*[$DOC_FAM]
.    QUOTE_FAMILY      \\*[$DOC_FAM]
.    BLOCKQUOTE_FAMILY \\*[$DOC_FAM]
.    EPIGRAPH_FAMILY   \\*[$DOC_FAM]
.    HDRFTR_FAMILY     \\*[$DOC_FAM]
.    PAGENUM_FAMILY    \\*[$DOC_FAM]
.END
\#
\#
\# DOCUMENT POINT SIZE
\# -------------------
\# *Argument:
\#   <point size of running text>
\# *Function:
\#   Creates or modifies register #DOC_PT_SIZE.
\# *Notes:
\#   DOC_PT_SIZE is the basis for calculating all type sizes in
\#   a document.
\#
.MAC DOC_PT_SIZE END
.    if \\n[#IGNORE] \{ .return \}
.    br
.    PT_SIZE \\$1
.    nr #DOC_PT_SIZE \\n[#PT_SIZE]
.END
\#
\#
\# DOCUMENT LEAD
\# -------------
\# *Argument:
\#   <lead (".vs") of running text> [ADJUST]
\# *Function:
\#   Creates or modifies register #DOC_LEAD.  If the optional
\#   ADJUST argument is given, adjusts leading so that the last
\#   line of text falls exactly on #B_MARGIN.
\# *Notes:
\#   DOC_LEAD is the basis for calculating all leading changes in
\#   a document.  Default for TYPESET is 16; 24 for TYPEWRITE.
\#
\#   Because the visible bottom or footer margin of a page depends
\#   on the overall document lead supplied by the register #DOC_LEAD,
\#   DOC_LEAD, in the body of a document, should always be associated
\#   with the start of a new page (in other words, just before or
\#   just after a manual NEWPAGE).
\#
.MAC DOC_LEAD END
.    if \\n[#IGNORE] \{ .return \}
.    br
.    vs \\$1
.    nr #DOC_LEAD \\n[#LEAD]
.    if '\\$2'ADJUST' \{ .TRAPS \}
.END
\#
\#
\# ADJUST DOCUMENT LEAD
\# --------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Adjusts document lead so that the last line of text falls exactly
\#   on #B_MARGIN.
\#
.MAC DOC_LEAD_ADJUST END
.    ie '\\$1'' \{ .nr #ADJ_DOC_LEAD 1 \}
.    el \{ .nr #ADJ_DOC_LEAD 0 \}
.END
\#
\#
\# SHIM
\# ----
\# *Argument:
\#   None
\# *Function:
\#   Advances to the next "legal" baseline.
\# *Notes:
\#   If a user plays around with spacing in a doc (say, with ALD),
\#   it isn't easy to get mom back on track so she can achieve
\#   perfectly flush bottom margins.  Any time SHIM is used, it
\#   ensures that the next output line falls on a legal baseline.
\#
\# First, a little convenience macro
\#
.MAC PROCESS_SHIM END
.    while \\n+[#LEGAL_BASELINE]<\\n[#CURRENT_V_POS] \{\
.
.    \}
.    nr #SHIM \\n[#LEGAL_BASELINE]-\\n[#CURRENT_V_POS]
.END
\#
.MAC SHIM END
.    nr #CURRENT_V_POS \\n(.d
.    nr #LEGAL_BASELINE \\n[#T_MARGIN]-1v \\n[#DOC_LEAD]
.    ie r#ADVANCE_FROM_TOP \{\
.       ie \\n[#CURRENT_V_POS]<(\\n[#T_MARGIN]-1v) \{\
.          while \\n-[#LEGAL_BASELINE]>\\n[#CURRENT_V_POS] \{\
.
.          \}
.          nr #LEGAL_BASELINE +\\n[#DOC_LEAD]
.          nr #SHIM \\n[#LEGAL_BASELINE]-\\n[#CURRENT_V_POS]
.       \}
.       el \{\
.          PROCESS_SHIM
.       \}
.    \}
.    el \{\
.       PROCESS_SHIM
.    \}
.    ALD \\n[#SHIM]u
.END
\#
\#
\# DOCUMENT QUAD
\# -------------
\# *Arguments:
\#   L | LEFT | R | RIGHT | C | CENTER | CENTRE | J | JUSTIFY
\# *Function:
\#   Creates or modifies string $DOC_QUAD.
\# *Notes:
\#   While QUAD (from the typesetting macros) can be used before START
\#   to change  the default document quad, DOC_QUAD *must* be used after
\#   the START macro has been invoked.
\#
\#   Default is LEFT for printstyle TYPEWRITE, JUSTIFY for printstyle
\#   TYPESET.
\#
.MAC DOC_QUAD END
.    ds $DOC_QUAD \\$1
.    QUAD \\*[$DOC_QUAD]
.END
\#
\# ====================================================================
\#
\# +++INTERNATIONALIZATION+++
\#
\# ATTRIBUTE STRING
\# ----------------
\# *Argument:
\#   <what goes in the "by" slot before author in the document header>
\# *Function:
\#   Creates or modifies string $ATTRIBUTE_STRING.
\# *Notes:
\#   Default is "by".  A blank string ("") may be used if no
\#   attribution is desired.
\#
.MAC ATTRIBUTE_STRING END
.    ds $ATTRIBUTE_STRING \\$1
.END
\#
\#
\# CHAPTER STRING
\# --------------
\# *Argument:
\#   <what to print any time the word "chapter" is required>
\# *Function:
\#   Creates or modifies string $CHAPTER_STRING.
\# *Notes:
\#   Default is "chapter".
\#
.MAC CHAPTER_STRING END
.    ds $CHAPTER_STRING \\$1
.END
\#
\#
\# DRAFT STRING
\# ------------
\# *Argument:
\#   <what to print any time the word "draft" is required>
\# *Function:
\#   Creates or modifies string $DRAFT_STRING.
\# *Notes:
\#   Default is "draft".
\#
.MAC DRAFT_STRING END
.    ds $DRAFT_STRING \\$1
.END
\#
\#
\# REVISION STRING
\# ---------------
\# *Argument:
\#   <what to print any time the word "revision" is required>
\# *Function:
\#   Creates or modifies string $REVISION_STRING.
\# *Notes:
\#   Default is "revision".
\#
.MAC REVISION_STRING END
.    ds $REVISION_STRING \\$1
.END
\#
\#
\# FINIS STRING
\# ------------
\# *Argument:
\#   <what to print with the finis macro>
\# *Function:
\#   Creates or modifies string $FINIS_STRING.
\# *Notes:
\#   Default is "END".
\#
.MAC FINIS_STRING END
.    nr #FINIS 1
.    CAPS
.    ds $FINIS_STRING \\$1
.    CAPS OFF
.END
\#
\# FINIS COLOR
\# -----------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Defines string $FINIS_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   FINIS_COLOR.
\#
.MAC FINIS_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    ds $FINIS_COLOR \\$1
.END
\#
\#
\# ====================================================================
\#
\# +++RECTO/VERSO+++
\#
\# RECTO_VERSO
\# -----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Switches HDRFTR_LEFT and HDRFTR_RIGHT on alternate pages.  Also
\#   switches page numbers left and right if either is chosen rather
\#   than the default centered page numbers.  Switches left and right
\#   margins if differing values have been entered.
\# *Notes:
\#   Default is OFF.
\#
.MAC RECTO_VERSO END
.    ie '\\$1'' \{ .nr #RECTO_VERSO 1 \}
.    el \{ .nr #RECTO_VERSO 0 \}
.END
\#
\# ====================================================================
\#
\# +++EPIGRAPHS+++
\#
\# EPIGRAPH FAMILY
\# ---------------
\# *Argument:
\#   <family to use for epigraphs>
\# *Function:
\#   Creates or modifies string $EPI_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC EPIGRAPH_FAMILY END
.    ds $EPI_FAM \\$1
.END
\#
\#
\# EPIGRAPH FONT
\# -------------
\# *Argument:
\#   <font to use for epigraphs>
\# *Function:
\#   Creates or modifies string $EPI_FT.
\# *Notes:
\#   Default is same as running text.
\#
.MAC EPIGRAPH_FONT END
.    ds $EPI_FT \\$1
.END
\#
\#
\# EPIGRAPH SIZE
\# -------------
\# *Argument:
\#   <-|+ number of points by which to de/increase point size of epigraphs
\#   (relative to running text)>
\# *Function:
\#   Creates or modifies string $EPI_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a - or + sign with no space afterwards.
\#   Fractional point sizes are allowed.  Default -1.5 for printstyle
\#   TYPESET; +0 for TYPEWRITE.
\#
.MAC EPIGRAPH_SIZE END
.    ds $EPI_SIZE_CHANGE \\$1
.END
\#
\#
\# EPIGRAPH COLOR
\# --------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Sets register #EPI_COLOR to 1; defines string
\#   $EPI_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   EPI_COLOR.
\#
.MAC EPIGRAPH_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    nr #EPI_COLOR 1
.    ds $EPI_COLOR \\$1
.END
\#
\#
\# EPIGRAPH QUAD
\# -------------
\# *Arguments:
\#   L | LEFT | J | JUSTIFY
\# *Function:
\#   Creates or modifies string $EPI_QUAD.
\# *Notes:
\#   Default is $DOC_QUAD when BLOCK argument is passed to EPIGRAPH.
\#
.MAC EPIGRAPH_QUAD END
.    ds $EPI_QUAD \\$1
.END
\#
\#
\# EPIGRAPH INDENT
\# ---------------
\# *Argument:
\#   <value by which to multiply PP_INDENT for block epigraphs>
\# *Function:
\#   Creates or modifies register #EPI_OFFSET_VALUE.
\# *Notes:
\#   Default is 2 for TYPEWRITE, 3 for TYPESET.
\#
.MAC EPIGRAPH_INDENT END
.    nr #EPI_OFFSET_VALUE \\$1
.END
\#
\#
\# EPIGRAPH AUTOLEAD
\# -----------------
\# *Argument:
\#   <amount of lead to add to the epigraph ps for epigraph leading>
\# *Function:
\#   Creates or modifies register #EPI_AUTOLEAD.
\# *Notes:
\#   Default is 2 (for TYPESET; TYPEWRITE doesn't require this).
\#
.MAC EPIGRAPH_AUTOLEAD END
.    nr #EPI_AUTOLEAD \\$1
.END
\#
\#
\# EPIGRAPH
\# --------
\# *Arguments:
\#   BLOCK | <anything>
\# *Function:
\#   Places an epigraph before the document's text, after the
\#   document header, or after a HEAD.
\# *Notes:
\#   #EPIGRAPH 1 = centered; 2 = block
\#
\#   By default, epigraphs are centered, allowing the user
\#   to input them on a line per line basis.  To change this
\#   behaviour, the user can supply the argument BLOCK, which
\#   will produce indented, filled text similar to BLOCKQUOTE.
\#
\#   If a block epigraph contains more than one para, ALL paras of
\#   the epigraph must be preceded by PP.  Otherwise, PP is optional.
\#
.MAC EPIGRAPH END
.    nr #PP_STYLE 2
.    nr #Q_PP     0
.    if \\n[#START] \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          if \\n[#AUTHOR_LINES]=1 \{ .ALD \\n[#DOC_LEAD]u \}
.       \}
.    \}
.    ie '\\$1'' \{\
.       nr #EPIGRAPH 1
.       ev EPIGRAPH
.       ll \\n[#L_LENGTH]u
.       ta \\n(.lu
.       CHECK_INDENT
.       if \\n[#COLUMNS] \{\
.          ie \\n[#START] \{\
.              ll \\n[#DOC_L_LENGTH]u
.              ta \\n(.lu
.          \}
.          el \{\
.             ll \\n[#COL_L_LENGTH]u
.             ta \\n(.lu
.          \}
.       \}
.       CENTER
.       if \\n[#PRINT_STYLE]=1 \{\
.          fam C
.          ft  R
.          if '\\*[$EPI_FT]'I' \{\
.             FT I
.          \}
.          ps  12
.          ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u \}
.          el \{ .vs  \\n[#DOC_LEAD]u/2u \}
.          nr #EPI_LEAD      \\n[#LEAD]
.          nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY   \\*[$EPI_FAM]
.          FT       \\*[$EPI_FT]
.          PT_SIZE  \\n[#DOC_PT_SIZE]u\\*[$EPI_SIZE_CHANGE]
.          if \\n[#EPI_COLOR]=1 \{\
.             nf
\m[\\*[$EPI_COLOR]]
.             EL
.          \}
.          AUTOLEAD \\n[#EPI_AUTOLEAD]
.          nr #EPI_LEAD      \\n[#LEAD]
.          nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.       \}
.       di EPI_TEXT
.       nr #EPI_ACTIVE 1
.    \}
.    el \{\
.       ie '\\$1'BLOCK' \{\
.          nr #EPIGRAPH 2
.          ev EPIGRAPH
.          ie \\n[#START] \{\
.             ie \\n[#COLUMNS] \{\
.                ll \\n[#L_LENGTH_FOR_EPI]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.                ta \\n(.lu
.             \}
.             el \{\
.                ll \\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.                ta \\n(.lu
.             \}
.          \}
.          el \{\
.             ll \\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.             ta \\n(.lu
.             if \\n[#COLUMNS] \{\
.                ll \\n[#COL_L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.                ta \\n(.lu
.             \}
.             CHECK_INDENT
.          \}
.          if \\n[#PRINT_STYLE]=1 \{\
.             fam C
.             ft  R
.             if '\\*[$EPI_FT]'I' \{\
.                FT I
.             \}
.             ps  12
.             ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u \}
.             el \{ .vs  \\n[#DOC_LEAD]u/2u \}
.             QUAD LEFT
.             HY OFF
.             nr #EPI_LEAD \\n[#LEAD]
.             nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.             di EPI_TEXT
.             nr #EPI_ACTIVE 1
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY   \\*[$EPI_FAM]
.             FT       \\*[$EPI_FT]
.             PT_SIZE  \\n[#DOC_PT_SIZE]u\\*[$EPI_SIZE_CHANGE]
.          if \\n[#EPI_COLOR]=1 \{\
.             nf
\m[\\*[$EPI_COLOR]]
.             EL
.          \}
.             AUTOLEAD \\n[#EPI_AUTOLEAD]
.             QUAD     \\*[$EPI_QUAD]
.             HY
.             nr #EPI_LEAD \\n[#LEAD]
.             nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.             di EPI_TEXT
.             nr #EPI_ACTIVE 1
.          \}
.       \}
.       el \{\
.          DO_EPIGRAPH
.       \}
.    \}
.END
\#
\#
\# DO EPIGRAPH
\# -----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Ends diversion started in EPIGRAPH.  Makes spacing
\#   adjustments to compensate for the difference between epigraph
\#   leading and overall document leading, so that the bottom of
\#   the pages remain flush.
\# *Notes:
\#   In addition to its usual place at the beginning of a
\#   document, EPIGRAPH may also be used after HEAD.
\#
.MAC DO_EPIGRAPH END
.    br
.    di
.    REMOVE_INDENT
.    ev
.    nr #EPI_DEPTH \\n[#DIVER_DEPTH]-\\n[#EPI_LEAD]
.    nr #EPI_LINES \\n[#EPI_DEPTH]/\\n[#EPI_LEAD]
.    ie \\n[#START] \{\
.       nr #EPI_WHITESPACE (\\n[#DOC_LEAD]*\\n[#EPI_LINES])-\\n[#EPI_DEPTH]
.       while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.             nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          RLD \\n[#DOC_LEAD]u
.          if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \{\
.             ALD \\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)
.          \}
.          if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.             ALD \\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.          \}
.       \}
.    \}
.    el \{\
.       ie \\n[#EPI_DEPTH]<\\n[#TRAP_DISTANCE] \{\
.          nr #EPI_FITS 1
.          nr #EPI_WHITESPACE (\\n[#DOC_LEAD]*\\n[#EPI_LINES])-\\n[#EPI_DEPTH]
.          while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.          \}
.          ie \\n[#PRINT_STYLE]=1 \{\
.             if \\n[#EPI_WHITESPACE]=\\n[#DOC_LEAD] \{ .ALD \\n[#EPI_WHITESPACE]u/2u \}
.          \}
.          el \{\
.             if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \{\
.                ALD \\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)
.             \}
.             if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                ALD \\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.             \}
.          \}
.       \}
.       el \{\
.          nr #EPI_LINES_TO_TRAP 0 1
.          while \\n[#EPI_LEAD]*\\n+[#EPI_LINES_TO_TRAP]<\\n[#TRAP_DISTANCE] \{\
.                nr #LOOP 1
.          \}
.          nr #EPI_LINES_TO_TRAP -1
.          nr #EPI_WHITESPACE (\\n[#EPI_LINES_TO_TRAP]*\\n[#DOC_LEAD])-(\\n[#EPI_LINES_TO_TRAP]*\\n[#EPI_LEAD])
.          while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.          \}
.          if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \{ .ALD \\n[#EPI_WHITESPACE]u \}
.          if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{ .ALD \\n[#EPI_WHITESPACE]u-\\n[#DOC_LEAD]u \}
.      \}
.    \}
.    if \\n[#EPIGRAPH]=1 \{\
.       po \\n[#L_MARGIN]u
.       if \\n[#COLUMNS] \{\
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n(.o
.       \}
.    \}
.    if \\n[#EPIGRAPH]=2 \{\
.       nr #EPI_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.       if \\n[#COLUMNS] \{\
.          nr #EPI_OFFSET \\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.       \}
.       po \\n[#EPI_OFFSET]u
.    \}
.    nf
.    EPI_TEXT
.    br
.    ie \\n[#START] \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          ie \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.          el \{\
.             ie \\n[#EPI_LINES]%2=1 \{ .ALD \\n[#DOC_LEAD]u \}
.             el \{ .ALD \\n[#DOC_LEAD]u/2u \}
.          \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \{\
.             ALD \\n[#EPI_WHITESPACE]u/2u
.          \}
.          if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.             ALD (\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.          \}
.       \}
.    \}
.    el \{\
.       rr #EPI_ACTIVE
.       ie \\n[#EPI_FITS] \{\
.          ie \\n[#FN_FOR_EPI] \{\
.             nr #EPI_LINES_TO_END 1
.             nr #EPI_WHITESPACE (\\n[#EPI_LINES_TO_END]*\\n[#DOC_LEAD])-(\\n[#EPI_LINES_TO_END]*\\n[#EPI_LEAD])
.             while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                   nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.             \}
.             ALD \\n[#EPI_WHITESPACE]u-(\\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u)
.          \}
.          el \{\
.             ie \\n[#PRINT_STYLE]=1 \{\
.                if \\n[#EPI_WHITESPACE]=\\n[#DOC_LEAD] \{ .ALD \\n[#EPI_WHITESPACE]u \}
.             \}
.             el \{\
.                if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \{\
.                   ALD \\n[#EPI_WHITESPACE]u/2u
.                \}
.                if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                   ALD (\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          nr #EPI_LINES_TO_END \\n[#EPI_LINES]-\\n[#EPI_LINES_TO_TRAP]
.          if \\n[#LOOP] \{. nr #EPI_LINES_TO_END +1 \}
.          rr #LOOP
.          nr #EPI_WHITESPACE (\\n[#EPI_LINES_TO_END]*\\n[#DOC_LEAD])-(\\n[#EPI_LINES_TO_END]*\\n[#EPI_LEAD])
.          while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.          \}
.          ALD \\n[#EPI_WHITESPACE]u-(\\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u)
.          if \\n[#PRINT_STYLE]=1 \{\
.             if !\\n[#SINGLE_SPACE] \{\
.                nr #EPI_LINES_EVEN \\n[#EPI_LINES_TO_END]%2
.                ie \\n[#EPI_LINES_EVEN] \{ .ALD .5v \}
.                el \{ .RLD .5v \}
.                rr #EPI_LINES_EVEN
.             \}
.          \}
.       \}
.    \}
.    nr #PP_STYLE 1
.    rr #EPI_FITS
.    ALD \\n[#DOC_LEAD]u
.    QUAD \\*[$DOC_QUAD]
.    po \\n[#L_MARGIN]u
.    if \\n[#COLUMNS] \{\
.       po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n(.o
.    \}
.    if \\n[#START] \{\
.       if \\n[#COLUMNS] \{\
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n(.o
.          mk dc
.       \}
.    \}
.END
\#
\# ====================================================================
\#
\# +++FINIS MACRO+++
\#
\# FINIS
\# -----
\# *Arguments:
\#   <none>
\# *Function:
\#   Deposits --END-- at the end of a document.
\#
.MAC FINIS END
.    ev FINIS
.    evc 0
.    nr #FINIS 1
.    if \\n[#TAB_ACTIVE] \{ .TQ \}
.    if \\n[#INDENT_ACTIVE] \{ .IQ CLEAR \}
.    if \\n[#FOOTERS_ON] \{\
.       nr #FOOTERS_WERE_ON 1
.       FOOTERS OFF
.    \}
.    if \\n[#PAGINATE] \{\
.       if \\n[#PAGE_NUM_V_POS]=2 \{\
.          nr #PAGINATION_WAS_ON 1
.          PAGINATION OFF
.       \}
.    \}
.    nr #EM_ADJUST (1m/8)
.    if \\n[#COLUMNS] \{\
.       po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n(.o
.    \}
.    ALD \\n[#DOC_LEAD]u
.    CENTER
.    if \\n[#PRINT_STYLE]=1 \{ .PRINT "--\\*[$FINIS_STRING]--\}
.    if \\n[#PRINT_STYLE]=2 \{\
.       PRINT "\m[\\*[$FINIS_COLOR]]\v'-\\n[#EM_ADJUST]u'\(em\v'+\\n[#EM_ADJUST]u'\\*[$FINIS_STRING]\v'-\\n[#EM_ADJUST]u'\*[FU1]\(em\m[]
.    \}
.    ev
.END
\#
\# ====================================================================
\#
\# +++HEADERS/FOOTERS+++
\#
\# Define a string so that the current page number can be incorporated
\# into the strings for hdrftr left, right, and center.  NOTE: This is
\# not the same thing as using the shortform # in hdrftr strings.
\#
.ds PAGE# \En[#PAGENUMBER]
\#
\#
\# HDRFTR FAMILY
\# -------------
\# *Argument:
\#   <family to use in header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC HDRFTR_FAMILY END
.    ds $HDRFTR_FAM \\$1
.END
\#
\#
\# HDRFTR SIZE
\# -----------
\# *Argument:
\#   <+|-number of points by which to in/decrease point size of
\#   header/footers (relative to running text)>
\# *Function:
\#   Creates or modifies string $HDRFTR_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign.  No space afterwards.
\#   Fractional point sizes are allowed.  Default is +0.
\#
\#   By default, header/footers print the author .5 points smaller
\#   than the base point size of running text, center titles
\#   (Chapter, Draft, Revision, etc.)  .5 points smaller
\#   than running text (in italics), and the document title 2 full
\#   points smaller than running text (in caps).  The HDRFTR_SIZE
\#   macro changes the overall size for all three parts while
\#   maintaining the internal size changes.
\#
\#   In other words, if the user likes the header/footers but wants
\#   them a bit bigger or a bit smaller, s/he should use HDRFTR_SIZE.
\#
.MAC HDRFTR_SIZE END
.    ds $HDRFTR_SIZE_CHANGE \\$1
.END
\#
\#
\# HDRFTR COLOR
\# ------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Sets register #HDRFTR_COLOR to 1; defines string $HDRFTR_COLOR to
\#   argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   HDRFTR_COLOR.
\#
.MAC HDRFTR_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    nr #HDRFTR_COLOR 1
.    ds $HDRFTR_COLOR \\$1
.END
\#
\#
\# HDRFTR RULE GAP
\# ---------------
\# *Argument:
\#   <amount of space between header/footer and header/footer rule>
\# *Function:
\#   Creates or modifies register #HDRFTR_RULE_GAP to hold amount
\#   of space between header/footer and header/footer rule.
\# *Notes:
\#   Default is 4p.
\#
.MAC HDRFTR_RULE_GAP END
.    nr #HDRFTR_RULE_GAP (\\$1)
.END
\#
\#
\# HDRFTR LEFT
\# -----------
\# *Argument:
\#   <what to put in the left position of page header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_LEFT.
\#   Creates register #USER_DEF_HDRFTR_LEFT, which, if 1,
\#   overrides the $HDRFTR_LEFT string created by default
\#   in DEFAULTS.
\# *Notes:
\#   Especially useful if doc has more than one author, and a list
\#   of authors by last name is desired in header/footers.
\#   Default is author.
\#
\#   If the argument is the # character, simply prints the current
\#   page number.
\#
\#   If the user wants to *incorporate* the page number into the string,
\#   \*[PAGE#] must be used.  For example, if the user wants to put
\#   an elipsis before the page number in the string, s/he should use
\#   ...\*[PAGE#], not ...#
\#
.MAC HDRFTR_LEFT END
.    nr #USER_DEF_HDRFTR_LEFT 1
.    ds $HDRFTR_LEFT \\$1
.END
\#
\#
\# HDRFTR LEFT FAMILY
\# ------------------
\# *Argument:
\#   <family of header/footer left string>
\# *Function:
\#   Creates or modifies string $HDRFTR_LEFT_FAM.
\#
.MAC HDRFTR_LEFT_FAMILY END
.    ds $HDRFTR_LEFT_FAM \\$1
.END
\#
\#
\# HDRFTR LEFT FONT
\# ----------------
\# *Argument:
\#   <font of header/footer left string>
\# *Function:
\#   Creates or modifies string $HDRFTR_LEFT_FT.
\#
.MAC HDRFTR_LEFT_FONT END
.    ds $HDRFTR_LEFT_FT \\$1
.END
\#
\#
\# HDRFTR LEFT SIZE
\# ----------------
\# *Argument:
\#   <+|- number of points to in/decrease size of left string in
\#   header/footers (relative to running text)>
\# *Function:
\#   Creates or modifies string HDRFTR_LEFT_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign.  No space afterwards.
\#   Fractional point sizes are allowed.
\#   Default is -.5 for printstyle TYPESET; if all caps, -2
\#   Has no effect in TYPEWRITE.
\#
.MAC HDRFTR_LEFT_SIZE END
.    ds $HDRFTR_LEFT_SIZE_CHANGE \\$1
.END
\#
\#
\# HDRFTR LEFT COLOR
\# -----------------
\# *Argument:
\#   <pre-defined color name>
\# *Function:
\#   Sets register #HDRFTR_LEFT_COLOR to 1; creates string
\#   $HDRFTR_LEFT_COLOR
\# *Notes:
\#   The color name must be pre-defined with NEWCOLOR or XCOLOR.
\#
.MAC HDRFTR_LEFT_COLOR END
.    nr #HDRFTR_LEFT_COLOR 1
.    ds $HDRFTR_LEFT_COLOR \\$1
.END
\#
\#
\# HDRFTR LEFT CAPS
\# ----------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalisation of $HDRFTR_LEFT (typically, the author of
\#   the document) on or off.
\# *Notes:
\#   Default is on.
\#
.MAC HDRFTR_LEFT_CAPS END
.    ie '\\$1'' \{\
.        nr #HDRFTR_LEFT_CAPS 1
.    \}
.    el \{\
.       nr #HDRFTR_LEFT_CAPS 0
.       ds $HDRFTR_LEFT_SIZE_CHANGE +0
.    \}
.END
\#
\#
\# HDRFTR CENTER
\# -------------
\# *Argument:
\#   <what to put in the centre position of page header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_CENTER.
\#   Creates register #USER_DEF_HDRFTR_CENTER, which, if 1,
\#   overrides the $HDRFTR_CENTER string created by default
\#   in COPYSTYLE.
\# *Notes:
\#   Default is document type if DOCTYPE NAMED, Chapter # if DOCTYPE
\#   CHAPTER, draft and revision number if COPYSTYLE DRAFT.
\#
\#   If the argument is the # character, simply prints the current
\#   page number.
\#
\#   If the user wants to *incorporate* the page number into the string,
\#   \*[PAGE#] must be used.  For example, if the user wants to put
\#   an elipsis before the page number in the string, s/he should use
\#   ...\*[PAGE#], not ...#
\#
.MAC HDRFTR_CENTER END
.    nr #USER_DEF_HDRFTR_CENTER 1
.    if '\\$0'FOOTER_CENTER' \{\
.       ds $HDRFTR_CENTER_OLD \\*[$HDRFTR_CENTER]
.       ds $HDRFTR_CENTER_NEW \\$1
.    \}
.    if '\\$0'FOOTER_CENTRE' \{\
.       ds $HDRFTR_CENTER_OLD \\*[$HDRFTR_CENTER]
.       ds $HDRFTR_CENTER_NEW \\$1
.    \}
.    ds $HDRFTR_CENTER \\$1
.END
\#
\#
\# HDRFTR CENTER FAMILY
\# --------------------
\# *Argument:
\#   <family of header/footer center string>
\# *Function:
\#   Creates or modifies string $HDRFTR_CENTER_FAM.
\#
.MAC HDRFTR_CENTER_FAMILY END
.    ds $HDRFTR_CENTER_FAM \\$1
.END
\#
\#
\# HDRFTR CENTER FONT
\# ------------------
\# *Argument:
\#   <font of header/footer center string>
\# *Function:
\#   Creates or modifies string $HDRFTR_CENTER_FT.
\#
.MAC HDRFTR_CENTER_FONT END
.    ds $HDRFTR_CENTER_FT \\$1
.END
\#
\#
\# HDRFTR CENTER SIZE
\# ------------------
\# *Argument:
\#   <+|- number of points to in/decrease size of centre string in
\#   header/footers (relative to header/footer size)>
\# *Function:
\#   Creates string HDRFTR_CENTER_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign.  No space afterwards.
\#   Fractional point sizes are allowed.
\#   Default is -.5 for printstyle TYPESET; if all caps, -2
\#   Has no effect in TYPEWRITE.
\#
.MAC HDRFTR_CENTER_SIZE END
.    ds $HDRFTR_CENTER_SIZE_CHANGE \\$1
.END
\#
\#
\# HDRFTR CENTER COLOR
\# -------------------
\# *Argument:
\#   <pre-defined color name>
\# *Function:
\#   Sets register #HDRFTR_CENTER_COLOR to 1; creates string
\#   $HDRFTR_CENTER_COLOR
\# *Notes:
\#   The color name must be pre-defined with NEWCOLOR or XCOLOR.
\#
.MAC HDRFTR_CENTER_COLOR END
.    nr #HDRFTR_CENTER_COLOR 1
.    ds $HDRFTR_CENTER_COLOR \\$1
.END
\#
\#
\# HDRFTR CENTER CAPS
\# ------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalisation of $HDRFTR_CENTER (typically, doctype of
\#   the document) on or off.
\# *Notes:
\#   Default is on.
\#
.MAC HDRFTR_CENTER_CAPS END
.    ie '\\$1'' \{\
.       nr #HDRFTR_CENTER_CAPS 1
.    \}
.    el \{\
.       nr #HDRFTR_CENTER_CAPS 0
.       ds $HDRFTR_CENTER_SIZE_CHANGE +0
.    \}
.END
\#
\#
\# HDRFTR CENTER PADDING
\# ---------------------
\# *Argument:
\#   LEFT | RIGHT <amount of padding to put left or right of hdrftr
\#   center string>
\# *Function:
\#   Creates or modifies registers #HDRFTR_CTR_PAD_LEFT or
\#   #HDRFTR_CTR_PAD_RIGHT.
\# *Notes:
\#   By default, the HDRFTR_CENTER string is centered on the doc
\#   line length.  Long titles or long author names can screw up
\#   visual centering, or create overprints.  This macro allows the
\#   user to pad the center string by the specified amount of space
\#   to fix these problems.  Use only one of LEFT or RIGHT.
\#
\#   A unit of measure is required.
\#
.MAC HDRFTR_CENTER_PAD END
.    if '\\$1'LEFT' \{\
.       nr #HDRFTR_CTR_PAD_LEFT (\\$2)
.    \}
.    if '\\$1'RIGHT' \{\
.       nr #HDRFTR_CTR_PAD_RIGHT (\\$2)
.    \}
.END
\#
\#
\# SWITCH HDRFTR CENTER PADDING SIDE - support macro
\# --------------------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Switches the padding side of hdrftr center padding.
\# *Notes:
\#   Required to keep spacing around hdrftr string constant
\#   in recto/verso documents.
\#
.MAC SWITCH_HDRFTR_CENTER_PAD END
.    nr #HDRFTR_CTR_PAD_TMP  \\n[#HDRFTR_CTR_PAD_LEFT]
.    HDRFTR_CENTER_PAD LEFT  \\n[#HDRFTR_CTR_PAD_RIGHT]u
.    HDRFTR_CENTER_PAD RIGHT \\n[#HDRFTR_CTR_PAD_TMP]u
.END
\#
\#
\# HDRFTR RIGHT
\# ------------
\# *Argument:
\#   <what to put in the right position of page header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_RIGHT.
\#   Creates register #USER_DEF_HDRFTR_RIGHT, which, if 1,
\#   overrides the $HDRFTR_RIGHT string created by default
\#   in DEFAULTS.
\# *Notes:
\#   Default is document title.
\#
\#   If the argument is the # character, simply prints the current
\#   page number.
\#
\#   If the user wants to *incorporate* the page number into the string,
\#   \*[PAGE#] must be used.  For example, if the user wants to put
\#   an elipsis before the page number in the string, s/he should use
\#   ...\*[PAGE#], not ...#
\#
.MAC HDRFTR_RIGHT END
.    nr #USER_DEF_HDRFTR_RIGHT 1
.    ds $HDRFTR_RIGHT \\$1
.END
\#
\#
\# HDRFTR RIGHT FAMILY
\# -------------------
\# *Argument:
\#   <family of header/footer right string>
\# *Function:
\#   Creates or modifies string $HDRFTR_RIGHT_FAM.
\#
.MAC HDRFTR_RIGHT_FAMILY END
.    ds $HDRFTR_RIGHT_FAM \\$1
.END
\#
\#
\# HDRFTR RIGHT FONT
\# -----------------
\# *Argument:
\#   <font of header/footer right string>
\# *Function:
\#   Creates or modifies string $HDRFTR_RIGHT_FT.
\#
.MAC HDRFTR_RIGHT_FONT END
.    ds $HDRFTR_RIGHT_FT \\$1
.END
\#
\#
\# HDRFTR RIGHT SIZE
\# -----------------
\# *Argument:
\#   <+|- number of points to in/decrease size of right string in
\#   header/footers (relative to header/footer size)>
\# *Function:
\#   Creates or modifies string HDRFTR_RIGHT_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign.  No space afterwards.
\#   Fractional point sizes are allowed.
\#   Default is -2 for printstyle TYPESET if all caps; otherwise -.5
\#   Has no effect in TYPEWRITE.
\#
.MAC HDRFTR_RIGHT_SIZE END
.    ds $HDRFTR_RIGHT_SIZE_CHANGE \\$1
.END
\#
\#
\# HDRFTR RIGHT COLOR
\# ------------------
\# *Argument:
\#   <pre-defined color name>
\# *Function:
\#   Sets register #HDRFTR_RIGHT_COLOR to 1; creates string
\#   $HDRFTR_RIGHT_COLOR
\# *Notes:
\#   The color name must be pre-defined with NEWCOLOR or XCOLOR.
\#
.MAC HDRFTR_RIGHT_COLOR END
.    nr #HDRFTR_RIGHT_COLOR 1
.    ds $HDRFTR_RIGHT_COLOR \\$1
.END
\#
\#
\# HDRFTR RIGHT CAPS
\# -----------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalisation of $HDRFTR_RIGHT (typically, the title of
\#   the document) on or off.
\# *Notes:
\#   Default is on.
\#
.MAC HDRFTR_RIGHT_CAPS END
.    ie '\\$1'' \{\
.       nr #HDRFTR_RIGHT_CAPS 1
.    \}
.    el \{\
.       nr #HDRFTR_RIGHT_CAPS 0
.       ds $HDRFTR_RIGHT_SIZE_CHANGE +0
.    \}
.END
\#
\#
\# HDRFTR RULE COLOR
\# -----------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Sets register #HDRFTR_COLOR to 1; defines string
\#   $HDRFTR_RULE_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   HDRFTR_RULE_COLOR.
\#
.MAC HDRFTR_RULE_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    nr #HDRFTR_RULE_COLOR 1
.    ds $HDRFTR_RULE_COLOR \\$1
.END
\#
\#
\# HDRFTR RULE
\# -----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   If invoked via the alias HDRFTR_RULE_INTERNAL in HDRFTR, prints a rule
\#   under the header/footer.  Otherwise, turns HDRFTR_RULE on or off.
\#
.MAC HDRFTR_RULE END   \"To print rule under header/over footer.
.    ie '\\$0'HDRFTR_RULE_INTERNAL' \{\
.       ie \\n[#USERDEF_HDRFTR] \{\
.          nr #CAP_HEIGHT_ADJUST \\n[#HDRFTR_HEIGHT]
.          ps 12
.          if \\n[#HEADERS_ON] \{\
.             rt \\nyu
.             ALD \\n[#HDRFTR_RULE_GAP]u
.          \}
.          if \\n[#FOOTERS_ON] \{\
.              rt \\nyu
.              RLD \\n[#HDRFTR_RULE_GAP]u+\\n[#CAP_HEIGHT_ADJUST]u+1p
.          \}
.          ie \\n[#HDRFTR_RULE_COLOR]=1 \{\
.             PRINT \m[\\*[$HDRFTR_RULE_COLOR]]\\l'\\n[#DOC_L_LENGTH]u'\m[]
.          \}
.          el \{\
.             PRINT \\l'\\n[#DOC_L_LENGTH]u'
.          \}
.          br
.       \}
.       el \{\
.          if \\n[#PRINT_STYLE]=1 \{\
.             nr #CAP_HEIGHT_ADJUST \\n[#CAP_HEIGHT]
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             ie \\n[#LEFT_CAP_HEIGHT]>\\n[#CENTER_CAP_HEIGHT] \{\
.                nr #CAP_HEIGHT_ADJUST \\n[#LEFT_CAP_HEIGHT]
.             \}
.             el \{ .nr #CAP_HEIGHT_ADJUST \\n[#CENTER_CAP_HEIGHT] \}
.             ie \\n[#CAP_HEIGHT_ADJUST]>\\n[#RIGHT_CAP_HEIGHT] \{\
.                nr #CAP_HEIGHT_ADJUST \\n[#CAP_HEIGHT_ADJUST]
.             \}
.             el \{ .nr #CAP_HEIGHT_ADJUST \\n[#RIGHT_CAP_HEIGHT] \}
.          \}
.          ps 12
.          if \\n[#HEADERS_ON] \{\
.             rt \\nyu
.             ALD \\n[#HDRFTR_RULE_GAP]u
.          \}
.          if \\n[#FOOTERS_ON] \{\
.             rt \\nyu
.             RLD \\n[#HDRFTR_RULE_GAP]u+\\n[#CAP_HEIGHT_ADJUST]u+1p
.          \}
.          ie \\n[#HDRFTR_RULE_COLOR]=1 \{\
.             PRINT \m[\\*[$HDRFTR_RULE_COLOR]]\\l'\\n[#DOC_L_LENGTH]u'\m[]
.          \}
.          el \{\
.             PRINT \\l'\\n[#DOC_L_LENGTH]u'
.          \}
.          br
.       \}
.    \}
.    el \{\
.       ie '\\$1'' \{ .nr #HDRFTR_RULE 1 \}
.       el \{ .nr #HDRFTR_RULE 0 \}
.    \}
.END
\#
\#
.ALIAS HDRFTR_RULE_INTERNAL HDRFTR_RULE
\#
\#
\# HDRFTR PLAIN
\# ------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Sets the family, font, and point size of all strings in
\#   header/footers to the same family and point size as running
\#   text.  Font for the header/footer becomes roman throughout.
\#
.MAC HDRFTR_PLAIN END
.    HDRFTR_FAMILY        \\*[$DOC_FAM]
.    HDRFTR_PT_SIZE       \\n[#DOC_PT_SIZE]
.    HDRFTR_LEFT_FAMILY   \\*[$DOC_FAM]
.    HDRFTR_LEFT_FONT     R
.    HDRFTR_LEFT_SIZE     +0
.    HDRFTR_LEFT_CAPS     OFF
.    HDRFTR_CENTER_FAMILY \\*[$DOC_FAM]
.    HDRFTR_CENTER_FONT   R
.    HDRFTR_CENTER_SIZE   +0
.    HDRFTR_CENTER_CAPS   OFF
.    HDRFTR_RIGHT_FAMILY  \\*[$DOC_FAM]
.    HDRFTR_RIGHT_FONT    R
.    HDRFTR_RIGHT_SIZE    +0
.    HDRFTR_RIGHT_CAPS    OFF
.END
\#
\#
\# SWITCH HDRFTR
\# -------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #SWITCH_HDRFTR, used to switch
\#   default location of HDRFTR_LEFT and HDRFTR_RIGHT.
\# *Notes:
\#   Typically, the author string appears at the left of header/footers,
\#   and the title string appears at the right.  This switches the
\#   location of the two.  Useful in conjuction with RECTO_VERSO to
\#   tweak switches on alternate pages to come out as the user wishes.
\#   The assumption of RECTO_VERSO is that the first page of the document
\#   (recto) is odd, and even though it has no header/footer, if it did have one,
\#   it would print as AUTHOR...CENTER...TITLE (or whatever strings
\#   the user has supplied for HDRFTR_LEFT/RIGHT), meaning that the
\#   next page, which does have a header/footer, will come out as
\#   TITLE...CENTER...AUTHOR (or whatever strings the user has
\#   supplied for HDRFTR_LEFT/RIGHT).  SWITCH_HDRFTRS allows the user
\#   to get the desired string in the desired place on the desired
\#   recto/verso page.
\#
\#   Default is OFF.
\#
.MAC SWITCH_HDRFTR END
.    ie '\\$1'' \{ .nr #SWITCH_HDRFTR 1 \}
.    el \{ .nr #SWITCH_HDRFTR 0 \}
.END
\#
\#
\# USER DEFINED HDRFTR RECTO
\# -------------------------
\# *Arguments:
\#   L | LEFT | C | CENTER | CENTER | R | RIGHT <hdrftr_recto_string>
\# *Function:
\#   Toggles #USERDEF_HDRFTR on, stores quad as #USERDEF_HDRFTR_RECTO_QUAD,
\#   stores string in $USERDEF_HDRFTR_RECTO.
\# *Notes:
\#   For use when users don't want 3-part headers/footers, but rather
\#   want to design their own headers/footers and need different
\#   headers/footers on recto and verso pages.  Using just
\#   HEADER_RECTO, even when recto/verso is not on, allows users to
\#   design their own headers/footers for doc pages.
\#
.MAC HDRFTR_RECTO END
.    nr #USERDEF_HDRFTR 1
.    if '\\$1'L'      \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 1 \}
.    if '\\$1'LEFT'   \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 1 \}
.    if '\\$1'C'      \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 2 \}
.    if '\\$1'CENTER' \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 2 \}
.    if '\\$1'CENTRE' \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 2 \}
.    if '\\$1'R'      \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 3 \}
.    if '\\$1'RIGHT'  \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 3 \}
.    ds $USERDEF_HDRFTR_RECTO \\$2
.END
\#
\#
\# USER DEFINED HDRFTR VERSO
\# -------------------------
\# *Arguments:
\#   L | LEFT | C | CENTER | CENTER | R | RIGHT <hdrftr_verso_string>
\# *Function:
\#   Toggles #USERDEF_HDRFTR on, stores quad as #USERDEF_HDRFTR_VERSO_QUAD,
\#   stores string in $USERDEF_HDRFTR_VERSO.
\# *Notes:
\#   For use when users don't want 3-part headers/footers, but rather
\#   want to design their own headers/footers and need different
\#   headers/footers on recto and verso pages.
\#
.MAC HDRFTR_VERSO END
.    nr #USERDEF_HDRFTR 1
.    if '\\$1'L'      \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 1 \}
.    if '\\$1'LEFT'   \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 1 \}
.    if '\\$1'C'      \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 2 \}
.    if '\\$1'CENTER' \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 2 \}
.    if '\\$1'CENTRE' \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 2 \}
.    if '\\$1'R'      \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 3 \}
.    if '\\$1'RIGHT'  \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 3 \}
.    ds $USERDEF_HDRFTR_VERSO \\$2
.END
\#
\#
\# PRINT FOOTER ON FIRST PAGE
\# --------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #PRINT_FOOTER_ON_PAGE_1
\# *Notes:
\#   Lets user choose whether to print footer on first
\#   page of doc.
\#
.MAC FOOTER_ON_FIRST_PAGE END
.    ie '\\$1'' \{ .nr #PRINT_FOOTER_ON_PAGE_1 1 \}
.    el \{ .rr #PRINT_FOOTER_ON_PAGE_1 \}
.END
\#
\#
\# PRINT PAGE NUMBER ON FIRST PAGE
\# -------------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #PRINT_PAGENUM_ON_PAGE_1
\# *Notes:
\#   Lets user choose whether to print page number on first
\#   page of doc and after collate when footers are on or page numbering
\#   has been user set at top of page.
\#
.MAC PAGENUM_ON_FIRST_PAGE END
.    ie '\\$1'' \{ .nr #PRINT_PAGENUM_ON_PAGE_1 1 \}
.    el \{ .rr #PRINT_PAGENUM_ON_PAGE_1 \}
.END
\#
\#
\# PRINT HEADER/FOOTER
\# -------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Based on defaults or values entered by user, prints a
\#   three-part title at either the top or the bottom of the page.
\# *Notes:
\#   Called from within either HEADER or FOOTER.
\#
.MAC PRINT_HDRFTR END
.    if \\n[#DOC_TYPE]=4 \{\
.       nr #SUITE \En[.pn]
.    \}
.    if \\n[#FOOTERS_ON] \{\
.       if \\n[#START_FOR_FOOTERS] \{\
.          rr #START_FOR_FOOTERS
.          if !\\n[#PRINT_FOOTER_ON_PAGE_1] \{ .return \}
.       \}
.    \}
.    if \\n[#USERDEF_HDRFTR] \{\
.       PRINT_USERDEF_HDRFTR
.       return
.    \}
.    if \\n[#SWITCH_HDRFTR] \{\
.       ds $HDRFTR_TMP_SWITCH             \\*[$HDRFTR_LEFT]
.       ds $HDRFTR_LEFT                   \\*[$HDRFTR_RIGHT]
.       ds $HDRFTR_RIGHT                  \\*[$HDRFTR_TMP_SWITCH]
.       ds $HDRFTR_TMP_SIZE_CHANGE_SWITCH \\*[$HDRFTR_LEFT_SIZE_CHANGE]
.       ds $HDRFTR_LEFT_SIZE_CHANGE       \\*[$HDRFTR_RIGHT_SIZE_CHANGE]
.       ds $HDRFTR_RIGHT_SIZE_CHANGE      \\*[$HDRFTR_TMP_SIZE_CHANGE_SWITCH]
.       nr #HDRFTR_TMP_CAPS_SWITCH        \\n[#HDRFTR_LEFT_CAPS]
.       nr #HDRFTR_LEFT_CAPS              \\n[#HDRFTR_RIGHT_CAPS]
.       nr #HDRFTR_RIGHT_CAPS             \\n[#HDRFTR_TMP_CAPS_SWITCH]
.       ds $HDRFTR_TMP_COLOR_SWITCH       \\*[$HDRFTR_LEFT_COLOR]
.       ds $HDRFTR_LEFT_COLOR             \\*[$HDRFTR_RIGHT_COLOR]
.       ds $HDRFTR_RIGHT_COLOR            \\*[$HDRFTR_TMP_COLOR_SWITCH]
.       rr #HDRFTR_TMP_CAPS_SWITCH
.       rm $HDRFTR_TMP_SWITCH
.       rm $HDRFTR_TMP_SIZE_CHANGE_SWITCH
.       rm $HDRFTR_TMP_COLOR_SWITCH
.       nr #SWITCH_HDRFTR 0
.    \}
.    nr #PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]
.    if \\n[#ENDNOTES] \{ .PAGENUM_STYLE \\*[$EN_PN_STYLE] \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #LEFT_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       if o                        \{ .RIGHT \}
.       if e                        \{ .LEFT  \}
.       if \\n[#RECTO_VERSO]=0      \{ .LEFT  \}
.       if \\n[#HDRFTR_LEFT_CAPS]   \{ .CAPS  \}
.       ie '\\*[$HDRFTR_LEFT]'#' \{\
.           PRINT \\n[#PAGENUMBER]
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_LEFT]'' \{ . PRINT \\*[$HDRFTR_LEFT] \}
.          el \{ .PRINT \& \}
.       \}
.       if \\n[#HDRFTR_LEFT_CAPS] \{ .CAPS OFF \}
.       CENTER
.       if \\n[#HDRFTR_CENTER_CAPS] \{ .CAPS \}
.       rt \\nyu
.       ie '\\*[$HDRFTR_CENTER]'#' \{\
.           PRINT \\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\n[#PAGENUMBER]\\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_CENTER]'' \{ .PRINT \\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\*[$HDRFTR_CENTER]\\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u' \}
.          el \{ .PRINT \& \}
.       \}
.       if \\n[#HDRFTR_CENTER_CAPS] \{ .CAPS OFF \}
.       if o                       \{ .LEFT  \}
.       if e                       \{ .RIGHT \}
.       if \\n[#RECTO_VERSO]=0     \{ .RIGHT \}
.       if \\n[#HDRFTR_RIGHT_CAPS] \{ .CAPS  \}
.       rt \\nyu
.       ie '\\*[$HDRFTR_RIGHT]'#' \{\
.           PRINT \\n[#PAGENUMBER]
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_RIGHT]'' \{ .PRINT \\*[$HDRFTR_RIGHT] \}
.          el \{ .PRINT \& \}
.       \}
.       if \\n[#HDRFTR_RIGHT_CAPS] \{ .CAPS OFF \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#HDRFTR_COLOR]=1 \{\
.          nf
\m[\\*[$HDRFTR_COLOR]]
.          EL
.       \}
.       fam     \\*[$HDRFTR_LEFT_FAM]
.       ft      \\*[$HDRFTR_LEFT_FT]
.       ps      \\n[#HDRFTR_PT_SIZE]u\\*[$HDRFTR_LEFT_SIZE_CHANGE]
.       vs      12
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #LEFT_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       if o                      \{ .LEFT  \}
.       if e                      \{ .RIGHT \}
.       if \\n[#RECTO_VERSO]=0    \{ .LEFT  \}
.       if \\n[#HDRFTR_LEFT_CAPS] \{ .CAPS  \}
.       ie '\\*[$HDRFTR_LEFT]'#' \{\
.          ie \\n[#HDRFTR_LEFT_COLOR]=1 \{\
.             PRINT \m[\\*[$HDRFTR_LEFT_COLOR]]\\n[#PAGENUMBER]\m[]
.          \}
.          el \{\
.             PRINT \\n[#PAGENUMBER]
.          \}
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_LEFT]'' \{\
.             ie \\n[#HDRFTR_LEFT_COLOR]=1 \{\
.                 PRINT \m[\\*[$HDRFTR_LEFT_COLOR]]\\*[$HDRFTR_LEFT]\m[]
.             \}
.             el \{\
.                 PRINT \\*[$HDRFTR_LEFT]
.             \}
.          \}
.          el \{ .PRINT \& \}
.       \}
.       if \\n[#HDRFTR_LEFT_CAPS] \{ .CAPS OFF \}
.       fam     \\*[$HDRFTR_CENTER_FAM]
.       ft      \\*[$HDRFTR_CENTER_FT]
.       ps      \\n[#HDRFTR_PT_SIZE]u\\*[$HDRFTR_CENTER_SIZE_CHANGE]
.       vs      12
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #CENTER_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       CENTER
.       if \\n[#HDRFTR_CENTER_CAPS] \{ .CAPS \}
.       rt \\nyu
.       ie '\\*[$HDRFTR_CENTER]'#' \{\
.           ie \\n[#HDRFTR_CENTER_COLOR]=1 \{\
.              PRINT \\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\m[\\*[$HDRFTR_CENTER_COLOR]]\\n[#PAGENUMBER]\\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'\m[]
.           \}
.           el \{\
.              PRINT \\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\n[#PAGENUMBER]\\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.           \}
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_CENTER]'' \{\
.             ie \\n[#HDRFTR_CENTER_COLOR]=1 \{\
.                PRINT \\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\m[\\*[$HDRFTR_CENTER_COLOR]]\\*[$HDRFTR_CENTER]\\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'\m[]
.             \}
.             el \{\
.                PRINT \\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\*[$HDRFTR_CENTER]\\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.             \}
.          \}
.          el \{ .PRINT \& \}
.       \}
.       if \\n[#HDRFTR_CENTER_CAPS] \{ .CAPS OFF \}
.       fam     \\*[$HDRFTR_RIGHT_FAM]
.       ft      \\*[$HDRFTR_RIGHT_FT]
.       ps      \\n[#HDRFTR_PT_SIZE]u\\*[$HDRFTR_RIGHT_SIZE_CHANGE]
.       vs      12
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #RIGHT_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       if o                       \{ .RIGHT \}
.       if e                       \{ .LEFT  \}
.       if \\n[#RECTO_VERSO]=0     \{ .RIGHT \}
.       if \\n[#HDRFTR_RIGHT_CAPS] \{ .CAPS  \}
.       rt \\nyu
.       ie '\\*[$HDRFTR_RIGHT]'#' \{\
.          ie \\n[#HDRFTR_RIGHT_COLOR]=1 \{\
.             PRINT \m[\\*[$HDRFTR_RIGHT_COLOR]]\\n[#PAGENUMBER]\m[]
.          \}
.          el \{\
.             PRINT \\n[#PAGENUMBER]
.          \}
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_RIGHT]'' \{\
.             ie \\n[#HDRFTR_RIGHT_COLOR]=1 \{\
.                PRINT \m[\\*[$HDRFTR_RIGHT_COLOR]]\\*[$HDRFTR_RIGHT]\m[]
.             \}
.             el \{\
.                PRINT \\*[$HDRFTR_RIGHT]
.             \}
.          \}
.          el \{ .PRINT \& \}
.       \}
.       if \\n[#HDRFTR_RIGHT_CAPS] \{ .CAPS OFF \}
.    \}
.    if \\n[#HDRFTR_RULE] \{\
.       HDRFTR_RULE_INTERNAL
.    \}
.END
\#
\#
\# PRINT USER DEFINED HEADER/FOOTER
\# --------------------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Based on defaults or values entered by user, prints a single part
\#   (i.e. not 3-part) title at either the top or the bottom of the page.
\# *Notes:
\#   Called from within PRINT_HDRFTR.
\#
.MAC PRINT_USERDEF_HDRFTR END
.    nr #PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]
.    fc ^ #
.    if \\n[#PRINT_STYLE]=2 \{\
.       FAMILY  \\*[$HDRFTR_FAM]
.       FT      R
.       PT_SIZE \\n[#HDRFTR_PT_SIZE]u
.       if \\n[#HDRFTR_COLOR]=1 \{\
.          nf
.          COLOR \\*[$HDRFTR_COLOR]
.       \}
.    \}
.    ie \\n[#RECTO_VERSO] \{\
.       if o \{\
.          if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=1 \{ .LEFT   \}
.          if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=2 \{ .CENTER \}
.          if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=3 \{ .RIGHT  \}
.          PRINT \\*[$USERDEF_HDRFTR_RECTO]
.          EL
.          if \\n[#FOOTERS_ON] \{\
.             di NULL
.             SIZESPECS
.             nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.             di
.          \}
.       \}
.       if e \{\
.          ie !'\\*[$USERDEF_HDRFTR_VERSO]'' \{\
.             if \\n[#USERDEF_HDRFTR_VERSO_QUAD]=1 \{ .LEFT   \}
.             if \\n[#USERDEF_HDRFTR_VERSO_QUAD]=2 \{ .CENTER \}
.             if \\n[#USERDEF_HDRFTR_VERSO_QUAD]=3 \{ .RIGHT  \}
.             PRINT \\*[$USERDEF_HDRFTR_VERSO]
.             EL
.             if \\n[#FOOTERS_ON] \{\
.                di NULL
.                SIZESPECS
.                nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.                di
.             \}
.          \}
.          el \{\
.             if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=1 \{ .LEFT   \}
.             if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=2 \{ .CENTER \}
.             if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=3 \{ .RIGHT  \}
.             PRINT \\*[$USERDEF_HDRFTR_RECTO]
.             EL
.             if \\n[#FOOTERS_ON] \{\
.                di NULL
.                SIZESPECS
.                nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.                di
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=1 \{ .LEFT   \}
.       if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=2 \{ .CENTER \}
.       if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=3 \{ .RIGHT  \}
.       PRINT \\*[$USERDEF_HDRFTR_RECTO]
.       EL
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.    \}
.    fc
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#HDRFTR_COLOR]=1 \m[\\*[$HDRFTR_COLOR]]
.       el \m[black]
.    \}
.    if \\n[#HDRFTR_RULE] \{\
.       HDRFTR_RULE_INTERNAL
.    \}
.END
\#
\#
\# +++HEADERS+++
\#
\# HEADERS (off or on)
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns headers at the top of the page off or on.
\# *Notes:
\#   Default is on.
\#
.MAC HEADERS END
.    ie '\\$1'' \{ .nr #HEADERS_ON 1 \}
.    el \{ .nr #HEADERS_ON 0 \}
.END
\#
\#
\# HEADER MARGIN
\# -------------
\# *Argument:
\#   <amount of space between top of page and header>
\# *Function:
\#   Creates or modifies register #HEADER_MARGIN to hold amount
\#   of space between top of page and header.
\# *Notes:
\#   Requires unit of measure.  Default is 4P+6p, measured top-of-page
\#   to baseline.
\#
.MAC HEADER_MARGIN END
.    nr #HEADER_MARGIN (\\$1)
.END
\#
\#
\# HEADER GAP
\# ----------
\# *Argument:
\#   <amount of space between header and running text>
\# *Function:
\#   Creates or modifies register #HEADER_GAP to hold amount
\#   of space between header and running text.
\# *Notes:
\#   Default is 1P+6p.
\#
.MAC HEADER_GAP END
.    nr #HEADER_GAP (\\$1)
.END
\#
\#
\# HEADER
\# ------
\# *Arguments:
\#   <none>
\# *Function:
\#   Prints header appropriate to DOC_TYPE, PRINTSTYLE, and COPYSTYLE.
\# *Notes:
\#   In order to convert the title string to caps in the header (in the
\#   event that the user enters .TITLE in caps/lc), I've used
\#   quad left, quad centre, and quad right to arrange the three bits
\#   of the header, rather than .tl.  This allows the use of the CAPS macro.
\#   The downside is that I have to add \\v'-(\\n[#LEAD]u*#) in order
\#   for -Tlatin1 output to align the header/footer strings on the baseline.
\#   The console output still isn't brilliant, but at least it's
\#   comprehensible.
\#
.MAC HEADER END
.    PROCESS_FN_LEFTOVER
.    nr #FN_COUNT_FOR_COLS 0 1
.    if \\n[#RESET_FN_NUMBER] \{ .nr #FN_NUMBER 0 1 \}
.    po \\n[#DOC_L_MARGIN]u
.    if \\n[#RECTO_VERSO] \{\
.       if !\\n[#TOC_RV_SWITCH] \{\
.          nr #DOC_LR_MARGIN_TMP \\n[#DOC_L_MARGIN]
.          DOC_LEFT_MARGIN  \\n[#DOC_R_MARGIN]u
.          DOC_RIGHT_MARGIN \\n[#DOC_LR_MARGIN_TMP]u
.          SWITCH_HDRFTR_CENTER_PAD
.       \}
.       rr #TOC_RV_SWITCH
.    \}
.    ev HEADER
.    if \\n[#PAGE_NUM_V_POS]=1 \{ .vs 0 \}
.    sp |\\n[#HEADER_MARGIN]u-1v
.    mk y
.    ll \\n[#DOC_L_LENGTH]u
.    ta \\n(.lu
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam C
.       ft  R
.       ps  12\\*[$HDRFTR_SIZE_CHANGE]
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.      fam \\*[$HDRFTR_FAM]
.      ft  R
.      ps  \\n[#DOC_PT_SIZE]u\\*[$HDRFTR_SIZE_CHANGE]
.      vs  12
.    \}
.    nr #HDRFTR_PT_SIZE \\n[#PT_SIZE]
.    if \\n[#CAPS_ON] \{\
.       nr #CAPS_WAS_ON 1
.       CAPS OFF
.    \}
.    if \\n[#UNDERLINE_ON] \{\
.       nr #UNDERLINE_WAS_ON 1
.       UNDERLINE OFF
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#ENDNOTES]=1 \{\
.          if \\n[#EN_SINGLESPACE] \{\   \"Endnotes s-spaced have different lead
.             nr #RESTORE_DOC_LEAD \\n[#DOC_LEAD]
.             nr #DOC_LEAD \\n[#EN_LEAD]u
.          \}
.       \}
.    \}
.    ie \\n[#HEADERS_ON] \{\
.       PRINT_HDRFTR
.       sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.    \}
.    el \{\
.       ie \\n[#PAGE_NUM_V_POS]=1 \{\
.          ie \\n[#PAGINATE] \{\
.             PRINT_PAGE_NUMBER
.             sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.          \}
.          el \{ .sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u \}
.       \}
.       el \{ .sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u \}
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#ENDNOTES]=1 \{\
.          if \\n[#EN_SINGLESPACE] \{\
.             nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]u
.             rr #RESTORE_DOC_LEAD
.          \}
.       \}
.    \}
.    nr #PAGE_TOP \\n(nl
.    ev
.    po \\n[#L_MARGIN]u
.    if \\n[#RECTO_VERSO] \{\
.       nr #L_MARGIN +\\n[#L_MARGIN_DIFF]
.    \}
.    if \\n[#CAPS_WAS_ON] \{\
.       CAPS
.       rr #CAPS_WAS_ON
.    \}
.    if \\n[#UNDERLINE_WAS_ON] \{\
.       UNDERLINE
.       rr #UNDERLINE_WAS_ON
.    \}
.    if \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.    if \\n[#QUOTE] \{\
.       ie \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.       el \{\
.          nr #Q_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.          po \\n[#Q_OFFSET]u
.       \}
.    \}
.    if \\n[#EPIGRAPH] \{\
.       ie \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.       el \{\
.          nr #EPI_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.          po \\n[#EPI_OFFSET]u
.       \}
.    \}
.    ie \\n[#EPIGRAPH] \{\
.       ie !\\n[#EPI_ACTIVE] \{\
.          ns
.          rr #EPI_ACTIVE
.       \}
.       el \{\
.          ie \\n[#EPI_FITS] \{ .ns \}
.          el \{ .ALD \\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u \}
.       \}
.    \}
.    el \{ .ns \}
.    ns
.    if \\n[#COLUMNS] \{\
.       nr #L_MARGIN \\n[#DOC_L_MARGIN]
.       if \\n[#RECTO_VERSO] \{ .COLUMNS \\n[#NUM_COLS] \\n[#GUTTER]u \}
.       nr #COL_NUM 0 1
.       mk dc
.       po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n(.o
.       if \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.       ll \\n[#COL_L_LENGTH]u
.       ta \\n(.lu
.       if \\n[#QUOTE] \{\
.          po +(\\n[#PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u)
.       \}
.       if \\n[#EPIGRAPH] \{\
.          if \\n[#EPI_ACTIVE] \{\
.             ie \\n[#EPI_FITS] \{ . \}
.             el \{ .nr dc -\\n[#EPI_LEAD_DIFF] \}
.          \}
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u+(\\n[#PP_INDENT]u*\\n[#EPI_OFFSET_VALUE]u)
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#SLANT_ON] \{\
.          if \\n[#UNDERLINE_SLANT] \{ .UNDERLINE \}
.       \}
.    \}
.END
\#
\# ====================================================================
\#
\# +++FOOTERS+++
\#
\# FOOTERS (off or on)
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns footers at the bottom of the page off or on.
\# *Notes:
\#   Default is off.  If on, page numbers automatically go at
\#   the top, centered, unless pagination has been turned off,
\#   or the pagenumber position has been changed to left or right.
\#
.MAC FOOTERS END
.    ie '\\$1''   \{\
.       nr #FOOTERS_ON 1
.       PAGE_NUM_POS TOP CENTER
.    \}
.    el \{ .nr #FOOTERS_ON 0 \}
.END
\#
\#
\# FOOTER MARGIN
\# -------------
\# *Argument:
\#   <footer margin>
\# *Function:
\#   Creates or modifies register #FOOTER_MARGIN which holds the
\#   amount of space to leave between the page number and the bottom
\#   of the page.
\# *Notes:
\#   Unit of measure required.  Default is 3P.
\#
.MAC FOOTER_MARGIN END
.    ie \\n%>0 \{ .nr #FOOTER_MARGIN (\\$1) \}
.    el \{ . \}
.END
\#
\#
\# FOOTER GAP
\# ----------
\# *Argument:
\#   <distance from end of running text to page # or footer>
\# *Function:
\#   Creates or modifies register #FOOTER_GAP which holds the
\#   amount of space to leave between running text and the page number.
\# *Notes:
\#   Requires unit of measure.  Default is 3P.  Measured baseline to
\#   baseline.
\#
.MAC FOOTER_GAP END
.    ie \\n%>0 \{ .nr #FOOTER_GAP (\\$1) \}
.    el \{ . \}
.END
\#
\#
\# FOOTER
\# ------
\# *Arguments:
\#   <none>
\# *Function:
\#   Places footer at bottom of page if #FOOTERS=1, otherwise
\#   places page number at bottom of page (if #PAGINATE=1).
\#   Page numbers are in arabic or roman according to COPYSTYLE.
\#   DRAFT starts the document at page 1 regardless of PAGENUMBER.
\#   FINAL respects PAGENUMBER.
\#
.MAC FOOTER END
.    ev PAGE_BOTTOM
\# Removed this next bit; can't figure out why I needed it.
\#.    if \\n[#START]=1 \{\
\#.       bp
\#.       ev
\#.       rr #START
\#.       return
\#.    \}
.    nr #L_MARGIN_DIFF \\n[#L_MARGIN]-\\n[#DOC_L_MARGIN]
.    if !\\n[#FN_DEFER] \{\
.       nr #DIVER_DEPTH 0
.       if \\n[#FN_COUNT] \{\
.          sp |\\n[#PAGE_LENGTH]u-(\\n[#B_MARGIN]u+\\n[#FN_DEPTH]u)
.          po \\n[#DOC_L_MARGIN]u
.          if \\n[#COLUMNS] \{\
.             po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.             nr #L_MARGIN \\n(.o
.          \}
.          nf
.          FOOTNOTES
.          rm FOOTNOTES
.          if '\\n(.z'FN_OVERFLOW' \{\
.              di
.              nr #FN_OVERFLOW_DEPTH \\n[#DIVER_DEPTH]
.          \}
.          nr #FN_COUNT 0
.          if \\n[#COL_NEXT] \{ .nr #COL_NUM \\n-[#COL_NUM] \}
.       \}
.    \}
.    ie \\n[#COLUMNS] \{\
.       ie \\n[#COL_NUM]=\\n[#NUM_COLS] \{ .DO_FOOTER \}
.       el \{\
.          ie \\n[#ENDNOTES] \{ .sp |\\n(ecu-\\n[#EN_LEAD]u \}
.          el \{ .sp |\\n(dcu \}
.          po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n(.o
.          PROCESS_FN_LEFTOVER
.          if !\\n[#EPIGRAPH] \{ .rr #COL_NEXT \}
.          if !\\n[#QUOTE]    \{ .rr #COL_NEXT \}
.          if \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.          if \\n[#QUOTE] \{\
.             ie \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.             el \{\
.                nr #Q_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.                if \\n[#COLUMNS] \{ .nr #Q_OFFSET \\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE]) \}
.                po \\n[#Q_OFFSET]u
.             \}
.          \}
.          if \\n[#EPIGRAPH] \{\
.             ie \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.             el \{\
.                nr #EPI_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.                if \\n[#COLUMNS] \{ .nr #EPI_OFFSET \\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE]) \}
.                po \\n[#EPI_OFFSET]u
.             \}
.          \}
.          ie \\n[#EPIGRAPH] \{\
.             ie !\\n[#EPI_ACTIVE] \{\
.                ns
.                rr #EPI_ACTIVE
.             \}
.             el \{\
.                sp |\\n(dcu+(\\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u)
.                rr #EPI_ACTIVE
.             \}
.          \}
.          el \{ .ns \}
.          ev
.       \}
.       ns
.    \}
.    el \{ .DO_FOOTER \}
.END
\#
\#
\# PROCESS FOOTER
\# --------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Prints footer (page number, or 3-part footer).
\#   Resets CAPS and UNDERLINE if they were on.
\#
.MAC DO_FOOTER END
.    ie (\\n[#FOOTER_MARGIN]+\\n(.v)>\\n[#B_MARGIN] \{\
.       nr #SKIP_FOOTER 1
.    \}
.    el \{\
.       vs 12
.       sp |\\n[#PAGE_LENGTH]u-\\n[#FOOTER_MARGIN]u-1v
.       mk y
.    \}
.    ev FOOTER
.    po \\n[#DOC_L_MARGIN]u
.    ll \\n[#DOC_L_LENGTH]u
.    ta \\n(.lu
.    FAMILY  \\*[$HDRFTR_FAM]
.    FT      R
.    PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$HDRFTR_SIZE_CHANGE]
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam C
.       ft  R
.       ps  12
.    \}
.    nr #HDRFTR_PT_SIZE \\n[#PT_SIZE]
.    if \\n[#CAPS_ON] \{\
.       nr #CAPS_WAS_ON 1
.       CAPS OFF
.    \}
.    if \\n[#UNDERLINE_ON] \{\
.       nr #UNDERLINE_WAS_ON 1
.       UNDERLINE OFF
.    \}
.    ie \\n[#FOOTERS_ON] \{\
.       if !\\n[#SKIP_FOOTER]=1 \{ .PRINT_HDRFTR \}
.    \}
.    el \{\
.       if \\n[#PAGINATE] \{\
.          if \\n[#PAGE_NUM_V_POS]=2 \{\
.             if !\\n[#SKIP_FOOTER]=1 \{ .PRINT_PAGE_NUMBER \}
.          \}
.       \}
.    \}
.    rr #SKIP_FOOTER
.    if \\n[#CAPS_WAS_ON] \{\
.       CAPS
.       rr #CAPS_WAS_ON
.    \}
.    if \\n[#UNDERLINE_WAS_ON] \{\
.       UNDERLINE
.       rr #UNDERLINE_WAS_ON
.    \}
.    ev
.    bp
.    ev
.END
\#
\# ====================================================================
\#
\# +++HEADS+++
\#
\# ---Head numbers---
\#
\# NUMBER HEADS
\# ------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #NUMBER_HEAD; sets incrementing register #HEAD_NUM.
\# *Notes:
\#   Default is OFF.
\#
.MAC NUMBER_HEADS END
.    ie '\\$1'' \{\
.       nr #NUMBER_HEAD 1
.       if !\\n[#HEAD_NUM] \{ .nr #HEAD_NUM 0 1 \}
.    \}
.    el \{ .rr #NUMBER_HEAD \}
.END
\#
\#
\# RESET HEAD NUMBER
\# -----------------
\# *Arguments:
\#   <none> | <desired head number>
\# *Function:
\#   Resets incrementing register #HEAD_NUM to 1 or, if there's
\#   an argument, to user supplied number.
\# *Notes:
\#   Also resets subhead and parahead numbers.  If this is not
\#   desired, subhead and parahead numbers may be reset individually.
\#
.MAC RESET_HEAD_NUMBER END
.    ie '\\$1'' \{\
.       nr #HEAD_NUM 0 1
.       nr #SH_NUM   0 1
.       nr #PH_NUM   0 1
.    \}
.    el \{\
.       nr #HEAD_NUM \\$1-1 1
.       nr #SH_NUM   0 1
.       nr #PH_NUM   0 1
.    \}
.END
\#
\#
\# NUMBER SUBHEADS
\# ---------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #NUMBER_SH; sets incrementing register #SH_NUM.
\# *Notes:
\#   Default is OFF.
\#
.MAC NUMBER_SUBHEADS END
.    ie '\\$1'' \{\
.       nr #NUMBER_SH 1
.       if !\\n[#SH_NUM] \{ .nr #SH_NUM 0 1 \}
.    \}
.    el \{ .rr #NUMBER_SH \}
.END
\#
\#
\# RESET SUBHEAD NUMBER
\# --------------------
\# *Arguments:
\#   <none> | <desired subhead number>
\# *Function:
\#   Resets incrementing register #SH_NUM to 1 or, if there's
\#   an argument, to user supplied number.
\# *Notes:
\#   When the subhead number is reset, it resets the parahead number as
\#   well.  If this behaviour is not what's wanted, RESET_SUBHEAD_NUMBER
\#   allows the user to set the parahead number to whatever s/he desires.
\#
.MAC RESET_SUBHEAD_NUMBER END
.    ie '\\$1'' \{ .nr #SH_NUM 0 1 \}
.    el \{\
.       nr #SH_NUM \\$1-1 1
.       nr #PH_NUM 0 1
.       \}
.END
\#
\#
\# NUMBER PARAHEADS
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #NUMBER_PH; sets incrementing register #PH_NUM.
\# *Notes:
\#   Default is OFF.
\#
.MAC NUMBER_PARAHEADS END
.    ie '\\$1'' \{\
.       nr #NUMBER_PH 1
.       if !\\n[#PH_NUM] \{ .nr #PH_NUM 0 1 \}
.    \}
.    el \{ .rr #NUMBER_PH \}
.END
\#
\#
\# RESET PARAHEAD NUMBER
\# ---------------------
\# *Arguments:
\#   <none> | <desired parahead number>
\# *Function:
\#   Resets incrementing register #PH_NUM to 1 or, if there's
\#   an argument, to user supplied number.
\# *Notes:
\#   Resetting the parahead number resets the parahead number
\#   only.
\#
.MAC RESET_PARAHEAD_NUMBER END
.    ie '\\$1'' \{ .nr #PH_NUM 0 1 \}
.    el \{ nr #SH_NUM \\$1-1 1 \}
.END
\#
\#
\# ---Main heads---
\#
\# HEAD FAMILY
\# -----------
\# *Argument:
\#   <family to use for section titles (main heads)>
\# *Function:
\#   Creates or modifies string $HEAD_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC HEAD_FAMILY END
.    ds $HEAD_FAM \\$1
.END
\#
\#
\# HEAD FONT
\# ---------
\# *Argument:
\#   <font to use for section titles (main heads)>
\# *Function:
\#   Creates or modifies string $HEAD_FT.
\# *Notes:
\#   Default is bold.
\#
.MAC HEAD_FONT END
.    ds $HEAD_FT \\$1
.END
\#
\#
\# HEAD SIZE
\# ---------
\# *Argument:
\#   <+|- number of points by which to in/decrease point size of
\#   section titles (relative to running text)>
\# *Function:
\#   Creates or modifies string $HEAD_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a - or + sign with no space afterwards.
\#   Fractional point sizes are allowed.
\#   Default +1 for printstyle TYPESET; +0 for TYPEWRITE.
\#
.MAC HEAD_SIZE END
.    ds $HEAD_SIZE_CHANGE \\$1
.END
\#
\#
\# HEAD QUAD
\# ---------
\# *Arguments:
\#   L | LEFT | R | RIGHT | C | CENTER | CENTRE
\# *Function:
\#   Creates or modifies string $HEAD_QUAD.
\# *Notes:
\#   Default is CENTER.
\#
.MAC HEAD_QUAD END
.    ds $HEAD_QUAD \\$1
.END
\#
\#
\# HEAD CAPS
\# ---------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #HEAD_CAPS.
\# *Notes:
\#   Default is on.
\#
.MAC HEAD_CAPS END
.    ie '\\$1'' \{ .nr #HEAD_CAPS 1 \}
.    el \{ .nr #HEAD_CAPS 0 \}
.END
\#
\#
\# HEAD COLOR
\# ----------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Defines string $HEAD_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   HEAD_COLOR.
\#
.MAC HEAD_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    nr #HEAD_COLOR 1
.    ds $HEAD_COLOR \\$1
.END
\#
\#
\# HEAD SPACE
\# ----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates register #HEAD_SPACE, which toggles whether the space
\#   before heads is 1 extra line space ("off") or 2 ("on").  Used only
\#   in PRINTSTYLE TYPESET.
\# *Notes:
\#   Default is on.
\#
.MAC HEAD_SPACE END
.    ie '\\$1'' \{ .nr #HEAD_SPACE 1 \}
.    el \{ .nr #HEAD_SPACE 0 \}
.END
\#
\#
\# HEAD UNDERLINE
\# --------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #HEAD_UNDERLINE.
\# *Notes:
\#   Default is on.
\#
.MAC HEAD_UNDERLINE END
.    ie '\\$1'' \{ .nr #HEAD_UNDERLINE 1 \}
.    el \{ .nr #HEAD_UNDERLINE 0 \}
.END
\#
\#
\# MAIN HEAD
\# ---------
\# *Arguments:
\#   "text of main head" ["text of main head"] ...
\# *Function:
\#   In TYPEWRITE, prints main heads centered, all caps, underlined.
\#   In TYPESET, prints bold main heads 1 point larger than running
\#   text, all caps, underlined.
\# *Notes:
\#   The HEAD macro requires that double-quotes (") surround
\#   each line of text.
\#
.MAC HEAD END
.    br
\# Collect head for TOC.
.    nr #ARG_NUM 0 1
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.    while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.       ie \\n[#ARG_NUM]=\\n[#NUM_ARGS] \{\
.          as $TOC_HEAD_ITEM \\$[\\n+[#ARG_NUM]]\\|
.       \}
.       el \{\
\# Note that in the .as lines, below, \ at the end has a literal
\# space after it.
.          ie \\n[#NUMBER_HEAD] \{\
.             ie \\n[#ARG_NUM]=0 \{\
.                as $TOC_HEAD_ITEM \\n+[#HEAD_NUM].\0\\$[\\n+[#ARG_NUM]]\ 
.                nr #HEAD_NUM \\n-[#HEAD_NUM]
.             \}
.             el \{\
.                as $TOC_HEAD_ITEM \\$[\\n+[#ARG_NUM]]\ 
.             \}
.          \}
.          el \{\
.             as $TOC_HEAD_ITEM \\$[\\n+[#ARG_NUM]]\ 
.          \}
.       \}
.    \}
\# Note the use of \!, which transparently embeds the macros used
\# in the TOC_ENTRIES diversion.  The elements they control must be
\# processed literally when the diversion is output.
.    ev TOC_EV
.    da TOC_ENTRIES
.    if \\n[#PRINT_STYLE]=1 \{\
\!.     fam C
\!.     ft  R
\!.     ps  12
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_HEAD_FAM]
\!.     FT      \\*[$TOC_HEAD_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_HEAD_SIZE_CHANGE]
.    \}
\!.  TRAP OFF
.    ie \\n[#PRINT_STYLE]=1 \{\
\!.     PAD "\\h'2m'\\*[$TOC_HEAD_ITEM]\\*[$TOC_PN_TYPEWRITE]"
.    \}
.    el \{\
\!.     PAD "\\h'\\n[#TOC_HEAD_INDENT]u'\\*[$TOC_HEAD_ITEM]\\*[$TOC_PN]"
.    \}
\!.  EL
\!.  ST 100 L
\!.  ST 101 R
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_PN_FAM]
\!.     FT      \\*[$TOC_PN_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.    \}
\!.  TAB 100
\!.  PRINT \\*[LEADER]
\!.  TN
\!.  TRAP
\!.  PRINT \\n[#TOC_ENTRY_PN]
\!.  TQ
.    di       
.    ev
\# End collection of head for TOC
\# Process head
.    nr #HEAD 1
.    ev HEAD
.    ll \\n[#L_LENGTH]u
.    ta \\n(.lu
.    if \\n[#COLUMNS] \{\
.       ll \\n[#COL_L_LENGTH]u
.       ta \\n(.lu
.    \}
.    CHECK_INDENT
.    QUAD \\*[$HEAD_QUAD]
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam C
.       ft  R
.       ps  12
.       vs  \\n[#DOC_LEAD]u
.       UNDERLINE OFF
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       FAMILY  \\*[$HEAD_FAM]
.       FT      \\*[$HEAD_FT]
.       PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$HEAD_SIZE_CHANGE]
.       LS      \\n[#DOC_LEAD]u
.    \}
.    if r#QUOTE             \{ .rr #QUOTE \}
.    if r#EPIGRAPH          \{ .rr #EPIGRAPH \}
.    if \\n[#PRINT_STYLE]=1 \{ .ne 3 \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#HEAD_SPACE] \{ .ne 4 \}
.       el \{ .ne 3 \}
.    \}
.    ie \\n[#START] \{\
.       if \\n[#DOC_HEADER]=0 \{ . \}
.    \}
.    el \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          if !\\n[#LINEBREAK] \{\
.             ALD \\n[#DOC_LEAD]u
.             if \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.          \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          ie \\n[#PP_SPACE] \{\
.             ie \\n[#END_QUOTE] \{ . \}
.             el \{\
.                if !\\n[#LINEBREAK] \{\
.                   if \\n[#HEAD_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.                \}
.             \}
.          \}
.          el \{\
.             ie \\n[#HEAD_SPACE] \{ .ALD \\n[#DOC_LEAD]u*2u \}
.             el \{ .ALD \\n[#DOC_LEAD]u \}
.          \}
.          if \\n[#END_QUOTE] \{\
.             if !\\n[#Q_FITS] \{\
.                RLD \\n[#DOC_LEAD]u
.                if \\n[#PP_ACTIVE] \{ .ALD \\n[#DOC_LEAD]u \}
.             \}
.             if \\n[#Q_AT_TOP] \{\
.                RLD \\n[#DOC_LEAD]u
.                if \\n[#Q_AT_TOP] \{ .ALD \\n[#DOC_LEAD]u \}
.             \}
.          \}
.          if \\n[#LINEBREAK] \{\
.             if \\n[#HEAD_SPACE] \{ .RLD \\n[#DOC_LEAD]u \}
.          \}
.       \}
.    \}
\# Print head
.    nr #ARG_NUM 0 1
.    if \\n[#HEAD_CAPS] \{ .CAPS \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#HEAD_COLOR]=1 \{\
.          TRAP OFF
.          COLOR \\*[$HEAD_COLOR]
.          EL
.          TRAP
.       \}
.    \}
.    while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.       ie \\n[#NUMBER_HEAD] \{\
.          ie \\n[#ARG_NUM]=0 \{\
.             br
.             ie \\n[#HEAD_UNDERLINE]=0 \{ .PRINT "\\n+[#HEAD_NUM].\0\\$[\\n+[#ARG_NUM]]\}
.             el \{ .UNDERSCORE "\\n+[#HEAD_NUM].\0\\$[\\n+[#ARG_NUM]]\}
.             br
.          \}
.          el \{\
.             br
.             ie \\n[#HEAD_UNDERLINE]=0 \{ .PRINT "\\$[\\n+[#ARG_NUM]]\}
.             el \{ .UNDERSCORE "\\$[\\n+[#ARG_NUM]]\}
.             br
.          \}
.       \}
.       el \{\
.          br
.          ie \\n[#HEAD_UNDERLINE]=0 \{ .PRINT "\\$[\\n+[#ARG_NUM]]\}
.          el \{ .UNDERSCORE "\\$[\\n+[#ARG_NUM]]\}
.          br
.       \}
.    \}
.    REMOVE_INDENT
.    CAPS OFF
.    ev
.    ALD \\n[#DOC_LEAD]u
.    RESET_SUBHEAD_NUMBER
.    RESET_PARAHEAD_NUMBER
.    if r#START      \{ .rr #START     \}
.    if r#EPIGRAPH   \{ .rr #EPIGRAPH  \}
.    if r#QUOTE      \{ .rr #QUOTE     \}
.    if r#Q_FITS     \{ .rr #Q_FITS    \}
.    if r#END_QUOTE  \{ .rr #END_QUOTE \}
.    if r#LINEBREAK  \{ .rr #LINEBREAK \}
.    if r#Q_AT_TOP   \{ .rr #Q_AT_TOP  \}
.    if r#PP_ACTIVE  \{ .rr #PP_ACTIVE \}
.    rr #ARG_NUM
.    rm $TOC_HEAD_ITEM
.    nr #PP 0
.END
\#
\#
\# ---Subheads---
\#
\# SUBHEAD FAMILY
\# --------------
\# *Argument:
\#   <family to use in subheads>
\# *Function:
\#   Creates or modifies string $SH_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC SUBHEAD_FAMILY END
.    ds $SH_FAM \\$1
.END
\#
\#
\# SUBHEAD FONT
\# --------------
\# *Argument:
\#   <font to use in subheads>
\# *Function:
\#   Creates or modifies string $SH_FT.
\# *Notes:
\#   Default is bold.
\#
.MAC SUBHEAD_FONT END
.    ds $SH_FT \\$1
.END
\#
\#
\# SUBHEAD SIZE
\# ------------
\# *Argument:
\#   <+|- number of points by which to in/decrease point size of subheads
\#   (relative to running text)>
\# *Function:
\#   Creates or modifies string $SH_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign.  No space afterwards.
\#   Fractional point sizes are allowed.
\#   Default is +.5 for printstyle TYPESET; +0 for TYPEWRITE.
\#
.MAC SUBHEAD_SIZE END
.    ds $SH_SIZE_CHANGE \\$1
.END
\#
\#
\# SUBHEAD COLOR
\# -------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Defines string $SH_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   SUBHEAD_COLOR.
\#
.MAC SUBHEAD_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    nr #SH_COLOR 1
.    ds $SH_COLOR \\$1
.END
\#
\#
\# SUBHEAD QUAD
\# ------------
\# *Argument:
\#   L | LEFT | R | RIGHT | C | CENTER | CENTRE
\# *Function:
\#   Creates or modifies string $SH_QUAD.
\# *Notes:
\#   Default is LEFT for both TYPESET and TYPEWRITE.
\#
.MAC SUBHEAD_QUAD END
.    ds $SH_QUAD \\$1
.END
\#
\#
\# SUBHEAD
\# -------
\# *Arguments:
\#   "text of subhead" ["text of subhead"] ...
\# *Function:
\#   In TYPEWRITE, prints subheads underlined.
\#   In TYPESET, prints subheads bold, .5 points larger than running
\#   text.
\#   In both styles, a line space precedes the subhead, and a small
\#   amount of lead comes after.
\# *Notes:
\#   As with the HEAD macro, double-quotes (") must surround
\#   each line of text.
\#
.MAC SUBHEAD END
.    br
\# Collect subhead for TOC.
.    nr #ARG_NUM 0 1
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.       ie \\n[#ARG_NUM]=\\n[#NUM_ARGS] \{\
.          as $TOC_SH_ITEM \\$[\\n+[#ARG_NUM]]\\|
.       \}
.       el \{\
\# Note that in the .as lines, below, \ at the end has a literal
\# space after it.
.          ie \\n[#NUMBER_SH] \{\
.             ie \\n[#ARG_NUM]=0 \{\
.                as $TOC_SH_ITEM \\n+[#SH_NUM].\0\\$[\\n+[#ARG_NUM]]\ 
.                nr #SH_NUM \\n-[#SH_NUM]
.             \}
.             el \{\
.                as $TOC_SH_ITEM \\$[\\n+[#ARG_NUM]]\ 
.             \}
.          \}
.          el \{\
.             as $TOC_SH_ITEM \\$[\\n+[#ARG_NUM]]\ 
.          \}
.       \}
.    \}
\# Note the use of \!, which transparently embeds the macros used
\# in the TOC_ENTRIES diversion.  The elements they control must be
\# processed literally when the diversion is output.
.    ev TOC_EV
.    da TOC_ENTRIES
.    if \\n[#PRINT_STYLE]=1 \{\
\!.     fam C
\!.     ft  R
\!.     ps  12
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_SH_FAM]
\!.     FT      \\*[$TOC_SH_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_SH_SIZE_CHANGE]
.    \}
\!.  TRAP OFF
.    ie \\n[#PRINT_STYLE]=1 \{\
\!.     PAD "\\h'4m'\\*[$TOC_SH_ITEM]\\*[$TOC_PN_TYPEWRITE]"
.    \}
.    el \{\
\!.     PAD "\\h'\\n[#TOC_SH_INDENT]u'\\*[$TOC_SH_ITEM]\\*[$TOC_PN]"
.    \}
\!.  EL
\!.  ST 100 L
\!.  ST 101 R
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_PN_FAM]
\!.     FT      \\*[$TOC_PN_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.    \}
\!.  TAB 100
\!.  PRINT \\*[LEADER]
\!.  TN
\!.  TRAP
\!.  PRINT \\n[#TOC_ENTRY_PN]
\!.  TQ
.    di       
.    ev
\# End collection of head for TOC
\# Process subhead
.    nr #ARG_NUM 0 1
.    if r#QUOTE    \{ .rr #QUOTE    \}
.    if r#Q_AT_TOP \{ .rr #Q_AT_TOP \}
.    ev SUBHEAD
.    ll \\n[#L_LENGTH]u
.    ta \\n(.lu
.    if \\n[#COLUMNS] \{\
.       ll \\n[#COL_L_LENGTH]u
.       ta \\n(.lu
.    \}
.    CHECK_INDENT
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam C
.       ft  R
.       ps  12
.       vs  \\n[#DOC_LEAD]u
.       QUAD   \\*[$SH_QUAD]
.       UNDERLINE OFF
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       FAMILY  \\*[$SH_FAM]
.       FT      \\*[$SH_FT]
.       PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$SH_SIZE_CHANGE]
.       LS      \\n[#DOC_LEAD]u
.       QUAD    \\*[$SH_QUAD]
.    \}
.    if \\n[#PRINT_STYLE]=1 \{ .nr #SH_LEAD_ADJUST \\n[#LEAD]/5 \}
.    if \\n[#PRINT_STYLE]=2 \{ .nr #SH_LEAD_ADJUST \\n[#LEAD]/8 \}
.    ie \\n[#START] \{ . \}
.    el \{\
.       ie ( \\n[#TRAP_DISTANCE] < (\\n[#DOC_LEAD]u*2u) ) \{\
.          ie \\n[#COLUMNS] \{ .COL_NEXT \}
.          el \{ .bp \}
.       \}
.       el \{\
.          ie \\n[#HEAD]=1 \{ . \}
.          el \{\
.             if \\n[#PRINT_STYLE]=1 \{\
.                if !\\n[#LINEBREAK] \{ .ALD \\n[#DOC_LEAD]u \}
.             \}
.             if \\n[#PRINT_STYLE]=2 \{\
.                ie \\n[#PP_SPACE]=1 \{\
.                   ie !\\n[#LINEBREAK] \{ .ALD \\n[#DOC_LEAD]u \}
.                   el \{ .RLD \\n[#DOC_LEAD]u \}
.                \}
.                el \{\
.                   if !\\n[#LINEBREAK] \{ .ALD \\n[#DOC_LEAD]u \}
.                \}
.             \}
.          \}
.       \}
.    \}
\# Print subhead
.    if \\n[#PRINT_STYLE]=1 \{\
.       while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.          ie \\n[#NUMBER_SH] \{\
.             ie \\n[#ARG_NUM]=0 \{\
.                ie \\n[#NUMBER_HEAD] \{\
.                   br
.                   UNDERSCORE "\v'-\\n[#SH_LEAD_ADJUST]u'\\n[#HEAD_NUM].\\n+[#SH_NUM]\0\\$[\\n+[#ARG_NUM]]
.                   br
.                \}
.                el \{\
.                   br
.                   UNDERSCORE "\v'-\\n[#SH_LEAD_ADJUST]u'\\n+[#SH_NUM].\0\\$[\\n+[#ARG_NUM]]
.                   br
.                \}
.             \}
.             el \{\
.                br
.                ie \\n[#HEAD_UNDERLINE]=0 \{ .PRINT "\v'-\\n[#SH_LEAD_ADJUST]u'\\$[\\n+[#ARG_NUM]]\}
.                el \{ .UNDERSCORE "\v'-\\n[#SH_LEAD_ADJUST]u'\\$[\\n+[#ARG_NUM]]\}
.                br
.             \}
.          \}
.          el \{\
.             br
.             UNDERSCORE "\v'-\\n[#SH_LEAD_ADJUST]u'\\$[\\n+[#ARG_NUM]]
.             br
.          \}
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#SH_COLOR]=1 \{ .COLOR \\*[$SH_COLOR] \}
.       ie \\n[#PP_SPACE]=0 \{\
.          while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.             ie \\n[#NUMBER_SH] \{\
.                ie \\n[#ARG_NUM]=0 \{\
.                   ie \\n[#NUMBER_HEAD] \{\
.                      br
.                      PRINT "\v'-\\n[#SH_LEAD_ADJUST]u'\\n[#HEAD_NUM].\\n+[#SH_NUM]\0\\$[\\n+[#ARG_NUM]]
.                      br
.                   \}
.                   el \{\
.                      br
.                      PRINT "\v'-\\n[#SH_LEAD_ADJUST]u'\\n+[#SH_NUM].\0\\$[\\n+[#ARG_NUM]]
.                      br
.                   \}
.                \}
.                el \{\
.                   br
.                   PRINT "\\v'-\\n[#SH_LEAD_ADJUST]u'\\$[\\n+[#ARG_NUM]]
.                   br
.                \}
.             \}
.             el \{\
.                br
.                PRINT "\\v'-\\n[#SH_LEAD_ADJUST]u'\\$[\\n+[#ARG_NUM]]
.                br
.             \}
.          \}
.       \}
.       el \{\
.          ALD \\n[#DOC_LEAD]u
.          if \\n[#HEAD]=1      \{ .RLD \\n[#DOC_LEAD]u \}
.          if \\n[#END_QUOTE]   \{ .RLD \\n[#DOC_LEAD]u \}
.          if \\n[#EPIGRAPH]    \{ .RLD \\n[#DOC_LEAD]u \}
.          while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.             PRINT "\\$[\\n+[#ARG_NUM]]
.          \}
.          ALD \\n[#DOC_LEAD]u
.       \}
.    \}
.    REMOVE_INDENT
.    ev
.    RESET_PARAHEAD_NUMBER
.    if r#START     \{ .rr #START     \}
.    if r#EPIGRAPH  \{ .rr #EPIGRAPH  \}
.    if r#Q_FITS    \{ .rr #Q_FITS    \}
.    if r#END_QUOTE \{ .rr #END_QUOTE \}
.    if r#LINEBREAK \{ .rr #LINEBREAK \}
.    rm $TOC_SH_ITEM
.    nr #PP 0
.    nr #HEAD 2
.END
\#
\# ---Paragraph heads---
\#
\# PARAHEAD FAMILY
\# ---------------
\# *Argument:
\#   <family to use in paraheads>
\# *Function:
\#   Creates or modifies string $PH_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC PARAHEAD_FAMILY END
.    ds $PH_FAM \\$1
.END
\#
\#
\# PARAHEAD FONT
\# -------------
\# *Argument:
\#   <font to use in paraheads>
\# *Function:
\#   Creates or modifies string $PH_FT.
\# *Notes:
\#   Default is bold italic for TYPESET; underlined for TYPEWRITE.
\#
.MAC PARAHEAD_FONT END
.    ds $PH_FT \\$1
.END
\#
\#
\# PARAHEAD SIZE
\# -------------
\# *Argument:
\#   <+|- number of points by which to in/decrease point size of subheads
\#   (relative to running text)>
\# *Function:
\#   Creates or modifies string $PH_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign.  No space afterwards.
\#   Fractional point sizes are allowed.  No unit of measure, please.
\#   Default is +.5 for printstyle TYPESET; +0 for TYPEWRITE.
\#
.MAC PARAHEAD_SIZE END
.    ds $PH_SIZE_CHANGE \\$1
.END
\#
\#
\# PARAHEAD COLOR
\# --------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Defines string $PH_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   PARAHEAD_COLOR.
\#
.MAC PARAHEAD_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    nr #PH_COLOR 1
.    ds $PH_COLOR \\$1
.END
\#
\#
\# PARAHEAD INDENT
\# ---------------
\# *Argument:
\#   <size of indent>
\# *Function:
\#   Creates or modifies register #PH_INDENT.
\# *Notes:
\#   Default is 1/2 #PP_INDENT for TYPESET and TYPEWRITE.
\#
.MAC PARAHEAD_INDENT END
.    nr #PH_INDENT (\\$1)
.END
\#
\#
\# PARAHEAD
\# --------
\# *Arguments:
\#   "<para head>"
\# *Function:
\#   Deposits a paragraph head at the start and into the body of a
\#   paragraph.
\# *Notes:
\#   PARAHEAD *must* come after PP.
\#
.MAC PARAHEAD END
\# Collect parahead for TOC.
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    ie \\n[#NUMBER_PH] \{\
.       ds $TOC_PH_ITEM \\n+[#PH_NUM].\0\\$1\\|
.       nr #PH_NUM \\n-[#PH_NUM]
.    \}
.    el \{\
.       ds $TOC_PH_ITEM \\$1\\|
.    \}
.    ev TOC_EV
.    da TOC_ENTRIES
.    if \\n[#PRINT_STYLE]=1 \{\
\!.       fam C
\!.       ft  R
\!.       ps  12
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_PH_FAM]
\!.     FT      \\*[$TOC_PH_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PH_SIZE_CHANGE]
.    \}
\!.  TRAP OFF
.    ie \\n[#PRINT_STYLE]=1 \{\
\!.     PAD "\\h'6m'\\*[$TOC_PH_ITEM]\\*[$TOC_PN_TYPEWRITE]" 
.    \}
.    el \{\
\!.     PAD "\\h'\\n[#TOC_PH_INDENT]u'\\*[$TOC_PH_ITEM]\\*[$TOC_PN]"
.    \}
\!.  EL
\!.  ST 100 L
\!.  ST 101 R
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_PN_FAM]
\!.     FT      \\*[$TOC_PN_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.    \}
\!.  TAB 100
\!.  PRINT \\*[LEADER]
\!.  TN
\!.  TRAP
\!.  PRINT \\n[#TOC_ENTRY_PN]
\!.  TQ
.    di       
.    ev
\# End collection of parahead for TOC
\# Process parahead
.    if \\n[#SLANT_ON] \{\
.       nr #SLANT_WAS_ON 1
\E*[SLANTX]
.    \}
.    ie \\n[#PP]=1 \{\
.       if \\n[#INDENT_FIRST_PARAS] \{\
.          ti \\n[#PH_INDENT]u
.       \}
.    \}
.    el \{ .ti \\n[#PH_INDENT]u \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam C
.       ft  R
.       ps  12
.       UNDERLINE OFF
.       ie \\n[#NUMBER_PH] \{\
.          if \\n[#NUMBER_HEAD] \{\
.             ie \\n[#NUMBER_SH] \{\
.                UNDERSCORE "\R'#NUMBERED 1'\\n[#HEAD_NUM].\\n[#SH_NUM].\\n+[#PH_NUM].\\ \\$1"
\0
.             \}
.             el \{\
.                UNDERSCORE "\R'#NUMBERED 1'\\n[#HEAD_NUM].\\n+[#PH_NUM].\\ \\$1
\0
.             \}
.          \}
.          ie \\n[#NUMBER_SH] \{\
.             if !\\n[#NUMBERED] \{\
.                UNDERSCORE "\\n[#SH_NUM].\\n+[#PH_NUM].\\ \\$1
\0
.             \}
.          \}
.          el \{\
.             if !\\n[#NUMBERED] \{\
.                UNDERSCORE "\\n+[#PH_NUM].\\ \\$1
\0
.             \}
.          \}
.       \}
.       el \{\
.          UNDERSCORE "\\$1
\0
.       \}
.       if \\n[#SLANT_WAS_ON] \{\
.          if \\n[#UNDERLINE_SLANT] \{ .UNDERLINE \}
.          if \\n[#SLANT_MEANS_SLANT] \{\
\E*[SLANT]\c
.          \}
.          rr #SLANT_WAS_ON
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       FAM     \\*[$PH_FAM]
.       FT      \\*[$PH_FT]
.       PT_SIZE \\*[$PH_SIZE_CHANGE]
.       if \\n[#PH_COLOR]=1 \{ .COLOR \\*[$PH_COLOR] \}
.          ie \\n[#NUMBER_PH] \{\
.             if \\n[#NUMBER_HEAD] \{\
.                ie \\n[#NUMBER_SH] \{\
.                   PRINT "\R'#NUMBERED 1'\\n[#HEAD_NUM].\\n[#SH_NUM].\\n+[#PH_NUM].\0\\$1\h'.6m'\c"
.                \}
.                el \{\
.                   PRINT "\R'#NUMBERED 1'\\n[#HEAD_NUM].\\n+[#PH_NUM].\0\\$1\h'.6m'\c"
.                \}
.             \}
.             ie \\n[#NUMBER_SH] \{\
.                if !\\n[#NUMBERED] \{\
.                   PRINT "\\n[#SH_NUM].\\n+[#PH_NUM].\0\\$1\h'.6m'\c"
.                \}
.             \}
.             el \{\
.                if !\\n[#NUMBERED] \{\
.                   PRINT "\\n+[#PH_NUM].\0\\$1\h'.6m'\c"
.                \}
.             \}
.          \}
.          el \{\
.             PRINT "\\$1\h'.6m'\c"
.          \}
.       \}
.       FAMILY  \\*[$DOC_FAM]
.       FT      \\*[$PP_FT]
.       PT_SIZE \\n[#DOC_PT_SIZE]u
.       if \\n[#PH_COLOR]=1 \m[]\c
.       if \\n[#SLANT_WAS_ON] \{\
.          rr #SLANT_WAS_ON 1
\E*[SLANT]\c
.       \}
.    \}
.    rr #NUMBERED
.    rm $TOC_PH_ITEM
.END
\#
\#
\# ====================================================================
\#
\# +++LINE BREAKS+++
\#
\# LINEBREAK CHARACTER
\# -------------------
\# *Arguments:
\#   [character] [iterations] [vertical adjustment]
\# *Function:
\#   Allows user to specify a line break character and the number
\#   of times to repeat it horiontally.
\# *Notes:
\#   Without an argument, LINEBREAK_CHAR will deposit a blank line.
\#
\#   Vertical adjustment requires a unit of measure (most likely
\#   "p"), and has to be preceded by +|-
\#
.MAC LINEBREAK_CHAR END
.    nr #REPEAT 1
.    ds $LINEBREAK_CHAR \\$1
.    ds $LINEBREAK_CHAR_V_ADJ \\$3
.    if '\\*[$LINEBREAK_CHAR_V_ADJ]'' \{\
.       ds $LINEBREAK_CHAR_V_ADJ +0
.    \}
.    while \\$2>\\n[#REPEAT] \{\
.       as $LINEBREAK_CHAR "\\ \\$1
.       nr #REPEAT \\n[#REPEAT]+1
.    \}
.   rr #REPEAT
.END
\#
\#
\# LINEBREAK COLOR
\# ---------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Defines string $LINEBREAK_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   LINEBREAK_COLOR.
\#
.MAC LINEBREAK_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    ds $LINEBREAK_COLOR \\$1
.END
\#
\#
\# LINE BREAK
\# ----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Deposits line break character.
\# *Notes:
\#   If $LINEBREAK_CHAR is blank, simply advances 2 line spaces.
\#
.MAC LINEBREAK END
.    if r#Q_AT_TOP \{ .rr #Q_AT_TOP \}
.    po \\n[#DOC_L_MARGIN]u
.    ie  '\\*[$LINEBREAK_CHAR]'' \{ .ALD \\n[#DOC_LEAD]u*2 \}
.    el \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          ie \\n[#END_QUOTE] \{ . \}
.          el \{ .ALD \\n[#DOC_LEAD]u \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          ie \\n[#END_QUOTE] \{ . \}
.          el \{ .ALD \\n[#DOC_LEAD]u \}
.       \}
.       ev LINEBREAK
.       evc 0
.       CENTER
.       PRINT \m[\\*[$LINEBREAK_COLOR]]\\v'\\*[$LINEBREAK_CHAR_V_ADJ]'\\*[$LINEBREAK_CHAR]\\v'\\*[$LINEBREAK_CHAR_V_ADJ]'\m[]
.       if \\n[#PRINT_STYLE]=1 \{ .ALD \\n[#DOC_LEAD]u \}
.       if \\n[#PRINT_STYLE]=2 \{ .ALD \\n[#DOC_LEAD]u \}
.       ev
.       QUAD \\*[$DOC_QUAD]
.    \}
.    nr #LINEBREAK 1
.    if r#QUOTE     \{ .rr #QUOTE     \}
.    if r#END_QUOTE \{ .rr #END_QUOTE \}
.    nr #PP 0
.END
\#
\# ====================================================================
\#
\# +++PARAGRAPHS+++
\#
\# PARAGRAPH FONT
\# --------------
\# *Argument:
\#   <font of running text>
\# *Function:
\#   Creates or modifies string $PP_FT.
\# *Notes:
\#   Affects all paragraphs.
\#
.MAC PP_FONT END
.    if \\n[#IGNORE] \{ .return \}
.    br
.    ds $PP_FT \\$1
.    FT \\*[$PP_FT]
.END
\#
\#
\# PARAGRAPH INDENT
\# ----------------
\# *Argument:
\#   <amount to indent paragraphs in running text (ipPcm)>
\# *Function:
\#   Allows user to change the default para indent.  The change will
\#   affect the indent of QUOTEs and BLOCKQUOTEs as well.
\# *Notes:
\#   Default for printstyle TYPEWRITE is 1/2-inch.  Default for
\#   printstyle TYPESET is 2 ems.  The defaults are set in
\#   PRINTSTYLE, not DEFAULTS.
\#
.MAC PARA_INDENT END
.    nr #PP_INDENT (\\$1)
.END
\#
\#
\# INDENT FIRST PARAGRAPHS
\# -----------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   By default, the first para of a document, as well as the first
\#   paras of blockquotes and block-style epigraphs are not indented.
\#   When invoked, this macro will indent all paras.
\# *Notes:
\#   Default is OFF.
\#
.MAC INDENT_FIRST_PARAS END
.    ie '\\$1'' \{ .nr #INDENT_FIRST_PARAS 1 \}
.    el \{ .rr #INDENT_FIRST_PARAS   \}
.END
\#
\#
\# INTER-PARAGRAPH SPACING
\# -----------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Adds a line space between paragraphs in body text.  Block quotes
\#   are unaffected.
\# *Notes:
\#   Default is OFF.  PARA_SPACE ON is not recommended for use
\#   with PRINTSTYLE TYPEWRITE.
\#
.MAC PARA_SPACE END
.    ie '\\$1'' \{ .nr #PP_SPACE 1 \}
.    el \{ .rr #PP_SPACE   \}
.END
\#
\#
\# PARAGRAPH
\# ---------
\# *Arguments:
\#   <none>
\# *Function:
\#   Figures out what to do with paragraphs under differing conditions.
\# *Notes:
\#   For the time being, there's no automatic widow/orphan control.
\#   Controlling them isn't just a matter of establishing an arbitrary
\#   number of lines needed for a para, since groff doesn't then
\#   handle single line paragraphs gracefully.  Usually, the whole
\#   page needs to be tweaked.
\#
\#   Note the use of transparent line break (\!.br) to get
\#   PP to work within blockquotes and epigraphs.
\#
\#   PP_STYLE 1 = regular paras; 2 = blockquotes, epigraphs
\#
.MAC PP END
.    br
.    if \\n[#DOC_TYPE]=4 \{\
.       if !'\\n(.z'' \{ .di \}
.       nr #TOTAL_FIELDS \\n[#FIELD]
.       nr #FIELD        0 1
.       nr #NUM_FIELDS   0 1
.       if \\n[#TOTAL_FIELDS]>0 \{\
.          while \\n+[#NUM_FIELDS]<=\\n[#TOTAL_FIELDS] \{\
.             nf
.             LETTERHEAD\\n+[#FIELD]
.             QUAD \\*[$DOC_QUAD]
.             ALD \\n[#DOC_LEAD]u
.             if \\n[#DATE_FIRST]=1 \{ .ALD \\n[#DOC_LEAD]u \}
.             rr #DATE_FIRST
.             rm LETTERHEAD\\n[#FIELD]
.          \}
.          rr #FIELD
.          rr #NUM_FIELDS
.          rr #TOTAL_FIELDS
.       \}
.    \}
.    rr #PP_ACTIVE
.    if r#Q_AT_TOP \{ .rr #Q_AT_TOP \}
.    if \\n[#PP_STYLE]=1 \{\
.       if \\n[#ENDNOTE] \{\
.          nr #RESET_PARA_SPACE \\n[#PP_SPACE]
.          ie \\n[#EN_PP_SPACE] \{ .PARA_SPACE \}
.          el \{ .PARA_SPACE OFF \}
.       \}
.       br
.       if !\\n[#ENDNOTE] \{ .po \\n[#L_MARGIN]u \}
.       if \\n[#COLUMNS] \{\
.          if !\\n[#ENDNOTE] \{\
.             po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.             nr #L_MARGIN \\n(.o
.          \}
.       \}
.       if \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.       ie \\n[#PRINT_STYLE]=1 \{\
.          fam C
.          ft  R
.          ps  12
.          ie \\n[#ENDNOTE] \{ .vs \\n[#EN_LEAD]u \}
.          el \{ .vs \\n[#DOC_LEAD]u \}
.          QUAD \\*[$DOC_QUAD]
.          UNDERLINE OFF
.          if \\n[#SLANT_ON] \{\
.             if \\n[#UNDERLINE_SLANT] \{ .UNDERLINE \}
.          \}
.       \}
.       el \{\
.          ie \\n[#ENDNOTE] \{\
.             FAMILY  \\*[$EN_FAM]
.             FT      \\*[$EN_FT]
.             PT_SIZE \\n[#EN_PS]u
.             vs      \\n[#EN_LEAD]u
.             QUAD    \\*[$EN_QUAD]
.          \}
.          el \{\
.             FAMILY  \\*[$DOC_FAM]
.             FT      \\*[$PP_FT]
.             PT_SIZE \\n[#DOC_PT_SIZE]u
.             LS      \\n[#DOC_LEAD]u
.             QUAD    \\*[$DOC_QUAD]
.          \}
.       \}
.       ie \\n[#PP]=0 \{\
.          if \\n[#INDENT_FIRST_PARAS] \{\
.             ie \\n[#INDENT_ACTIVE] \{ .ti \\n[#INDENT]u+\\n[#PP_INDENT]u \}
.             el \{ .ti \\n[#PP_INDENT]u \}
.             if '\\n(.z'END_NOTES' \{\
.                ti \\n[#EN_PP_INDENT]u+\\n[#EN_TEXT_INDENT]u
.             \}
.          \}
.          if r#END_QUOTE \{\
.             if \\n[#END_QUOTE] \{\
.                if !\\n[#LINEBREAK] \{\
.                   ie \\n[#INDENT_ACTIVE] \{ .ti \\n[#INDENT]u+\\n[#PP_INDENT]u \}
.                   el \{ .ti \\n[#PP_INDENT]u \}
.                   if '\\n(.z'END_NOTES' \{\
.                      ti \\n[#EN_PP_INDENT]u+\\n[#EN_TEXT_INDENT]u
.                   \}
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          br
.          if \\n[#PP_SPACE] \{\
.             if \\n[#PRINT_STYLE]=2 \{\
.                ie \\n[#END_QUOTE] \{\
.                   rr #END_QUOTE
.                \}
.                el \{ .ALD \\n[#DOC_LEAD]u \}
.             \}
.          \}
.          ie \\n[#INDENT_ACTIVE] \{ .ti \\n[#INDENT]u+\\n[#PP_INDENT]u \}
.          el \{ .ti \\n[#PP_INDENT]u \}
.          if '\\n(.z'END_NOTES' \{\
.             ti \\n[#EN_PP_INDENT]u+\\n[#EN_TEXT_INDENT]u
.          \}
.       \}
.       if r#START     \{ .rr #START     \}
.       if r#QUOTE     \{ .rr #QUOTE     \}
.       if r#END_QUOTE \{ .rr #END_QUOTE \}
.       if r#HEAD      \{ .rr #HEAD      \}
.       if r#EPIGRAPH  \{ .rr #EPIGRAPH  \}
.       if r#Q_FITS    \{ .rr #Q_FITS    \}
.       if r#LINEBREAK \{ .rr #LINEBREAK \}
.       if \\n[#ENDNOTE] \{\
.          ie \\n[#RESET_PARA_SPACE] \{ .PARA_SPACE \}
.          el \{ .PARA_SPACE OFF \}
.       \}
.       if \\n[#CONDENSE] \{\
\E*[COND]\c
.       \}
.       if \\n[#EXTEND]=1 \{\
\E*[EXT]\c
.       \}
.       nr #PP +1
.    \}
.    if \\n[#PP_STYLE]=2 \{\
\!.     br
.       if \\n[#BROKEN_QUOTE] \{\
.          ie \\n(nl=\\n[#PAGE_TOP] \{ .nr #Q_PP 1 \}
.          el \{ .nr #Q_PP 0 \}
.          rr #BROKEN_QUOTE
.       \}
.       ie \\n[#Q_PP]=0 \{\
.          if \\n[#INDENT_FIRST_PARAS] \{\
.             ti \\n[#PP_INDENT]u/2u
.          \}
.          if \\n[#ENDNOTE] \{\
.             ie \\n[#INDENT_FIRSTS] \{ .ti \\n[#PP_INDENT]u/2u \}
.             el \{ .ti 0 \}
.          \}
.       \}
.       el \{\
.          ti \\n[#PP_INDENT]u/2u
.       \}
.       if \\n[#CONDENSE] \{\
\E*[COND]\c
.       \}
.       if \\n[#EXTEND]=1 \{\
\E*[EXT]\c
.       \}
.    nr #Q_PP +1
.    \}
.    nr #PP_ACTIVE 1
.END
\#
\# ====================================================================
\#
\# +++QUOTES+++
\#
\# ---Line for line (poetic) quotes---
\#
\# QUOTE FAMILY
\# ------------
\# *Argument:
\#   <family to use in line for line quotes>
\# *Function:
\#   Creates or modifies string $QUOTE_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC QUOTE_FAMILY END
.    ds $QUOTE_FAM \\$1
.END
\#
\#
\# QUOTE FONT
\# ----------
\# *Argument:
\#   <font to use in line for line quotes>
\# *Function:
\#   Creates or modifies string $QUOTE_FT.
\# *Notes:
\#   Default is italic for TYPESET.
\#
.MAC QUOTE_FONT END
.    ds $QUOTE_FT \\$1
.END
\#
\#
\# QUOTE SIZE
\# ----------
\# *Argument:
\#   <-|+ number of points by which to de/increase point size of
\#   line for line quotes (relative to running text)>
\# *Function:
\#   Creates or modifies string $QUOTE_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a - or + sign with no space afterwards.
\#   Fractional point sizes are allowed.
\#   Default is +0.
\#
.MAC QUOTE_SIZE END
.    ds $QUOTE_SIZE_CHANGE \\$1
.END
\#
\#
\# QUOTE COLOR
\# -----------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Sets register #QUOTE_COLOR to 1; defines string $QUOTE_COLOR to
\#   argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   QUOTE_COLOR.
\#
.MAC QUOTE_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    nr #QUOTE_COLOR 1
.    ds $QUOTE_COLOR \\$1
.END
\#
\#
\# UNDERLINE QUOTES
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #UNDERLINE_QUOTES (toggle).
\#   If on, line for line quotes are underlined when printstyle
\#   is TYPEWRITE.
\# *Notes:
\#   Default is ON for printstyle TYPEWRITE.
\#
.MAC UNDERLINE_QUOTES END
.    ie '\\$1'' \{ .nr #UNDERLINE_QUOTES 1 \}
.    el \{ .rr #UNDERLINE_QUOTES   \}
.END
\#
\#
\# QUOTE INDENT
\# ------------
\# *Argument:
\#   <value by which to multiply PP_INDENT for indented quoted text>
\# *Function:
\#   Creates or modifies register #Q_OFFSET_VALUE.
\# *Notes:
\#   Default is 3 for typeset; 2 for typewrite
\#
.MAC QUOTE_INDENT END
.    nr #Q_OFFSET_VALUE \\$1
.END
\#
\#
\# ALWAYS FULLSPACE QUOTES
\# -----------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #FULLSPACE_QUOTES.
\# *Notes:
\#   If user doesn't like the default 1/2 line space above and below
\#   quotes, s/he can turn it off here.  Has no effect in TYPEWRITE.
\#
.MAC ALWAYS_FULLSPACE_QUOTES END
.    if '\\$1'' \{ .nr #FULLSPACE_QUOTES 1 \}
.    el \{ .rr #FULLSPACE_QUOTES \}
.END
\#
\#
\# QUOTE
\# -----
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Indents quoted text on a line for line basis, or turns QUOTE off.
\# *Notes:
\#   Owing to the need to bottom align TYPESET pages, quoted text gets
\#   diverted so its depth can be measured (in DO_QUOTE) for determining
\#   how much space to put before and after.
\#
.MAC QUOTE END
.    br
\# **Uncomment the next line to prevent orphaned quote lines.
\#.  ne 1
.    ie '\\$1'' \{\
.       ev QUOTE
.       nr #QUOTE 1
.       di P_QUOTE
.       ll \\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u)
.       ta \\n(.lu
.       if \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u-(\\n[#PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u)
.          ta \\n(.lu
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          fam C
.          ft  R
.          ps 12
.          vs \\n[#DOC_LEAD]u
.          LEFT
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$QUOTE_FAM]
.          FT      \\*[$QUOTE_FT]
.          PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$QUOTE_SIZE_CHANGE]
.          LS      \\n[#DOC_LEAD]u
.          LEFT
.          if \\n[#QUOTE_COLOR]=1 \{\
.             nf
\m[\\*[$QUOTE_COLOR]]
.             EL
.          \}
.       \}
.       nr #Q_TOP \\n(nl
.       if \\n[#PRINT_STYLE]=1 \{\
.          if \\n[#UNDERLINE_QUOTES] \{\
.               FT I
.          \}
.       \}
.    \}
.    el \{ .DO_QUOTE \}
.END
\#
\#
\# ---Blockquotes---
\#
\# BLOCKQUOTE FAMILY
\# -----------------
\# *Argument:
\#   <family to use in blockquotes>
\# *Function:
\#   Creates or modifies string $BQUOTE_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC BLOCKQUOTE_FAMILY END
.    ds $BQUOTE_FAM \\$1
.END
\#
\#
\# BLOCKQUOTE FONT
\# ---------------
\# *Argument:
\#   <font to use in blockquotes>
\# *Function:
\#   Creates or modifies string $BQUOTE_FT.
\# *Notes:
\#   Default is same as running text.
\#
.MAC BLOCKQUOTE_FONT END
.    ds $BQUOTE_FT \\$1
.END
\#
\#
\# BLOCKQUOTE SIZE
\# ---------------
\# *Argument:
\#   <-|+ number of points by which to de/increase point size of blockquotes
\#   (relative to running text)>
\# *Function:
\#   Creates or modifies string $BQUOTE_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a - or + sign with no space afterwards.
\#   Fractional point sizes are allowed.
\#   Default is -1 for printstyle TYPESET; +0 for TYPEWRITE.
\#
.MAC BLOCKQUOTE_SIZE END
.    ds $BQUOTE_SIZE_CHANGE \\$1
.END
\#
\#
\# BLOCKQUOTE COLOR
\# ----------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Sets register #BQUOTE_COLOR to 1; defines string
\#   $BQUOTE_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   BLOCKQUOTE_COLOR.
\#
.MAC BLOCKQUOTE_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    nr #BQUOTE_COLOR 1
.    ds $BQUOTE_COLOR \\$1
.END
\#
\#
\# BLOCKQUOTE QUAD
\# ---------------
\# *Arguments:
\#   <quad to use in blockquotes>
\# *Function:
\#   Creates or modifies string $BQUOTE_QUAD.
\# *Notes:
\#   Default is LEFT.
\#
.MAC BLOCKQUOTE_QUAD END
.    ds $BQUOTE_QUAD \\$1
.END
\#
\#
\# BLOCKQUOTE
\# ----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Indents quoted text in fill mode and shortens line length
\#   accordingly, or turns BLOCKQUOTE off.
\# *Notes:
\#   Owing to the need to bottom align TYPESET pages, quoted text gets
\#   diverted so its depth can be measured (in DO_QUOTE) for determining
\#   how much space to put before and after.
\#
\#   .PP after blockquote is optional if there's only one para,
\#   but REQUIRED if there's more than one.
\#
.MAC BLOCKQUOTE END
.    br
.    ie '\\$1'' \{\
.       ev BLOCKQUOTE
.       nr #QUOTE    2
.       nr #PP_STYLE 2
.       nr #Q_PP     0
.       di B_QUOTE
.       ll \\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.       if \\n[#ENDNOTE] \{\
.          if \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.             ll \\n[#RESET_L_LENGTH]u-\\n[#EN_TEXT_INDENT]u-(\\n[#EN_PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.          \}
.          if \\n[#EN_NUMBERS_ALIGN_LEFT] \{\
.             ll \\n[#L_LENGTH]u-(\\n[#EN_PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.          \}
.       \}
.       ta \\n(.lu
.       CHECK_INDENT
.       if \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.          if \\n[#ENDNOTE] \{\
.             if \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.                ll \\n[#RESET_L_LENGTH]u-\\n[#EN_TEXT_INDENT]u-(\\n[#EN_PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.             \}
.             if \\n[#EN_NUMBERS_ALIGN_LEFT] \{\
.                ll \\n[#COL_L_LENGTH]u-(\\n[#EN_PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.             \}
.          \}
.          ta \\n(.lu
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          fam C
.          ft  R
.          ps  12
.          vs  \\n[#DOC_LEAD]u
.          QUAD LEFT
.          HY OFF
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$BQUOTE_FAM]
.          FT      \\*[$BQUOTE_FT]
.          PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$BQUOTE_SIZE_CHANGE]
.          LS      \\n[#DOC_LEAD]u
.          if \\n[#ENDNOTE] \{\
.             PT_SIZE \\n[#EN_PS]u\\*[$BQUOTE_SIZE_CHANGE]
.          \}
.          if \\n[#BQUOTE_COLOR]=1 \{\
.             nf
\m[\\*[$BQUOTE_COLOR]]
.             EL
.          \}
.          QUAD \\*[$BQUOTE_QUAD]
.          HY
.       \}
.       nr #Q_TOP \\n(nl
.       if \\n[#INDENT_FIRST_PARAS] \{\
.          ie !\\n[#ENDNOTE] \{\
.             if \\n[#PRINT_STYLE]=1 \{ .ti \\n[#PP_INDENT]u/2u \}
.             if \\n[#PRINT_STYLE]=2 \{ .ti \\n[#PP_INDENT]u/2u \}
.          \}
.          el \{\
.             if \\n[#INDENT_FIRSTS]=1 \{\
.                if \\n[#PRINT_STYLE]=1 \{ .ti \\n[#EN_PP_INDENT]u/2u \}
.                if \\n[#PRINT_STYLE]=2 \{ .ti \\n[#EN_PP_INDENT]u/2u \}
.             \}
.          \}
.       \}
.    \}
.    el \{ .DO_QUOTE \}
.END
\#
\#
\# DO QUOTE
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Ends the diversion P_QUOTE or B_QUOTE.  Spaces them according to
\#   PRINTSTYLE, whether there's inter-paragraph spacing, and page
\#   position.  TYPEWRITE treats spacing the same way in all circumstance
\#   (viz. an extra line space).  TYPESET puts in only half
\#   line spaces if the entire quote plus 1 line of body under the quote
\#   fits on the the page; otherwise it puts in a full extra blank
\#   line.  (This is to ensure the page remains bottom aligned).
\#
.MAC DO_QUOTE END
.    di
.    REMOVE_INDENT
.    ev
\#   **Change *1 to *2 in next line to prevent orphans after quotes
.    if \\n[#ENDNOTE] \{\
.       nr #RESET_QUOTE_SPACING \\n[#FULLSPACE_QUOTES]
.       ALWAYS_FULLSPACE_QUOTES
.    \}
.    nr #Q_DEPTH \\n[#DIVER_DEPTH]+(\\n[#LEAD]*1)
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#START]=1 \{ . \}
.       if \\n[#START]=0 \{\
.          if !\\n[#LINEBREAK] \{ .ALD \\n[#DOC_LEAD]u \}
.       \}
.       if \\n[#HEAD] \{\
.          if \\n[#HEAD]=1 \{ .RLD \\n[#DOC_LEAD]u \}
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#PP_SPACE] \{\
.          ie \\n[#HEAD]>0 \{ . \}
.          el \{\
.             ie \\n[#START] \{ . \}
.             el \{ .ALD \\n[#DOC_LEAD]u \}
.          \}
.       \}
.       el \{\
.          ie \\n[#Q_DEPTH]<\\n[#TRAP_DISTANCE] \{\
.             nr #Q_FITS 1
.             ie \\n[#HEAD]=1 \{ . \}
.             el \{\
.                ie \\n[#START] \{ . \}
.                el \{\
.                   ie \\n[#FULLSPACE_QUOTES] \{\
.                      ie \\n[#ENDNOTE] \{\
.                         ALD \\n[#EN_LEAD]u
.                      \}
.                      el \{ .ALD \\n[#DOC_LEAD]u \}
.                   \}
.                   el \{\
.                      ie \\n[#ENDNOTE] \{\
.                         ALD \\n[#EN_LEAD]u/2u
.                      \}
.                      el \{ .ALD \\n[#DOC_LEAD]u/2u \}
.                   \}
.                \}
.             \}
.          \}
.          el \{\
.             rr #Q_FITS
.             ie r#HEAD \{\
.                if \\n[#HEAD]=1 \{ . \}
.             \}
.             el \{\
.                ie \\n[#ENDNOTE] \{ .ALD \\n[#EN_LEAD]u \}
.                el \{ .ALD \\n[#DOC_LEAD]u \}
.             \}
.          \}
.       \}
.    \}
.    nr #Q_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.    if \\n[#COLUMNS] \{\
.       nr #Q_OFFSET \\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.    \}
.    if !\\n[#ENDNOTE] \{ .po \\n[#Q_OFFSET]u \}
.    if \\n[#ENDNOTE] \{\
.       in +\\n[#EN_PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u
.    \}
.    if \\n[#QUOTE]=1 \{\
.       nf
.       P_QUOTE
.       if !\\n[#START] \{ .rr #QUOTE \}
.    \}
.    if \\n[#QUOTE]=2 \{\
.       nf
.       B_QUOTE
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       ALD \\n[#DOC_LEAD]u
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#START] \{\
.          ie \\n[#PP_SPACE] \{ . \}
.          el \{ .ALD \\n[#DOC_LEAD]u \}
.       \}
.       el \{\
.          ie \\n[#PP_SPACE] \{ . \}
.          el \{\
.             ie \\n[#HEAD]=1 \{ .ALD \\n[#DOC_LEAD]u \}
.             el \{\
.                ie \\n[#Q_FITS] \{\
.                   ie \\n[#Q_TOP]=\\n[#PAGE_TOP] \{\
.                      nr #Q_AT_TOP 1
.                      ALD \\n[#DOC_LEAD]u
.                   \}
.                   el \{\
.                      ie \\n[#FULLSPACE_QUOTES] \{ .ALD \\n[#DOC_LEAD]u \}
.                      el \{ .ALD \\n[#DOC_LEAD]u/2u \}
.                   \}
.                \}
.                el \{ .ALD \\n[#DOC_LEAD]u \}
.             \}
.          \}
.       \}
.    \}
.    if \\n[#ENDNOTE] \{ .nr #FULLSPACE_QUOTES \\n[#RESET_QUOTE_SPACING] \}
.    if r#HEAD     \{ .rr #HEAD     \}
.    if r#EPIGRAPH \{ .rr #EPIGRAPH \}
.    rr #Q_PP
.    rr #LINEBREAK
.    nr #PP_STYLE  1
.    nr #END_QUOTE 1
.    if !\\n[#ENDNOTE] \{ .po \\n[#L_MARGIN]u \}
.    if \\n[#ENDNOTE] \{\
.       in \\n[#EN_TEXT_INDENT]u
.    \}
.    if \\n[#COLUMNS] \{\
.       if !\\n[#ENDNOTE] \{\
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n(.o
.       \}
.       if \\n[#ENDNOTE] \{\
.          in \\n[#EN_TEXT_INDENT]u
.       \}
.    \}
.    ie !\\n[#ENDNOTE] \{\
.       nr #RESET_PP_INDENT \\n[#PP_INDENT]
.       PARA_INDENT 0
.       PP
.       PARA_INDENT \\n[#RESET_PP_INDENT]u
.       QUAD \\*[$DOC_QUAD]
.    \}
.    el \{\
.       nr #RESET_EN_PP_INDENT \\n[#EN_PP_INDENT]
.       ENDNOTE_PARA_INDENT 0
.       PP
.       ENDNOTE_PARA_INDENT \\n[#RESET_EN_PP_INDENT]u
.       QUAD \\*[EN_QUAD]
.    \}
.END
\#
\# ====================================================================
\#
\# BREAK QUOTE
\# -----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Ends the diversion P_QUOTE or B_QUOTE, breaks to a new
\#   page, and reinvokes BLOCKQUOTE.
\# *Notes:
\#   Because quotes go into a diversion before they're output,
\#   footnotes in quotes that cross pages behave erratically.  The footnote
\#   isn't processed until the diversion ends, hence the footnote
\#   marker in the quote isn't always correct for the new page (it's
\#   picked up from the old one).  BREAK_QUOTE is a workaround for
\#   this problem.
\#
.MAC BREAK_QUOTE END
.    br
.    di
.    nr #BROKEN_QUOTE 1
.    REMOVE_INDENT
.    ev
.    nr #Q_DEPTH \\n[#DIVER_DEPTH]+\\n[#LEAD]
.    if \\n[#PRINT_STYLE]=1 \{\
.       if !\\n[#LINEBREAK] \{ .ALD \\n[#DOC_LEAD]u \}
.       if \\n[#HEAD] \{\
.          if \\n[#HEAD]=1 \{ .RLD \\n[#DOC_LEAD]u \}
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#PP_SPACE] \{\
.          ie \\n[#HEAD]=1 \{ . \}
.          el \{\
.             if !\\n[#LINEBREAK] \{ .ALD \\n[#DOC_LEAD]u \}
.          \}
.       \}
.       el \{\
.          rr #Q_FITS
.          ie r#HEAD \{\
.             if \\n[#HEAD]=1 \{ . \}
.          \}
.          el \{ .ALD \\n[#DOC_LEAD]u \}
.       \}
.    \}
.    nr #Q_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.    if \\n[#COLUMNS] \{ .nr #Q_OFFSET \\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE]) \}
.    po \\n[#Q_OFFSET]u
.    if \\n[#QUOTE]=1 \{\
.       nf
.       P_QUOTE
.       if !\\n[#START] \{ .rr #QUOTE \}
.    \}
.    if \\n[#QUOTE]=2 \{\
.       nf
.       B_QUOTE
.    \}
.    if r#HEAD     \{ .rr #HEAD     \}
.    if r#EPIGRAPH \{ .rr #EPIGRAPH \}
.    rr #Q_PP
.    rr #LINEBREAK
.    nr #PP_STYLE  1
.    nr #END_QUOTE 1
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#UNDERLINE_QUOTES] \{\
.          UNDERLINE OFF
.       \}
.    \}
.    po \\n[#L_MARGIN]u
.    if \\n[#COLUMNS] \{\
.       po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n(.o
.    \}
.    QUAD \\*[$DOC_QUAD]
.    sp |\\n[#PAGE_LENGTH]u  \" To trip footer/header
.    BLOCKQUOTE
.END
\#
\# ====================================================================
\#
\# +++PAGINATION+++
\#
\# PAGINATE
\# --------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns page numbering off or on during document processing.
\# *Notes:
\#   Default is on.
\#
.MAC PAGINATE END
.    ie '\\$1'' \{ .nr #PAGINATE 1 \}
.    el \{ .nr #PAGINATE 0 \}
.END
\#
\#
\# SUSPEND PAGINATION (before ENDNOTES)
\# ------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Creates register #SUSPEND_PAGINATION
\# *Notes:
\#   Useful only to suspend pagination before outputting endnotes.
\#
.MAC SUSPEND_PAGINATION END
.    nr #SUSPEND_PAGINATION 1
.END
\#
\# RESTORE PAGINATION (after ENDNOTES)
\# ------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Removes register #SUSPEND_PAGINATION.  Creates register
\#   #DEFER_PAGINATION
\# *Notes:
\#   Useful only to restore pagination after outputting endnotes.
\#
.MAC RESTORE_PAGINATION END
.    rr #SUSPEND_PAGINATION
.    if \\n[#PAGE_NUM_V_POS]=1 \{ .PAGINATE \}
.    if \\n[#PAGE_NUM_V_POS]=2 \{ .nr #DEFER_PAGINATION 1 \}
.END
\#
\#
\# PAGENUMBER FAMILY
\# -----------------
\# *Argument:
\#   <family to use for page numbers>
\# *Function:
\#   Creates or modifies string $PAGE_NUM_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC PAGENUM_FAMILY END
.    ds $PAGE_NUM_FAM \\$1
.END
\#
\#
\# PAGE NUMBER FONT
\# ----------------
\# *Arguments:
\#   <font to use for page numbers>
\# *Function:
\#   Creates or modifies string $PAGE_NUM_FT.
\# *Notes:
\#   Default is same as running text.
\#
.MAC PAGENUM_FONT END
.    ds $PAGE_NUM_FT \\$1
.END
\#
\#
\# PAGE NUMBER SIZE
\# ----------------
\# *Argument:
\#   <+|- number of points by which to in/decrease point size of
\#   page numbers (relative to running text)>
\# *Function:
\#   Creates or modifies string $PAGE_NUM_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign with no space afterward.
\#   Fractional point sizes are allowed.
\#   Default is +0.
\#
.MAC PAGENUM_SIZE END
.    ds $PAGE_NUM_SIZE_CHANGE \\$1
.END
\#
\#
\# PAGNUMBER COLOR
\# ---------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Defines string $PAGENUM_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   PAGENUM_COLOR.
\#
.MAC PAGENUM_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    ds $PAGENUM_COLOR \\$1
.END
\#
\#
\# PAGE NUMBER FORMAT
\# ------------------
\# *Arguments:
\#   DIGIT | ROMAN | roman | ALPHA | alpha
\# *Function:
\#   Assigns user entered format to #PAGENUMBER.
\#
.MAC PAGENUM_STYLE END
.    nr #PAGENUM_STYLE_SET 1
.    if '\\$1'DIGIT'  \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER 1
.    \}
.    if '\\$1'ROMAN'  \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER I
.    \}
.    if '\\$1'roman'  \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER i
.    \}
.    if '\\$1'ALPHA'  \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER A
.    \}
.    if '\\$1'alpha'  \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER a
.    \}
.END
\#
\#
\# HYPHENS AROUND PAGE NUMBERS
\# ---------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #PAGE_NUM_HYPHENS.
\#   Used to dis/enable hyphens on either side of page numbers.
\# *Notes:
\#   Default is on.
\#
.MAC PAGENUM_HYPHENS END
.    nr #PAGE_NUM_HYPHENS_SET 1
.    ie '\\$1'' \{ .nr #PAGE_NUM_HYPHENS 1 \}
.    el \{ .rr #PAGE_NUM_HYPHENS   \}
.END
\#
\#
\# PAGENUMBER POSITION
\# -------------------
\# *Arguments:
\#   TOP | BOTTOM  LEFT | CENTER | RIGHT
\# *Function:
\#   Creates or modifies various PAGE_NUM_H | V_POS registers.
\#   Used to position page numbers.
\# *Notes:
\#   Default is center/bottom.
\#
.MAC PAGENUM_POS END
.    nr #PAGE_NUM_POS_SET 1
.    if '\\$1'TOP'    \{ .nr #PAGE_NUM_V_POS 1 \}
.    if '\\$1'BOTTOM' \{ .nr #PAGE_NUM_V_POS 2 \}
.    if '\\$2'LEFT'   \{ .nr #PAGE_NUM_H_POS 1 \}
.    if '\\$2'CENTER' \{ .nr #PAGE_NUM_H_POS 2 \}
.    if '\\$2'CENTRE' \{ .nr #PAGE_NUM_H_POS 2 \}
.    if '\\$2'RIGHT'  \{ .nr #PAGE_NUM_H_POS 3 \}
.END
\#
\#
.MAC PN_WITH_HYPHENS END
.    nr #HYPHEN_ADJ \\n[#CAP_HEIGHT]/12
.    ds $HYPHEN \v'-\En[#HYPHEN_ADJ]u'-\v'\En[#HYPHEN_ADJ]u'
.    PRINT \m[\\*[$PAGENUM_COLOR]]\\*[$HYPHEN]\|\\n[#PAGENUMBER]\|\\*[$HYPHEN]
.END
\#
\#
\# PRINT PAGE NUMBER
\# -----------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Prints page number if PAGINATE=1.
\#
.MAC PRINT_PAGE_NUMBER END
.    ev PAGENUMBER
.    nf
.    na
.    po \\n[#DOC_L_MARGIN]u
.    ll \\n[#DOC_L_LENGTH]u
.    ta \\n(.lu
.    FAMILY  \\*[$PAGE_NUM_FAM]
.    FT      \\*[$PAGE_NUM_FT]
.    PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$PAGE_NUM_SIZE_CHANGE]
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam C
.       ft  R
.       ps 12
.    \}
.    if \\n[#PAGE_NUM_V_POS]=1 \{ .EL \}
.    if o \{\
.       ie \\n[#PAGE_NUM_H_POS]=1 \{ .LEFT  \}
.       el                        \{ .RIGHT \}
.    \}
.    if e \{\
.       ie \\n[#PAGE_NUM_H_POS]=1 \{ .RIGHT  \}
.       el                        \{ .LEFT   \}
.    \}
.    if \\n[#PAGE_NUM_H_POS]=2    \{ .CENTER \}
.    if \\n[#RECTO_VERSO]=0 \{\
.       if \\n[#PAGE_NUM_H_POS]=1 \{ .LEFT   \}
.       if \\n[#PAGE_NUM_H_POS]=2 \{ .CENTER \}
.       if \\n[#PAGE_NUM_H_POS]=3 \{ .RIGHT  \}
.    \}
.    nr #PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]
.    if \\n[#EN_FIRST_PAGE] \{\
.       if \\n[#EN_FIRST_PN] \{ .PAGENUMBER \\n[#EN_FIRST_PN] \}
.       rr #EN_FIRST_PAGE
.    \}
.    if \\n[#TOC_FIRST_PAGE] \{\
.       PAGENUMBER 1
.       rr #TOC_FIRST_PAGE
.    \}
.    ie \\n[#DRAFT_WITH_PAGENUM] \{\
.       ie '\\*[$REVISION]'' \{\
.          PRINT "\\*[$DRAFT_STRING]\\*[$DRAFT] / \\n[#PAGENUMBER]"
.       \}
.       el \{\
.          ie '\\*[$DRAFT]'' \{\
.             PRINT "\\*[$REVISION_STRING] \\*[$REVISION] / \\n[#PAGENUMBER]"
.          \}
.          el \{\
.             PRINT "\\*[$DRAFT_STRING]\\*[$DRAFT], \\*[$REVISION_STRING] \\*[$REVISION] / \\n[#PAGENUMBER]"
.          \}
.       \}
.    \}
.    el \{\
.       ie \\n[#PAGE_NUM_HYPHENS] \{\
.          if '\\*[$PAGENUM_STYLE]'DIGIT' \{\
.             di NULL
1\\R'#CAP_HEIGHT \\n[.cht]'
.             di
.             PN_WITH_HYPHENS
.          \}
.          if '\\*[$PAGENUM_STYLE]'ROMAN' \{\
.             di NULL
I\\R'#CAP_HEIGHT \\n[.cht]'
.             di
.             PN_WITH_HYPHENS
.          \}
.          if '\\*[$PAGENUM_STYLE]'ALPHA' \{\
.             di NULL
E\\R'#CAP_HEIGHT \\n[.cht]'
.             di
.             PN_WITH_HYPHENS
.          \}
.          if '\\*[$PAGENUM_STYLE]'roman' \{\
.             PRINT \m[\\*[$PAGENUM_COLOR]]-\|\\n[#PAGENUMBER]\|-
.          \}
.          if '\\*[$PAGENUM_STYLE]'alpha' \{\
.             PRINT "\m[\\*[$PAGENUM_COLOR]]-\|\\n[#PAGENUMBER]\|-"
.          \}
.       \}
.       el \{ .PRINT "\m[\\*[$PAGENUM_COLOR]]\\n[#PAGENUMBER]" \}
.    \}
.    ev
.END
\#
\# ====================================================================
\#
\# +++FOOTNOTES+++
\#
\# FOOTNOTE FAMILY
\# --------------
\# *Argument:
\#   <family to use in footnotes>
\# *Function:
\#   Creates or modifies string $FN_FAM.
\# *Notes:
\#   Default is same as running text.
\#
.MAC FOOTNOTE_FAMILY END
.    ds $FN_FAM \\$1
.END
\#
\#
\# FOOTNOTE FONT
\# --------------
\# *Argument:
\#   <font to use in footnotes>
\# *Function:
\#   Creates or modifies string $FN_FT.
\# *Notes:
\#   Default is roman.
\#
.MAC FOOTNOTE_FONT END
.    ds $FN_FT \\$1
.END
\#
\#
\# FOOTNOTE SIZE
\# ------------
\# *Argument:
\#   <+|- number of points by which to in/decrease point size of footnotes
\#   (relative to running text)>
\# *Function:
\#   Creates or modifies string $FN_SIZE_CHANGE.
\# *Notes:
\#   Must be preceded by a +|- sign.  No space afterwards.
\#   Fractional point sizes are allowed.
\#   Default is -2 for printstyle TYPESET; +0 for TYPEWRITE.
\#
.MAC FOOTNOTE_SIZE END
.    ds $FN_SIZE_CHANGE \\$1
.END
\#
\#
\# FOOTNOTE COLOR
\# --------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Sets register #FOOTNOTE_COLOR to 1; defines string
\#   $FOOTNOTE_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   FOOTNOTE_COLOR.
\#
.MAC FOOTNOTE_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    nr #FOOTNOTE_COLOR 1
.    ds $FOOTNOTE_COLOR \\$1
.END
\#
\#
\# FOOTNOTE AUTOLEAD
\# -----------------
\# *Arguments:
\#   <autolead value for footnotes>
\# *Function:
\#   Creates or modifies register #FN_AUTOLEAD.
\# *Notes:
\#   Default is #DOC_LEAD/2 for TYPEWRITE; 2 for TYPESET
\#
.MAC FOOTNOTE_AUTOLEAD END
.    nr #FN_AUTOLEAD \\$1
.END
\#
\#
\# FOOTNOTE QUAD
\# -------------
\# *Arguments:
\#   <quad to use in footnotes>
\# *Function:
\#   Creates or modifies string $FN_QUAD.
\# *Notes:
\#   Default is same as running text.
\#
.MAC FOOTNOTE_QUAD END
.    ds $FN_QUAD \\$1
.END
\#
\#
\# FOOTNOTE MARKERS
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns generation of footnote markers on or off.
\# *Notes:
\#   Default is on.
\#
.MAC FOOTNOTE_MARKERS END
.    ie '\\$1'' \{ .nr #FN_MARKERS 1 \}
.    el \{ .nr #FN_MARKERS 0 \}
.END
\#
\#
\# FOOTNOTE MARKER STYLE
\# ---------------------
\# *Arguments:
\#   STAR | NUMBER
\# *Function:
\#   Sets register #FN_MARKER_STYLE, used in FOOTNOTE to determine
\#   the style of footnote markers.
\# *Notes:
\#   1=STAR; 2=NUMBER.  Default is STAR.
\#
.MAC FOOTNOTE_MARKER_STYLE END
.    if '\\$1'STAR' \{\
.       nr #FN_MARKER_STYLE 1
.    \}
.    if '\\$1'NUMBER' \{\
.       nr #FN_MARKER_STYLE 2
.    \}
.END
\#
\#
\# RESET FOOTNOTE NUMBER
\# ---------------------
\# *Arguments:
\#   <none> | PAGE
\# *Function:
\#   Resets register #FN_NUMBER to 1.  If argument is PAGE, creates
\#   toggle #RESET_FN_NUMBER which is checked in HEADER.  If 1,
\#   numbered footnotes on every page start at 1.
\#
.MAC RESET_FOOTNOTE_NUMBER END
.    ie '\\$1'' \{ .nr #FN_NUMBER 0 1 \}
.    el \{ .nr #RESET_FN_NUMBER 1 \}
.END
\#
\#
\# FOOTNOTE RULE LENGTH
\# --------------------
\# *Arguments:
\#   <length of rule used to separate footnotes from running text>
\# *Function:
\#   Creates or modifies registers #FN_RULE_LENGTH.
\# *Notes:
\#   Requires unit of measure (iPpcm).
\#   Default is 4P for both PRINTSTYLEs.
\#
.MAC FOOTNOTE_RULE_LENGTH END
.    nr #FN_RULE_LENGTH (\\$1)
.END
\#
\#
\# FOOTNOTE_RULE_ADJ
\# -----------------
\# *Arguments:
\#   <number of points to raise footnote rule from it's baseline position>
\# *Function:
\#   Creates or modifies register #FN_RULE_ADJ.
\# *Notes:
\#   Default is 3p for both TYPESTYLES.
\#
\#   Requires unit of measure.
\#
.MAC FOOTNOTE_RULE_ADJ END
.    nr #FN_RULE_ADJ (\\$1)
.END
\#
\#
\# FOOTNOTE RULE
\# -------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns printing of footnote separator rule on or off.  If invoked as
\#   PRINT_FOOTNOTE_RULE, prints footnote separator rule.
\# *Notes:
\#   Default is on.
\#
\#   Invoked in FOOTNOTE (as PRINT_FOOTNOTE_RULE) as 1st line of a footnote
\#   if the footnote number (#FN_COUNT) is 1.
\#
.MAC FOOTNOTE_RULE END
.    ie '\\$0'PRINT_FOOTNOTE_RULE' \{\
.       if \\n[#FN_RULE]=0 \{ .RLD 1v \}
\!.     PT_SIZE 12  \"Not sure why these have to be transparently embedded, but they do.
.       RLD 1v
.       LEFT
.       PRINT \\v'-\\n[#FN_RULE_ADJ]u'\\l'\\n[#FN_RULE_LENGTH]u'\\v'+\\n[#FN_RULE_ADJ]u'
\!.     PT_SIZE \\n[#DOC_PT_SIZE]u\\*$[FN_SIZE_CHANGE]
.       QUAD \\*[$FN_QUAD]
.    \}
.    el \{\
.       ie '\\$1'' \{ .nr #FN_RULE 1 \}
.       el \{ .nr #FN_RULE 0 \}
.    \}
.END
\#
\#
\# FOOTNOTE
\# --------
\# *Arguments:
\#   <none> | INDENT  L|LEFT|R|RIGHT|B|BOTH  <indent value> > | <anything>
\# *Function:
\#   Begins collecting and diverting footnote text if no argument
\#   given.  Otherwise, ends diversion FOOTNOTES, measures footnote
\#   depth, and sets footnote trap.
\# *Notes:
\#   The input line preceding a footnote call MUST terminate with \c
\#   or the footnote marker will be spaced away from the word it
\#   should be joined to.
\#
\#   If FOOTNOTES is invoked with INDENT, the footnote will
\#   be indented.  An indent style and an indent value must be given.
\#   Subsequent footnotes will NOT be indented; INDENT must be given
\#   for each footnote the user wants indented.
\#
.MAC FOOTNOTE END
.    ie '\\$1'' \{\
.       if \\n[#FN_MARKERS] \{\
.          if \\n[#CONDENSE] \{ \*[CONDX]\c \}
.          if \\n[#EXTEND]   \{ \*[EXTX]\c  \}
.          if \\n[#PRINT_STYLE]=1 \{\
.             if \\n[#UNDERLINE_ON] \{\
.                nr #UNDERLINE_WAS_ON 1
.                UNDERLINE OFF
.             \}
.          \}
.          if !\\n[#NO_FN_MARKER] \{\
.             if \\n[#FN_MARKER_STYLE]=1 \{\
.                ie \\n[#FN_COUNT_FOR_COLS] \{\
.                   if \\n[#FN_COUNT_FOR_COLS]=0 \{ .PRINT \*[BU3]* \}
.                   if \\n[#FN_COUNT_FOR_COLS]=1 \{ .PRINT \*[BU3]\(dg \}
.                   if \\n[#FN_COUNT_FOR_COLS]=2 \{ .PRINT \*[BU3]** \}
.                   if \\n[#FN_COUNT_FOR_COLS]=3 \{ .PRINT \*[BU3]\(dg\(dg \}
.                   if \\n[#FN_COUNT_FOR_COLS]=4 \{ .PRINT \*[BU3]*** \}
.                   if \\n[#FN_COUNT_FOR_COLS]=5 \{ .PRINT \*[BU3]\(dg\(dg\(dg \}
.                   if \\n[#FN_COUNT_FOR_COLS]=6 \{ .PRINT \*[BU3]**** \}
.                   if \\n[#FN_COUNT_FOR_COLS]=7 \{ .PRINT \*[BU3]\(dg\(dg\(dg\(dg \}
.                   if \\n[#FN_COUNT_FOR_COLS]=8 \{ .PRINT \*[BU3]***** \}
.                   if \\n[#FN_COUNT_FOR_COLS]=9 \{ .PRINT \*[BU3]\(dg\(dg\(dg\(dg\(dg \}
.                \}
.                el \{\
.                   if \\n[#FN_COUNT]=0 \{ .PRINT \*[BU3]* \}
.                   if \\n[#FN_COUNT]=1 \{ .PRINT \*[BU3]\(dg \}
.                   if \\n[#FN_COUNT]=2 \{ .PRINT \*[BU3]** \}
.                   if \\n[#FN_COUNT]=3 \{ .PRINT \*[BU3]\(dg\(dg \}
.                   if \\n[#FN_COUNT]=4 \{ .PRINT \*[BU3]*** \}
.                   if \\n[#FN_COUNT]=5 \{ .PRINT \*[BU3]\(dg\(dg\(dg \}
.                   if \\n[#FN_COUNT]=6 \{ .PRINT \*[BU3]**** \}
.                   if \\n[#FN_COUNT]=7 \{ .PRINT \*[BU3]\(dg\(dg\(dg\(dg \}
.                   if \\n[#FN_COUNT]=8 \{ .PRINT \*[BU3]***** \}
.                   if \\n[#FN_COUNT]=9 \{ .PRINT \*[BU3]\(dg\(dg\(dg\(dg\(dg\(dg \}
.                \}
.             \}
.             if \\n[#FN_MARKER_STYLE]=2 \{\
.                if \\n[#PRINT_STYLE]=1 \{ .PRINT "\s-2\v'-\\n[#DOC_LEAD]u/5u'\\n+[#FN_NUMBER]\v'+\\n[#DOC_LEAD]u/5u'\s+2" \}
.                if \\n[#PRINT_STYLE]=2 \{ .PRINT "\*[SUP]\\n+[#FN_NUMBER]\*[SUPX]" \}
.             \}
.          \}
.       \}
.       nr #SPACE_REMAINING \\n[#PAGE_LENGTH]-\\n[#B_MARGIN]-(\\n(nl+1v)
.       nr #PP_STYLE_PREV \\n[#PP_STYLE]
.       nr #PP_STYLE 2
.       if \\n[#INDENT_FIRST_PARAS] \{ .nr #INDENT_FIRSTS 1 \}
.       INDENT_FIRST_PARAS
.       ev FOOTNOTES
.       ll \\n[#DOC_L_LENGTH]u
.       ta \\n(.lu
.       if \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u
.          ta \\n(.lu
.       \}
.       if \\n[#FN_R_INDENT]  \{\
.          ll -\\n[#FN_R_INDENT]u
.          ta \\n(.lu
.       \}
.       if \\n[#FN_BR_INDENT] \{\
.          ll -\\n[#FN_BR_INDENT]u
.          ta \\n(.lu
.       \}
.       FAMILY   \\*[$FN_FAM]
.       FT       \\*[$FN_FT]
.       PT_SIZE  \\n[#DOC_PT_SIZE]u\\*[$FN_SIZE_CHANGE]
.       AUTOLEAD \\n[#FN_AUTOLEAD]
.       QUAD     \\*[$FN_QUAD]
.       if \\n[#PRINT_STYLE]=1 \{\
.          fam C
.          ft  R
.          ps 12
.          ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u \}
.          el \{ .vs \\n[#DOC_LEAD]u/2u \}
.          QUAD LEFT
.          HY OFF
.       \}
.       nr #FN_LEAD \\n[#LEAD]
.       da FOOTNOTES
.          if \\n[#FOOTNOTE_COLOR]=1 \{\
.             TRAP OFF
.             nf
\m[\\*[$FOOTNOTE_COLOR]]
.             EL
.             fi
.             TRAP
.          \}
.       if \\n[#EPIGRAPH] \{ .nr #FN_FOR_EPI 1 \}
.       if \\n[#FN_DEFER_SPACE] \{\
.          if \\n[#FN_MARKER_STYLE]=1 \{ .ALD 1v \}
.          if \\n[#RESET_FN_NUMBER] \{ .ALD 1v \}
.          rr #FN_DEFER_SPACE
.       \}
.       if \\n+[#FN_COUNT]=1 \{\
.          if !\\n[#FN_DEPTH] \{\
.             if \\n[#PRINT_STYLE]=1 \{ .ALD \\n[#DOC_LEAD]u \}
.             ie \\n[#FN_RULE] \{ .PRINT_FOOTNOTE_RULE \}
.             el \{ .ALD 1v \}
.          \}
.       \}
.       if \\n[#FN_MARKERS] \{\
.          if !\\n[#NO_FN_MARKER] \{\
.             if \\n[#FN_MARKER_STYLE]=1 \{\
.                ie \\n+[#FN_COUNT_FOR_COLS] \{\
.                   if \\n[#FN_COUNT_FOR_COLS]=1  \{ .PRINT *\c \}
.                   if \\n[#FN_COUNT_FOR_COLS]=2  \{ .PRINT \(dg\c \}
.                   if \\n[#FN_COUNT_FOR_COLS]=3  \{ .PRINT **\c \}
.                   if \\n[#FN_COUNT_FOR_COLS]=4  \{ .PRINT \(dg\(dg\c \}
.                   if \\n[#FN_COUNT_FOR_COLS]=5  \{ .PRINT ***\c \}
.                   if \\n[#FN_COUNT_FOR_COLS]=6  \{ .PRINT \(dg\(dg\(dg\c \}
.                   if \\n[#FN_COUNT_FOR_COLS]=7  \{ .PRINT ****\c \}
.                   if \\n[#FN_COUNT_FOR_COLS]=8  \{ .PRINT \(dg\(dg\(dg\(dg\c \}
.                   if \\n[#FN_COUNT_FOR_COLS]=9  \{ .PRINT *****\c \}
.                   if \\n[#FN_COUNT_FOR_COLS]=10 \{ .PRINT \(dg\(dg\(dg\(dg\(dg\c \}
.                \}
.                el \{\
.                   if \\n[#FN_COUNT]=1  \{ .PRINT *\c \}
.                   if \\n[#FN_COUNT]=2  \{ .PRINT \(dg\c \}
.                   if \\n[#FN_COUNT]=3  \{ .PRINT **\c \}
.                   if \\n[#FN_COUNT]=4  \{ .PRINT \(dg\(dg\c \}
.                   if \\n[#FN_COUNT]=5  \{ .PRINT ***\c \}
.                   if \\n[#FN_COUNT]=6  \{ .PRINT \(dg\(dg\(dg\c \}
.                   if \\n[#FN_COUNT]=7  \{ .PRINT ****\c \}
.                   if \\n[#FN_COUNT]=8  \{ .PRINT \(dg\(dg\(dg\(dg\c \}
.                   if \\n[#FN_COUNT]=9  \{ .PRINT *****\c \}
.                   if \\n[#FN_COUNT]=10 \{ .PRINT \(dg\(dg\(dg\(dg\(dg\c \}
.                \}
.             \}
.             if \\n[#FN_MARKER_STYLE]=2 \{\
.                if \\n[#PRINT_STYLE]=1 \{ .PRINT "(\\n[#FN_NUMBER])\c" \}
.                if \\n[#PRINT_STYLE]=2 \{ .PRINT "\*[SUP]\\n[#FN_NUMBER]\*[SUPX]\c" \}
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       ie '\\$1'INDENT' \{\
.          ev FOOTNOTES
.          if '\\$2'L'     \{ .in (\\$3)  \}
.          if '\\$2'LEFT'  \{ .in (\\$3)  \}
.          if '\\$2'R'     \{ .nr #FN_R_INDENT (\\$3) \}
.          if '\\$2'RIGHT' \{ .nr #FN_R_INDENT (\\$3) \}
.          if '\\$2'B' \{\
.             nr #FN_BL_INDENT (\\$3)
.             ie '\\$4'' \{ .nr #FN_BR_INDENT \\n[#FN_BL_INDENT] \}
.             el \{ .nr #FN_BR_INDENT (\\$4) \}
.             in \\n[#FN_BL_INDENT]u
.          \}
.          if '\\$2'BOTH' \{\
.             nr #FN_BL_INDENT (\\$3)
.             ie '\\$4'' \{ .nr #FN_BR_INDENT \\n[#FN_BL_INDENT] \}
.             el \{ .nr #FN_BR_INDENT (\\$4) \}
.             in \\n[#FN_BL_INDENT]u
.          \}
.          ev
.          FOOTNOTE
.       \}
.       el \{\
.          br
.          di
.          in 0 \"Turn off indent possibly set by FOOTNOTE INDENT...
.          if \\n[#PRINT_STYLE]=1 \{\
.             if \\n[#UNDERLINE_WAS_ON] \{\
.                UNDERLINE
.                rr #UNDERLINE_WAS_ON
.             \}
.          \}
.          ev
.          rr #FN_R_INDENT
.          rr #FN_BR_INDENT
.          nr #PP_STYLE \\n[#PP_STYLE_PREV]
.          if !\\n[#INDENT_FIRSTS] \{ .INDENT_FIRST_PARAS OFF \}
.          rr #INDENT_FIRSTS
.          nr #FN_DEPTH +\\n[#DIVER_DEPTH]
.          if \\n[#FN_DEFER] \{\
.             nr #FN_DEFER_SPACE 1
.             rr #FN_DEFER
.          \}
.          if \\n[#FN_DEPTH]>\\n[#SPACE_REMAINING] \{\
.             ie \\n[#SPACE_REMAINING]<(\\n[#LEAD]*2) \{ .nr #FN_DEFER 1 \}
.             el \{\
.                nr #FN_LINES 0 1
.                while (\\n+[#FN_LINES]*\\n[#FN_LEAD])<\\n[#SPACE_REMAINING] \{\
.                   nr #FN_DEPTH (\\n[#FN_LINES]*\\n[#FN_LEAD])
.                \}
.             \}
.          \}
.          nr #VARIABLE_FOOTER_POS -\\n[#DIVER_DEPTH]
.          if \\n[#FN_COUNT]=1 \{ .nr #VARIABLE_FOOTER_POS -1v \}
.       \}
.       ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.       if (\\n(nl+1v)>(\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS]) \{\
.          ch FOOTER \\n(nlu+1v
.       \}
.       if \\n[#FN_DEFER] \{\
.          nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]u
.          ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.       \}
.    \}
.    nr #NO_FN_MARKER 0
.END
\#
\#
.MAC FN_OVERFLOW_TRAP END
.    if \\n[#FN_COUNT] \{\
.       di FN_OVERFLOW
.     \}
.END
\#
\#
.MAC DIVERT_FN_LEFTOVER END
.    nr #NO_FN_MARKER 1
.    nr #OVERFLOW 1
.    FOOTNOTE
.    nf
.    FN_OVERFLOW
.    FOOTNOTE OFF
.    rr #FN_OVERFLOW_DEPTH
.END
\#
\#
.MAC PROCESS_FN_LEFTOVER END
.    if !\\n[#FN_DEFER] \{\
.       nr #FN_COUNT 0 1
.       nr #FN_DEPTH 0
.       nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]
.    \}
.    if \\n[#FN_DEFER] \{\
.       nr #VARIABLE_FOOTER_POS -(\\n[#FN_DEPTH]+\\n[#DOC_LEAD])
.    \}
.    nr #SPACE_REMAINING 0
.    ch FOOTER -\\n[#B_MARGIN]u
.    if \\n[#FN_DEFER] \{\
.       nr #NO_FN_MARKER 1
.       da FOOTNOTES
.       di
.       FOOTNOTE
.       nf
.       FOOTNOTE OFF
.    \}
.    if !\\n[#FN_DEFER] \{\
.       if \\n[#FN_OVERFLOW_DEPTH] \{\
.           DIVERT_FN_LEFTOVER
.       \}
.    \}
.    nr #FN_COUNT 0 1
.END
\#
\#
\# ====================================================================
\#
\# +++ENDNOTES+++
\#
\# When endnotes are output, the spacing between the notes is always 1
\# extra linespace.  This can have bottom margin consequences.  If this
\# doesn't bother you, don't worry about it.  If it does bother you, and
\# you want to adjust the spacing between any two endnotes (as they're
\# output), make the spacing adjustments (.ALD/.RLD) at the *end* of
\# endnotes (i.e. just before .ENDNOTE OFF), not at the top.
\#
\# Endnotes must be output manually with .ENDNOTES.  This allows user
\# the flexibility to output endnotes at the end of each collated
\# document, or to output them at the end of the entire document.
\#
\# ENDNOTE FAMILY
\# --------------
\# *Argument:
\#   <family to use in endnotes>
\# *Function:
\#   Creates or modifies string $EN_FAM.
\# *Notes:
\#   Default is same as running text in body of document.
\#
.MAC ENDNOTE_FAMILY END
.    ds $EN_FAM \\$1
.END
\#
\#
\# ENDNOTE FONT
\# ------------
\# *Argument:
\#   <font to use in endnotes>
\# *Function:
\#   Creates or modifies string $EN_FT.
\# *Notes:
\#   Default is roman.
\#
.MAC ENDNOTE_FONT END
.    ds $EN_FT \\$1
.END
\#
\#
\# ENDNOTE POINT SIZE
\# ------------------
\# *Argument:
\#   <base point size for endnotes>
\# *Function:
\#   Creates or modifies register #EN_PS.
\# *Notes:
\#   Default is same as running text in body of document.
\#
\#   This size control macro differs from other size control macros
\#   in that it sets an absolute point size, not a relative one.  This
\#   is because a) endnotes always appear separate from the body of
\#   a document and therefore don't need to be relative to the body
\#   of the document, and b) there are quite a few elements of the
\#   endnotes page(s) that need to be relative to the base point size
\#   of that page.  If the base endnote point size were relative to
\#   the body of the document (i.e. a _SIZE macro taking a +|- value)
\#   getting the rest of the endnote elements sized properly could
\#   become very confusing.
\#
.MAC ENDNOTE_PT_SIZE END
.    nr #EN_PS (p;\\$1)
.END
\#
\#
\# ENDNOTE LEAD
\# ------------
\# *Argument:
\#   <base leading to use in endnotes> [ ADJUST ]
\# *Function:
\#   Creates or modifies register #EN_LEAD.  Creates or removes
\#   register #ADJ_EN_LEAD.  Stores arguments in strings if ENDNOTE_LEAD
\#   set before START.
\# *Notes:
\#   Default is 14 points for TYPESET, adjusted; 24 for TYPEWRITE.
\#
.MAC ENDNOTE_LEAD END
.    if !\\n[#OK_PROCESS_LEAD] \{\
.       ds $EN_LEAD \\$1
.       if !'\\$2'' \{\
.           ds $ADJUST_EN_LEAD \\$2
.       \}
.       return
.    \}
.    rr #ADJ_EN_LEAD
.    nr #EN_LEAD (p;\\$1)
.    if '\\$2'ADJUST' \{\
.       nr #ORIG_DOC_LEAD \\n[#DOC_LEAD]
.       nr #ADJ_DOC_LEAD 1
.       nr #ADJ_EN_LEAD 1
.       nr #NO_TRAP_RESET 1
.       DOC_LEAD \\n[#EN_LEAD]u ADJUST
.       nr #EN_LEAD \\n[#DOC_LEAD]
.       DOC_LEAD \\n[#ORIG_DOC_LEAD]u
.       rr #NO_TRAP_RESET
.       rr #ADJ_DOC_LEAD
.       rr #ORIG_DOC_LEAD
.    \}
.END
\#
\#
\# ENDNOTE QUAD
\# ------------
\# *Argument:
\#   LEFT | L | CENTER | C | RIGHT | R | JUSTIFY | J
\# *Function:
\#   Creates or modifies string $EN_QUAD.
\# *Notes:
\#   Default is justified for TYPESET, left for TYPEWRITE.
\#
.MAC ENDNOTE_QUAD END
.    ds $EN_QUAD \\$1
.END
\#
\#
\# ENDNOTES_HDRFTR_CENTER
\# ----------------------
\# *Argument:
\#   toggle
\# *Function:
\#   Creates or removes toggle register #EN_HDRFTR_CENTER, used to
\#   determine whether mom should print a/the hdrftr center string
\#   on the endnotes page.  Primarily to enable/disable printing of the
\#   chapter name in hdrftrs when DOCTYPE CHAPTER.
\# *Notes:
\#   Default is OFF
\#
.MAC ENDNOTES_HDRFTR_CENTER END
.    ie '\\$1'' \{ .nr #EN_HDRFTR_CENTER 1 \}
.    el         \{ .rr #EN_HDRFTR_CENTER   \}
.END
\#
\#
\# ENDNOTE STRING 
\# --------------
\# *Argument:
\#   <title for endnotes page>
\# *Function:
\#   Creates or modifies string $EN_STRING.
\# *Notes:
\#   Default is "Endnotes"
\#
.MAC ENDNOTE_STRING END
.    ds $EN_STRING \\$1
.END
\#
\#
\# ENDNOTE STRING FAMILY
\# ---------------------
\# *Argument:
\#   <family to use for endnote string>
\# *Function:
\#   Creates or modifies string $EN_STRING_FAM.
\# *Notes:
\#   Default is same as running text in body of document.
\#
.MAC ENDNOTE_STRING_FAMILY END
.    ds $EN_STRING_FAM \\$1
.END
\#
\#
\# ENDNOTE STRING FONT
\# -------------------
\# *Argument:
\#   <font to use for endnote string>
\# *Function:
\#   Creates or modifies string $EN_FT.
\# *Notes:
\#   Default is BOLD for TYPEWRITE; roman for TYPESET
\#
.MAC ENDNOTE_STRING_FONT END
.    ds $EN_STRING_FT \\$1
.END
\#
\#
\# ENDNOTE STRING SIZE
\# -------------------
\# *Argument:
\#   <+|- number of points by which to in/decrease endnote string
\#    (relative to base endnote size)>
\# *Function:
\#   Creates or modifies string $EN_STRING_SIZE_CHANGE.
\# *Notes:
\#   Default is +1 for TYPESET.
\#
.MAC ENDNOTE_STRING_SIZE END \"Default for TYPESET is +1
.    ds $EN_STRING_SIZE_CHANGE \\$1
.END
\#
\#
\# ENDNOTE STRING QUAD
\# -------------------
\# *Argument:
\#   LEFT | L | CENTER | C | RIGHT | R
\# *Function:
\#   Creates or modifies string $EN_STRING_QUAD.
\# *Notes:
\#   Default is centered.
\#
.MAC ENDNOTE_STRING_QUAD END
.    ds $EN_STRING_QUAD \\$1
.END
\#
\#
\# ENDNOTE STRING UNDERSCORE
\# -------------------------
\# *Arguments:
\#   toggle | 2
\# *Function:
\#   Turns underscoring of endnote main title on or off.  If the argument
\#   is the digit "2", turns on double-underscoring.
\# *Notes:
\#   Default is double-underscored.
\#
.MAC ENDNOTE_STRING_UNDERSCORE END
.    ie '\\$1'' \{ .nr #EN_STRING_UNDERSCORE 1 \}
.    el \{\
.       ie '\\$1'2' \{ .nr #EN_STRING_UNDERSCORE 2 \}
.       el \{ .nr #EN_STRING_UNDERSCORE 0 \}
.    \}
.END
\#
\#
\# ENDNOTE STRING CAPS
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalization of the endnotes pages title string
\#   "Endnotes" on or off.
\# *Notes:
\#   Users may want the endnotes pages title string to be in caps,
\#   but the toc entry for endnotes in lower case.  If the argument
\#   to ENDNOTE_STRING is in lower case and ENDNOTE_STRING_CAPS is
\#   turned on, this is exactly what will happen.
\#
\#   Default is on.
\#
.MAC ENDNOTE_STRING_CAPS END
.   ie '\\$1'' \{ .nr #EN_STRING_CAPS 1 \}
.   el \{ .rr #EN_STRING_CAPS \}
.END
\#
\#
\# ENDNOTE TITLE
\# -------------
\# *Argument:
\#   <string that appears before the first endnote pertaining to any document>
\# *Function:
\#   Creates string $EN_TITLE_STRING.
\# *Notes:
\#   Default is the document title, or, if doc is a chapter, "Chapter #"
\#
.MAC ENDNOTE_TITLE END
.    ds $EN_TITLE \\$1
.END
\#
\#
\# ENDNOTE TITLE FAMILY
\# --------------------
\# *Argument:
\#   <family to use for endnote title>
\# *Function:
\#   Creates string $EN_TITLE_FAM.
\# *Notes:
\#   Default is same as running text of document.
\#
.MAC ENDNOTE_TITLE_FAMILY END
.    ds $EN_TITLE_FAM \\$1
.END
\#
\#
\# ENDNOTE TITLE FONT
\# ------------------
\# *Argument:
\#   <font to use for endnote title>
\# *Function:
\#   Creates string $EN_TITLE_FT.
\# *Notes:
\#   Default is bold for TYPESET; roman for TYPEWRITE.
\#
.MAC ENDNOTE_TITLE_FONT END
.    ds $EN_TITLE_FT \\$1
.END
\#
\#
\# ENDNOTE TITLE SIZE
\# ------------------
\# *Argument:
\#   <+|- number of points by which to in/decrease endnote title
\#    (relative to base endnote size)>
\# *Function:
\#   Creates string $EN_TITLE_SIZE_CHANGE.
\# *Notes:
\#   Default is 0 (i.e. title same size as text of endnotes).
\#
.MAC ENDNOTE_TITLE_SIZE END
.    ds $EN_TITLE_SIZE_CHANGE \\$1 
.END
\#
\#
\# ENDNOTE TITLE QUAD
\# ------------------
\# *Argument:
\#   <quad direction of endnote title>
\# *Function:
\#   Creates string $EN_TITLE_QUAD.
\# *Notes:
\#   Default is left.
\#
.MAC ENDNOTE_TITLE_QUAD END
.    ds $EN_TITLE_QUAD \\$1
.END
\#
\#
\# ENDNOTE TITLE UNDERSCORE
\# ------------------------
\# *Argument:
\#   toggle
\# *Function:
\#   Creates or removes register #EN_TITLE_UNDERSCORE.
\# *Notes:
\#   Default is to underscore the endnote titles.
\#
.MAC ENDNOTE_TITLE_UNDERSCORE END
.    ie '\\$1'' \{ .nr #EN_TITLE_UNDERSCORE 1 \}
.    el \{ .rr #EN_TITLE_UNDERSCORE \}
.END
\#
\#
\# ENDNOTE NUMBER FAMILY
\# ---------------------
\# *Argument:
\#   <family to use for endnote numbers on endnotes page>
\# *Function:
\#   Creates string $EN_NUMBER_FAM.
\# *Notes:
\#   Default is same as running text of document.
\#
\#   Family, font, and size of endnote numbers applies only to the
\#   numbers as they appear on the endnotes page(s).  The superscript
\#   numbers that appear in running text are unaffected.
\#
.MAC ENDNOTE_NUMBER_FAMILY END
.    ds $EN_NUMBER_FAM \\$1
.END
\#
\#
\# ENDNOTE NUMBER FONT
\# -------------------
\# *Argument:
\#   <font to use for endnote numbers on endnotes page>
\# *Function:
\#   Creates string $EN_NUMBER_FT.
\# *Notes:
\#   Default is bold for TYPESET; roman for TYPEWRITE.
\#
\#   Family, font, and size of endnote numbers applies only to the
\#   numbers as they appear on the endnotes page(s).  The superscript
\#   numbers that appear in running text are unaffected.
\#
.MAC ENDNOTE_NUMBER_FONT END \"Default for TYPESET is bold
.    ds $EN_NUMBER_FT \\$1
.END
\#
\#
\# ENDNOTE NUMBER SIZE
\# -------------------
\# *Argument:
\#   <+|- number of points by which to in/decrease endnote numbers
\#    (relative to base endnote size)>
\# *Function:
\#   Creates string $EN_NUMBER_SIZE_CHANGE.
\# *Notes:
\#   Default is 0.
\#
\#   Family, font, and size of endnote numbers applies only to the
\#   numbers as they appear on the endnotes page(s).  The superscript
\#   numbers that appear in running text are unaffected.
\#
.MAC ENDNOTE_NUMBER_SIZE END
.    ds $EN_NUMBER_SIZE_CHANGE \\$1
.END
\#
\#
\# ENDNOTE NUMBERS ALIGN RIGHT
\# ---------------------------
\# *Argument:
\#   <max. number of digit placeholders that will appear in endnotes>
\# *Function:
\#   Toggles register #EN_NUMBERS_ALIGN_RIGHT on; creates register
\#   #EN_NUMBER_PLACEHOLDERS.
\# *Notes:
\#   Default is for footnote numbers to be right aligned to 2 placeholders.
\#
.MAC ENDNOTE_NUMBERS_ALIGN_RIGHT END
.    rr #EN_NUMBERS_ALIGN_LEFT
.    nr #EN_NUMBERS_ALIGN_RIGHT 1
.    nr #EN_NUMBER_PLACEHOLDERS \\$1
.END
\#
\#
\# ENDNOTE NUMBERS ALIGN LEFT
\# --------------------------
\# *Argument:
\#   none
\# *Function:
\#   Toggles register #EN_NUMBERS_ALIGN_LEFT on.
\# *Notes:
\#   Default is for footnote numbers to be right aligned to 2 placeholders
\#   (i.e. not left aligned).
\#
.MAC ENDNOTE_NUMBERS_ALIGN_LEFT END
.    rr #EN_NUMBERS_ALIGN_RIGHT
.    nr #EN_NUMBERS_ALIGN_LEFT 1
.END
\#
\#
\# ENDNOTE PARAGRAPH INDENT
\# ------------------------
\# *Argument:
\#   <first line indent of paras subsequent to 1st in endnotes>
\# *Function:
\#   Creates register #EN_PP_INDENT for use in .PP.
\# *Notes:
\#   Requires a unit of measure.
\#
\#   Default is 1.5m for TYPESET; same indent as PARA_INDENT for TYPEWRITE.
\#
.MAC ENDNOTE_PARA_INDENT END
.    nr #EN_PP_INDENT (\\$1)
.END
\#
\#
\# TURN OFF COLUMN MODE FOR ENDNOTES
\# ---------------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #EN_NO_COLS
\# *Notes:
\#   Allows user to tell mom not to set endnotes in columnar
\#   documents in columns.  Default is to set endnotes in columns.
\#
.MAC ENDNOTES_NO_COLUMNS END
.    ie '\\$1'' \{ .nr #EN_NO_COLS 1 \}
.    el \{ .rr #EN_NO_COLS \}
.END
\#
\#
\# NO FIRST PAGE NUMBER ON ENDNOTES FIRST PAGE
\# -------------------------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #EN_NO_FIRST_PN
\# *Notes:
\#   For use if FOOTERS are on.  Tells ENDNOTES not to put a page
\#   number on the first endnotes page.  Some users may want this.
\#   Default is to print a page number at the top of the first
\#   endnotes page when footers are on.
\#
.MAC ENDNOTES_NO_FIRST_PAGENUM END
.    ie '\\$1'' \{ .nr #EN_NO_FIRST_PN 1 \}
.    el \{ .rr #EN_NO_FIRST_PN \}
.END
\#
\#
\# PAGE HEADERS ON ENDNOTES PAGES
\# ------------------------------
\# *Argument:
\#   <none> | ALL
\# *Function:
\#   Creates or removes register #EN_ALLOWS_HEADERS or
\#   #EN_ALLOWS_HEADERS_ALL
\# *Notes:
\#   Whether ENDNOTES puts a page header at the top of endnotes
\#   pages if page headers are used throughout the document.
\#   Default is to insert the page headers, but not on the first
\#   page.  If the optional argument ALL is given, ENDNOTES puts a
\#   page header on the first page as well.
\#
.MAC ENDNOTES_ALLOWS_HEADERS END
.    ie '\\$1'' \{ .nr #EN_ALLOWS_HEADERS 1 \}
.    el \{\
.       ie '\\$1'ALL' \{\
.          nr #EN_ALLOWS_HEADERS 1
.          nr #EN_ALLOWS_HEADERS_ALL 1
.       \}
.       el \{\
.          rr #EN_ALLOWS_HEADERS
.          rr #EN_ALLOWS_HEADERS_ALL
.       \}
.    \}
.END
\#
\#
\# ENDNOTES PAGES PAGE NUMBERING STYLE
\# -----------------------------------
\# *Argument:
\#   DIGIT | ROMAN | roman | ALPHA | alpha
\# *Function:
\#   Creates or modifies $EN_PN_STYLE.
\# *Notes:
\#   Allows user to define what style should be used for endnotes
\#   pages page numbering.  Arguments are the same as for
\#   PAGENUM_STYLE.
\#
\#   Default is DIGIT.
\#
.MAC ENDNOTES_PAGENUM_STYLE END
.    ds $EN_PN_STYLE \\$1
.END
\#
\#
\# FIRST PAGE NUMBER FOR ENDNOTES
\# ------------------------------
\# *Argument:
\#   <page number that appears on page 1 of endnotes pages>
\# *Function:
\#   Creates or modifies string $EN_FIRST_PN
\# *Notes:
\#   To be used with caution, only if all endnotes
\#   are to be output at once, i.e. not at the end of the separate
\#   docs of a collated doc
\#
.MAC ENDNOTES_FIRST_PAGENUMBER END
.    nr #EN_FIRST_PN \\$1
.END
\#
\# SINGLESPACE ENDNOTES
\# --------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Sets lead of endnotes pages in TYPEWRITE to 12 points,
\#   adjusted.
\# *Notes:
\#   Default is to double-space endnotes pages.
\#
.MAC SINGLESPACE_ENDNOTES END
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE] \{\
.          nr #EN_SINGLESPACE 1
.          rr #IGNORE
.          if \\n[#OK_PROCESS_LEAD] \{\
.             ENDNOTE_LEAD 12 ADJUST
.             nr #IGNORE 1
.          \}
.       \}
.       el \{\
.          ie '\\$1'' \{\
.             nr #EN_SINGLESPACE 1
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                ENDNOTE_LEAD 12 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.          el \{\
.             rr #EN_SINGLESPACE
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                ENDNOTE_LEAD 24 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.       \}
.    \}
.END
\#
\#
\# ENDNOTE PARAGRAPH SPACE
\# -----------------------
\# *Argument:
\#   toggle
\# *Function:
\#   Creates toggle register #EN_PP_SPACE for use in .PP.
\# *Notes:
\#   Like PARA_SPACE.  Default is not to space endnote paras.
\#
.MAC ENDNOTE_PARA_SPACE END
.    ie '\\$1'' \{ .nr #EN_PP_SPACE 1 \}
.    el \{ .rr #EN_PP_SPACE \}
.END
\#
\#
\# ENDNOTE
\# -------
\# *Argument:
\#   toggle
\# *Function:
\#   Places superscript endnote number in text, then collects and
\#   processes endnote in diversion END_NOTES.
\# *Notes:
\#   \c must be appended to the word immediately preceding .ENDNOTE.
\#
.MAC ENDNOTE END
.    ie '\\$1'' \{\
.       nr #ENDNOTE 1
.       if \\n[#CONDENSE] \{ \*[CONDX]\c \}
.       if \\n[#EXTEND]   \{ \*[EXTX]\c  \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          if \\n[#UNDERLINE_ON] \{\
.             nr #UNDERLINE_WAS_ON 1
.             UNDERLINE OFF
.          \}
.          if \\n[#SLANT_ON] \{\
.              nr #SLANT_WAS_ON 1
\*[SLANTX]\c
.          \}
.          PRINT "\s-2\v'-\\n[#DOC_LEAD]u/5u'\\n+[#EN_NUMBER]\v'+\\n[#DOC_LEAD]u/5u'\s+2"
.       \}
.       if \\n[#PRINT_STYLE]=2 \{ .PRINT "\*[SUP]\\n+[#EN_NUMBER]\*[SUPX]" \}
.       nr #PP_STYLE_PREV \\n[#PP_STYLE]
.       nr #PP_STYLE 1
.       if \\n[#INDENT_FIRST_PARAS] \{ .nr #INDENT_FIRSTS 1 \}
.       INDENT_FIRST_PARAS
.       ev EN
.       da END_NOTES
.       LL \\n[#DOC_L_LENGTH]u
.       ta \\n(.lu
.       if \\n[#COLUMNS] \{\
.          ie \\n[#EN_NO_COLS] \{ .LL \\n[#DOC_L_LENGTH]u \}
.          el \{ .LL \\n[#COL_L_LENGTH]u \}
.          ta \\n(.lu
.       \}
.       vs \\n[#EN_LEAD]u
.       if \\n[#EN_NUMBER]=1 \{\
\!.        ne 3
.          if \\n[#PRINT_STYLE]=1 \{\
.             fam C
.             ft  R  
.             ps  12
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$EN_TITLE_FAM]
.             FT      \\*[$EN_TITLE_FT]
.             PT_SIZE \\n[#EN_PS]u\\*[$EN_TITLE_SIZE_CHANGE]
.          \}
.          sp
.          if !'\\*[$EN_TITLE]'' \{\
.             if '\\*[$EN_TITLE_QUAD]'L'      \{ .LEFT   \}
.             if '\\*[$EN_TITLE_QUAD]'LEFT'   \{ .LEFT   \}
.             if '\\*[$EN_TITLE_QUAD]'C'      \{ .CENTER \}
.             if '\\*[$EN_TITLE_QUAD]'CENTER' \{ .CENTER \}
.             if '\\*[$EN_TITLE_QUAD]'CENTRE' \{ .CENTER \}
.             if '\\*[$EN_TITLE_QUAD]'R'      \{ .RIGHT  \}
.             if '\\*[$EN_TITLE_QUAD]'RIGHT'  \{ .RIGHT  \}
.             ie \\n[#EN_TITLE_UNDERSCORE] \{\
.                UNDERSCORE "\\*[$EN_TITLE]
.             \}
.             el \{\
.                PRINT "\\*[$EN_TITLE]
.             \}
.          \}
.       \}
.       ie \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.          ie \\n[#EN_NUMBER]=1 \{\
.             if !'\\*[$EN_TITLE]'' \{ .sp \}
.          \}
.          el \{ .sp \}
\!.        TRAP OFF
.          if \\n[#PRINT_STYLE]=1 \{\
.             fam C
.             ft  R
.             ps  12
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$EN_NUMBER_FAM]
.             FT      \\*[$EN_NUMBER_FT]
.             PT_SIZE \\n[#EN_PS]u\\*[$EN_NUMBER_SIZE_CHANGE]
.          \}
.          nr #RESET_L_LENGTH \\n(.l
.          nr #EN_NUMBER_L_LENGTH \w'\0'*\\n[#EN_NUMBER_PLACEHOLDERS]+\w'.'
.          ll \\n[#EN_NUMBER_L_LENGTH]u
.          RIGHT
\En[#EN_NUMBER].
.          if \\n[#PRINT_STYLE]=1 \{\
.             fam C
.             ft  R
.             ps  12
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$EN_FAM]
.             FT      \\*[$EN_FT]
.             PT_SIZE \\n[#EN_PS]u
.          \}
.          EL
.          ll \\n[#RESET_L_LENGTH]u
.          in \\n[#EN_NUMBER_L_LENGTH]u+\w'.\0'u
.          nr #EN_TEXT_INDENT \\n(.i
.          QUAD \\*[$EN_QUAD]
\!.        TRAP
.       \}
.       el \{\
.          ie \\n[#EN_NUMBER]=1 \{\
.             if !'\\*[$EN_TITLE]'' \{ .sp \}
.          \}
.          el \{ .sp \}
.          if \\n[#PRINT_STYLE]=1 \{\
.             fam C
.             ft  R
.             ps  12
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$EN_NUMBER_FAM]
.             FT      \\*[$EN_NUMBER_FT]
.             PT_SIZE \\n[#EN_PS]u\\*[$EN_NUMBER_SIZE_CHANGE]
.          \}
.          QUAD \\*[$EN_QUAD]
\En[#EN_NUMBER].\0\c
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$EN_FAM]
.             FT      \\*[$EN_FT]
.             PT_SIZE \\n[#EN_PS]u
.          \}
.       \}
.    \}
.    el \{\
.       br
.       if \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.          in 0
.       \}
.       di
.       ev
.       nr #PP_STYLE \\n[#PP_STYLE_PREV]
.       if !\\n[#INDENT_FIRSTS] \{ .INDENT_FIRST_PARAS OFF \}
.       rr #INDENT_FIRSTS
.       rr #ENDNOTE
.       if \\n[#PRINT_STYLE]=1 \{\
.          if \\n[#UNDERLINE_WAS_ON] \{\
.             rr #UNDERLINE_WAS_ON
.             UNDERLINE
.          \}
.       \}
.       if \\n[#SLANT_WAS_ON] \{\
.          rr #SLANT_WAS_ON
\*[SLANT]\c
.       \}
.    \}
.END
\#
\#
\# ENDNOTES
\# --------
\# *Arguments:
\#   none
\# *Function:
\#   Sets new document leading from #EN_LEAD, breaks to a new page,
\#   sets up an endnotes page based on registers and strings associated
\#   with endnotes, then outputs diversion END_NOTES.
\#
.MAC ENDNOTES END
.    nr #ENDNOTES 1
.    nr #PAGINATION_STATE \\n[#PAGINATE]
.    nr #EN_FIRST_PAGE 1
.    nr #HEADER_STATE \\n[#HEADERS_ON]
.    ds $RESTORE_PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.    if \\n[#HEADERS_ON]=1 \{\
.       if !\\n[#EN_ALLOWS_HEADERS_ALL] \{ .HEADERS OFF \}
.    \}
.    if \\n[#HEADER_STATE]=1 \{\
.       ie \\n[#EN_HDRFTR_CENTER]=1 \{ . \}
.       el \{ .rm $HDRFTR_CENTER  \}
.    \}
.    ie !\\n[#SUSPEND_PAGINATION] \{\
.       if \\n[#PAGINATE]=1 \{\
.          if \\n[#PAGE_NUM_V_POS]=1 \{\
.             PAGENUM_STYLE \\*[$EN_PN_STYLE]
.             if \\n[#EN_FIRST_PN] \{ .PAGENUMBER \\n[#EN_FIRST_PN]-1 \}
.             if r#EN_NO_FIRST_PN \{ .nr #PAGINATE 0 \}
.          \}
.       \}
.    \}
.    el \{\
.       ie \\n[#PAGE_NUM_V_POS]=2 \{ .nr #PAGINATE 1 \}
.       el \{ .nr #PAGINATE 0 \}
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       if !'\\*[$HDRFTR_CENTER_OLD]'' \{ .ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_OLD] \}
.    \}
.    NEWPAGE
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] \{\
.          FOOTERS
.          rr #FOOTERS_WERE_ON
.       \}
.       if \\n[#PAGINATION_WAS_ON] \{\ \"This register only set in FINIS
.          if \\n[#PAGINATION_STATE]=1 \{\
.             PAGINATE
.             rr #PAGINATION_WAS_ON
.          \}
.       \}
.       rr #FINIS
.    \}
.    if \\n[#FOOTERS_WERE_ON] \{\
.       FOOTERS
.       rr #FOOTERS_WERE_ON
.    \}
.    if \\n[#PAGINATION_WAS_ON] \{\
.       if \\n[#PAGINATION_STATE]=1 \{\
.          PAGINATE
.          rr #PAGINATION_WAS_ON
.       \}
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_NEW]
.       rm $HDRFTR_CENTER_OLD
.       rm $HDRFTR_CENTER_NEW
.    \}
.    ie !\\n[#SUSPEND_PAGINATION] \{\
.       if \\n[#PAGE_NUM_V_POS]=1 \{\
.          if r#EN_NO_FIRST_PN \{\
.             if \\n[#PAGINATION_STATE]=1 \{\
.                nr #PAGINATE 1
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       if \\n[#PAGE_NUM_V_POS]=2 \{ .nr #PAGINATE 0 \}
.    \}
.    rr #PAGINATION_STATE
.    PAGENUM_STYLE \\*[$EN_PN_STYLE]
.    if \\n[#EN_FIRST_PN] \{ .PAGENUMBER \\n[#EN_FIRST_PN] \}
.    if \\n[#HEADER_STATE]=1 \{\
.       if \\n[#EN_ALLOWS_HEADERS] \{ .HEADERS \}
.    \}
\# Collect endnote title string for TOC
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.    ds $TOC_TITLE_ITEM \\*[$EN_STRING]\\|
.    ev TOC_EV
.    da TOC_ENTRIES
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam C
.       ft  R
.       ps  12
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_TITLE_FAM]
\!.     FT      \\*[$TOC_TITLE_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_TITLE_SIZE_CHANGE]
.    \}
\!.  TRAP OFF
.    ie \\n[#PRINT_STYLE]=1 \{\
\!.     PAD "\\*[$TOC_TITLE_ITEM]\\*[$TOC_PN_TYPEWRITE]" 
.    \}
.    el \{\
\!.     PAD "\\h'\\n[#TOC_TITLE_INDENT]u'\\*[$TOC_TITLE_ITEM]\\*[$TOC_PN]"
.    \}
\!.  EL
\!.  ST 100 L
\!.  ST 101 R
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_PN_FAM]
\!.     FT      \\*[$TOC_PN_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.    \}
\!.  TAB 100
\!.  PRINT \\*[LEADER]
\!.  TN
\!.  TRAP
\!.  PRINT \\n[#TOC_ENTRY_PN]
\!.  TQ
.    di       
.    ev
\# End collection of endnote title string for TOC
\# Process endnote
.    if \\n[#PRINT_STYLE]=1 \{ .vs \\n[#EN_LEAD]u \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#EN_NO_COLS] \{\
.          if \\n[#COLUMNS] \{ .nr #COLUMNS_WERE_ON 1 \}
.          nr #COLUMNS 0
.       \}
.       nr #RESTORE_DOC_LEAD \\n[#DOC_LEAD]
.       ie \\n[#ADJ_EN_LEAD] \{\
.          nr #DOC_LEAD \\n[#EN_LEAD]
.       \}
.       el \{ .DOC_LEAD \\n[#EN_LEAD]u \}
.    \}
.    PRINT \&
.    sp |\\n[#T_MARGIN]u
.    mk ec
.    if \\n[#SLANT_ON] \{\
\*[SLANTX]\c
.    \}
.    ev ENDNOTES
.    if !'\\*[$EN_STRING]'' \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          fam C
.          ft  R
.          ps  12
.          vs \\n[#EN_LEAD]u
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          LL \\n[#DOC_L_LENGTH]u
.          ta \\n(.lu
.          if \\n[#COLUMNS] \{\
.             ie \\n[#EN_NO_COLS] \{ .LL \\n[#DOC_L_LENGTH]u \}
.             el \{ .LL \\n[#COL_L_LENGTH]u \}
.             ta \\n(.lu
.          \}
.          FAMILY  \\*[$EN_STRING_FAM]
.          FT      \\*[$EN_STRING_FT]
.          PT_SIZE \\n[#EN_PS]u\\*[$EN_STRING_SIZE_CHANGE]
.          vs      \\n[#EN_LEAD]u
.       \}
.       if '\\*[$EN_STRING_QUAD]'L'      \{ .LEFT   \}
.       if '\\*[$EN_STRING_QUAD]'LEFT'   \{ .LEFT   \}
.       if '\\*[$EN_STRING_QUAD]'C'      \{ .CENTER \}
.       if '\\*[$EN_STRING_QUAD]'CENTER' \{ .CENTER \}
.       if '\\*[$EN_STRING_QUAD]'CENTRE' \{ .CENTER \}
.       if '\\*[$EN_STRING_QUAD]'R'      \{ .RIGHT  \}
.       if '\\*[$EN_STRING_QUAD]'RIGHT'  \{ .RIGHT  \}
.       EL
.       if \\n[#EN_STRING_CAPS] \{ .CAPS \}
.       ie \\n[#EN_STRING_UNDERSCORE] \{\
.          ie \\n[#EN_STRING_UNDERSCORE]=2 \{\
.             UNDERSCORE2 "\\*[$EN_STRING]
.          \}
.          el \{\
.             UNDERSCORE "\\*[$EN_STRING]
.          \}
.       \}
.       el \{\
.          PRINT "\\*[$EN_STRING]
.       \}
.    \}
.    CAPS OFF
.    ALD \\n[#EN_LEAD]u
.    QUAD \\*[$EN_QUAD]
.    nf
.    END_NOTES
.    br
.    ev
.    rm END_NOTES
.    if \\n[#PRINT_STYLE]=1 \{ .vs \\n[#DOC_LEAD]u \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#ADJ_EN_LEAD] \{\
.          nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]
.       \}
.       el \{ .DOC_LEAD \\n[#RESTORE_DOC_LEAD]u \}
.       rr #RESTORE_DOC_LEAD
.    \}
.    if \\n[#COLUMNS_WERE_ON] \{ .nr #COLUMNS 1 \}
.    if \\n[#HEADER_STATE]=1 \{ .HEADERS \}
.    rr #ENDNOTES
.END
\#
\# ====================================================================
\#
\# +++TABLE OF CONTENTS+++
\#
\# Strings to allocate space for leaders and entry page numbers
\#
.ds $TOC_PN \\*[ST100]\\F[\\*[$TOC_PN_FAM]]\\f[\\*[$TOC_PN_FT]]\\s[\\n[#TOC_PS]u]#\\*[ST100X]\\*[ST101]\\s[\\*[$TOC_PN_SIZE_CHANGE]]\\|\\h'\\w'0'u*\\n[#TOC_PN_PADDING]u'\*[ST101X]
.ds $TOC_PN_TYPEWRITE \\*[ST100]#\\*[ST100X]\\*[ST101]\\|\\h'\\w'0'u*\\n[#TOC_PN_PADDING]u'\\*[ST101X]
\#
\# TOC ENTRIES PAGE NUMBERS PADDING
\# --------------------------------
\# *Argument:
\#   <number of placeholders for toc entries page numbers>
\# *Function:
\#   Creates or modifies register #TOC_PN_PADDING.
\# *Notes:
\#   "Placeholders" is the maximum number of digits in a page
\#   number numeral.
\#
\#   Default is 3.
\#
.MAC TOC_PADDING END
.    nr #TOC_PN_PADDING \\$1
.END
\#
\#
\# PAGINATE TOC
\# ------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #PAGINATE_TOC.
\# *Notes:
\#   Default is to paginate toc.
\#
.MAC PAGINATE_TOC END
.    ie '\\$1'' \{ .nr #PAGINATE_TOC 1 \}
.    el \{ .nr #PAGINATE_TOC 0 \}
.END
\#
\#
\# TOC FAMILY
\# ----------
\# *Argument:
\#   <overall default family for toc pages>
\# *Function:
\#   Creates string $TOC_FAM.
\# *Notes:
\#   Default is same as document family. 
\#
.MAC TOC_FAMILY END
.    ds $TOC_FAM \\$1
.END
\#
\#
\# TOC POINT SIZE
\# --------------
\# *Argument:
\#   <base point size for toc pages>
\# *Function:
\#   Creates or modifies register #TOC_PS.
\# *Notes:
\#   This size control macro differs from other size control macros
\#   in that it sets an absolute point size, not a relative one.
\#   See notes for ENDNOTE_PT_SIZE for explanation.  No unit of
\#   measure required.
\#
\#   No unit of measure required (points assumed).  Default is 11.5
\#   for TYPESET.
\#
.MAC TOC_PT_SIZE END
.    nr #TOC_PS (p;\\$1)
.END
\#
\#
\# TOC LEADING
\# -----------
\# *Argument:
\#   <leading for toc pages> [ADJUST]
\# *Function:
\#   Creates or modifies register #TOC_LEAD. If optional ADJUST
\#   given, adjusts lead to fill page.  If #OK_PROCESS_LEAD doesn't
\#   exist, stores arguments for when it's okay to run the macro.
\# *Notes:
\#   No unit of measure required (points assumed).
\#
\#   Default is same as DOC_LEAD.
\#
.MAC TOC_LEAD END
.    if !\\n[#OK_PROCESS_LEAD] \{\
.       ds $TOC_LEAD \\$1
.       if !'\\$2'' \{\
.           ds $ADJUST_TOC_LEAD \\$2
.       \}
.       return
.    \}
.    rr #ADJ_TOC_LEAD
.    nr #TOC_LEAD (p;\\$1)
.    if '\\$2'ADJUST' \{\
.       nr #ORIG_DOC_LEAD \\n[#DOC_LEAD]
.       nr #ADJ_DOC_LEAD 1
.       nr #ADJ_TOC_LEAD 1
.       nr #NO_TRAP_RESET 1
.       DOC_LEAD \\n[#TOC_LEAD]u ADJUST
.       nr #TOC_LEAD \\n[#DOC_LEAD]
.       DOC_LEAD \\n[#ORIG_DOC_LEAD]u
.       rr #NO_TRAP_RESET
.       rr #ADJ_DOC_LEAD
.       rr #ORIG_DOC_LEAD
.    \}
.END
\#
\#
\# TOC PAGES PAGE-NUMBERING STYLE
\# ------------------------------
\# *Argument:
\#   DIGIT | ROMAN | roman | ALPHA | alpha
\# *Function:
\#   Creates or modifies string $TOC_PN_STYLE
\# *Notes:
\#   Page numbering style for page numbers that appear in the
\#   headers/footers of toc pages.  See notes for PAGENUM_STYLE.  
\#
\#   Default is roman.
\#
.MAC TOC_PAGENUM_STYLE END
.    ds $TOC_PN_STYLE \\$1
.END
\#
\#
\# TOC RECTO_VERSO SWITCH
\# ----------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #TOC_RV_SWITCH
\# *Notes:
\#   Allows switching of L/R margins if a doc is recto/verso and
\#   the first toc page happens to fall the wrong way
\#
.MAC TOC_RV_SWITCH END
.    ie '\\$1'' \{ .nr #TOC_RV_SWITCH 1 \}
.    el \{ .rr #TOC_RV_SWITCH \}
.END
\#
\# - for TOC "doc header" (i.e. "Contents")
\#
\# TOC HEADER FAMILY
\# -----------------
\# *Argument:
\#   <family for toc header>
\# *Function:
\#   Creates or modifies string $TOC_HEADER_FAM
\# *Notes:
\#   Default is same as TOC_FAMILY.
\#
.MAC TOC_HEADER_FAMILY END
.    ds $TOC_HEADER_FAM \\$1
.END
\#
\#
\# TOC HEADER FONT
\# ---------------
\# *Argument:
\#   <font for toc header>
\# *Function:
\#   Creates or modified string $TOC_HEADER_FT
\# *Notes:
\#   Default is bold for TYPESET.
\#
.MAC TOC_HEADER_FONT END
.    ds $TOC_HEADER_FT \\$1
.END
\#
\#
\# TOC HEADER SIZE
\# --------------
\# *Argument:
\#   <+|- number of points by which to in/decrease toc header
\#   (relative to overall toc point size)>
\# *Function:
\#   Creates or modifies string $TOC_HEADER_SIZE_CHANGE.
\# *Notes:
\#   Default is +4
\#
.MAC TOC_HEADER_SIZE END
.    ds $TOC_HEADER_SIZE_CHANGE \\$1
.END
\#
\#
\# TOC HEADER QUAD
\# ---------------
\# *Argument:
\#   L | LEFT | C | CENTER | CENTRE | R | RIGHT
\# *Function:
\#   Creates or modifies string $TOC_HEADER_QUAD.
\# *Notes:
\#   Default is LEFT.
\#
.MAC TOC_HEADER_QUAD END
.    ds $TOC_HEADER_QUAD \\$1
.END
\#
\#
\# TOC HEADER STRING
\# -----------------
\# *Argument:
\#   <string for "doc header" of first toc page>
\# *Function:
\#   Creates or modifies string $TOC_HEADER_STRING
\# *Notes:
\#   Default is "Contents".
\#
.MAC TOC_HEADER_STRING END
.    ds $TOC_HEADER_STRING \\$1
.END
\#
\# - for TOC entries page number numerals
\#
\# TOC ENTRIES PAGE NUMBER FAMILY
\# ------------------------------
\# *Argument:
\#   <family to use for toc entries page number>
\# *Function:
\#   Creates or modifies string $TOC_PN_FAM.
\# *Notes:
\#   Default is same as $TOC_FAM.
\#
.MAC TOC_PN_FAMILY END
.    ds $TOC_PN_FAM \\$1
.END
\#
\#
\# TOC ENTRIES PAGE NUMBER FONT
\# ----------------------------
\# *Argument:
\#   <font to use for toc entries page number>
\# *Function:
\#   Creates or modifies string $TOC_PN_FT.
\# *Notes:
\#   Default is roman.
\#
.MAC TOC_PN_FONT END
.    ds $TOC_PN_FT \\$1
.END
\#
\#
\# TOC ENTRIES PAGE NUMBER SIZE
\# ----------------------------
\# *Argument:
\#   <+|- number of points by which to in/decrease toc
\#   entries page numbers (relative to overall toc point size)>
\# *Function:
\#   Creates or modifies string $TOC_PN_SIZE_CHANGE.
\# *Notes:
\#   Default is +0.
\#
.MAC TOC_PN_SIZE END
.    ds $TOC_PN_SIZE_CHANGE \\$1
.END
\#
\#
\# Control macros for toc doc titles, heads, subheads and paraheads 
\# ----------------------------------------------------------------
\#
\# All these control macros behave the same way, setting the family,
\# font, point size and indent from the left margin of the different
\# kinds of entries that can appear in the toc.  The way they
\# operate is identical to all other _FAMILY, _FONT and _SIZE
\# control macros.  _INDENT takes an absolute value.
\# TOC_APPENDS_AUTHORS is unique in this section.
\# 
\# - for title entries
\#
.MAC TOC_TITLE_FAMILY END
.    ds $TOC_TITLE_FAM \\$1
.END
\#
\#
.MAC TOC_TITLE_FONT END
.    ds $TOC_TITLE_FT \\$1
.END
\#
\#
.MAC TOC_TITLE_SIZE END
.    ds $TOC_TITLE_SIZE_CHANGE \\$1
.END
\#
\#
.MAC TOC_TITLE_INDENT END
.    nr #TOC_TITLE_INDENT (\\$1)
.END
\#
\#
.MAC TOC_TITLE_ENTRY END
.    nr #USER_SET_TITLE_ITEM 1
.    ds $USER_SET_TITLE_ITEM \\$1
.END
\#
\#
\# APPEND AUTHOR(S) TO TOC DOC TITLE ENTRIES
\# -----------------------------------------
\# *Argument:
\#   <none> | <name(s) of author(s) as they should appear in toc doc title entries>
\# *Function:
\#   Creates register #TOC_AUTHORS (to tell TOC to append authors
\#   to toc doc title entries).  Optionally creates string
\#   $TOC_AUTHORS.
\# *Notes:
\#   Normally, TOC does not append the author(s) to a toc doc title
\#   entry.  This special macro instructs TOC to do so.
\#
\#   If user has multiple authors for each doc when collating,
\#   TOC_APPENDS_AUTHOR "<string>" must be inserted somewhere between
\#   COLLATE and START in each doc.  Otherwise, mom prints only the
\#   first author given to AUTHOR.
\#
.MAC TOC_APPENDS_AUTHOR END
.    nr #TOC_AUTHORS 1
.    if !'\\$1'' \{\
.       ds $TOC_AUTHORS \\$1
.    \}
.END
\#
\# - for head entries
\#
.MAC TOC_HEAD_FAMILY END
.    ds $TOC_HEAD_FAM \\$1
.END
\#
\#
.MAC TOC_HEAD_FONT END
.    ds $TOC_HEAD_FT \\$1
.END
\#
\#
.MAC TOC_HEAD_SIZE END
.    ds $TOC_HEAD_SIZE_CHANGE \\$1
.END
\#
\#
.MAC TOC_HEAD_INDENT END
.    nr #TOC_HEAD_INDENT (\\$1)
.END
\#
\# - for subhead entries
\#
.MAC TOC_SUBHEAD_FAMILY END
.    ds $TOC_SH_FAM \\$1
.END
\#
\#
.MAC TOC_SUBHEAD_FONT END
.    ds $TOC_SH_FT \\$1
.END
\#
\#
.MAC TOC_SUBHEAD_SIZE END
.    ds $TOC_SH_SIZE_CHANGE \\$1
.END
\#
\#
.MAC TOC_SUBHEAD_INDENT END
.    nr #TOC_SH_INDENT (\\$1)
.END
\#
\# - for parahead entries
\#
.MAC TOC_PARAHEAD_FAMILY END
.    ds $TOC_PH_FAM \\$1
.END
\#
\#
.MAC TOC_PARAHEAD_FONT END
.    ds $TOC_PH_FT \\$1
.END
\#
\#
.MAC TOC_PARAHEAD_SIZE END
.    ds $TOC_PH_SIZE_CHANGE \\$1
.END
\#
\#
.MAC TOC_PARAHEAD_INDENT END
.    nr #TOC_PH_INDENT (\\$1)
.END
\#
\#
.MAC TOC END
.    if !r#PAGINATE_TOC \{ .PAGINATE_TOC \}
.    nr #TOC_FIRST_PAGE 1
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] \{\
.          FOOTERS \" Have to turn FOOTERS on for next bit to work, so we can't skip this step
.       \}
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       if !'\\*[$HDRFTR_CENTER_OLD]'' \{ .ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_OLD] \}
.       ie \\n[#PAGINATE_TOC]=1 \{ .PAGINATE \}
.       el \{ .PAGINATION OFF \}
.    \}
.    if \\n[#FOOTERS_WERE_ON] \{ .FOOTERS OFF \} \" But have to turn FOOTERS off again so they don't print when FINIS was called
.    COLLATE
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] \{ .FOOTERS \} \" Finally, turn footers on if they were on
.       rr #FOOTERS_WERE_ON
.       if \\n[#PAGINATION_WAS_ON] \{\
.          nr #PAGINATE 1
.          rr #PAGINATION_WAS_ON
.       \}
.       rr #FINIS
.    \}
.    ie \\n[#PAGINATE_TOC]=1 \{ .PAGINATE \}
.    el \{ .PAGINATION OFF \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_NEW]
.       rm $HDRFTR_CENTER_OLD
.       rm $HDRFTR_CENTER_NEW
.    \}
.    rr #COLLATED_DOC
.    DOCHEADER OFF
.    PAGENUMBER 1
.    if \\n[#PRINT_STYLE]=1 \{\
.       rr #IGNORE
.       DOC_LEAD 24 ADJUST
.       nr #IGNORE 1
.    \}
.    START
.    PP
.    nr #COLUMNS 0
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie r#ADJ_TOC_LEAD \{\
.          nr #NO_TRAP_RESET 1
.          DOC_LEAD \\n[#TOC_LEAD]u ADJUST
.          rr #NO_TRAP_RESET
.       \}
.       el \{ .DOC_LEAD \\n[#TOC_LEAD]u \}
.    \}
.    sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.    if \\n[#SLANT_ON] \{\
\*[SLANTX]\c
.    \}
.    DOC_LINE_LENGTH \\n[#DOC_L_LENGTH]u
.    QUAD \\*[$TOC_HEADER_QUAD]
.    PAGENUM_STYLE \\*[$TOC_PN_STYLE]
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam C
.       ft  R
.       ps  12
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       FAMILY  \\*[$TOC_HEADER_FAM]
.       FT      \\*[$TOC_HEADER_FT]
.       PT_SIZE \\n[#TOC_PS]u\\*[$TOC_HEADER_SIZE_CHANGE]
.    \}
.    ie \\n[#PRINT_STYLE]=1 \{\
.       CAPS
.       UNDERLINE
.       PRINT "\\*[$TOC_HEADER_STRING]"
.       UNDERLINE OFF
.       CAPS      OFF
.    \}
.    el \{\
.       PRINT "\\*[$TOC_HEADER_STRING]"
.    \}
.    LEFT
.    SP
\# In collated docs, this bit inserts the first doc's title
\# underneath the TOC header, before the TOC_ENTRIES diversion
\# gets output.
.    nf
.    if d$FIRST_DOC_TITLE \{\
.    nr #RESTORE_TOC_PN_PADDING \\n[#TOC_PN_PADDING]
.    TOC_PADDING \\n[#FIRST_DOC_TOC_PN_PADDING]
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$TOC_TITLE_FAM]
.          FT      \\*[$TOC_TITLE_FT]
.          PT_SIZE \\n[#TOC_PS]u\\*[$TOC_TITLE_SIZE_CHANGE]
.       \}
.       ie \\n[#PRINT_STYLE]=1 \{\
.          PAD "\\*[$FIRST_DOC_TITLE]\\*[$TOC_PN_TYPEWRITE]" 
.       \}
.       el \{\
.          PAD "\\h'\\n[#TOC_TITLE_INDENT]u'\\*[$FIRST_DOC_TITLE]\\*[$TOC_PN]"
.       \}
.       EL
.       ST 100 L
.       ST 101 R
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$TOC_PN_FAM]
.          FT      \\*[$TOC_PN_FT]
.          PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.       \}
.       TAB 100
.       PRINT \\*[LEADER]
.       TN
.       PRINT \\n[#FIRST_DOC_TITLE_PN]
.       TQ
.    \}
.    TOC_PADDING \\n[#RESTORE_TOC_PN_PADDING]
.    nf
.    TOC_ENTRIES
.    br
.    rr #TOC
.END
\#
\# ====================================================================
\#
\# +++COLUMNS+++
\#
\# COLUMNS
\# -------
\# *Arguments:
\#   <number of columns>  <width of gutters>
\# *Function:
\#   Creates registers associated with setting docs in columns.
\#   Calculates column line lengths and offsets
\# *Notes:
\#   COLUMNS, if used, s/b the last macro invoked before START.
\#
.MAC COLUMNS END
.    if \\n[#IGNORE_COLUMNS]=1 \{ .return \}
.    nr #COLUMNS 1
.    nr #NUM_COLS \\$1
.    nr #GUTTER (\\$2)
.    nr #COL_L_LENGTH \\n[#L_LENGTH]-(\\n[#GUTTER]*(\\n[#NUM_COLS]-1))/\\n[#NUM_COLS]
.    nr #COL_TOTAL 0 \\n[#COL_L_LENGTH]+\\n[#GUTTER]
.    nr #COL_NUM 0 1
.    while !\\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.       nr #COL_\\n+[#COL_NUM]_L_MARGIN \\n[#L_MARGIN]+\\n[#COL_TOTAL]
.       nr #COL_TOTAL \\n+[#COL_TOTAL]
.    \}
.    rr #COL_TOTAL
.    rr #COL_NUM
.END
\#
\#
\# NEXT COLUMN
\# -----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Breaks current column and moves to next column.
\#   If current column is the last on the page, breaks
\#   to a new page.
\#
.MAC COL_NEXT END
.    if \\n[#COLUMNS] \{\
.       nr #COL_NEXT 1
.       ie '\\$0'COL_NEXT' \{ .br  \}
.       el \{\
.          brp
.          RLD 1v
.       \}
.       ie \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.          bp
.       \}
.       el \{ .FOOTER \}
.    \}
.END
\#
\# ====================================================================
\#
\# +++LISTS+++
\#
\# LIST
\# ----
\# *Arguments:
\#   [ BULLET | DASH | DIGIT | ALPHA | USER ] [ <separator> ] [ <anything> ]
\# *Function:
\#   Stores indent information in effect prior to invocation and
\#   initializes a list with the supplied enumerator (and separator).
\# *Notes:
\#   Default enumerator is a bullet.
\#
\#   Enumerator *must* be supplied for every list that's to the
\#   right of another list, every time, unless the default bullet is
\#   desired.
\#
\#   <anything> moves back one list level intuitively, or exits lists
\#   completely if the level at which it's invoked is the first.
\#
.MAC LIST END
.    if !r#DEPTH \{\
.       nr #STORED_HL_INDENT \\n[#HL_INDENT]
.       nr #STORED_T_INDENT  \\n[#T_INDENT]
.       nr #CURRENT_L_LENGTH \\n(.l
.       nr #DEPTH 0 1
.       if \\n[#INDENT_ACTIVE]=1 \{\
.          if \\n[#INDENT_LEFT_ACTIVE]=1 \{\
.             nr #STORED_L_INDENT \\n[#L_INDENT]
.             nr #RESTORE_PREV_INDENT 1
.          \}
.          if \\n[#INDENT_BOTH_ACTIVE]=1 \{\
.             nr #STORED_BL_INDENT \\n[#BL_INDENT]
.             nr #STORED_BR_INDENT \\n[#BR_INDENT]
.             IBX
.             nr #ORIG_L_LENGTH \\n(.l
.             IB
.             nr #RESTORE_PREV_INDENT 2
.          \}
.          if \\n[#INDENT_RIGHT_ACTIVE]=1 \{\
.             nr #STORED_R_INDENT \\n[#R_INDENT]
.             IRX
.             nr #ORIG_L_LENGTH \\n(.l
.             IR
.             nr #RESTORE_PREV_INDENT 3
.             if \\n[#INDENT_LEFT_ACTIVE]=1 \{ .nr #RESTORE_PREV_INDENT 4 \}
.          \}
.       \}
.    \}
.    if \\n[#NUM_ARGS]=0 \{\
.       nr #ARGS_TO_LIST 1 \" So default behaves as if LIST BULLET
.       ds $ENUMERATOR\\n+[#DEPTH] \(bu
.       ds $SEPARATOR
.    \}
.    if \\n[#NUM_ARGS]>0 \{\
.       rr #ARGS_TO_LIST \" Clear this before processing arg 1.
.       if '\\$1'DASH'   \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH] \(en
.          ds $SEPARATOR\\n[#DEPTH]
.       \}
.       if '\\$1'BULLET' \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH] \(bu
.          ds $SEPARATOR\\n[#DEPTH]
.       \}
.       if '\\$1'DIGIT'  \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] register
.          ds $SEPARATOR\\n[#DEPTH] .
.          if \\n[#NUM_ARGS]=2 \{\
.             ie '\\$2'NONE' \{ .ds $SEPARATOR\\n[#DEPTH]\}
.             el             \{ .ds $SEPARATOR\\n[#DEPTH] \\$2\}
.          \}
.       \}
.       if '\\$1'ALPHA'  \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          af #ENUMERATOR\\n[#DEPTH] a
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] register
.          ds $SEPARATOR\\n[#DEPTH] )
.          if \\n[#NUM_ARGS]=2 \{\
.             ie '\\$2'NONE' \{ .ds $SEPARATOR\\n[#DEPTH]\}
.             el             \{ .ds $SEPARATOR\\n[#DEPTH] \\$2\}
.          \}
.       \}
.       if '\\$1'USER'   \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH] \\$2
.          ds $SEPARATOR\\n[#DEPTH]
.       \}
.       if \\n[#NUM_ARGS]=1 \{\
.          if !r#ARGS_TO_LIST \{\
.             ie \\n[#DEPTH]=1 \{\
.                ie \\n[#NEXT_DEPTH_BACK]=0 \{\
.                   SET_LIST_INDENT
.                   if \\n[#QUIT]=1 \{\
.                      QUIT_LISTS
.                      return
.                   \}
.                   return
.                \}
.                el \{\
.                   QUIT_LISTS
.                   return
.                \} 
.             \}
.             el \{\
.                SET_LIST_INDENT
.                return
.             \}
.          \}
.       \}
.    \}
.    nr #TOTAL_LISTS \\n[#DEPTH]
.    ie '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'register' \{\
.       nr #LIST_INDENT\\n[#DEPTH] \\w'm\\*[$SEPARATOR\\n[#DEPTH]]\\ '
.    \}
.    el \{\
.       nr #LIST_INDENT\\n[#DEPTH] \\w'\\*[$ENUMERATOR\\n[#DEPTH]]\\0'
.    \}
.    LL \\n[#CURRENT_L_LENGTH]u
.    ie \\n[#DEPTH]=1 \{\
.       ie \\n[#INDENT_ACTIVE]=1 \{\
.          if \\n[#INDENT_LEFT_ACTIVE]=1 \{\
.             nr #L_INDENT \\n[#L_INDENT]+\\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #LIST_INDENT\\n[#DEPTH] \\n[#L_INDENT]
.          \}
.          if \\n[#INDENT_BOTH_ACTIVE]=1 \{\
.             nr #L_INDENT \\n[#BL_INDENT]+\\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #LIST_INDENT\\n[#DEPTH] \\n[#L_INDENT]
.          \}
.          if \\n[#INDENT_RIGHT_ACTIVE]=1 \{\
.             ie \\n[#INDENT_LEFT_ACTIVE]=1 \{\
.             \" Don't do anything; we already have a left indent
.             \}
.             el \{\
.                nr #L_INDENT +\\n[#LIST_INDENT\\n[#DEPTH]]
.                nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.             \}
.          \}
.       \}
.       el \{\
.          nr #L_INDENT +\\n[#LIST_INDENT\\n[#DEPTH]]
.          nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.       \}
.    \}
.    el \{\
.       nr #L_INDENT +\\n[#LIST_INDENT\\n[#DEPTH]]
.       nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.    \}
.END
\#
\#
\# ITEM
\# ----
\# *Arguments:
\#   none
\# *Function:
\#   Prints enumerator for a given list depth and prepares mom to
\#   receive the text of an item.
\#
.MAC ITEM END
.    KERN OFF
.    IL 
.    ll \\n[#CURRENT_L_LENGTH]u \" Set ll again because IL turns IB off.
.    TRAP OFF
.    HI \\n[#HL_INDENT\\n[#DEPTH]]u
.    ie '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'register' \{\
.       ie '\\g[#ENUMERATOR\\n[#DEPTH]]'0' \{\
.          ie \\n[#PAD_LIST_DIGITS\\n[#DEPTH]]=1 \{\
.             ie \\n[#ENUMERATOR\\n[#DEPTH]]<9 \{\
.                PRINT \\0\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.             el \{\
.                PRINT \\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.          \}
.          el \{\
.             PRINT \\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.          \}
.       \}
.       el \{\
.          PRINT \\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.       \}
.    \}
.    el \{\
.       PRINT \\*[$ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.    \}
.    EL
.    TRAP
.    KERN
.END
\#
\#
\# SHIFT LIST
\# ---------
\# *Arguments:
\#   <amount by which to indent a list to the right>
\# *Function:
\#   Adds the value of the arg to the current list's indent.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC SHIFT_LIST END
.    nr #LIST_INDENT\\n[#DEPTH] \\n[#L_INDENT]+(\\$1)
.    nr #L_INDENT \\n[#LIST_INDENT\\n[#DEPTH]]
.END
\#
\#
\# PAD LIST DIGITS
\# ---------------
\# *Arguments:
\#   [ LEFT ]
\# *Function:
\#   Adds a figure space to a list's hanging and left indent.  If
\#   LEFT is given, sets reg. #PAD_LIST_DIGITS to 1 for use in ITEM.
\#
.MAC PAD_LIST_DIGITS END
.    if '\\g[#ENUMERATOR\\n[#DEPTH]]'0' \{\
.       nr #LIST_INDENT\\n[#DEPTH] +\\w'\\0'
.       nr #L_INDENT \\n[#LIST_INDENT\\n[#DEPTH]]+\\n[#LIST_INDENT\\n-[#DEPTH]]
.       nr #HL_INDENT\\n+[#DEPTH] +\\w'\\n[#ENUMERATOR\\n[#DEPTH]]'
.       if '\\$1'LEFT' \{ .nr #PAD_LIST_DIGITS\\n[#DEPTH] 1 \}
.    \}
.END
\#
\#
\# RESET LIST
\# ----------
\# *Arguments:
\#   none
\# *Function:
\#   Resets register enumerators to 1 or a.
\#
.MAC RESET_LIST END
.    nr #ENUMERATOR\\n[#DEPTH] 0 1
.END
\#
\#
\# QUIT LISTS
\# ----------
\# *Arguments:
\#   none
\# *Function:
\#   Exits lists cleanly and restores any indents that were in
\#   effect prior to LIST.
\#
.MAC QUIT_LISTS END
.   IQ CLEAR
.   nr #HL_INDENT \\n[#STORED_HL_INDENT]
.   nr #T_INDENT  \\n[#STORED_T_INDENT]
.   rr #STORED_HL_INDENT
.   if \\n[#RESTORE_PREV_INDENT]=1 \{\
.      nr #L_INDENT  \\n[#STORED_L_INDENT]
.      IL
.      rr #STORED_L_INDENT
.   \}
.   if \\n[#RESTORE_PREV_INDENT]=2 \{\
.      nr #BL_INDENT \\n[#STORED_BL_INDENT]
.      nr #BR_INDENT \\n[#STORED_BR_INDENT]
.      LL \\n[#ORIG_L_LENGTH]u
.      IB
.      rr #STORED_BL_INDENT
.      rr #STORED_BR_INDENT
.   \}
.   if \\n[#RESTORE_PREV_INDENT]=3 \{\
.      nr #R_INDENT \\n[#STORED_R_INDENT]
.      LL \\n[#ORIG_L_LENGTH]u
.      IR
.      rr #STORED_R_INDENT
.   \}
.   if \\n[#RESTORE_PREV_INDENT]=4 \{\
.      nr #R_INDENT \\n[#STORED_R_INDENT]
.      nr #L_INDENT \\n[#STORED_L_INDENT]
.      LL \\n[#ORIG_L_LENGTH]u
.      IR
.      IL
.      rr #STORED_R_INDENT
.      rr #STORED_L_INDENT
.   \}
.\" Clean up after exiting last depth of list
.   nr #REMOVE 0 1
.   while \\n+[#REMOVE]<=\\n[#TOTAL_LISTS] \{\
.      rr #LIST_INDENT\\n[#REMOVE]
.      rr #ENUMERATOR\\n[#REMOVE]
.      rm $ENUMERATOR\\n[#REMOVE]
.      rr #SEPARATOR\\n[#REMOVE]
.      rm $ENUMERATOR_TYPE\\n[#REMOVE]
.      rr #PAD_LIST_DIGITS\\n[#REMOVE]
.   \}
.   rr #REMOVE
.   rr #TOTAL_LISTS
.   rr #QUIT
.   rr #DEPTH
.   rr #NEXT_DEPTH_BACK
.   rr #RESTORE_PREV_INDENT
.   rr #ORIG_L_LENGTH
.   rr #CURRENT_L_LENGTH
.END
\#
\#
\# SET LIST INDENT
\# ---------------
\# *Arguments:
\#   none
\# *Function:
\#   Restores indent of prev. list in nested lists.  Also sets the
\#   #QUIT register if an invocation of LIST OFF applies to the first
\#   level of list.
\#
.MAC SET_LIST_INDENT END
.    nr #NEXT_DEPTH_BACK \\n[#DEPTH]-1
.    if \\n[#NEXT_DEPTH_BACK]=0 \{\
.       nr #QUIT 1
.       return
.    \}
.    ie \\n[#NEXT_DEPTH_BACK]=1 \{ .nr #L_INDENT \\n[#LIST_INDENT1] \}
.    el \{ .nr #L_INDENT -\\n[#LIST_INDENT\\n[#DEPTH]] \}
.    nr #HL_INDENT \\n[#HL_INDENT\\n-[#DEPTH]]
.END
\#
\# ====================================================================
\#
\# +++DOCUMENT PROCESSING MISC AND SUPPORT MACROS+++
\#
\# COLLATE
\# -------
\# *Arguments:
\#   <none>
\# *Function:
\#   Turns headers off (if on) and saves header state, sets register
\#   #COLLATE to 1 (toggle), and breaks to a new page.
\# *Notes:
\#   COLLATE exists primarily to allow putting multiple chapters in
\#   a single file, although it can be used for any document type.  After
\#   COLLATE, any of the macros that normally precede START may be
\#   used, and should behave as expected.
\#
\#   N.B.--the START macro *must* be used after COLLATE (and any other
\#   macros that alter mom's behaviour).
\#
.MAC COLLATE END
.    nr #COLLATE 1
.    nr #HEADER_STATE \\n[#HEADERS_ON]
.    HEADERS OFF
.    if \\n[#PAGE_NUM_V_POS]=1 \{\
.       nr #PAGINATION_STATE \\n[#PAGINATE]
.       PAGINATION OFF
.    \}
.    IQ CLEAR
.    TQ
\# Collect first doc's title for TOC
.    if \\n[#COLLATED_DOC]=0 \{\
.       ie \\n[#USER_SET_TITLE_ITEM] \{\
.          ds $FIRST_DOC_TITLE \\*[$USER_SET_TITLE_ITEM]\\|
.          rr #USER_SET_TITLE_ITEM
.          rm $USER_SET_TITLE_ITEM
.       \}
.       el \{\
.          ie \\n[#DOC_TYPE]=2 \{\
.             ie '\\*[$CHAPTER_TITLE]'' \{\
.                ds $FIRST_DOC_TITLE \\*[$CHAPTER_STRING] \\*[$CHAPTER]\\|
.             \}
.             el \{\
.                ie '\\*[$CHAPTER]'' \{\
.                   ds $FIRST_DOC_TITLE \\*[$CHAPTER_TITLE]\\|
.                \}
.                el \{\
.                   ds $FIRST_DOC_TITLE \\*[$CHAPTER_STRING] \\*[$CHAPTER]: \\*[$CHAPTER_TITLE]\\|
.                \}
.             \}
.          \}
.          el \{\
.             ds $FIRST_DOC_TITLE \\*[$TITLE]\\|
.          \}
.       \}
.       if \\n[#TOC_AUTHORS]=1 \{\
.          ie '\\*[$TOC_AUTHORS]'' \{\
.             as $FIRST_DOC_TITLE /\\|\\*[$AUTHOR_1]\\|
.          \}
.          el \{\
.             as $FIRST_DOC_TITLE /\\|\\*[$TOC_AUTHORS]\\|
.             rm $TOC_AUTHORS
.          \}
.       \}
.       nr #COLLATED_DOC 1
.    \}
\# End title collection for TOC
.    LL \\n[#DOC_L_LENGTH]u
.    QUAD $DOC_QUAD
.    LS \\n[#DOC_LEAD]u
\*[SLANTX]
\*[CONDX]
\*[EXTX]
'    NEWPAGE
.    if \\n[#DEFER_PAGINATION] \{ .PAGINATE \}
.    if !'\\*[$RESTORE_PAGENUM_STYLE]'' \{\
.       PAGENUM_STYLE \\*[$RESTORE_PAGENUM_STYLE]
.       rm $RESTORE_PAGENUM_STYLE
.    \}
.    rm $EN_TITLE
.    rr #PAGENUM_STYLE_SET
.END
\#
\#
\# OUTPUT BLANK PAGES
\# ------------------
\# *Argument:
\#   <number of blank pages to output>
\# *Function:
\#   Outputs blank pages.
\# *Notes:
\#   If recto/verso, each page is recto/verso, even if there's
\#   nothing on it.
\#
.MAC BLANKPAGE END
.    nr #HOW_MANY \\$1
.    nr #PAGES 0 1
.    while \\n+[#PAGES]<=\\n[#HOW_MANY] \{\
.    if \\n[#HEADERS_ON]=1 \{\
.       nr #HEADERS_WERE_ON 1
.       HEADERS OFF
.    \}
.    if \\n[#PAGE_NUM_V_POS]=1 \{\
.       if \\n[#PAGINATE]=1 \{ .nr #PAGINATE_WAS_ON 1 \}
.       PAGINATION OFF
.    \}
.    NEWPAGE
.    PRINT \&
.    if \\n[#FOOTERS_ON]=1 \{\
.       nr #FOOTERS_WERE_ON 1
.       FOOTERS OFF
.    \}
.    if \\n[#PAGE_NUM_V_POS]=2 \{\
.       if \\n[#PAGINATE]=1 \{ .nr #PAGINATE_WAS_ON 1 \}
.       PAGINATION OFF
.    \}
.    if \\n[#HEADERS_WERE_ON] \{ .HEADERS \}
.    if \\n[#PAGE_NUM_V_POS]=1 \{\
.       if \\n[#PAGINATE_WAS_ON] \{ .PAGINATE \}
.    \}
.    \}
.    NEWPAGE
.    if \\n[#FOOTERS_WERE_ON] \{ .FOOTERS \}
.    if \\n[#PAGE_NUM_V_POS]=2 \{\
.       if \\n[#PAGINATE_WAS_ON] \{ .PAGINATE \}
.     \}
.    rr #HEADERS_WERE_ON
.    rr #FOOTERS_WERE_ON
.    rr #PAGINATE_WAS_ON
.END
\#
\#
\# SET TRAPS FOR HEADERS/FOOTERS/FOOTNOTES
\# ---------------------------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Sets header/footer/footnotes/etc... traps.
\#     Calculates the number of lines that actually fit on a
\#   page based on #B_MARGIN and resets page bottom trap to coincide
\#   with the depth of that number of lines, or, if #ADJ_DOC_LEAD=1,
\#   adjusts #DOC_LEAD so that the last line of text on a page falls
\#   exactly on #B_MARGIN.
\#
.MAC TRAPS END
\#  *Remove all header/footer traps
.    if !\\n[#NO_TRAP_RESET] \{\
.       ch DO_T_MARGIN
.       ch DO_B_MARGIN
.       ch HEADER
.       ch FOOTER
\#  *Plant header trap
.       wh 0 HEADER
.    \}
\#  *Adjust lead so last line of text falls on B_MARGIN,...
.    ie \\n[#ADJ_DOC_LEAD]=1 \{\
.       nr #LINES_PER_PAGE 0 1
.       nr #DOC_LEAD_ADJ 0 1
.       nr #DEPTH_TO_B_MARGIN \\n[#PAGE_LENGTH]-\\n[#B_MARGIN]-1v
.       while \\n[#T_MARGIN]+(\\n[#DOC_LEAD]*\\n+[#LINES_PER_PAGE])<\\n[#DEPTH_TO_B_MARGIN] \{\
.
.       \}
.       nr #LINES_PER_PAGE -1
.       while \\n[#T_MARGIN]+(\\n[#DOC_LEAD]+\\n+[#DOC_LEAD_ADJ]*\\n[#LINES_PER_PAGE])<\\n[#DEPTH_TO_B_MARGIN] \{\
.
.       \}
.       DOC_LEAD \\n[#DOC_LEAD]u+\\n[#DOC_LEAD_ADJ]u
.    \}
\#  *...or calculate new B_MARGIN based on # of lines (at #DOC_LEAD) that fit
\#  *on the page.
.    el \{\
.       nr #LINES_PER_PAGE 0 1
.       nr #DEPTH_TO_B_MARGIN \\n[#PAGE_LENGTH]-\\n[#B_MARGIN]-1v
.       while \\n[#T_MARGIN]+(\\n[#DOC_LEAD]*\\n+[#LINES_PER_PAGE])<\\n[#DEPTH_TO_B_MARGIN] \{\
.
.       \}
.       nr #B_MARGIN \\n[#PAGE_LENGTH]-(\\n[#T_MARGIN]+(\\n[#DOC_LEAD]*\\n[#LINES_PER_PAGE]))
.    \}
\#  *Set footer and footnote overflow traps
.    if !\\n[#NO_TRAP_RESET] \{\
.       nr #FN_COUNT 0 1
.       nr #SPACE_REMAINING 0
.       nr #FN_DEPTH 0
.       nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]u
.       wh 12i FOOTER
.       wh -\\n[#B_MARGIN]u FN_OVERFLOW_TRAP
.       ch FOOTER -\\n[#B_MARGIN]u
.    \}
.    rr #ADJ_DOC_LEAD
.END
\#
\#
\# CHECK INDENT
\# ------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Adds left, right, or both indent values to document elements
\#   like heads and subheads that are processed in environments.
\#
.MAC CHECK_INDENT END
.    if \\n[#INDENT_LEFT_ACTIVE] \{\
.       in \\n[#L_INDENT]u
.       if \\n[#QUOTE] \{\
.          in -\\n[#L_INDENT]u \"Because you added an indent in 2nd line of macro
.          ll -\\n[#L_INDENT]u
.          ta \\n(.lu
.       \}
.       if \\n[#EPIGRAPH] \{\
.          in -\\n[#L_INDENT]u
.          ll -\\n[#L_INDENT]u
.          ta \\n(.lu
.       \}
.    \}
.    if \\n[#INDENT_RIGHT_ACTIVE] \{\
.       ll -\\n[#R_INDENT]u
.       ta \\n(.lu
.    \}
.    if \\n[#INDENT_BOTH_ACTIVE] \{\
.       in \\n[#BL_INDENT]u
.       ll -\\n[#BR_INDENT]u
.       ta \\n(.lu
.       if \\n[#QUOTE] \{\
.          in -\\n[#BL_INDENT]u
.          ie \\n[#BR_INDENT]=\\n[#BL_INDENT] \{\
.             ll -\\n[#BR_INDENT]u
.             ta \\n(.lu
.          \}
.          el \{\
.             ll -(\\n[#BR_INDENT]u/2u)
.             ta \\n(.lu
.          \}
.       \}
.       if \\n[#EPIGRAPH] \{\
.          in -\\n[#BL_INDENT]u
.          ie \\n[#BR_INDENT]=\\n[#BL_INDENT] \{\
.             ll -\\n[#BR_INDENT]u
.             ta \\n(.lu
.          \}
.          el \{\
.             ll -(\\n[#BR_INDENT]u/2u)
.             ta \\n(.lu
.          \}
.       \}
.    \}
.END
\#
\#
\# REMOVE INDENT
\# -------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Removes left, right, or both indent values from document elements
\#   like heads and subheads that are processed in environments.
\#
.MAC REMOVE_INDENT END
.    in 0
.    ll \\n[#L_LENGTH]u
.    ta \\n(.lu
.END
\#
\#
\# Set up a default papersize of US letter
\#
.PAPER LETTER
\#
\# ====================================================================
\#
\# +++DOCUMENT PROCESSING ALIASES+++
\#
\# Aliases to make life easier for users: synonyms, short forms
\# and alternate spellings.
\#
\# Macros
\# ------
.ALIAS   BLOCKQUOTE_COLOUR               BLOCKQUOTE_COLOR
.ALIAS   BREAK_BLOCKQUOTE                BREAK_QUOTE
.ALIAS   BREAK_CITATION                  BREAK_QUOTE
.ALIAS   BREAK_CITE                      BREAK_QUOTE
.ALIAS   CITATION                        BLOCKQUOTE
.ALIAS   CITATION_COLOUR                 CITATION_COLOR
.ALIAS   CITATION_FAMILY                 BLOCKQUOTE_FAMILY
.ALIAS   CITATION_FONT                   BLOCKQUOTE_FONT
.ALIAS   CITATION_SIZE                   BLOCKQUOTE_SIZE
.ALIAS   CITATION_COLOR                  BLOCKQUOTE_COLOR
.ALIAS   CITATION_QUAD                   BLOCKQUOTE_QUAD
.ALIAS   CITE                            BLOCKQUOTE
.ALIAS   CITE_COLOUR                     CITE_COLOR
.ALIAS   CITE_FAMILY                     BLOCKQUOTE_FAMILY
.ALIAS   CITE_FONT                       BLOCKQUOTE_FONT
.ALIAS   CITE_SIZE                       BLOCKQUOTE_SIZE
.ALIAS   CITE_COLOR                      BLOCKQUOTE_COLOR
.ALIAS   CITE_QUAD                       BLOCKQUOTE_QUAD
.ALIAS   DOC_R_MARGIN                    DOC_RIGHT_MARGIN
.ALIAS   DOC_L_MARGIN                    DOC_LEFT_MARGIN
.ALIAS   DOC_L_LENGTH                    DOC_LINE_LENGTH
.ALIAS   DOC_RMARGIN                     DOC_RIGHT_MARGIN
.ALIAS   DOC_LMARGIN                     DOC_LEFT_MARGIN
.ALIAS   DOC_LLENGTH                     DOC_LINE_LENGTH
.ALIAS   DOC_FAM                         DOC_FAMILY
.ALIAS   DOC_LS                          DOC_LEAD
.ALIAS   DOC_PS                          DOC_PT_SIZE
.ALIAS   DOCHEADER_COLOUR                DOCHEADER_COLOUR
.ALIAS   EPIGRAPH_COLOUR                 EPIGRAPH_COLOR
.ALIAS   FILL                            QUAD
.ALIAS   FINIS_COLOUR                    FINIS_COLOR
.ALIAS   HEAD_COLOUR                     HEAD_COLOR
.ALIAS   LINEBREAK_COLOUR                LINEBREAK_COLOR
.ALIAS   PAGENUM                         PAGENUMBER
.ALIAS   PAGENUM_COLOUR                  PAGENUM_COLOR
.ALIAS   PAGINATION                      PAGINATE
.ALIAS   PARAHEAD_COLOUR                 PARAHEAD_COLOR
.ALIAS   PP_FT                           PP_FONT
.ALIAS   QUOTE_COLOUR                    QUOTE_COLOR
.ALIAS   SUBHEAD_COLOUR                  SUBHEAD_COLOR
.ALIAS   TOC_FAM                         TOC_FAM
.ALIAS   TOC_PS                          TOC_PT_SIZE
\#
\# HEADER and FOOTER aliases for HDRFTR macros.
\#
.ALIAS   ENDNOTES_FOOTER_CENTER          ENDNOTES_HDRFTR_CENTER
.ALIAS   ENDNOTES_HEADER_CENTER          ENDNOTES_HDRFTR_CENTER
.ALIAS   ENDNOTES_FOOTER_CENTRE          ENDNOTES_HDRFTR_CENTRE
.ALIAS   ENDNOTES_HEADER_CENTRE          ENDNOTES_HDRFTR_CENTRE
.ALIAS   FOOTER_CENTER_CAPS              HDRFTR_CENTER_CAPS
.ALIAS   FOOTER_CENTER_COLOR             HDRFTR_CENTER_COLOR
.ALIAS   FOOTER_CENTER_COLOUR            HDRFTR_CENTER_COLOUR
.ALIAS   FOOTER_CENTER_FAM               HDRFTR_CENTER_FAMILY
.ALIAS   FOOTER_CENTER_FAMILY            HDRFTR_CENTER_FAMILY
.ALIAS   FOOTER_CENTER_FONT              HDRFTR_CENTER_FONT
.ALIAS   FOOTER_CENTER_FT                HDRFTR_CENTER_FONT
.ALIAS   FOOTER_CENTER                   HDRFTR_CENTER
.ALIAS   FOOTER_CENTER_PAD               HDRFTR_CENTER_PAD
.ALIAS   FOOTER_CENTER_PS                HDRFTR_CENTER_SIZE
.ALIAS   FOOTER_CENTER_SIZE              HDRFTR_CENTER_SIZE
.ALIAS   FOOTER_CENTRE_CAPS              HDRFTR_CENTER_CAPS
.ALIAS   FOOTER_CENTRE_COLOR             HDRFTR_CENTRE_COLOR
.ALIAS   FOOTER_CENTRE_COLOUR            HDRFTR_CENTRE_COLOUR
.ALIAS   FOOTER_CENTRE_FAM               HDRFTR_CENTER_FAMILY
.ALIAS   FOOTER_CENTRE_FAMILY            HDRFTR_CENTER_FAMILY
.ALIAS   FOOTER_CENTRE_FONT              HDRFTR_CENTER_FONT
.ALIAS   FOOTER_CENTRE_FT                HDRFTR_CENTER_FONT
.ALIAS   FOOTER_CENTRE                   HDRFTR_CENTER
.ALIAS   FOOTER_CENTRE_PAD               HDRFTR_CENTER_PAD
.ALIAS   FOOTER_CENTRE_PS                HDRFTR_CENTER_SIZE
.ALIAS   FOOTER_CENTRE_SIZE              HDRFTR_CENTER_SIZE
.ALIAS   FOOTER_COLOR                    HDRFTR_COLOR
.ALIAS   FOOTER_COLOUR                   HDRFTR_COLOR
.ALIAS   FOOTER_FAM                      HDRFTR_FAMILY
.ALIAS   FOOTER_FAMILY                   HDRFTR_FAMILY
.ALIAS   FOOTER_LEFT_CAPS                HDRFTR_LEFT_CAPS
.ALIAS   FOOTER_LEFT_COLOR               HDRFTR_LEFT_COLOR
.ALIAS   FOOTER_LEFT_COLOUR              HDRFTR_LEFT_COLOUR
.ALIAS   FOOTER_LEFT_FAM                 HDRFTR_LEFT_FAMILY
.ALIAS   FOOTER_LEFT_FAMILY              HDRFTR_LEFT_FAMILY
.ALIAS   FOOTER_LEFT_FONT                HDRFTR_LEFT_FONT
.ALIAS   FOOTER_LEFT_FT                  HDRFTR_LEFT_FONT
.ALIAS   FOOTER_LEFT                     HDRFTR_LEFT
.ALIAS   FOOTER_LEFT_PS                  HDRFTR_LEFT_SIZE
.ALIAS   FOOTER_LEFT_SIZE                HDRFTR_LEFT_SIZE
.ALIAS   FOOTER_PLAIN                    HDRFTR_PLAIN
.ALIAS   FOOTER_RECTO                    HDRFTR_RECTO
.ALIAS   FOOTER_RIGHT_CAPS               HDRFTR_RIGHT_CAPS
.ALIAS   FOOTER_RIGHT_COLOR              HDRFTR_RIGHT_COLOR
.ALIAS   FOOTER_RIGHT_COLOUR             HDRFTR_RIGHT_COLOUR
.ALIAS   FOOTER_RIGHT_FAM                HDRFTR_RIGHT_FAMILY
.ALIAS   FOOTER_RIGHT_FAMILY             HDRFTR_RIGHT_FAMILY
.ALIAS   FOOTER_RIGHT_FONT               HDRFTR_RIGHT_FONT
.ALIAS   FOOTER_RIGHT_FT                 HDRFTR_RIGHT_FONT
.ALIAS   FOOTER_RIGHT                    HDRFTR_RIGHT
.ALIAS   FOOTER_RIGHT_PS                 HDRFTR_RIGHT_SIZE
.ALIAS   FOOTER_RIGHT_SIZE               HDRFTR_RIGHT_SIZE
.ALIAS   FOOTER_RULE_COLOR               HDRFTR_RULE_COLOR
.ALIAS   FOOTER_RULE_GAP                 HDRFTR_RULE_GAP
.ALIAS   FOOTER_RULE                     HDRFTR_RULE
.ALIAS   FOOTER_SIZE                     HDRFTR_SIZE
.ALIAS   FOOTER_VERSO                    HDRFTR_VERSO
.ALIAS   HEADER_CENTER_CAPS              HDRFTR_CENTER_CAPS
.ALIAS   HEADER_CENTER_COLOR             HDRFTR_CENTER_COLOR
.ALIAS   HEADER_CENTER_COLOUR            HDRFTR_CENTER_COLOUR
.ALIAS   HEADER_CENTER_FAM               HDRFTR_CENTER_FAMILY
.ALIAS   HEADER_CENTER_FAMILY            HDRFTR_CENTER_FAMILY
.ALIAS   HEADER_CENTER_FONT              HDRFTR_CENTER_FONT
.ALIAS   HEADER_CENTER_FT                HDRFTR_CENTER_FONT
.ALIAS   HEADER_CENTER                   HDRFTR_CENTER
.ALIAS   HEADER_CENTER_PAD               HDRFTR_CENTER_PAD
.ALIAS   HEADER_CENTER_PS                HDRFTR_CENTER_SIZE
.ALIAS   HEADER_CENTER_SIZE              HDRFTR_CENTER_SIZE
.ALIAS   HEADER_CENTRE_CAPS              HDRFTR_CENTER_CAPS
.ALIAS   HEADER_CENTRE_COLOR             HDRFTR_CENTRE_COLOR
.ALIAS   HEADER_CENTRE_COLOUR            HDRFTR_CENTRE_COLOUR
.ALIAS   HEADER_CENTRE_FAM               HDRFTR_CENTER_FAMILY
.ALIAS   HEADER_CENTRE_FAMILY            HDRFTR_CENTER_FAMILY
.ALIAS   HEADER_CENTRE_FONT              HDRFTR_CENTER_FONT
.ALIAS   HEADER_CENTRE_FT                HDRFTR_CENTER_FONT
.ALIAS   HEADER_CENTRE                   HDRFTR_CENTER
.ALIAS   HEADER_CENTRE_PAD               HDRFTR_CENTER_PAD
.ALIAS   HEADER_CENTRE_PS                HDRFTR_CENTER_SIZE
.ALIAS   HEADER_CENTRE_SIZE              HDRFTR_CENTER_SIZE
.ALIAS   HEADER_COLOR                    HDRFTR_COLOR
.ALIAS   HEADER_COLOUR                   HDRFTR_COLOR
.ALIAS   HEADER_FAM                      HDRFTR_FAMILY
.ALIAS   HEADER_FAMILY                   HDRFTR_FAMILY
.ALIAS   HEADER_LEFT_CAPS                HDRFTR_LEFT_CAPS
.ALIAS   HEADER_LEFT_COLOR               HDRFTR_LEFT_COLOR
.ALIAS   HEADER_LEFT_COLOUR              HDRFTR_LEFT_COLOUR
.ALIAS   HEADER_LEFT_FAM                 HDRFTR_LEFT_FAMILY
.ALIAS   HEADER_LEFT_FAMILY              HDRFTR_LEFT_FAMILY
.ALIAS   HEADER_LEFT_FONT                HDRFTR_LEFT_FONT
.ALIAS   HEADER_LEFT_FT                  HDRFTR_LEFT_FONT
.ALIAS   HEADER_LEFT                     HDRFTR_LEFT
.ALIAS   HEADER_LEFT_PS                  HDRFTR_LEFT_SIZE
.ALIAS   HEADER_LEFT_SIZE                HDRFTR_LEFT_SIZE
.ALIAS   HEADER_PLAIN                    HDRFTR_PLAIN
.ALIAS   HEADER_RECTO                    HDRFTR_RECTO
.ALIAS   HEADER_RIGHT_CAPS               HDRFTR_RIGHT_CAPS
.ALIAS   HEADER_RIGHT_COLOR              HDRFTR_RIGHT_COLOR
.ALIAS   HEADER_RIGHT_COLOUR             HDRFTR_RIGHT_COLOUR
.ALIAS   HEADER_RIGHT_FAM                HDRFTR_RIGHT_FAMILY
.ALIAS   HEADER_RIGHT_FAMILY             HDRFTR_RIGHT_FAMILY
.ALIAS   HEADER_RIGHT_FONT               HDRFTR_RIGHT_FONT
.ALIAS   HEADER_RIGHT_FT                 HDRFTR_RIGHT_FONT
.ALIAS   HEADER_RIGHT                    HDRFTR_RIGHT
.ALIAS   HEADER_RIGHT_PS                 HDRFTR_RIGHT_SIZE
.ALIAS   HEADER_RIGHT_SIZE               HDRFTR_RIGHT_SIZE
.ALIAS   HEADER_RULE_COLOR               HDRFTR_RULE_COLOR
.ALIAS   HEADER_RULE_GAP                 HDRFTR_RULE_GAP
.ALIAS   HEADER_RULE                     HDRFTR_RULE
.ALIAS   HEADER_SIZE                     HDRFTR_SIZE
.ALIAS   HEADER_VERSO                    HDRFTR_VERSO
.ALIAS   SWITCH_FOOTERS                  SWITCH_HDRFTR
.ALIAS   SWITCH_HEADERS                  SWITCH_HDRFTR
\#
\# Support aliases
\#
.ALIAS   COL_BREAK                       COL_NEXT
.ALIAS   PRINT_FOOTNOTE_RULE             FOOTNOTE_RULE
