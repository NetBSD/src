
                                   GCC Bugs

   The latest version of this document is always available at
   [1]http://gcc.gnu.org/bugs.html.
     _________________________________________________________________

Table of Contents

     * [2]Reporting Bugs
          + [3]What we need
          + [4]What we DON'T want
          + [5]Where to post it
          + [6]Detailed bug reporting instructions
          + [7]Detailed bug reporting instructions for GNAT
          + [8]Detailed bug reporting instructions when using a
            precompiled header
     * [9]Frequently Reported Bugs in GCC
          + [10]C++
               o [11]Missing features
               o [12]Bugs fixed in the 3.4 series
          + [13]Fortran
     * [14]Non-bugs
          + [15]General
          + [16]C
          + [17]C++
               o [18]Common problems when upgrading the compiler
     _________________________________________________________________

                                Reporting Bugs

   The main purpose of a bug report is to enable us to fix the bug. The
   most important prerequisite for this is that the report must be
   complete and self-contained, which we explain in detail below.

   Before you report a bug, please check the [19]list of well-known bugs
   and, if possible in any way, try a current development snapshot. If
   you want to report a bug with versions of GCC before 3.1 we strongly
   recommend upgrading to the current release first.

   Before reporting that GCC compiles your code incorrectly, please
   compile it with gcc -Wall and see whether this shows anything wrong
   with your code that could be the cause instead of a bug in GCC.

Summarized bug reporting instructions

   After this summary, you'll find detailed bug reporting instructions,
   that explain how to obtain some of the information requested in this
   summary.

  What we need

   Please include in your bug report all of the following items, the
   first three of which can be obtained from the output of gcc -v:
     * the exact version of GCC;
     * the system type;
     * the options given when GCC was configured/built;
     * the complete command line that triggers the bug;
     * the compiler output (error messages, warnings, etc.); and
     * the preprocessed file (*.i*) that triggers the bug, generated by
       adding -save-temps to the complete compilation command, or, in the
       case of a bug report for the GNAT front end, a complete set of
       source files (see below).

  What we do not want

     * A source file that #includes header files that are left out of the
       bug report (see above)
     * That source file and a collection of header files.
     * An attached archive (tar, zip, shar, whatever) containing all (or
       some :-) of the above.
     * A code snippet that won't cause the compiler to produce the exact
       output mentioned in the bug report (e.g., a snippet with just a
       few lines around the one that apparently triggers the bug, with
       some pieces replaced with ellipses or comments for extra
       obfuscation :-)
     * The location (URL) of the package that failed to build (we won't
       download it, anyway, since you've already given us what we need to
       duplicate the bug, haven't you? :-)
     * An error that occurs only some of the times a certain file is
       compiled, such that retrying a sufficient number of times results
       in a successful compilation; this is a symptom of a hardware
       problem, not of a compiler bug (sorry)
     * E-mail messages that complement previous, incomplete bug reports.
       Post a new, self-contained, full bug report instead, if possible
       as a follow-up to the original bug report
     * Assembly files (*.s) produced by the compiler, or any binary
       files, such as object files, executables, core files, or
       precompiled header files
     * Duplicate bug reports, or reports of bugs already fixed in the
       development tree, especially those that have already been reported
       as fixed last week :-)
     * Bugs in the assembler, the linker or the C library. These are
       separate projects, with separate mailing lists and different bug
       reporting procedures
     * Bugs in releases or snapshots of GCC not issued by the GNU
       Project. Report them to whoever provided you with the release
     * Questions about the correctness or the expected behavior of
       certain constructs that are not GCC extensions. Ask them in forums
       dedicated to the discussion of the programming language

  Where to post it

   Please submit your bug report directly to the [20]GCC bug database.
   Alternatively, you can use the gccbug script that mails your bug
   report to the bug database.
   Only if all this is absolutely impossible, mail all information to
   [21]gcc-bugs@gcc.gnu.org.

Detailed bug reporting instructions

   Please refer to the [22]next section when reporting bugs in GNAT, the
   Ada compiler, or to the [23]one after that when reporting bugs that
   appear when using a precompiled header.

   In general, all the information we need can be obtained by collecting
   the command line below, as well as its output and the preprocessed
   file it generates.

     gcc -v -save-temps all-your-options source-file

   Typically the preprocessed file (extension .i for C or .ii for C++,
   and .f if the preprocessor is used on Fortran files) will be large, so
   please compress the resulting file with one of the popular compression
   programs such as bzip2, gzip, zip or compress (in decreasing order of
   preference). Use maximum compression (-9) if available. Please include
   the compressed preprocessor output in your bug report, even if the
   source code is freely available elsewhere; it makes the job of our
   volunteer testers much easier.

   The only excuses to not send us the preprocessed sources are (i) if
   you've found a bug in the preprocessor, (ii) if you've reduced the
   testcase to a small file that doesn't include any other file or (iii)
   if the bug appears only when using precompiled headers. If you can't
   post the preprocessed sources because they're proprietary code, then
   try to create a small file that triggers the same problem.

   Since we're supposed to be able to re-create the assembly output
   (extension .s), you usually should not include it in the bug report,
   although you may want to post parts of it to point out assembly code
   you consider to be wrong.

   Whether to use MIME attachments or uuencode is up to you. In any case,
   make sure the compiler command line, version and error output are in
   plain text, so that we don't have to decode the bug report in order to
   tell who should take care of it. A meaningful subject indicating
   language and platform also helps.

   Please avoid posting an archive (.tar, .shar or .zip); we generally
   need just a single file to reproduce the bug (the .i/.ii/.f
   preprocessed file), and, by storing it in an archive, you're just
   making our volunteers' jobs harder. Only when your bug report requires
   multiple source files to be reproduced should you use an archive. This
   is, for example, the case if you are using INCLUDE directives in
   Fortran code, which are not processed by the preprocessor, but the
   compiler. In that case, we need the main file and all INCLUDEd files.
   In any case, make sure the compiler version, error message, etc, are
   included in the body of your bug report as plain text, even if
   needlessly duplicated as part of an archive.

   If you fail to supply enough information for a bug report to be
   reproduced, someone will probably ask you to post additional
   information (or just ignore your bug report, if they're in a bad day,
   so try to get it right on the first posting :-). In this case, please
   post the additional information to the bug reporting mailing list, not
   just to the person who requested it, unless explicitly told so. If
   possible, please include in this follow-up all the information you had
   supplied in the incomplete bug report (including the preprocessor
   output), so that the new bug report is self-contained.

Detailed bug reporting instructions for GNAT

   See the [24]previous section for bug reporting instructions for GCC
   language implementations other than Ada.

   Bug reports have to contain at least the following information in
   order to be useful:
     * the exact version of GCC, as shown by "gcc -v";
     * the system type;
     * the options when GCC was configured/built;
     * the exact command line passed to the gcc program triggering the
       bug (not just the flags passed to gnatmake, but gnatmake prints
       the parameters it passed to gcc)
     * a collection of source files for reproducing the bug, preferably a
       minimal set (see below);
     * a description of the expected behavior;
     * a description of actual behavior.

   If your code depends on additional source files (usually package
   specifications), submit the source code for these compilation units in
   a single file that is acceptable input to gnatchop, i.e. contains no
   non-Ada text. If the compilation terminated normally, you can usually
   obtain a list of dependencies using the "gnatls -d main_unit" command,
   where main_unit is the file name of the main compilation unit (which
   is also passed to gcc).

   If you report a bug which causes the compiler to print a bug box,
   include that bug box in your report, and do not forget to send all the
   source files listed after the bug box along with your report.

   If you use gnatprep, be sure to send in preprocessed sources (unless
   you have to report a bug in gnatprep).

   When you have checked that your report meets these criteria, please
   submit it according to our [25]generic instructions. (If you use a
   mailing list for reporting, please include an "[Ada]" tag in the
   subject.)

Detailed bug reporting instructions when using a precompiled header

   If you're encountering a bug when using a precompiled header, the
   first thing to do is to delete the precompiled header, and try running
   the same GCC command again. If the bug happens again, the bug doesn't
   really involve precompiled headers, please report it without using
   them by following the instructions [26]above.

   If you've found a bug while building a precompiled header (for
   instance, the compiler crashes), follow the usual instructions
   [27]above.

   If you've found a real precompiled header bug, what we'll need to
   reproduce it is the sources to build the precompiled header (as a
   single .i file), the source file that uses the precompiled header, any
   other headers that source file includes, and the command lines that
   you used to build the precompiled header and to use it.

   Please don't send us the actual precompiled header. It is likely to be
   very large and we can't use it to reproduce the problem.
     _________________________________________________________________

                        Frequently Reported Bugs in GCC

   This is a list of bugs in GCC that are reported very often, but not
   yet fixed. While it is certainly better to fix bugs instead of
   documenting them, this document might save people the effort of
   writing a bug report when the bug is already well-known.

   There are many reasons why a reported bug doesn't get fixed. It might
   be difficult to fix, or fixing it might break compatibility. Often,
   reports get a low priority when there is a simple work-around. In
   particular, bugs caused by invalid code have a simple work-around: fix
   the code.
     _________________________________________________________________

C++

  Missing features

   The export keyword is not implemented.
          Most C++ compilers (G++ included) do not yet implement export,
          which is necessary for separate compilation of template
          declarations and definitions. Without export, a template
          definition must be in scope to be used. The obvious workaround
          is simply to place all definitions in the header itself.
          Alternatively, the compilation unit containing template
          definitions may be included from the header.

  Bugs fixed in the 3.4 series

   The following bugs are present up to (and including) GCC 3.3.x. They
   have been fixed in 3.4.0.

   Two-stage name-lookup.
          GCC did not implement two-stage name-lookup (also see
          [28]below).

   Covariant return types.
          GCC did not implement non-trivial covariant returns.

   Parse errors for "simple" code.
          GCC gave parse errors for seemingly simple code, such as

struct A
{
  A();
  A(int);
};

struct B
{
  B(A);
  B(A,A);
  void foo();
};

A bar()
{
  B b(A(),A(1));  // Variable b, initialized with two temporaries
  B(A(2)).foo();  // B temporary, initialized with A temporary
  return (A());   // return A temporary
}

          Although being valid code, each of the three lines with a
          comment was rejected by GCC. The work-arounds for older
          compiler versions proposed below do not change the semantics of
          the programs at all.

          The problem in the first case was that GCC started to parse the
          declaration of b as a function called b returning B, taking a
          function returning A as an argument. When it encountered the 1,
          it was too late. To show the compiler that this should be
          really an expression, a comma operator with a dummy argument
          could be used:

B b((0,A()),A(1));

          The work-around for simpler cases like the second one was to
          add additional parentheses around the expressions that were
          mistaken as declarations:

(B(A(2))).foo();

          In the third case, however, additional parentheses were causing
          the problems: The compiler interpreted A() as a function
          (taking no arguments, returning A), and (A()) as a cast lacking
          an expression to be casted, hence the parse error. The
          work-around was to omit the parentheses:

return A();

          This problem occurred in a number of variants; in throw
          statements, people also frequently put the object in
          parentheses.
     _________________________________________________________________

Fortran

   Fortran bugs are documented in the G77 manual rather than explicitly
   listed here. Please see [29]Known Causes of Trouble with GNU Fortran
   in the G77 manual.
     _________________________________________________________________

                                   Non-bugs

   The following are not actually bugs, but are reported often enough to
   warrant a mention here.

   It is not always a bug in the compiler, if code which "worked" in a
   previous version, is now rejected. Earlier versions of GCC sometimes
   were less picky about standard conformance and accepted invalid source
   code. In addition, programming languages themselves change, rendering
   code invalid that used to be conforming (this holds especially for
   C++). In either case, you should update your code to match recent
   language standards.
     _________________________________________________________________

General

   Problems with floating point numbers - the [30]most often reported
          non-bug.
          In a number of cases, GCC appears to perform floating point
          computations incorrectly. For example, the C++ program

#include <iostream>

int main()
{
  double a = 0.5;
  double b = 0.01;
  std::cout << (int)(a / b) << std::endl;
  return 0;
}

          might print 50 on some systems and optimization levels, and 49
          on others.

          This is the result of rounding: The computer cannot represent
          all real numbers exactly, so it has to use approximations. When
          computing with approximation, the computer needs to round to
          the nearest representable number.

          This is not a bug in the compiler, but an inherent limitation
          of the floating point types. Please study [31]this paper for
          more information.
     _________________________________________________________________

C

   Increment/decrement operator (++/--) not working as expected - a
          [32]problem with many variations.
          The following expressions have unpredictable results:

x[i]=++i
foo(i,++i)
i*(++i)                 /* special case with foo=="operator*" */
std::cout << i << ++i   /* foo(foo(std::cout,i),++i)          */

          since the i without increment can be evaluated before or after
          ++i.

          The C and C++ standards have the notion of "sequence points".
          Everything that happens between two sequence points happens in
          an unspecified order, but it has to happen after the first and
          before the second sequence point. The end of a statement and a
          function call are examples for sequence points, whereas
          assignments and the comma between function arguments are not.

          Modifying a value twice between two sequence points as shown in
          the following examples is even worse:

i=++i
foo(++i,++i)
(++i)*(++i)               /* special case with foo=="operator*" */
std::cout << ++i << ++i   /* foo(foo(std::cout,++i),++i)        */

          This leads to undefined behavior (i.e. the compiler can do
          anything).

   Casting does not work as expected when optimization is turned on.
          This is often caused by a violation of aliasing rules, which
          are part of the ISO C standard. These rules say that a program
          is invalid if you try to access a variable through a pointer of
          an incompatible type. This is happening in the following
          example where a short is accessed through a pointer to integer
          (the code assumes 16-bit shorts and 32-bit ints):

#include <stdio.h>

int main()
{
  short a[2];

  a[0]=0x1111;
  a[1]=0x1111;

  *(int *)a = 0x22222222; /* violation of aliasing rules */

  printf("%x %x\n", a[0], a[1]);
  return 0;
}

          The aliasing rules were designed to allow compilers more
          aggressive optimization. Basically, a compiler can assume that
          all changes to variables happen through pointers or references
          to variables of a type compatible to the accessed variable.
          Dereferencing a pointer that violates the aliasing rules
          results in undefined behavior.

          In the case above, the compiler may assume that no access
          through an integer pointer can change the array a, consisting
          of shorts. Thus, printf may be called with the original values
          of a[0] and a[1]. What really happens is up to the compiler and
          may change with architecture and optimization level.

          Recent versions of GCC turn on the option -fstrict-aliasing
          (which allows alias-based optimizations) by default with -O2.
          And some architectures then really print "1111 1111" as result.
          Without optimization the executable will generate the
          "expected" output "2222 2222".

          To disable optimizations based on alias-analysis for faulty
          legacy code, the option -fno-strict-aliasing can be used as a
          work-around.

          The option -Wstrict-aliasing (which is included in -Wall) warns
          about some - but not all - cases of violation of aliasing rules
          when -fstrict-aliasing is active.

          To fix the code above, you can use a union instead of a cast
          (note that this is a GCC extension which might not work with
          other compilers):

#include <stdio.h>

int main()
{
  union
  {
    short a[2];
    int i;
  } u;

  u.a[0]=0x1111;
  u.a[1]=0x1111;

  u.i = 0x22222222;

  printf("%x %x\n", u.a[0], u.a[1]);
  return 0;
}

          Now the result will always be "2222 2222".

          For some more insight into the subject, please have a look at
          [33]this article.

   Cannot use preprocessor directive in macro arguments.
          Let me guess... you used an older version of GCC to compile
          code that looks something like this:

  memcpy(dest, src,
#ifdef PLATFORM1
         12
#else
         24
#endif
        );

          and you got a whole pile of error messages:

test.c:11: warning: preprocessing directive not recognized within macro arg
test.c:11: warning: preprocessing directive not recognized within macro arg
test.c:11: warning: preprocessing directive not recognized within macro arg
test.c: In function `foo':
test.c:6: undefined or invalid # directive
test.c:8: undefined or invalid # directive
test.c:9: parse error before `24'
test.c:10: undefined or invalid # directive

          This is because your C library's <string.h> happens to define
          memcpy as a macro - which is perfectly legitimate. In recent
          versions of glibc, for example, printf is among those functions
          which are implemented as macros.

          Versions of GCC prior to 3.3 did not allow you to put #ifdef
          (or any other preprocessor directive) inside the arguments of a
          macro. The code therefore would not compile.

          As of GCC 3.3 this kind of construct is always accepted and the
          preprocessor will probably do what you expect, but see the
          manual for detailed semantics.

          However, this kind of code is not portable. It is "undefined
          behavior" according to the C standard; that means different
          compilers may do different things with it. It is always
          possible to rewrite code which uses conditionals inside macros
          so that it doesn't. You could write the above example

#ifdef PLATFORM1
   memcpy(dest, src, 12);
#else
   memcpy(dest, src, 24);
#endif

          This is a bit more typing, but I personally think it's better
          style in addition to being more portable.

   Cannot initialize a static variable with stdin.
          This has nothing to do with GCC, but people ask us about it a
          lot. Code like this:

#include <stdio.h>

FILE *yyin = stdin;

          will not compile with GNU libc, because stdin is not a
          constant. This was done deliberately, to make it easier to
          maintain binary compatibility when the type FILE needs to be
          changed. It is surprising for people used to traditional Unix C
          libraries, but it is permitted by the C standard.

          This construct commonly occurs in code generated by old
          versions of lex or yacc. We suggest you try regenerating the
          parser with a current version of flex or bison, respectively.
          In your own code, the appropriate fix is to move the
          initialization to the beginning of main.

          There is a common misconception that the GCC developers are
          responsible for GNU libc. These are in fact two entirely
          separate projects; please check the [34]GNU libc web pages for
          details.
     _________________________________________________________________

C++

   Nested classes can access private members and types of the containing
          class.
          Defect report 45 clarifies that nested classes are members of
          the class they are nested in, and so are granted access to
          private members of that class.

   G++ emits two copies of constructors and destructors.
          In general there are three types of constructors (and
          destructors).

         1. The complete object constructor/destructor.
         2. The base object constructor/destructor.
         3. The allocating constructor/deallocating destructor.

          The first two are different, when virtual base classes are
          involved.

   Global destructors are not run in the correct order.
          Global destructors should be run in the reverse order of their
          constructors completing. In most cases this is the same as the
          reverse order of constructors starting, but sometimes it is
          different, and that is important. You need to compile and link
          your programs with --use-cxa-atexit. We have not turned this
          switch on by default, as it requires a cxa aware runtime
          library (libc, glibc, or equivalent).

   Classes in exception specifiers must be complete types.
          [15.4]/1 tells you that you cannot have an incomplete type, or
          pointer to incomplete (other than cv void *) in an exception
          specification.

   Exceptions don't work in multithreaded applications.
          You need to rebuild g++ and libstdc++ with --enable-threads.
          Remember, C++ exceptions are not like hardware interrupts. You
          cannot throw an exception in one thread and catch it in
          another. You cannot throw an exception from a signal handler
          and catch it in the main thread.

   Templates, scoping, and digraphs.
          If you have a class in the global namespace, say named X, and
          want to give it as a template argument to some other class, say
          std::vector, then std::vector<::X> fails with a parser error.

          The reason is that the standard mandates that the sequence <:
          is treated as if it were the token [. (There are several such
          combinations of characters - they are called digraphs.)
          Depending on the version, the compiler then reports a parse
          error before the character : (the colon before X) or a missing
          closing bracket ].

          The simplest way to avoid this is to write std::vector< ::X>,
          i.e. place a space between the opening angle bracket and the
          scope operator.

   Copy constructor access check while initializing a reference.
          Consider this code:

class A
{
public:
  A();

private:
  A(const A&);   // private copy ctor
};

A makeA(void);
void foo(const A&);

void bar(void)
{
  foo(A());       // error, copy ctor is not accessible
  foo(makeA());   // error, copy ctor is not accessible

  A a1;
  foo(a1);        // OK, a1 is a lvalue
}

          Starting with GCC 3.4.0, binding an rvalue to a const reference
          requires an accessible copy constructor. This might be
          surprising at first sight, especially since most popular
          compilers do not correctly implement this rule.

          The C++ Standard says that a temporary object should be created
          in this context and its contents filled with a copy of the
          object we are trying to bind to the reference; it also says
          that the temporary copy can be elided, but the semantic
          constraints (eg. accessibility) of the copy constructor still
          have to be checked.

          For further information, you can consult the following
          paragraphs of the C++ standard: [dcl.init.ref]/5, bullet 2,
          sub-bullet 1, and [class.temporary]/2.

  Common problems when upgrading the compiler

    ABI changes

   The C++ application binary interface (ABI) consists of two components:
   the first defines how the elements of classes are laid out, how
   functions are called, how function names are mangled, etc; the second
   part deals with the internals of the objects in libstdc++. Although we
   strive for a non-changing ABI, so far we have had to modify it with
   each major release. If you change your compiler to a different major
   release you must recompile all libraries that contain C++ code. If you
   fail to do so you risk getting linker errors or malfunctioning
   programs. Some of our Java support libraries also contain C++ code, so
   you might want to recompile all libraries to be safe. It should not be
   necessary to recompile if you have changed to a bug-fix release of the
   same version of the compiler; bug-fix releases are careful to avoid
   ABI changes. See also the [35]compatibility section of the GCC manual.

   Remark: A major release is designated by a change to the first or
   second component of the two- or three-part version number. A minor
   (bug-fix) release is designated by a change to the third component
   only. Thus GCC 3.2 and 3.3 are major releases, while 3.3.1 and 3.3.2
   are bug-fix releases for GCC 3.3. With the 3.4 series we are
   introducing a new naming scheme; the first release of this series is
   3.4.0 instead of just 3.4.

    Standard conformance

   With each release, we try to make G++ conform closer to the ISO C++
   standard (available at [36]http://www.ncits.org/cplusplus.htm). We
   have also implemented some of the core and library defect reports
   (available at
   [37]http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html &
   [38]http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html
   respectively).

   Non-conforming legacy code that worked with older versions of GCC may
   be rejected by more recent compilers. There is no command-line switch
   to ensure compatibility in general, because trying to parse
   standard-conforming and old-style code at the same time would render
   the C++ frontend unmaintainable. However, some non-conforming
   constructs are allowed when the command-line option -fpermissive is
   used.

   Two milestones in standard conformance are GCC 3.0 (including a major
   overhaul of the standard library) and the 3.4.0 version (with its new
   C++ parser).

    New in GCC 3.0

     * The standard library is much more conformant, and uses the std::
       namespace (which is now a real namespace, not an alias for ::).
     * The standard header files for the c library don't end with .h, but
       begin with c (i.e. <cstdlib> rather than <stdlib.h>). The .h names
       are still available, but are deprecated.
     * <strstream> is deprecated, use <sstream> instead.
     * streambuf::seekoff & streambuf::seekpos are private, instead use
       streambuf::pubseekoff & streambuf::pubseekpos respectively.
     * If std::operator << (std::ostream &, long long) doesn't exist, you
       need to recompile libstdc++ with --enable-long-long.

   If you get lots of errors about things like cout not being found,
   you've most likely forgotten to tell the compiler to look in the std::
   namespace. There are several ways to do this:
     * Say std::cout at the call. This is the most explicit way of saying
       what you mean.
     * Say using std::cout; somewhere before the call. You will need to
       do this for each function or type you wish to use from the
       standard library.
     * Say using namespace std; somewhere before the call. This is the
       quick-but-dirty fix. This brings the whole of the std:: namespace
       into scope. Never do this in a header file, as every user of your
       header file will be affected by this decision.

    New in GCC 3.4.0

   The new parser brings a lot of improvements, especially concerning
   name-lookup.
     * The "implicit typename" extension got removed (it was already
       deprecated since GCC 3.1), so that the following code is now
       rejected, see [14.6]:

template <typename> struct A
{
    typedef int X;
};

template <typename T> struct B
{
    A<T>::X          x;  // error
    typename A<T>::X y;  // OK
};

B<void> b;

     * For similar reasons, the following code now requires the template
       keyword, see [14.2]:

template <typename> struct A
{
    template <int> struct X {};
};

template <typename T> struct B
{
    typename A<T>::X<0>          x;  // error
    typename A<T>::template X<0> y;  // OK
};

B<void> b;

     * We now have two-stage name-lookup, so that the following code is
       rejected, see [14.6]/9:

template <typename T> int foo()
{
    return i;  // error
}

     * This also affects members of base classes, see [14.6.2]:

template <typename> struct A
{
    int i, j;
};

template <typename T> struct B : A<T>
{
    int foo1() { return i; }       // error
    int foo2() { return this->i; } // OK
    int foo3() { return B<T>::i; } // OK
    int foo4() { return A<T>::i; } // OK

    using A<T>::j;
    int foo5() { return j; }       // OK
};

   In addition to the problems listed above, the manual contains a
   section on [39]Common Misunderstandings with GNU C++.

References

   1. http://gcc.gnu.org/bugs.html
   2. http://gcc.gnu.org/bugs.html#report
   3. http://gcc.gnu.org/bugs.html#need
   4. http://gcc.gnu.org/bugs.html#dontwant
   5. http://gcc.gnu.org/bugs.html#where
   6. http://gcc.gnu.org/bugs.html#detailed
   7. http://gcc.gnu.org/bugs.html#gnat
   8. http://gcc.gnu.org/bugs.html#pch
   9. http://gcc.gnu.org/bugs.html#known
  10. http://gcc.gnu.org/bugs.html#cxx
  11. http://gcc.gnu.org/bugs.html#missing
  12. http://gcc.gnu.org/bugs.html#fixed34
  13. http://gcc.gnu.org/bugs.html#fortran
  14. http://gcc.gnu.org/bugs.html#nonbugs
  15. http://gcc.gnu.org/bugs.html#nonbugs_general
  16. http://gcc.gnu.org/bugs.html#nonbugs_c
  17. http://gcc.gnu.org/bugs.html#nonbugs_cxx
  18. http://gcc.gnu.org/bugs.html#upgrading
  19. http://gcc.gnu.org/bugs.html#known
  20. http://gcc.gnu.org/bugzilla/
  21. mailto:gcc-bugs@gcc.gnu.org
  22. http://gcc.gnu.org/bugs.html#gnat
  23. http://gcc.gnu.org/bugs.html#pch
  24. http://gcc.gnu.org/bugs.html#detailed
  25. http://gcc.gnu.org/bugs.html#where
  26. http://gcc.gnu.org/bugs.html#detailed
  27. http://gcc.gnu.org/bugs.html#detailed
  28. http://gcc.gnu.org/bugs.html#new34
  29. http://gcc.gnu.org/onlinedocs/g77/Trouble.html
  30. http://gcc.gnu.org/PR323
  31. http://www.validlab.com/goldberg/paper.ps
  32. http://gcc.gnu.org/PR11751
  33. http://mail-index.NetBSD.org/tech-kern/2003/08/11/0001.html
  34. http://www.gnu.org/software/libc/
  35. http://gcc.gnu.org/onlinedocs/gcc/Compatibility.html
  36. http://www.ncits.org/cplusplus.htm
  37. http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html
  38. http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html
  39. http://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Misunderstandings.html
