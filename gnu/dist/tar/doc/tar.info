This is tar.info, produced by makeinfo version 4.0 from tar.texi.

INFO-DIR-SECTION GNU Packages
START-INFO-DIR-ENTRY
* Tar: (tar).			Making tape (or disk) archives.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* tar: (tar)tar invocation.                     Invoking GNU `tar'
END-INFO-DIR-ENTRY

   This file documents GNU `tar', which creates and extracts files from
archives.

   Copyright 1992, 1994, 1995, 1996, 1997, 1999, 2000, 2001 Free
Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled "GNU
Free Documentation License".


File: tar.info,  Node: Top,  Next: Introduction,  Up: (dir)

GNU tar: an archiver tool
*************************

   GNU `tar' creates and extracts files from archives.

   This manual documents version 1.13.24 of GNU `tar'.

   The first part of this master menu lists the major nodes in this Info
document.  The rest of the menu lists all the lower level nodes.

* Menu:

* Introduction::
* Tutorial::
* tar invocation::
* operations::
* Backups::
* Choosing::
* Date input formats::
* Formats::
* Media::
* Free Software Needs Free Documentation::
* Copying This Manual::
* Index::

 --- The Detailed Node Listing ---

Introduction

* Book Contents::               What this Book Contains
* Definitions::                 Some Definitions
* What tar Does::               What `tar' Does
* Naming tar Archives::         How `tar' Archives are Named
* posix compliance::
* Authors::                     GNU `tar' Authors
* Reports::                     Reporting bugs or suggestions

Tutorial Introduction to `tar'

* assumptions::
* stylistic conventions::
* basic tar options::           Basic `tar' Operations and Options
* frequent operations::
* Two Frequent Options::
* create::                      How to Create Archives
* list::                        How to List Archives
* extract::                     How to Extract Members from an Archive
* going further::

Two Frequently Used Options

* file tutorial::
* verbose tutorial::
* help tutorial::

How to Create Archives

* prepare for examples::
* Creating the archive::
* create verbose::
* short create::
* create dir::

How to List Archives

* list dir::

How to Extract Members from an Archive

* extracting archives::
* extracting files::
* extract dir::
* failing commands::

Invoking GNU `tar'

* Synopsis::
* using tar options::
* Styles::
* All Options::
* help::
* verbose::
* interactive::

The Three Option Styles

* Mnemonic Options::            Mnemonic Option Style
* Short Options::               Short Option Style
* Old Options::                 Old Option Style
* Mixing::                      Mixing Option Styles

All `tar' Options

* Operation Summary::
* Option Summary::
* Short Option Summary::

GNU `tar' Operations

* Basic tar::
* Advanced tar::
* create options::
* extract options::
* backup::
* Applications::
* looking ahead::

Advanced GNU `tar' Operations

* Operations::
* current state::
* append::
* update::
* concatenate::
* delete::
* compare::

How to Add Files to Existing Archives: `--append'

* appending files::             Appending Files to an Archive
* multiple::

Updating an Archive

* how to update::

Options Used by `--create'

* Ignore Failed Read::

Options Used by `--extract'

* Reading::                     Options to Help Read Archives
* Writing::                     Changing How `tar' Writes Files
* Scarce::                      Coping with Scarce Resources

Options to Help Read Archives

* read full records::
* Ignore Zeros::

Changing How `tar' Writes Files

* Dealing with Old Files::
* Overwrite Old Files::
* Keep Old Files::
* Unlink First::
* Recursive Unlink::
* Modification Times::
* Setting Access Permissions::
* Writing to Standard Output::
* remove files::

Coping with Scarce Resources

* Starting File::
* Same Order::

Performing Backups and Restoring Files

* Full Dumps::                  Using `tar' to Perform Full Dumps
* Inc Dumps::                   Using `tar' to Perform Incremental Dumps
* incremental and listed-incremental::  The Incremental Options
* Backup Levels::               Levels of Backups
* Backup Parameters::           Setting Parameters for Backups and Restoration
* Scripted Backups::            Using the Backup Scripts
* Scripted Restoration::        Using the Restore Script

Setting Parameters for Backups and Restoration

* backup-specs example::        An Example Text of `Backup-specs'
* Script Syntax::               Syntax for `Backup-specs'

Choosing Files and Names for `tar'

* file::                        Choosing the Archive's Name
* Selecting Archive Members::
* files::                       Reading Names from a File
* exclude::                     Excluding Some Files
* Wildcards::
* after::                       Operating Only on New Files
* recurse::                     Descending into Directories
* one::                         Crossing Filesystem Boundaries

Reading Names from a File

* nul::

Excluding Some Files

* controlling pattern-patching with exclude::
* problems with exclude::

Crossing Filesystem Boundaries

* directory::                   Changing Directory
* absolute::                    Absolute File Names

Date input formats

* General date syntax::            Common rules.
* Calendar date items::            19 Dec 1994.
* Time of day items::              9:20pm.
* Time zone items::                EST, PDT, GMT, ...
* Day of week items::              Monday and others.
* Relative items in date strings:: next tuesday, 2 years ago.
* Pure numbers in date strings::   19931219, 1440.
* Authors of getdate::             Bellovin, Eggert, Salz, Berets, et al.

Controlling the Archive Format

* Portability::                 Making `tar' Archives More Portable
* Compression::                 Using Less Space through Compression
* Attributes::                  Handling File Attributes
* Standard::                    The Standard Format
* Extensions::                  GNU Extensions to the Archive Format
* cpio::                        Comparison of `tar' and `cpio'

Making `tar' Archives More Portable

* Portable Names::              Portable Names
* dereference::                 Symbolic Links
* old::                         Old V7 Archives
* posix::                       POSIX archives
* Checksumming::                Checksumming Problems
* Large or Negative Values::    Large files, negative time stamps, etc.

Using Less Space through Compression

* gzip::                        Creating and Reading Compressed Archives
* sparse::                      Archiving Sparse Files

Tapes and Other Archive Media

* Device::                      Device selection and switching
* Remote Tape Server::
* Common Problems and Solutions::
* Blocking::                    Blocking
* Many::                        Many archives on one tape
* Using Multiple Tapes::        Using Multiple Tapes
* label::                       Including a Label in the Archive
* verify::
* Write Protection::

Blocking

* Format Variations::           Format Variations
* Blocking Factor::             The Blocking Factor of an Archive

Many Archives on One Tape

* Tape Positioning::            Tape Positions and Tape Marks
* mt::                          The `mt' Utility

Using Multiple Tapes

* Multi-Volume Archives::       Archives Longer than One Tape or Disk
* Tape Files::                  Tape Files

Copying This Manual

* GNU Free Documentation License::  License for copying this manual


File: tar.info,  Node: Introduction,  Next: Tutorial,  Prev: Top,  Up: Top

Introduction
************

   Welcome to the GNU `tar' manual.  GNU `tar' creates and manipulates
("archives") which are actually collections of many other files; the
program provides users with an organized and systematic method for
controlling a large amount of data.

* Menu:

* Book Contents::               What this Book Contains
* Definitions::                 Some Definitions
* What tar Does::               What `tar' Does
* Naming tar Archives::         How `tar' Archives are Named
* posix compliance::
* Authors::                     GNU `tar' Authors
* Reports::                     Reporting bugs or suggestions


File: tar.info,  Node: Book Contents,  Next: Definitions,  Up: Introduction

What this Book Contains
=======================

   The first part of this chapter introduces you to various terms that
will recur throughout the book.  It also tells you who has worked on GNU
`tar' and its documentation, and where you should send bug reports or
comments.

   The second chapter is a tutorial (*note Tutorial::) which provides a
gentle introduction for people who are new to using `tar'.  It is meant
to be self contained, not requiring any reading from subsequent
chapters to make sense.  It moves from topic to topic in a logical,
progressive order, building on information already explained.

   Although the tutorial is paced and structured to allow beginners to
learn how to use `tar', it is not intended solely for beginners.  The
tutorial explains how to use the three most frequently used operations
(`create', `list', and `extract') as well as two frequently used
options (`file' and `verbose').  The other chapters do not refer to the
tutorial frequently; however, if a section discusses something which is
a complex variant of a basic concept, there may be a cross reference to
that basic concept.  (The entire book, including the tutorial, assumes
that the reader understands some basic concepts of using a Unix-type
operating system; *note Tutorial::.)

   The third chapter presents the remaining five operations, and
information about using `tar' options and option syntax.

   The other chapters are meant to be used as a reference.  Each
chapter presents everything that needs to be said about a specific
topic.

   One of the chapters (*note Date input formats::) exists in its
entirety in other GNU manuals, and is mostly self-contained.  In
addition, one section of this manual (*note Standard::) contains a big
quote which is taken directly from `tar' sources.

   In general, we give both the long and short (abbreviated) option
names at least once in each section where the relevant option is
covered, so that novice readers will become familiar with both styles.
(A few options have no short versions, and the relevant sections will
indicate this.)


File: tar.info,  Node: Definitions,  Next: What tar Does,  Prev: Book Contents,  Up: Introduction

Some Definitions
================

   The `tar' program is used to create and manipulate `tar' archives.
An "archive" is a single file which contains the contents of many
files, while still identifying the names of the files, their owner(s),
and so forth.  (In addition, archives record access permissions, user
and group, size in bytes, and last modification time.  Some archives
also record the file names in each archived directory, as well as other
file and directory information.)  You can use `tar' to "create" a new
archive in a specified directory.

   The files inside an archive are called "members".  Within this
manual, we use the term "file" to refer only to files accessible in the
normal ways (by `ls', `cat', and so forth), and the term "member" to
refer only to the members of an archive.  Similarly, a "file name" is
the name of a file, as it resides in the filesystem, and a "member
name" is the name of an archive member within the archive.

   The term "extraction" refers to the process of copying an archive
member (or multiple members) into a file in the filesystem.  Extracting
all the members of an archive is often called "extracting the archive".
The term "unpack" can also be used to refer to the extraction of many
or all the members of an archive.  Extracting an archive does not
destroy the archive's structure, just as creating an archive does not
destroy the copies of the files that exist outside of the archive.  You
may also "list" the members in a given archive (this is often thought
of as "printing" them to the standard output, or the command line), or
"append" members to a pre-existing archive.  All of these operations
can be performed using `tar'.


File: tar.info,  Node: What tar Does,  Next: Naming tar Archives,  Prev: Definitions,  Up: Introduction

What `tar' Does
===============

   The `tar' program provides the ability to create `tar' archives, as
well as various other kinds of manipulation.  For example, you can use
`tar' on previously created archives to extract files, to store
additional files, or to update or list files which were already stored.

   Initially, `tar' archives were used to store files conveniently on
magnetic tape.  The name `tar' comes from this use; it stands for
`t'ape `ar'chiver.  Despite the utility's name, `tar' can direct its
output to available devices, files, or other programs (using pipes).
`tar' may even access remote devices or files (as archives).

   You can use `tar' archives in many ways.  We want to stress a few of
them: storage, backup, and transportation.

Storage
     Often, `tar' archives are used to store related files for
     convenient file transfer over a network.  For example, the GNU
     Project distributes its software bundled into `tar' archives, so
     that all the files relating to a particular program (or set of
     related programs) can be transferred as a single unit.

     A magnetic tape can store several files in sequence.  However, the
     tape has no names for these files; it only knows their relative
     position on the tape.  One way to store several files on one tape
     and retain their names is by creating a `tar' archive.  Even when
     the basic transfer mechanism can keep track of names, as FTP can,
     the nuisance of handling multiple files, directories, and multiple
     links makes `tar' archives useful.

     Archive files are also used for long-term storage.  You can think
     of this as transportation from the present into the future.  (It
     is a science-fiction idiom that you can move through time as well
     as in space; the idea here is that `tar' can be used to move
     archives in all dimensions, even time!)

Backup
     Because the archive created by `tar' is capable of preserving file
     information and directory structure, `tar' is commonly used for
     performing full and incremental backups of disks.  A backup puts a
     collection of files (possibly pertaining to many users and
     projects) together on a disk or a tape.  This guards against
     accidental destruction of the information in those files.  GNU
     `tar' has special features that allow it to be used to make
     incremental and full dumps of all the files in a filesystem.

Transportation
     You can create an archive on one system, transfer it to another
     system, and extract the contents there.  This allows you to
     transport a group of files from one system to another.


File: tar.info,  Node: Naming tar Archives,  Next: posix compliance,  Prev: What tar Does,  Up: Introduction

How `tar' Archives are Named
============================

   Conventionally, `tar' archives are given names ending with `.tar'.
This is not necessary for `tar' to operate properly, but this manual
follows that convention in order to accustom readers to it and to make
examples more clear.

   Often, people refer to `tar' archives as "`tar' files," and archive
members as "files" or "entries".  For people familiar with the
operation of `tar', this causes no difficulty.  However, in this
manual, we consistently refer to "archives" and "archive members" to
make learning to use `tar' easier for novice users.


File: tar.info,  Node: posix compliance,  Next: Authors,  Prev: Naming tar Archives,  Up: Introduction

POSIX Compliance
================

We make some of our recommendations throughout this book for one reason
in addition to what we think of as "good sense".  The main additional
reason for a recommendation is to be compliant with the POSIX
standards.  If you set the shell environment variable
`POSIXLY_CORRECT', GNU `tar' will force you to adhere to these
standards.  Therefore, if this variable is set and you violate one of
the POSIX standards in the way you phrase a command, for example, GNU
`tar' will not allow the command and will signal an error message.  You
would then have to reorder the options or rephrase the command to
comply with the POSIX standards.

   There is a chance in the future that, if you set this environment
variable, your archives will be forced to comply with POSIX standards,
also.  No GNU `tar' extensions will be allowed.


File: tar.info,  Node: Authors,  Next: Reports,  Prev: posix compliance,  Up: Introduction

GNU `tar' Authors
=================

   GNU `tar' was originally written by John Gilmore, and modified by
many people.  The GNU enhancements were written by Jay Fenlason, then
Joy Kendall, and the whole package has been further maintained by
Thomas Bushnell, n/BSG, and finally Franc,ois Pinard, with the help of
numerous and kind users.

   We wish to stress that `tar' is a collective work, and owes much to
all those people who reported problems, offered solutions and other
insights, or shared their thoughts and suggestions.  An impressive, yet
partial list of those contributors can be found in the `THANKS' file
from the GNU `tar' distribution.

   Jay Fenlason put together a draft of a GNU `tar' manual, borrowing
notes from the original man page from John Gilmore.  This was withdrawn
in version 1.11.  Thomas Bushnell, n/BSG and Amy Gorin worked on a
tutorial and manual for GNU `tar'.  Franc,ois Pinard put version 1.11.8
of the manual together by taking information from all these sources and
merging them.  Melissa Weisshaus finally edited and redesigned the book
to create version 1.12.

   For version 1.12, Daniel Hagerty contributed a great deal of
technical consulting.  In particular, he is the primary author of *Note
Backups::.


File: tar.info,  Node: Reports,  Prev: Authors,  Up: Introduction

Reporting bugs or suggestions
=============================

   If you find problems or have suggestions about this program or
manual, please report them to `bug-tar@gnu.org'.


File: tar.info,  Node: Tutorial,  Next: tar invocation,  Prev: Introduction,  Up: Top

Tutorial Introduction to `tar'
******************************

   This chapter guides you through some basic examples of three `tar'
operations: `--create', `--list', and `--extract'.  If you already know
how to use some other version of `tar', then you may not need to read
this chapter.  This chapter omits most complicated details about how
`tar' works.

* Menu:

* assumptions::
* stylistic conventions::
* basic tar options::           Basic `tar' Operations and Options
* frequent operations::
* Two Frequent Options::
* create::                      How to Create Archives
* list::                        How to List Archives
* extract::                     How to Extract Members from an Archive
* going further::


File: tar.info,  Node: assumptions,  Next: stylistic conventions,  Up: Tutorial

Assumptions this Tutorial Makes
===============================

   This chapter is paced to allow beginners to learn about `tar'
slowly.  At the same time, we will try to cover all the basic aspects of
these three operations.  In order to accomplish both of these tasks, we
have made certain assumptions about your knowledge before reading this
manual, and the hardware you will be using:

   * Before you start to work through this tutorial, you should
     understand what the terms "archive" and "archive member" mean
     (*note Definitions::).  In addition, you should understand
     something about how Unix-type operating systems work, and you
     should know how to use some basic utilities.  For example, you
     should know how to create, list, copy, rename, edit, and delete
     files and directories; how to change between directories; and how
     to figure out where you are in the filesystem.  You should have
     some basic understanding of directory structure and how files are
     named according to which directory they are in.  You should
     understand concepts such as standard output and standard input,
     what various definitions of the term "argument" mean, and the
     differences between relative and absolute path names.

   * This manual assumes that you are working from your own home
     directory (unless we state otherwise).  In this tutorial, you will
     create a directory to practice `tar' commands in.  When we show
     path names, we will assume that those paths are relative to your
     home directory.  For example, my home directory path is
     `/home/fsf/melissa'.  All of my examples are in a subdirectory of
     the directory named by that path name; the subdirectory is called
     `practice'.

   * In general, we show examples of archives which exist on (or can be
     written to, or worked with from) a directory on a hard disk.  In
     most cases, you could write those archives to, or work with them
     on any other device, such as a tape drive.  However, some of the
     later examples in the tutorial and next chapter will not work on
     tape drives.  Additionally, working with tapes is much more
     complicated than working with hard disks.  For these reasons, the
     tutorial does not cover working with tape drives.  *Note Media::,
     for complete information on using `tar' archives with tape drives.



File: tar.info,  Node: stylistic conventions,  Next: basic tar options,  Prev: assumptions,  Up: Tutorial

Stylistic Conventions
=====================

   In the examples, `$' represents a typical shell prompt.  It precedes
lines you should type; to make this more clear, those lines are shown
in `this font', as opposed to lines which represent the computer's
response; those lines are shown in `this font', or sometimes `like
this'.  When we have lines which are too long to be displayed in any
other way, we will show them like this:

     This is an example of a line which would otherwise not fit in this space.


File: tar.info,  Node: basic tar options,  Next: frequent operations,  Prev: stylistic conventions,  Up: Tutorial

Basic `tar' Operations and Options
==================================

   `tar' can take a wide variety of arguments which specify and define
the actions it will have on the particular set of files or the archive.
The main types of arguments to `tar' fall into one of two classes:
operations, and options.

   Some arguments fall into a class called "operations"; exactly one of
these is both allowed and required for any instance of using `tar'; you
may _not_ specify more than one.  People sometimes speak of "operating
modes".  You are in a particular operating mode when you have specified
the operation which specifies it; there are eight operations in total,
and thus there are eight operating modes.

   The other arguments fall into the class known as "options".  You are
not required to specify any options, and you are allowed to specify more
than one at a time (depending on the way you are using `tar' at that
time).  Some options are used so frequently, and are so useful for
helping you type commands more carefully that they are effectively
"required".  We will discuss them in this chapter.

   You can write most of the `tar' operations and options in any of
three forms: long (mnemonic) form, short form, and old style.  Some of
the operations and options have no short or "old" forms; however, the
operations and options which we will cover in this tutorial have
corresponding abbreviations.  We will indicate those abbreviations
appropriately to get you used to seeing them.  (Note that the "old
style" option forms exist in GNU `tar' for compatibility with Unix
`tar'.  We present a full discussion of this way of writing options and
operations appears in *Note Old Options::, and we discuss the other two
styles of writing options in *Note Mnemonic Options:: and *Note Short
Options::.)

   In the examples and in the text of this tutorial, we usually use the
long forms of operations and options; but the "short" forms produce the
same result and can make typing long `tar' commands easier.  For
example, instead of typing

     tar --create --verbose --file=afiles.tar apple angst aspic

you can type
     tar -c -v -f afiles.tar apple angst aspic

or even
     tar -cvf afiles.tar apple angst aspic

For more information on option syntax, see *Note Advanced tar::.  In
discussions in the text, when we name an option by its long form, we
also give the corresponding short option in parentheses.

   The term, "option", can be confusing at times, since "operations"
are often lumped in with the actual, _optional_ "options" in certain
general class statements.  For example, we just talked about "short and
long forms of options and operations".  However, experienced `tar'
users often refer to these by shorthand terms such as, "short and long
options".  This term assumes that the "operations" are included, also.
Context will help you determine which definition of "options" to use.

   Similarly, the term "command" can be confusing, as it is often used
in two different ways.  People sometimes refer to `tar' "commands".  A
`tar' "command" is the entire command line of user input which tells
`tar' what to do -- including the operation, options, and any arguments
(file names, pipes, other commands, etc).  However, you will also
sometimes hear the term "the `tar' command".  When the word "command"
is used specifically like this, a person is usually referring to the
`tar' _operation_, not the whole line.  Again, use context to figure
out which of the meanings the speaker intends.


File: tar.info,  Node: frequent operations,  Next: Two Frequent Options,  Prev: basic tar options,  Up: Tutorial

The Three Most Frequently Used Operations
=========================================

   Here are the three most frequently used operations (both short and
long forms), as well as a brief description of their meanings.  The
rest of this chapter will cover how to use these operations in detail.
We will present the rest of the operations in the next chapter.

`--create'
`-c'
     Create a new `tar' archive.

`--list'
`-t'
     List the contents of an archive.

`--extract'
`-x'
     Extract one or more members from an archive.


File: tar.info,  Node: Two Frequent Options,  Next: create,  Prev: frequent operations,  Up: Tutorial

Two Frequently Used Options
===========================

   To understand how to run `tar' in the three operating modes listed
previously, you also need to understand how to use two of the options to
`tar': `--file' (which takes an archive file as an argument) and
`--verbose'.  (You are usually not _required_ to specify either of
these options when you run `tar', but they can be very useful in making
things more clear and helping you avoid errors.)

* Menu:

* file tutorial::
* verbose tutorial::
* help tutorial::


File: tar.info,  Node: file tutorial,  Next: verbose tutorial,  Up: Two Frequent Options

The `--file' Option
-------------------

`--file=ARCHIVE-NAME'
`-f ARCHIVE-NAME'
     Specify the name of an archive file.

   You can specify an argument for the `--file=ARCHIVE-NAME' (`-f
ARCHIVE-NAME') option whenever you use `tar'; this option determines
the name of the archive file that `tar' will work on.

   If you don't specify this argument, then `tar' will use a default,
usually some physical tape drive attached to your machine.  If there is
no tape drive attached, or the default is not meaningful, then `tar'
will print an error message.  The error message might look roughly like
one of the following:

     tar: can't open /dev/rmt8 : No such device or address
     tar: can't open /dev/rsmt0 : I/O error

To avoid confusion, we recommend that you always specify an archive file
name by using `--file=ARCHIVE-NAME' (`-f ARCHIVE-NAME') when writing
your `tar' commands.  For more information on using the
`--file=ARCHIVE-NAME' (`-f ARCHIVE-NAME') option, see *Note file::.


File: tar.info,  Node: verbose tutorial,  Next: help tutorial,  Prev: file tutorial,  Up: Two Frequent Options

The `--verbose' Option
----------------------

`--verbose'
`-v'
     Show the files being worked on as `tar' is running.

   `--verbose' (`-v') shows details about the results of running `tar'.
This can be especially useful when the results might not be obvious.
For example, if you want to see the progress of `tar' as it writes
files into the archive, you can use the `--verbose' option.  In the
beginning, you may find it useful to use `--verbose' at all times; when
you are more accustomed to `tar', you will likely want to use it at
certain times but not at others.  We will use `--verbose' at times to
help make something clear, and we will give many examples both using
and not using `--verbose' to show the differences.

   Sometimes, a single instance of `--verbose' on the command line will
show a full, `ls' style listing of an archive or files, giving sizes,
owners, and similar information.  Other times, `--verbose' will only
show files or members that the particular operation is operating on at
the time.  In the latter case, you can use `--verbose' twice in a
command to get a listing such as that in the former case.  For example,
instead of saying

     tar -cvf afiles.tar apple angst aspic

above, you might say

     tar -cvvf afiles.tar apple angst aspic

This works equally well using short or long forms of options.  Using
long forms, you would simply write out the mnemonic form of the option
twice, like this:

     $ tar --create --verbose --verbose ...

Note that you must double the hyphens properly each time.

   Later in the tutorial, we will give examples using
`--verbose --verbose'.


File: tar.info,  Node: help tutorial,  Prev: verbose tutorial,  Up: Two Frequent Options

Getting Help: Using the `--help' Option
---------------------------------------

`--help'
     The `--help' option to `tar' prints out a very brief list of all
     operations and option available for the current version of `tar'
     available on your system.


File: tar.info,  Node: create,  Next: list,  Prev: Two Frequent Options,  Up: Tutorial

How to Create Archives
======================

     _(This message will disappear, once this node revised.)_

   One of the basic operations of `tar' is `--create' (`-c'), which you
use to create a `tar' archive.  We will explain `--create' first
because, in order to learn about the other operations, you will find it
useful to have an archive available to practice on.

   To make this easier, in this section you will first create a
directory containing three files.  Then, we will show you how to create
an _archive_ (inside the new directory).  Both the directory, and the
archive are specifically for you to practice on.  The rest of this
chapter and the next chapter will show many examples using this
directory and the files you will create: some of those files may be
other directories and other archives.

   The three files you will archive in this example are called `blues',
`folk', and `jazz'.  The archive is called `collection.tar'.

   This section will proceed slowly, detailing how to use `--create' in
`verbose' mode, and showing examples using both short and long forms.
In the rest of the tutorial, and in the examples in the next chapter,
we will proceed at a slightly quicker pace.  This section moves more
slowly to allow beginning users to understand how `tar' works.

* Menu:

* prepare for examples::
* Creating the archive::
* create verbose::
* short create::
* create dir::


File: tar.info,  Node: prepare for examples,  Next: Creating the archive,  Up: create

Preparing a Practice Directory for Examples
-------------------------------------------

   To follow along with this and future examples, create a new directory
called `practice' containing files called `blues', `folk' and `jazz'.
The files can contain any information you like: ideally, they should
contain information which relates to their names, and be of different
lengths.  Our examples assume that `practice' is a subdirectory of your
home directory.

   Now `cd' to the directory named `practice'; `practice' is now your
"working directory".  (_Please note_: Although the full path name of
this directory is `/HOMEDIR/practice', in our examples we will refer to
this directory as `practice'; the HOMEDIR is presumed.

   In general, you should check that the files to be archived exist
where you think they do (in the working directory) by running `ls'.
Because you just created the directory and the files and have changed to
that directory, you probably don't need to do that this time.

   It is very important to make sure there isn't already a file in the
working directory with the archive name you intend to use (in this case,
`collection.tar'), or that you don't care about its contents.  Whenever
you use `create', `tar' will erase the current contents of the file
named by `--file=ARCHIVE-NAME' (`-f ARCHIVE-NAME') if it exists.  `tar'
will not tell you if you are about to overwrite an archive unless you
specify an option which does this.  To add files to an existing
archive, you need to use a different option, such as `--append' (`-r');
see *Note append:: for information on how to do this.


File: tar.info,  Node: Creating the archive,  Next: create verbose,  Prev: prepare for examples,  Up: create

Creating the Archive
--------------------

   To place the files `blues', `folk', and `jazz' into an archive named
`collection.tar', use the following command:

     $ tar --create --file=collection.tar blues folk jazz

   The order of the arguments is not very important, _when using long
option forms_.  You could also say:

     $ tar blues --create folk --file=collection.tar jazz

However, you can see that this order is harder to understand; this is
why we will list the arguments in the order that makes the commands
easiest to understand (and we encourage you to do the same when you use
`tar', to avoid errors).

   Note that the part of the command which says,
`--file=collection.tar' is considered to be _one_ argument.  If you
substituted any other string of characters for `collection.tar',  then
that string would become the name of the archive file you create.

   The order of the options becomes more important when you begin to use
short forms.  With short forms, if you type commands in the wrong order
(even if you type them correctly in all other ways), you may end up with
results you don't expect.  For this reason, it is a good idea to get
into the habit of typing options in the order that makes inherent sense.
*Note short create::, for more information on this.

   In this example, you type the command as shown above: `--create' is
the operation which creates the new archive (`collection.tar'), and
`--file' is the option which lets you give it the name you chose.  The
files, `blues', `folk', and `jazz', are now members of the archive,
`collection.tar' (they are "file name arguments" to the `--create'
operation).  Now that they are in the archive, they are called _archive
members_, not files.

   When you create an archive, you _must_ specify which files you want
placed in the archive.  If you do not specify any archive members, GNU
`tar' will complain.

   If you now list the contents of the working directory (`ls'), you
will find the archive file listed as well as the files you saw
previously:

     blues   folk   jazz   collection.tar

Creating the archive `collection.tar' did not destroy the copies of the
files in the directory.

   Keep in mind that if you don't indicate an operation, `tar' will not
run and will prompt you for one.  If you don't name any files, `tar'
will complain.  You must have write access to the working directory, or
else you will not be able to create an archive in that directory.

   _Caution_: Do not attempt to use `--create' (`-c') to add files to
an existing archive; it will delete the archive and write a new one.
Use `--append' (`-r') instead.  *Note append::.


File: tar.info,  Node: create verbose,  Next: short create,  Prev: Creating the archive,  Up: create

Running `--create' with `--verbose'
-----------------------------------

   If you include the `--verbose' (`-v') option on the command line,
`tar' will list the files it is acting on as it is working.  In verbose
mode, the `create' example above would appear as:

     $ tar --create --verbose --file=collection.tar blues folk jazz
     blues
     folk
     jazz

   This example is just like the example we showed which did not use
`--verbose', except that `tar' generated the remaining lines .

   In the rest of the examples in this chapter, we will frequently use
`verbose' mode so we can show actions or `tar' responses that you would
otherwise not see, and which are important for you to understand.


File: tar.info,  Node: short create,  Next: create dir,  Prev: create verbose,  Up: create

Short Forms with `create'
-------------------------

   As we said before, the `--create' (`-c') operation is one of the most
basic uses of `tar', and you will use it countless times.  Eventually,
you will probably want to use abbreviated (or "short") forms of
options.  A full discussion of the three different forms that options
can take appears in *Note Styles::; for now, here is what the previous
example (including the `--verbose' (`-v') option) looks like using
short option forms:

     $ tar -cvf collection.tar blues folk jazz
     blues
     folk
     jazz

As you can see, the system responds the same no matter whether you use
long or short option forms.

   One difference between using short and long option forms is that,
although the exact placement of arguments following options is no more
specific when using short forms, it is easier to become confused and
make a mistake when using short forms.  For example, suppose you
attempted the above example in the following way:

     $ tar -cfv collection.tar blues folk jazz

In this case, `tar' will make an archive file called `v', containing
the files `blues', `folk', and `jazz', because the `v' is the closest
"file name" to the `-f' option, and is thus taken to be the chosen
archive file name.  `tar' will try to add a file called
`collection.tar' to the `v' archive file; if the file `collection.tar'
did not already exist, `tar' will report an error indicating that this
file does not exist.  If the file `collection.tar' does already exist
(e.g., from a previous command you may have run), then `tar' will add
this file to the archive.  Because the `-v' option did not get
registered, `tar' will not run under `verbose' mode, and will not
report its progress.

   The end result is that you may be quite confused about what happened,
and possibly overwrite a file.  To illustrate this further, we will show
you how an example we showed previously would look using short forms.

   This example,

     $ tar blues --create folk --file=collection.tar jazz

is confusing as it is.  When shown using short forms, however, it
becomes much more so:

     $ tar blues -c folk -f collection.tar jazz

It would be very easy to put the wrong string of characters immediately
following the `-f', but doing that could sacrifice valuable data.

   For this reason, we recommend that you pay very careful attention to
the order of options and placement of file and archive names,
especially when using short option forms.  Not having the option name
written out mnemonically can affect how well you remember which option
does what, and therefore where different names have to be placed.
(Placing options in an unusual order can also cause `tar' to report an
error if you have set the shell environment variable `POSIXLY_CORRECT';
*note posix compliance:: for more information on this.)


File: tar.info,  Node: create dir,  Prev: short create,  Up: create

Archiving Directories
---------------------

   You can archive a directory by specifying its directory name as a
file name argument to `tar'.  The files in the directory will be
archived relative to the working directory, and the directory will be
re-created along with its contents when the archive is extracted.

   To archive a directory, first move to its superior directory.  If you
have followed the previous instructions in this tutorial, you should
type:

     $ cd ..
     $

This will put you into the directory which contains `practice', i.e.
your home directory.  Once in the superior directory, you can specify
the subdirectory, `practice', as a file name argument.  To store
`practice' in the new archive file `music.tar', type:

     $ tar --create --verbose --file=music.tar practice

`tar' should output:

     practice/
     practice/blues
     practice/folk
     practice/jazz
     practice/collection.tar

   Note that the archive thus created is not in the subdirectory
`practice', but rather in the current working directory--the directory
from which `tar' was invoked.  Before trying to archive a directory
from its superior directory, you should make sure you have write access
to the superior directory itself, not only the directory you are trying
archive with `tar'.  For example, you will probably not be able to
store your home directory in an archive by invoking `tar' from the root
directory; *Note absolute::.  (Note also that `collection.tar', the
original archive file, has itself been archived.  `tar' will accept any
file as a file to be archived, regardless of its content.  When
`music.tar' is extracted, the archive file `collection.tar' will be
re-written into the file system).

   If you give `tar' a command such as

     $ tar --create --file=foo.tar .

`tar' will report `tar: ./foo.tar is the archive; not dumped'.  This
happens because `tar' creates the archive `foo.tar' in the current
directory before putting any files into it.  Then, when `tar' attempts
to add all the files in the directory `.' to the archive, it notices
that the file `./foo.tar' is the same as the archive `foo.tar', and
skips it.  (It makes no sense to put an archive into itself.)  GNU
`tar' will continue in this case, and create the archive normally,
except for the exclusion of that one file.  (_Please note:_ Other
versions of `tar' are not so clever; they will enter an infinite loop
when this happens, so you should not depend on this behavior unless you
are certain you are running GNU `tar'.)


File: tar.info,  Node: list,  Next: extract,  Prev: create,  Up: Tutorial

How to List Archives
====================

   Frequently, you will find yourself wanting to determine exactly what
a particular archive contains.  You can use the `--list' (`-t')
operation to get the member names as they currently appear in the
archive, as well as various attributes of the files at the time they
were archived.  For example, you can examine the archive
`collection.tar' that you created in the last section with the command,

     $ tar --list --file=collection.tar

The output of `tar' would then be:

     blues
     folk
     jazz

The archive `bfiles.tar' would list as follows:

     ./birds
     baboon
     ./box

Be sure to use a `--file=ARCHIVE-NAME' (`-f ARCHIVE-NAME') option just
as with `--create' (`-c') to specify the name of the archive.

   If you use the `--verbose' (`-v') option with `--list', then `tar'
will print out a listing reminiscent of `ls -l', showing owner, file
size, and so forth.

   If you had used `--verbose' (`-v') mode, the example above would look
like:

     $ tar --list --verbose --file=collection.tar folk
     -rw-rw-rw- myself user 62 1990-05-23 10:55 folk

   You can specify one or more individual member names as arguments when
using `list'.  In this case, `tar' will only list the names of members
you identify.  For example, `tar --list --file=afiles.tar apple' would
only print `apple'.

   Because `tar' preserves paths, file names must be specified as they
appear in the archive (ie., relative to the directory from which the
archive was created).  Therefore, it is essential when specifying
member names to `tar' that you give the exact member names.  For
example, `tar --list --file=bfiles birds' would produce an error message
something like `tar: birds: Not found in archive', because there is no
member named `birds', only one named `./birds'.  While the names
`birds' and `./birds' name the same file, _member_ names are compared
using a simplistic name comparison, in which an exact match is
necessary.  *Note absolute::.

   However, `tar --list --file=collection.tar folk' would respond with
`folk', because `folk' is in the archive file `collection.tar'.  If you
are not sure of the exact file name, try listing all the files in the
archive and searching for the one you expect to find; remember that if
you use `--list' with no file names as arguments, `tar' will print the
names of all the members stored in the specified archive.

* Menu:

* list dir::


File: tar.info,  Node: list dir,  Up: list

Listing the Contents of a Stored Directory
------------------------------------------

     _(This message will disappear, once this node revised.)_

   To get information about the contents of an archived directory, use
the directory name as a file name argument in conjunction with `--list'
(`-t').  To find out file attributes, include the `--verbose' (`-v')
option.

   For example, to find out about files in the directory `practice', in
the archive file `music.tar', type:

     $ tar --list --verbose --file=music.tar practice

   `tar' responds:

     drwxrwxrwx myself user 0 1990-05-31 21:49 practice/
     -rw-rw-rw- myself user 42 1990-05-21 13:29 practice/blues
     -rw-rw-rw- myself user 62 1990-05-23 10:55 practice/folk
     -rw-rw-rw- myself user 40 1990-05-21 13:30 practice/jazz
     -rw-rw-rw- myself user 10240 1990-05-31 21:49 practice/collection.tar

   When you use a directory name as a file name argument, `tar' acts on
all the files (including sub-directories) in that directory.


File: tar.info,  Node: extract,  Next: going further,  Prev: list,  Up: Tutorial

How to Extract Members from an Archive
======================================

     _(This message will disappear, once this node revised.)_

   Creating an archive is only half the job--there is no point in
storing files in an archive if you can't retrieve them.  The act of
retrieving members from an archive so they can be used and manipulated
as unarchived files again is called "extraction".  To extract files
from an archive, use the `--extract' (`--get', `-x') operation.  As with
`--create' (`-c'), specify the name of the archive with
`--file=ARCHIVE-NAME' (`-f ARCHIVE-NAME').  Extracting an archive does
not modify the archive in any way; you can extract it multiple times if
you want or need to.

   Using `--extract', you can extract an entire archive, or specific
files.  The files can be directories containing other files, or not.  As
with `--create' (`-c') and `--list' (`-t'), you may use the short or the
long form of the operation without affecting the performance.

* Menu:

* extracting archives::
* extracting files::
* extract dir::
* failing commands::


File: tar.info,  Node: extracting archives,  Next: extracting files,  Up: extract

Extracting an Entire Archive
----------------------------

   To extract an entire archive, specify the archive file name only,
with no individual file names as arguments.  For example,

     $ tar -xvf collection.tar

produces this:

     -rw-rw-rw- me user     28 1996-10-18 16:31 jazz
     -rw-rw-rw- me user     21 1996-09-23 16:44 blues
     -rw-rw-rw- me user     20 1996-09-23 16:44 folk


File: tar.info,  Node: extracting files,  Next: extract dir,  Prev: extracting archives,  Up: extract

Extracting Specific Files
-------------------------

   To extract specific archive members, give their exact member names as
arguments, as printed by `--list' (`-t').  If you had mistakenly deleted
one of the files you had placed in the archive `collection.tar' earlier
(say, `blues'), you can extract it from the archive without changing
the archive's structure.  It will be identical to the original file
`blues' that you deleted.

   First, make sure you are in the `practice' directory, and list the
files in the directory.  Now, delete the file, `blues', and list the
files in the directory again.

   You can now extract the member `blues' from the archive file
`collection.tar' like this:

     $ tar --extract --file=collection.tar blues

If you list the files in the directory again, you will see that the file
`blues' has been restored, with its original permissions, creation
times, and owner.  (These parameters will be identical to those which
the file had when you originally placed it in the archive; any changes
you may have made before deleting the file from the file system,
however, will _not_ have been made to the archive member.)  The archive
file, `collection.tar', is the same as it was before you extracted
`blues'.  You can confirm this by running `tar' with `--list' (`-t').

   Remember that as with other operations, specifying the exact member
name is important.  `tar --extract --file=bfiles.tar birds' will fail,
because there is no member named `birds'.  To extract the member named
`./birds', you must specify `tar --extract --file=bfiles.tar ./birds'.
To find the exact member names of the members of an archive, use
`--list' (`-t') (*note list::).

   You can extract a file to standard output by combining the above
options with the `--to-stdout' option (*note Writing to Standard
Output::).

   If you give the `--verbose' (`-v') option, then `--extract'
(`--get', `-x') will print the names of the archive members as it
extracts them.


File: tar.info,  Node: extract dir,  Next: failing commands,  Prev: extracting files,  Up: extract

Extracting Files that are Directories
-------------------------------------

   Extracting directories which are members of an archive is similar to
extracting other files.  The main difference to be aware of is that if
the extracted directory has the same name as any directory already in
the working directory, then files in the extracted directory will be
placed into the directory of the same name.  Likewise, if there are
files in the pre-existing directory with the same names as the members
which you extract, the files from the extracted archive will replace
the files already in the working directory (and possible
subdirectories).  This will happen regardless of whether or not the
files in the working directory were more recent than those extracted.

   However, if a file was stored with a directory name as part of its
file name, and that directory does not exist under the working
directory when the file is extracted, `tar' will create the directory.

   We can demonstrate how to use `--extract' to extract a directory
file with an example.  Change to the `practice' directory if you
weren't there, and remove the files `folk' and `jazz'.  Then, go back
to the parent directory and extract the archive `music.tar'.  You may
either extract the entire archive, or you may extract only the files
you just deleted.  To extract the entire archive, don't give any file
names as arguments after the archive name `music.tar'.  To extract only
the files you deleted, use the following command:

     $ tar -xvf music.tar practice/folk practice/jazz

Because you created the directory with `practice' as part of the file
names of each of the files by archiving the `practice' directory as
`practice', you must give `practice' as part of the file names when you
extract those files from the archive.


File: tar.info,  Node: failing commands,  Prev: extract dir,  Up: extract

Commands That Will Fail
-----------------------

   Here are some sample commands you might try which will not work, and
why they won't work.

   If you try to use this command,

     $ tar -xvf music.tar folk jazz

you will get the following response:

     tar: folk: Not found in archive
     tar: jazz: Not found in archive
     $

This is because these files were not originally _in_ the parent
directory `..', where the archive is located; they were in the
`practice' directory, and their file names reflect this:

     $ tar -tvf music.tar
     practice/folk
     practice/jazz
     practice/rock

Likewise, if you try to use this command,

     $ tar -tvf music.tar folk jazz

you would get a similar response.  Members with those names are not in
the archive.  You must use the correct member names in order to extract
the files from the archive.

   If you have forgotten the correct names of the files in the archive,
use `tar --list --verbose' to list them correctly.


File: tar.info,  Node: going further,  Prev: extract,  Up: Tutorial

Going Further Ahead in this Manual
==================================


File: tar.info,  Node: tar invocation,  Next: operations,  Prev: Tutorial,  Up: Top

Invoking GNU `tar'
******************

     _(This message will disappear, once this node revised.)_

   This chapter is about how one invokes the GNU `tar' command, from
the command synopsis (*note Synopsis::).  There are numerous options,
and many styles for writing them.  One mandatory option specifies the
operation `tar' should perform (*note Operation Summary::), other
options are meant to detail how this operation should be performed
(*note Option Summary::).  Non-option arguments are not always
interpreted the same way, depending on what the operation is.

   You will find in this chapter everything about option styles and
rules for writing them (*note Styles::).  On the other hand, operations
and options are fully described elsewhere, in other chapters.  Here,
you will find only synthetic descriptions for operations and options,
together with pointers to other parts of the `tar' manual.

   Some options are so special they are fully described right in this
chapter.  They have the effect of inhibiting the normal operation of
`tar' or else, they globally alter the amount of feedback the user
receives about what is going on.  These are the `--help' and
`--version' (*note help::), `--verbose' (`-v') (*note verbose::) and
`--interactive' (`-w') options (*note interactive::).

* Menu:

* Synopsis::
* using tar options::
* Styles::
* All Options::
* help::
* verbose::
* interactive::


File: tar.info,  Node: Synopsis,  Next: using tar options,  Up: tar invocation

General Synopsis of `tar'
=========================

   The GNU `tar' program is invoked as either one of:

     tar OPTION... [NAME]...
     tar LETTER... [ARGUMENT]... [OPTION]... [NAME]...

   The second form is for when old options are being used.

   You can use `tar' to store files in an archive, to extract them from
an archive, and to do other types of archive manipulation.  The primary
argument to `tar', which is called the "operation", specifies which
action to take.  The other arguments to `tar' are either "options",
which change the way `tar' performs an operation, or file names or
archive members, which specify the files or members `tar' is to act on.

   You can actually type in arguments in any order, even if in this
manual the options always precede the other arguments, to make examples
easier to understand.  Further, the option stating the main operation
mode (the `tar' main command) is usually given first.

   Each NAME in the synopsis above is interpreted as an archive member
name when the main command is one of `--compare' (`--diff', `-d'),
`--delete', `--extract' (`--get', `-x'), `--list' (`-t') or `--update'
(`-u').  When naming archive members, you must give the exact name of
the member in the archive, as it is printed by `--list' (`-t').  For
`--append' (`-r') and `--create' (`-c'), these NAME arguments specify
the names of either files or directory hierarchies to place in the
archive.  These files or hierarchies should already exist in the file
system, prior to the execution of the `tar' command.

   `tar' interprets relative file names as being relative to the
working directory.  `tar' will make all file names relative (by
removing leading slashes when archiving or restoring files), unless you
specify otherwise (using the `--absolute-names' (`-P') option).
*Note absolute::, for more information about `--absolute-names' (`-P').

   If you give the name of a directory as either a file name or a member
name, then `tar' acts recursively on all the files and directories
beneath that directory.  For example, the name `/' identifies all the
files in the filesystem to `tar'.

   The distinction between file names and archive member names is
especially important when shell globbing is used, and sometimes a
source of confusion for newcomers.  *Note Wildcards::, for more
information about globbing.  The problem is that shells may only glob
using existing files in the file system.  Only `tar' itself may glob on
archive members, so when needed, you must ensure that wildcard
characters reach `tar' without being interpreted by the shell first.
Using a backslash before `*' or `?', or putting the whole argument
between quotes, is usually sufficient for this.

   Even if NAMEs are often specified on the command line, they can also
be read from a text file in the file system, using the
`--files-from=FILE-OF-NAMES' (`-T FILE-OF-NAMES') option.

   If you don't use any file name arguments, `--append' (`-r'),
`--delete' and `--concatenate' (`--catenate', `-A') will do nothing,
while `--create' (`-c') will usually yield a diagnostic and inhibit
`tar' execution.  The other operations of `tar' (`--list' (`-t'),
`--extract' (`--get', `-x'), `--compare' (`--diff', `-d'), and
`--update' (`-u')) will act on the entire contents of the archive.

   Besides successful exits, GNU `tar' may fail for many reasons.  Some
reasons correspond to bad usage, that is, when the `tar' command is
improperly written.  Errors may be encountered later, while
encountering an error processing the archive or the files.  Some errors
are recoverable, in which case the failure is delayed until `tar' has
completed all its work.  Some errors are such that it would not
meaningful, or at least risky, to continue processing: `tar' then aborts
processing immediately.  All abnormal exits, whether immediate or
delayed, should always be clearly diagnosed on `stderr', after a line
stating the nature of the error.

   GNU `tar' returns only a few exit statuses.  I'm really aiming
simplicity in that area, for now.  If you are not using the `--compare'
(`--diff', `-d') option, zero means that everything went well, besides
maybe innocuous warnings.  Nonzero means that something went wrong.
Right now, as of today, "nonzero" is almost always 2, except for remote
operations, where it may be 128.


File: tar.info,  Node: using tar options,  Next: Styles,  Prev: Synopsis,  Up: tar invocation

Using `tar' Options
===================

   GNU `tar' has a total of eight operating modes which allow you to
perform a variety of tasks.  You are required to choose one operating
mode each time you employ the `tar' program by specifying one, and only
one operation as an argument to the `tar' command (two lists of four
operations each may be found at *Note frequent operations:: and *Note
Operations::).  Depending on circumstances, you may also wish to
customize how the chosen operating mode behaves.  For example, you may
wish to change the way the output looks, or the format of the files that
you wish to archive may require you to do something special in order to
make the archive look right.

   You can customize and control `tar''s performance by running `tar'
with one or more options (such as `--verbose' (`-v'), which we used in
the tutorial).  As we said in the tutorial, "options" are arguments to
`tar' which are (as their name suggests) optional.  Depending on the
operating mode, you may specify one or more options.  Different options
will have different effects, but in general they all change details of
the operation, such as archive format, archive name, or level of user
interaction.  Some options make sense with all operating modes, while
others are meaningful only with particular modes.  You will likely use
some options frequently, while you will only use others infrequently,
or not at all.  (A full list of options is available in *note All
Options::.)

   The `TAR_OPTIONS' environment variable specifies default options to
be placed in front of any explicit options.  For example, if
`TAR_OPTIONS' is `-v --unlink-first', `tar' behaves as if the two
options `-v' and `--unlink-first' had been specified before any
explicit options.  Option specifications are separated by whitespace.
A backslash escapes the next character, so it can be used to specify an
option containing whitespace or a backslash.

   Note that `tar' options are case sensitive.  For example, the
options `-T' and `-t' are different; the first requires an argument for
stating the name of a file providing a list of NAMEs, while the second
does not require an argument and is another way to write `--list'
(`-t').

   In addition to the eight operations, there are many options to
`tar', and three different styles for writing both: long (mnemonic)
form, short form, and old style.  These styles are discussed below.
Both the options and the operations can be written in any of these three
styles.


File: tar.info,  Node: Styles,  Next: All Options,  Prev: using tar options,  Up: tar invocation

The Three Option Styles
=======================

   There are three styles for writing operations and options to the
command line invoking `tar'.  The different styles were developed at
different times during the history of `tar'.  These styles will be
presented below, from the most recent to the oldest.

   Some options must take an argument.  (For example,
`--file=ARCHIVE-NAME' (`-f ARCHIVE-NAME') takes the name of an archive
file as an argument.  If you do not supply an archive file name, `tar'
will use a default, but this can be confusing; thus, we recommend that
you always supply a specific archive file name.)  Where you _place_ the
arguments generally depends on which style of options you choose.  We
will detail specific information relevant to each option style in the
sections on the different option styles, below.  The differences are
subtle, yet can often be very important; incorrect option placement can
cause you to overwrite a number of important files.  We urge you to
note these differences, and only use the option style(s) which makes
the most sense to you until you feel comfortable with the others.

* Menu:

* Mnemonic Options::            Mnemonic Option Style
* Short Options::               Short Option Style
* Old Options::                 Old Option Style
* Mixing::                      Mixing Option Styles


File: tar.info,  Node: Mnemonic Options,  Next: Short Options,  Up: Styles

Mnemonic Option Style
---------------------

   Each option has at least one long (or mnemonic) name starting with
two dashes in a row, e.g. `--list'.  The long names are more clear than
their corresponding short or old names.  It sometimes happens that a
single mnemonic option has many different different names which are
synonymous, such as `--compare' and `--diff'.  In addition, long option
names can be given unique abbreviations.  For example, `--cre' can be
used in place of `--create' because there is no other mnemonic option
which begins with `cre'.  (One way to find this out is by trying it and
seeing what happens; if a particular abbreviation could represent more
than one option, `tar' will tell you that that abbreviation is
ambiguous and you'll know that that abbreviation won't work.  You may
also choose to run `tar --help' to see a list of options.  Be aware
that if you run `tar' with a unique abbreviation for the long name of
an option you didn't want to use, you are stuck; `tar' will perform the
command as ordered.)

   Mnemonic options are meant to be obvious and easy to remember, and
their meanings are generally easier to discern than those of their
corresponding short options (see below).  For example:

     $ tar --create --verbose --blocking-factor=20 --file=/dev/rmt0

gives a fairly good set of hints about what the command does, even for
those not fully acquainted with `tar'.

   Mnemonic options which require arguments take those arguments
immediately following the option name; they are introduced by an equal
sign.  For example, the `--file' option (which tells the name of the
`tar' archive) is given a file such as `archive.tar' as argument by
using the notation `--file=archive.tar' for the mnemonic option.


File: tar.info,  Node: Short Options,  Next: Old Options,  Prev: Mnemonic Options,  Up: Styles

Short Option Style
------------------

   Most options also have a short option name.  Short options start with
a single dash, and are followed by a single character, e.g. `-t' (which
is equivalent to `--list').  The forms are absolutely identical in
function; they are interchangeable.

   The short option names are faster to type than long option names.

   Short options which require arguments take their arguments
immediately following the option, usually separated by white space.  It
is also possible to stick the argument right after the short option
name, using no intervening space.  For example, you might write
`-f archive.tar' or `-farchive.tar' instead of using
`--file=archive.tar'.  Both `--file=ARCHIVE-NAME' and `-f ARCHIVE-NAME'
denote the option which indicates a specific archive, here named
`archive.tar'.

   Short options' letters may be clumped together, but you are not
required to do this (as compared to old options; see below).  When short
options are clumped as a set, use one (single) dash for them all, e.g.
``tar' -cvf'.  Only the last option in such a set is allowed to have an
argument(1).

   When the options are separated, the argument for each option which
requires an argument directly follows that option, as is usual for Unix
programs.  For example:

     $ tar -c -v -b 20 -f /dev/rmt0

   If you reorder short options' locations, be sure to move any
arguments that belong to them.  If you do not move the arguments
properly, you may end up overwriting files.

   ---------- Footnotes ----------

   (1) Clustering many options, the last of which has an argument, is a
rather opaque way to write options.  Some wonder if GNU `getopt' should
not even be made helpful enough for considering such usages as invalid.


File: tar.info,  Node: Old Options,  Next: Mixing,  Prev: Short Options,  Up: Styles

Old Option Style
----------------

     _(This message will disappear, once this node revised.)_

   Like short options, old options are single letters.  However, old
options must be written together as a single clumped set, without
spaces separating them or dashes preceding them(1).  This set of
letters must be the first to appear on the command line, after the
`tar' program name and some white space; old options cannot appear
anywhere else.  The letter of an old option is exactly the same letter
as the corresponding short option.  For example, the old option `t' is
the same as the short option `-t', and consequently, the same as the
mnemonic option `--list'.  So for example, the command `tar cv'
specifies the option `-v' in addition to the operation `-c'.

   When options that need arguments are given together with the command,
all the associated arguments follow, in the same order as the options.
Thus, the example given previously could also be written in the old
style as follows:

     $ tar cvbf 20 /dev/rmt0

Here, `20' is the argument of `-b' and `/dev/rmt0' is the argument of
`-f'.

   On the other hand, this old style syntax makes it difficult to match
option letters with their corresponding arguments, and is often
confusing.  In the command `tar cvbf 20 /dev/rmt0', for example, `20'
is the argument for `-b', `/dev/rmt0' is the argument for `-f', and
`-v' does not have a corresponding argument.  Even using short options
like in `tar -c -v -b 20 -f /dev/rmt0' is clearer, putting all
arguments next to the option they pertain to.

   If you want to reorder the letters in the old option argument, be
sure to reorder any corresponding argument appropriately.

   This old way of writing `tar' options can surprise even experienced
users.  For example, the two commands:

     tar cfz archive.tar.gz file
     tar -cfz archive.tar.gz file

are quite different.  The first example uses `archive.tar.gz' as the
value for option `f' and recognizes the option `z'.  The second
example, however, uses `z' as the value for option `f'--probably not
what was intended.

   Old options are kept for compatibility with old versions of `tar'.

   This second example could be corrected in many ways, among which the
following are equivalent:

     tar -czf archive.tar.gz file
     tar -cf archive.tar.gz -z file
     tar cf archive.tar.gz -z file

   As far as we know, all `tar' programs, GNU and non-GNU, support old
options.  GNU `tar' supports them not only for historical reasons, but
also because many people are used to them.  For compatibility with Unix
`tar', the first argument is always treated as containing command and
option letters even if it doesn't start with `-'.  Thus, `tar c' is
equivalent to `tar -c': both of them specify the `--create' (`-c')
command to create an archive.

   ---------- Footnotes ----------

   (1) Beware that if you precede options with a dash, you are
announcing the short option style instead of the old option style;
short options are decoded differently.


File: tar.info,  Node: Mixing,  Prev: Old Options,  Up: Styles

Mixing Option Styles
--------------------

   All three styles may be intermixed in a single `tar' command, so
long as the rules for each style are fully respected(1).  Old style
options and either of the modern styles of options may be mixed within
a single `tar' command.  However, old style options must be introduced
as the first arguments only, following the rule for old options (old
options must appear directly after the `tar' command and some white
space).  Modern options may be given only after all arguments to the
old options have been collected.  If this rule is not respected, a
modern option might be falsely interpreted as the value of the argument
to one of the old style options.

   For example, all the following commands are wholly equivalent, and
illustrate the many combinations and orderings of option styles.

     tar --create --file=archive.tar
     tar --create -f archive.tar
     tar --create -farchive.tar
     tar --file=archive.tar --create
     tar --file=archive.tar -c
     tar -c --file=archive.tar
     tar -c -f archive.tar
     tar -c -farchive.tar
     tar -cf archive.tar
     tar -cfarchive.tar
     tar -f archive.tar --create
     tar -f archive.tar -c
     tar -farchive.tar --create
     tar -farchive.tar -c
     tar c --file=archive.tar
     tar c -f archive.tar
     tar c -farchive.tar
     tar cf archive.tar
     tar f archive.tar --create
     tar f archive.tar -c
     tar fc archive.tar

   On the other hand, the following commands are _not_ equivalent to
the previous set:

     tar -f -c archive.tar
     tar -fc archive.tar
     tar -fcarchive.tar
     tar -farchive.tarc
     tar cfarchive.tar

These last examples mean something completely different from what the
user intended (judging based on the example in the previous set which
uses long options, whose intent is therefore very clear).  The first
four specify that the `tar' archive would be a file named `-c', `c',
`carchive.tar' or `archive.tarc', respectively.  The first two examples
also specify a single non-option, NAME argument having the value
`archive.tar'.  The last example contains only old style option letters
(repeating option `c' twice), not all of which are meaningful (eg., `.',
`h', or `i'), with no argument value.

   ---------- Footnotes ----------

   (1) Before GNU `tar' version 1.11.6, a bug prevented intermixing old
style options with mnemonic options in some cases.


File: tar.info,  Node: All Options,  Next: help,  Prev: Styles,  Up: tar invocation

All `tar' Options
=================

   The coming manual sections contain an alphabetical listing of all
`tar' operations and options, with brief descriptions and cross
references to more in-depth explanations in the body of the manual.
They also contain an alphabetically arranged table of the short option
forms with their corresponding long option.  You can use this table as
a reference for deciphering `tar' commands in scripts.

* Menu:

* Operation Summary::
* Option Summary::
* Short Option Summary::


File: tar.info,  Node: Operation Summary,  Next: Option Summary,  Up: All Options

Operations
----------

`--append'
`-r'
     Appends files to the end of the archive.  *Note append::.

`--catenate'
`-A'
     Same as `--concatenate'.  *Note concatenate::.

`--compare'
`-d'
     Compares archive members with their counterparts in the file
     system, and reports differences in file size, mode, owner,
     modification date and contents.  *Note compare::.

`--concatenate'
`-A'
     Appends other `tar' archives to the end of the archive.  *Note
     concatenate::.

`--create'
`-c'
     Creates a new `tar' archive.  *Note create::.

`--delete'
     Deletes members from the archive.  Don't try this on a archive on a
     tape!  *Note delete::.

`--diff'
`-d'
     Same `--compare'.  *Note compare::.

`--extract'
`-x'
     Extracts members from the archive into the file system.  *Note
     extract::.

`--get'
`-x'
     Same as `--extract'.   *Note extract::.

`--list'
`-t'
     Lists the members in an archive.  *Note list::.

`--update'
`-u'
     Adds files to the end of the archive, but only if they are newer
     than their counterparts already in the archive, or if they do not
     already exist in the archive.  *Note update::.


File: tar.info,  Node: Option Summary,  Next: Short Option Summary,  Prev: Operation Summary,  Up: All Options

`tar' Options
-------------

`--absolute-names'
`-P'
     Normally when creating an archive, `tar' strips an initial `/' from
     member names.  This option disables that behavior.

`--after-date'
     (See `--newer'.)

`--anchored'
     An exclude pattern must match an initial subsequence of the name's
     components.

`--atime-preserve'
     Tells `tar' to preserve the access time field in a file's inode
     when reading it.  Due to limitations in the `utimes' system call,
     the modification time field is also preserved, which may cause
     problems if the file is simultaneously being modified by another
     program.  This option is incompatible with incremental backups,
     because preserving the access time involves updating the
     last-changed time.  Also, this option does not work on files that
     you do not own, unless you're root.

`--backup=BACKUP-TYPE'
     Rather than deleting files from the file system, `tar' will back
     them up using simple or numbered backups, depending upon
     BACKUP-TYPE.

`--block-number'
`-R'
     With this option present, `tar' prints error messages for read
     errors with the block number in the archive file.

`--blocking-factor=BLOCKING'
`-b BLOCKING'
     Sets the blocking factor `tar' uses to BLOCKING x 512 bytes per
     record.

`--bzip2'
`-j'
     This option tells `tar' to read or write archives through `bzip2'.

`--checkpoint'
     This option directs `tar' to print periodic checkpoint messages as
     it reads through the archive.  Its intended for when you want a
     visual indication that `tar' is still running, but don't want to
     see `--verbose' output.

`--compress'
`--uncompress'
`-Z'
     `tar' will use the `compress' program when reading or writing the
     archive.  This allows you to directly act on archives while saving
     space.

`--confirmation'
     (See `--interactive'.)

`--dereference'
`-h'
     When creating a `tar' archive, `tar' will archive the file that a
     symbolic link points to, rather than archiving the symlink.

`--directory=DIR'
`-C DIR'
     When this option is specified, `tar' will change its current
     directory to DIR before performing any operations.  When this
     option is used during archive creation, it is order sensitive.

`--exclude=PATTERN'
     When performing operations, `tar' will skip files that match
     PATTERN.

`--exclude-from=FILE'
`-X FILE'
     Similar to `--exclude', except `tar' will use the list of patterns
     in the file FILE.

`--file=ARCHIVE'
`-f ARCHIVE'
     `tar' will use the file ARCHIVE as the `tar' archive it performs
     operations on, rather than `tar''s compilation dependent default.

`--files-from=FILE'
`-T FILE'
     `tar' will use the contents of FILE as a list of archive members
     or files to operate on, in addition to those specified on the
     command-line.

`--force-local'
     Forces `tar' to interpret the filename given to `--file' as a local
     file, even if it looks like a remote tape drive name.

`--group=GROUP'
     Files added to the `tar' archive will have a group id of GROUP,
     rather than the group from the source file.  GROUP is first decoded
     as a group symbolic name, but if this interpretation fails, it has
     to be a decimal numeric group ID.

     Also see the comments for the `--owner=USER' option.

`--gunzip'
     (See `--gzip'.)

`--gzip'
`--gunzip'
`--ungzip'
`-z'
     This option tells `tar' to read or write archives through `gzip',
     allowing `tar' to directly operate on several kinds of compressed
     archives transparently.

`--help'
     `tar' will print out a short message summarizing the operations and
     options to `tar' and exit.

`--ignore-case'
     Ignore case when excluding files.

`--ignore-failed-read'
     Do not exit unsuccessfully merely because an unreadable file was
     encountered.  *Note Reading::.

`--ignore-zeros'
`-i'
     With this option, `tar' will ignore zeroed blocks in the archive,
     which normally signals EOF.  *Note Reading::.

`--incremental'
`-G'
     Used to inform `tar' that it is working with an  old GNU-format
     incremental backup archive.  It is intended primarily for backwards
     compatibility only.

`--info-script=SCRIPT-FILE'
`--new-volume-script=SCRIPT-FILE'
`-F SCRIPT-FILE'
     When `tar' is performing multi-tape backups, SCRIPT-FILE is run at
     the end of each tape.  If SCRIPT-FILE exits with nonzero status,
     `tar' fails immediately.

`--interactive'
`--confirmation'
`-w'
     Specifies that `tar' should ask the user for confirmation before
     performing potentially destructive options, such as overwriting
     files.

`--keep-old-files'
`-k'
     Do not overwrite existing files when extracting files from an
     archive.  *Note Writing::.

`--label=NAME'
`-V NAME'
     When creating an archive, instructs `tar' to write NAME as a name
     record in the archive.  When extracting or listing archives, `tar'
     will only operate on archives that have a label matching the
     pattern specified in NAME.

`--listed-incremental=SNAPSHOT-FILE'
`-g SNAPSHOT-FILE'
     During a `--create' operation, specifies that the archive that
     `tar' creates is a new GNU-format incremental backup, using
     SNAPSHOT-FILE to determine which files to backup.  With other
     operations, informs `tar' that the archive is in incremental
     format.

`--mode=PERMISSIONS'
     When adding files to an archive, `tar' will use PERMISSIONS for
     the archive members, rather than the permissions from the files.
     The program `chmod' and this `tar' option share the same syntax
     for what PERMISSIONS might be.  *Note Permissions: (fileutils)File
     permissions.  This reference also has useful information for those
     not being overly familiar with the Unix permission system.

     Of course, PERMISSIONS might be plainly specified as an octal
     number.  However, by using generic symbolic modifications to mode
     bits, this allows more flexibility.  For example, the value `a+rw'
     adds read and write permissions for everybody, while retaining
     executable bits on directories or on any other file already marked
     as executable.

`--multi-volume'
`-M'
     Informs `tar' that it should create or otherwise operate on a
     multi-volume `tar' archive.

`--new-volume-script'
     (see -info-script)

`--newer=DATE'
`--after-date=DATE'
`-N'
     When creating an archive, `tar' will only add files that have
     changed since DATE.  If DATE begins with `/' or `.', it is taken
     to be the name of a file whose last-modified time specifies the
     date.

`--newer-mtime=DATE'
     Like `--newer', but add only files whose contents have changed (as
     opposed to just `--newer', which will also back up files for which
     any status information has changed).

`--no-anchored'
     An exclude pattern can match any subsequence of the name's
     components.

`--no-ignore-case'
     Use case-sensitive matching when excluding files.

`--no-recursion'
     With this option, `tar' will not recurse into directories.

`--no-same-owner'
     When extracting an archive, do not attempt to preserve the owner
     specified in the `tar' archive.  This the default behavior for
     ordinary users; this option has an effect only for the superuser.

`--no-same-permissions'
     When extracting an archive, subtract the user's umask from files
     from the permissions specified in the archive.  This is the
     default behavior for ordinary users; this option has an effect
     only for the superuser.

`--no-wildcards'
     Do not use wildcards when excluding files.

`--no-wildcards-match-slash'
     Wildcards do not match `/' when excluding files.

`--null'
     When `tar' is using the `--files-from' option, this option
     instructs `tar' to expect filenames terminated with `NUL', so
     `tar' can correctly work with file names that contain newlines.

`--numeric-owner'
     This option will notify `tar' that it should use numeric user and
     group IDs when creating a `tar' file, rather than names.

`--old-archive'
     (See `--portability'.)

`--one-file-system'
`-l'
     Used when creating an archive.  Prevents `tar' from recursing into
     directories that are on different file systems from the current
     directory.

`--overwrite'
     Overwrite existing files and directory metadata when extracting
     files from an archive.  *Note Overwrite Old Files::.

`--overwrite-dir'
     Overwrite the metadata of existing directories when extracting
     files from an archive.  *Note Overwrite Old Files::.

`--owner=USER'
     Specifies that `tar' should use USER as the owner of members when
     creating archives, instead of the user associated with the source
     file.  USER is first decoded as a user symbolic name, but if this
     interpretation fails, it has to be a decimal numeric user ID.

     There is no value indicating a missing number, and `0' usually
     means `root'.  Some people like to force `0' as the value to offer
     in their distributions for the owner of files, because the `root'
     user is anonymous anyway, so that might as well be the owner of
     anonymous archives.

     This option does not affect extraction from archives.

`--portability'
`--old-archive'
`-o'
     Tells `tar' to create an archive that is compatible with Unix V7
     `tar'.

`--posix'
     Instructs `tar' to create a POSIX compliant `tar' archive.

`--preserve'
     Synonymous with specifying both `--preserve-permissions' and
     `--same-order'.

`--preserve-order'
     (See `--same-order'; *note Reading::.)

`--preserve-permissions'
`--same-permissions'
`-p'
     When `tar' is extracting an archive, it normally subtracts the
     users' umask from the permissions specified in the archive and
     uses that number as the permissions to create the destination
     file.  Specifying this option instructs `tar' that it should use
     the permissions directly from the archive.  *Note Writing::.

`--read-full-records'
`-B'
     Specifies that `tar' should reblock its input, for reading from
     pipes on systems with buggy implementations.  *Note Reading::.

`--record-size=SIZE'
     Instructs `tar' to use SIZE bytes per record when accessing the
     archive.

`--recursion'
     With this option, `tar' recurses into directories.

`--recursive-unlink'
     Remove existing directory hierarchies before extracting
     directories of the same name from the archive.  *Note Writing::.

`--remove-files'
     Directs `tar' to remove the source file from the file system after
     appending it to an archive.

`--rsh-command=CMD'
     Notifies `tar' that is should use CMD to communicate with remote
     devices.

`--same-order'
`--preserve-order'
`-s'
     This option is an optimization for `tar' when running on machines
     with small amounts of memory.  It informs `tar' that the list of
     file arguments has already been sorted to match the order of files
     in the archive.  *Note Reading::.

`--same-owner'
     When extracting an archive, `tar' will attempt to preserve the
     owner specified in the `tar' archive with this option present.
     This is the default behavior for the superuser; this option has an
     effect only for ordinary users.

`--same-permissions'
     (See `--preserve-permissions'; *note Writing::.)

`--show-omitted-dirs'
     Instructs `tar' to mention directories its skipping over when
     operating on a `tar' archive.

`--sparse'
`-S'
     Invokes a GNU extension when adding files to an archive that
     handles sparse files efficiently.

`--starting-file=NAME'
`-K NAME'
     This option affects extraction only; `tar' will skip extracting
     files in the archive until it finds one that matches NAME.  *Note
     Scarce::.

`--suffix=SUFFIX'
     Alters the suffix `tar' uses when backing up files from the default
     `~'.

`--tape-length=NUM'
`-L NUM'
     Specifies the length of tapes that `tar' is writing as being
     NUM x 1024 bytes long.

`--to-stdout'
`-O'
     During extraction, `tar' will extract files to stdout rather than
     to the file system.  *Note Writing::.

`--totals'
     Displays the total number of bytes written after creating an
     archive.

`--touch'
`-m'
     Sets the modification time of extracted files to the extraction
     time, rather than the modification time stored in the archive.
     *Note Writing::.

`--uncompress'
     (See `--compress'.)

`--ungzip'
     (See `--gzip'.)

`--unlink-first'
`-U'
     Directs `tar' to remove the corresponding file from the file
     system before extracting it from the archive.  *Note Writing::.

`--use-compress-program=PROG'
     Instructs `tar' to access the archive through PROG, which is
     presumed to be a compression program of some sort.

`--verbose'
`-v'
     Specifies that `tar' should be more verbose about the operations
     its performing.  This option can be specified multiple times for
     some operations to increase the amount of information displayed.

`--verify'
`-W'
     Verifies that the archive was correctly written when creating an
     archive.

`--version'
     `tar' will print an informational message about what version it is
     and a copyright message, some credits, and then exit.

`--volno-file=FILE'
     Used in conjunction with `--multi-volume'.  `tar' will keep track
     of which volume of a multi-volume archive its working in FILE.

`--wildcards'
     Use wildcards when excluding files.

`--wildcards-match-slash'
     Wildcards match `/' when excluding files.


File: tar.info,  Node: Short Option Summary,  Prev: Option Summary,  Up: All Options

Short Options Cross Reference
-----------------------------

   Here is an alphabetized list of all of the short option forms,
matching them with the equivalent long option.

`-A'
     `--concatenate'

`-B'
     `--read-full-records'

`-C'
     `--directory'

`-F'
     `--info-script'

`-G'
     `--incremental'

`-K'
     `--starting-file'

`-L'
     `--tape-length'

`-M'
     `--multi-volume'

`-N'
     `--newer'

`-O'
     `--to-stdout'

`-P'
     `--absolute-names'

`-R'
     `--block-number'

`-S'
     `--sparse'

`-T'
     `--files-from'

`-U'
     `--unlink-first'

`-V'
     `--label'

`-W'
     `--verify'

`-X'
     `--exclude-from'

`-Z'
     `--compress'

`-b'
     `--blocking-factor'

`-c'
     `--create'

`-d'
     `--compare'

`-f'
     `--file'

`-g'
     `--listed-incremental'

`-h'
     `--dereference'

`-i'
     `--ignore-zeros'

`-k'
     `--keep-old-files'

`-l'
     `--one-file-system'

`-m'
     `--touch'

`-o'
     `--portability'

`-p'
     `--preserve-permissions'

`-r'
     `--append'

`-s'
     `--same-order'

`-t'
     `--list'

`-u'
     `--update'

`-v'
     `--verbose'

`-w'
     `--interactive'

`-x'
     `--extract'

`-z'
     `--gzip'


File: tar.info,  Node: help,  Next: verbose,  Prev: All Options,  Up: tar invocation

GNU `tar' documentation
=======================

   Being careful, the first thing is really checking that you are using
GNU `tar', indeed.  The `--version' option will generate a message
giving confirmation that you are using GNU `tar', with the precise
version of GNU `tar' you are using.  `tar' identifies itself and prints
the version number to the standard output, then immediately exits
successfully, without doing anything else, ignoring all other options.
For example, `tar --version' might return:

     tar (GNU tar) 1.13.24

The first occurrence of `tar' in the result above is the program name
in the package (for example, `rmt' is another program), while the
second occurrence of `tar' is the name of the package itself,
containing possibly many programs.  The package is currently named
`tar', after the name of the main program it contains(1).

   Another thing you might want to do is checking the spelling or
meaning of some particular `tar' option, without resorting to this
manual, for once you have carefully read it.  GNU `tar' has a short help
feature, triggerable through the `--help' option.  By using this
option, `tar' will print a usage message listing all available options
on standard output, then exit successfully, without doing anything else
and ignoring all other options.  Even if this is only a brief summary,
it may be several screens long.  So, if you are not using some kind of
scrollable window, you might prefer to use something like:

     $ tar --help | less

presuming, here, that you like using `less' for a pager.  Other popular
pagers are `more' and `pg'.  If you know about some KEYWORD which
interests you and do not want to read all the `--help' output, another
common idiom is doing:

     tar --help | grep KEYWORD

for getting only the pertinent lines.

   The perceptive reader would have noticed some contradiction in the
previous paragraphs.  It is written that both `--version' and `--help'
print something, and have all other options ignored.  In fact, they
cannot ignore each other, and one of them has to win.  We do not
specify which is stronger, here; experiment if you really wonder!

   The short help output is quite succinct, and you might have to get
back to the full documentation for precise points.  If you are reading
this paragraph, you already have the `tar' manual in some form.  This
manual is available in printed form, as a kind of small book.  It may
printed out of the GNU `tar' distribution, provided you have TeX
already installed somewhere, and a laser printer around.  Just configure
the distribution, execute the command `make dvi', then print
`doc/tar.dvi' the usual way (contact your local guru to know how).  If
GNU `tar' has been conveniently installed at your place, this manual is
also available in interactive, hypertextual form as an Info file.  Just
call `info tar' or, if you do not have the `info' program handy, use
the Info reader provided within GNU Emacs, calling `tar' from the main
Info menu.

   There is currently no `man' page for GNU `tar'.  If you observe such
a `man' page on the system you are running, either it does not long to
GNU `tar', or it has not been produced by GNU.  Currently, GNU `tar'
documentation is provided in Texinfo format only, if we except, of
course, the short result of `tar --help'.

   ---------- Footnotes ----------

   (1) There are plans to merge the `cpio' and `tar' packages into a
single one which would be called `paxutils'.  So, who knows if, one of
this days, the `--version' would not yield `tar (GNU paxutils) 3.2'


File: tar.info,  Node: verbose,  Next: interactive,  Prev: help,  Up: tar invocation

Checking `tar' progress
=======================

   Typically, `tar' performs most operations without reporting any
information to the user except error messages.  When using `tar' with
many options, particularly ones with complicated or
difficult-to-predict behavior, it is possible to make serious mistakes.
`tar' provides several options that make observing `tar' easier.  These
options cause `tar' to print information as it progresses in its job,
and you might want to use them just for being more careful about what
is going on, or merely for entertaining yourself.  If you have
encountered a problem when operating on an archive, however, you may
need more information than just an error message in order to solve the
problem.  The following options can be helpful diagnostic tools.

   Normally, the `--list' (`-t') command to list an archive prints just
the file names (one per line) and the other commands are silent.  When
used with most operations, the `--verbose' (`-v') option causes `tar'
to print the name of each file or archive member as it is processed.
This and the other options which make `tar' print status information
can be useful in monitoring `tar'.

   With `--create' (`-c') or `--extract' (`--get', `-x'), `--verbose'
(`-v') used once just prints the names of the files or members as they
are processed.  Using it twice causes `tar' to print a longer listing
(reminiscent of `ls -l') for each member.  Since `--list' (`-t')
already prints the names of the members, `--verbose' (`-v') used once
with `--list' (`-t') causes `tar' to print an `ls -l' type listing of
the files in the archive.  The following examples both extract members
with long list output:

     $ tar --extract --file=archive.tar --verbose --verbose
     $ tar xvv archive.tar

   Verbose output appears on the standard output except when an archive
is being written to the standard output, as with `tar --create --file=-
--verbose' (`tar cfv -', or even `tar cv'--if the installer let
standard output be the default archive).  In that case `tar' writes
verbose output to the standard error stream.

   The `--totals' option--which is only meaningful when used with
`--create' (`-c')--causes `tar' to print the total amount written to
the archive, after it has been fully created.

   The `--checkpoint' option prints an occasional message as `tar'
reads or writes the archive.  In fact, it print directory names while
reading the archive.  It is designed for those who don't need the more
detailed (and voluminous) output of `--block-number' (`-R'), but do
want visual confirmation that `tar' is actually making forward progress.

   The `--show-omitted-dirs' option, when reading an archive--with
`--list' (`-t') or `--extract' (`--get', `-x'), for example--causes a
message to be printed for each directory in the archive which is
skipped.  This happens regardless of the reason for skipping: the
directory might not have been named on the command line (implicitly or
explicitly), it might be excluded by the use of the `--exclude=PATTERN'
option, or some other reason.

   If `--block-number' (`-R') is used, `tar' prints, along with every
message it would normally produce, the block number within the archive
where the message was triggered.  Also, supplementary messages are
triggered when reading blocks full of NULs, or when hitting end of file
on the archive.  As of now, if the archive if properly terminated with
a NUL block, the reading of the file may stop before end of file is
met, so the position of end of file will not usually show when
`--block-number' (`-R') is used.  Note that GNU `tar' drains the
archive before exiting when reading the archive from a pipe.

   This option is especially useful when reading damaged archives, since
it helps pinpoint the damaged sections.  It can also be used with
`--list' (`-t') when listing a file-system backup tape, allowing you to
choose among several backup tapes when retrieving a file later, in
favor of the tape where the file appears earliest (closest to the front
of the tape).


File: tar.info,  Node: interactive,  Prev: verbose,  Up: tar invocation

Asking for Confirmation During Operations
=========================================

   Typically, `tar' carries out a command without stopping for further
instructions.  In some situations however, you may want to exclude some
files and archive members from the operation (for instance if disk or
storage space is tight).  You can do this by excluding certain files
automatically (*note Choosing::), or by performing an operation
interactively, using the `--interactive' (`-w') option.  `tar' also
accepts `--confirmation' for this option.

   When the `--interactive' (`-w') option is specified, before reading,
writing, or deleting files, `tar' first prints a message for each such
file, telling what operation it intends to take, then asks for
confirmation on the terminal.  The actions which require confirmation
include adding a file to the archive, extracting a file from the
archive, deleting a file from the archive, and deleting a file from
disk.  To confirm the action, you must type a line of input beginning
with `y'.  If your input line begins with anything other than `y',
`tar' skips that file.

   If `tar' is reading the archive from the standard input, `tar' opens
the file `/dev/tty' to support the interactive communications.

   Verbose output is normally sent to standard output, separate from
other error messages.  However, if the archive is produced directly on
standard output, then verbose output is mixed with errors on `stderr'.
Producing the archive on standard output may be used as a way to avoid
using disk space, when the archive is soon to be consumed by another
process reading it, say.  Some people felt the need of producing an
archive on stdout, still willing to segregate between verbose output
and error output.  A possible approach would be using a named pipe to
receive the archive, and having the consumer process to read from that
named pipe.  This has the advantage of letting standard output free to
receive verbose output, all separate from errors.


File: tar.info,  Node: operations,  Next: Backups,  Prev: tar invocation,  Up: Top

GNU `tar' Operations
********************

* Menu:

* Basic tar::
* Advanced tar::
* create options::
* extract options::
* backup::
* Applications::
* looking ahead::


File: tar.info,  Node: Basic tar,  Next: Advanced tar,  Up: operations

Basic GNU `tar' Operations
==========================

   The basic `tar' operations, `--create' (`-c'), `--list' (`-t') and
`--extract' (`--get', `-x'), are currently presented and described in
the tutorial chapter of this manual.  This section provides some
complementary notes for these operations.

`--create' (`-c')
     Creating an empty archive would have some kind of elegance.  One
     can initialize an empty archive and later use `--append' (`-r')
     for adding all members.  Some applications would not welcome
     making an exception in the way of adding the first archive member.
     On the other hand, many people reported that it is dangerously
     too easy for `tar' to destroy a magnetic tape with an empty
     archive(1).  The two most common errors are:

       1. Mistakingly using `create' instead of `extract', when the
          intent was to extract the full contents of an archive.  This
          error is likely: keys `c' and `x' are right next ot each
          other on the QWERTY keyboard.  Instead of being unpacked, the
          archive then gets wholly destroyed.  When users speak about
          "exploding" an archive, they usually mean something else :-).

       2. Forgetting the argument to `file', when the intent was to
          create an archive with a single file in it.  This error is
          likely because a tired user can easily add the `f' key to the
          cluster of option letters, by the mere force of habit,
          without realizing the full consequence of doing so.  The
          usual consequence is that the single file, which was meant to
          be saved, is rather destroyed.

     So, recognizing the likelihood and the catastrophical nature of
     these errors, GNU `tar' now takes some distance from elegance, and
     cowardly refuses to create an archive when `--create' (`-c')
     option is given, there are no arguments besides options, and
     `--files-from=FILE-OF-NAMES' (`-T FILE-OF-NAMES') option is _not_
     used.  To get around the cautiousness of GNU `tar' and
     nevertheless create an archive with nothing in it, one may still
     use, as the value for the `--files-from=FILE-OF-NAMES' (`-T
     FILE-OF-NAMES') option, a file with no names in it, as shown in
     the following commands:

          tar --create --file=empty-archive.tar --files-from=/dev/null
          tar cfT empty-archive.tar /dev/null

`--extract' (`--get', `-x')
     A socket is stored, within a GNU `tar' archive, as a pipe.

`--list' (`-t')
     GNU `tar' now shows dates as `1996-08-30', while it used to show
     them as `Aug 30 1996'.  (One can revert to the old behavior by
     defining `USE_OLD_CTIME' in `src/list.c' before reinstalling.)
     But preferably, people should get used to ISO 8601 dates.  Local
     American dates should be made available again with full date
     localization support, once ready.  In the meantime, programs not
     being localizable for dates should prefer international dates,
     that's really the way to go.

     Look up <http://www.ft.uni-erlangen.de/~mskuhn/iso-time.html> if
     you are curious, it contains a detailed explanation of the ISO
     8601 standard.

   ---------- Footnotes ----------

   (1) This is well described in `Unix-haters Handbook', by Simson
Garfinkel, Daniel Weise & Steven Strassmann, IDG Books, ISBN
1-56884-203-1.


File: tar.info,  Node: Advanced tar,  Next: create options,  Prev: Basic tar,  Up: operations

Advanced GNU `tar' Operations
=============================

   Now that you have learned the basics of using GNU `tar', you may
want to learn about further ways in which `tar' can help you.

   This chapter presents five, more advanced operations which you
probably won't use on a daily basis, but which serve more specialized
functions.  We also explain the different styles of options and why you
might want to use one or another, or a combination of them in your `tar'
commands.  Additionally, this chapter includes options which allow you
to define the output from `tar' more carefully, and provide help and
error correction in special circumstances.

* Menu:

* Operations::
* current state::
* append::
* update::
* concatenate::
* delete::
* compare::


File: tar.info,  Node: Operations,  Next: current state,  Up: Advanced tar

The Five Advanced `tar' Operations
----------------------------------

     _(This message will disappear, once this node revised.)_

   In the last chapter, you learned about the first three operations to
`tar'.  This chapter presents the remaining five operations to `tar':
`--append', `--update', `--concatenate', `--delete', and `--compare'.

   You are not likely to use these operations as frequently as those
covered in the last chapter; however, since they perform specialized
functions, they are quite useful when you do need to use them.  We will
give examples using the same directory and files that you created in
the last chapter.  As you may recall, the directory is called
`practice', the files are `jazz', `blues', `folk', `rock', and the two
archive files you created are `collection.tar' and `music.tar'.

   We will also use the archive files `afiles.tar' and `bfiles.tar'.
`afiles.tar' contains the members `apple', `angst', and `aspic'.
`bfiles.tar' contains the members `./birds', `baboon', and `./box'.

   Unless we state otherwise, all practicing you do and examples you
follow in this chapter will take place in the `practice' directory that
you created in the previous chapter; see *Note prepare for examples::.
(Below in this section, we will remind you of the state of the examples
where the last chapter left them.)

   The five operations that we will cover in this chapter are:

`--append'
`-r'
     Add new entries to an archive that already exists.

`--update'
`-r'
     Add more recent copies of archive members to the end of an
     archive, if they exist.

`--concatenate'
`--catenate'
`-A'
     Add one or more pre-existing archives to the end of another
     archive.

`--delete'
     Delete items from an archive (does not work on tapes).

`--compare'
`--diff'
`-d'
     Compare archive members to their counterparts in the file system.


File: tar.info,  Node: current state,  Next: append,  Prev: Operations,  Up: Advanced tar

The Current State of the Practice Files
---------------------------------------

   Currently, the listing of the directory using `ls' is as follows:


The archive file `collection.tar' looks like this:

     $ tar -tvf collection.tar

The archive file `music.tar' looks like this:

     $ tar -tvf music.tar


File: tar.info,  Node: append,  Next: update,  Prev: current state,  Up: Advanced tar

How to Add Files to Existing Archives: `--append'
-------------------------------------------------

     _(This message will disappear, once this node revised.)_

   If you want to add files to an existing archive, you don't need to
create a new archive; you can use `--append' (`-r').  The archive must
already exist in order to use `--append'.  (A related operation is the
`--update' operation; you can use this to add newer versions of archive
members to an existing archive.  To learn how to do this with
`--update', *note update::.)

   If you use `--append' (`-r') to add a file that has the same name as
an archive member to an archive containing that archive member, then the
old member is not deleted.  What does happen, however, is somewhat
complex.  `tar' _allows_ you to have infinite numbers of files with the
same name.  Some operations treat these same-named members no
differently than any other set of archive members: for example, if you
view an archive with `--list' (`-t'), you will see all of those members
listed, with their modification times, owners, etc.

   Other operations don't deal with these members as perfectly as you
might prefer; if you were to use `--extract' (`--get', `-x') to extract
the archive, only the most recently added copy of a member with the
same name as four other members would end up in the working directory.
This is because `--extract' extracts an archive in the order the
members appeared in the archive; the most recently archived members
will be extracted last.  Additionally, an extracted member will
_replace_ a file of the same name which existed in the directory
already, and `tar' will not prompt you about this.  Thus, only the most
recently archived member will end up being extracted, as it will
replace the one extracted before it, and so on.

   There are a few ways to get around this.

   If you want to replace an archive member, use `--delete' to delete
the member you want to remove from the archive, , and then use
`--append' to add the member you want to be in the archive.  Note that
you can not change the order of the archive; the most recently added
member will still appear last.  In this sense, you cannot truly
"replace" one member with another.  (Replacing one member with another
will not work on certain types of media, such as tapes; see *Note
delete:: and *Note Media::, for more information.)

* Menu:

* appending files::             Appending Files to an Archive
* multiple::


File: tar.info,  Node: appending files,  Next: multiple,  Up: append

Appending Files to an Archive
.............................

     _(This message will disappear, once this node revised.)_

   The simplest way to add a file to an already existing archive is the
`--append' (`-r') operation, which writes specified files into the
archive whether or not they are already among the archived files.  When
you use `--append', you _must_ specify file name arguments, as there is
no default.  If you specify a file that already exists in the archive,
another copy of the file will be added to the end of the archive.  As
with other operations, the member names of the newly added files will
be exactly the same as their names given on the command line.  The
`--verbose' (`-v') option will print out the names of the files as they
are written into the archive.

   `--append' cannot be performed on some tape drives, unfortunately,
due to deficiencies in the formats those tape drives use.  The archive
must be a valid `tar' archive, or else the results of using this
operation will be unpredictable.  *Note Media::.

   To demonstrate using `--append' to add a file to an archive, create
a file called `rock' in the `practice' directory.  Make sure you are in
the `practice' directory.  Then, run the following `tar' command to add
`rock' to `collection.tar':

     $ tar --append --file=collection.tar rock

If you now use the `--list' (`-t') operation, you will see that `rock'
has been added to the archive:

     $ tar --list --file=collection.tar
     -rw-rw-rw- me user     28 1996-10-18 16:31 jazz
     -rw-rw-rw- me user     21 1996-09-23 16:44 blues
     -rw-rw-rw- me user     20 1996-09-23 16:44 folk
     -rw-rw-rw- me user     20 1996-09-23 16:44 rock


File: tar.info,  Node: multiple,  Prev: appending files,  Up: append

Multiple Files with the Same Name
.................................

   You can use `--append' (`-r') to add copies of files which have been
updated since the archive was created.  (However, we do not recommend
doing this since there is another `tar' option called `--update'; *note
update:: for more information.  We describe this use of `--append' here
for the sake of completeness.)  When you extract the archive, the older
version will be effectively lost.  This works because files are
extracted from an archive in the order in which they were archived.
Thus, when the archive is extracted, a file archived later in time will
replace a file of the same name which was archived earlier, even though
the older version of the file will remain in the archive unless you
delete all versions of the file.

   Supposing you change the file `blues' and then append the changed
version to `collection.tar'.  As you saw above, the original `blues' is
in the archive `collection.tar'.  If you change the file and append the
new version of the file to the archive, there will be two copies in the
archive.  When you extract the archive, the older version of the file
will be extracted first, and then replaced by the newer version when it
is extracted.

   You can append the new, changed copy of the file `blues' to the
archive in this way:

     $ tar --append --verbose --file=collection.tar blues
     blues

Because you specified the `--verbose' option, `tar' has printed the
name of the file being appended as it was acted on.  Now list the
contents of the archive:

     $ tar --list --verbose --file=collection.tar
     -rw-rw-rw- me user     28 1996-10-18 16:31 jazz
     -rw-rw-rw- me user     21 1996-09-23 16:44 blues
     -rw-rw-rw- me user     20 1996-09-23 16:44 folk
     -rw-rw-rw- me user     20 1996-09-23 16:44 rock
     -rw-rw-rw- me user     58 1996-10-24 18:30 blues

The newest version of `blues' is now at the end of the archive (note
the different creation dates and file sizes).  If you extract the
archive, the older version of the file `blues' will be replaced by the
newer version.  You can confirm this by extracting the archive and
running `ls' on the directory.  *Note Writing::, for more information.
(_Please note:_ This is the case unless you employ the `--backup'
option. .)


File: tar.info,  Node: update,  Next: concatenate,  Prev: append,  Up: Advanced tar

Updating an Archive
-------------------

     _(This message will disappear, once this node revised.)_

   In the previous section, you learned how to use `--append' (`-r') to
add a file to an existing archive.  A related operation is `--update'
(`-u').  The `--update' operation updates a `tar' archive by comparing
the date of the specified archive members against the date of the file
with the same name.  If the file has been modified more recently than
the archive member, then the newer version of the file is added to the
archive (as with `--append' (`-r')).

   Unfortunately, you cannot use `--update' with magnetic tape drives.
The operation will fail.

   Both `--update' and `--append' work by adding to the end of the
archive.  When you extract a file from the archive, only the version
stored last will wind up in the file system, unless you use the
`--backup' option.

* Menu:

* how to update::


File: tar.info,  Node: how to update,  Up: update

How to Update an Archive Using `--update'
.........................................

   You must use file name arguments with the `--update' (`-u')
operation.  If you don't specify any files, `tar' won't act on any
files and won't tell you that it didn't do anything (which may end up
confusing you).

   To see the `--update' option at work, create a new file,
`classical', in your practice directory, and some extra text to the
file `blues', using any text editor.  Then invoke `tar' with the
`update' operation and the `--verbose' (`-v') option specified, using
the names of all the files in the practice directory as file name
arguments:

     $ tar --update -v -f collection.tar blues folk rock classical
     blues
     classical
     $

Because we have specified verbose mode, `tar' prints out the names of
the files it is working on, which in this case are the names of the
files that needed to be updated.  If you run `tar --list' and look at
the archive, you will see `blues' and `classical' at its end.  There
will be a total of two versions of the member `blues'; the one at the
end will be newer and larger, since you added text before updating it.

   (The reason `tar' does not overwrite the older file when updating it
is because writing to the middle of a section of tape is a difficult
process.  Tapes are not designed to go backward.  *Note Media::, for
more information about tapes.

   `--update' (`-u') is not suitable for performing backups for two
reasons: it does not change directory content entries, and it lengthens
the archive every time it is used.  The GNU `tar' options intended
specifically for backups are more efficient.  If you need to run
backups, please consult *Note Backups::.


File: tar.info,  Node: concatenate,  Next: delete,  Prev: update,  Up: Advanced tar

Combining Archives with `--concatenate'
---------------------------------------

   Sometimes it may be convenient to add a second archive onto the end
of an archive rather than adding individual files to the archive.  To
add one or more archives to the end of another archive, you should use
the `--concatenate' (`--catenate', `-A') operation.

   To use `--concatenate', name the archives to be concatenated on the
command line.  (Nothing happens if you don't list any.)  The members,
and their member names, will be copied verbatim from those archives.  If
this causes multiple members to have the same name, it does not delete
any members; all the members with the same name coexist.

   To demonstrate how `--concatenate' works, create two small archives
called `bluesrock.tar' and `folkjazz.tar', using the relevant files
from `practice':

     $ tar -cvf bluesrock.tar blues rock
     blues
     classical
     $ tar -cvf folkjazz.tar folk jazz
     folk
     jazz

If you like, You can run `tar --list' to make sure the archives contain
what they are supposed to:

     $ tar -tvf bluesrock.tar
     -rw-rw-rw- melissa user    105 1997-01-21 19:42 blues
     -rw-rw-rw- melissa user     33 1997-01-20 15:34 rock
     $ tar -tvf folkjazz.tar
     -rw-rw-rw- melissa user     20 1996-09-23 16:44 folk
     -rw-rw-rw- melissa user     65 1997-01-30 14:15 jazz

   We can concatenate these two archives with `tar':

     $ cd ..
     $ tar --concatenate --file=bluesrock.tar jazzfolk.tar

   If you now list the contents of the `bluesclass.tar', you will see
that now it also contains the archive members of `jazzfolk.tar':

     $ tar --list --file=bluesrock.tar
     blues
     rock
     jazz
     folk

   When you use `--concatenate', the source and target archives must
already exist and must have been created using compatible format
parameters.  The new, concatenated archive will be called by the same
name as the first archive listed on the command line.

   Like `--append' (`-r'), this operation cannot be performed on some
tape drives, due to deficiencies in the formats those tape drives use.

   It may seem more intuitive to you to want or try to use `cat' to
concatenate two archives instead of using the `--concatenate'
operation; after all, `cat' is the utility for combining files.

   However, `tar' archives incorporate an end-of-file marker which must
be removed if the concatenated archives are to be read properly as one
archive.  `--concatenate' removes the end-of-archive marker from the
target archive before each new archive is appended.  If you use `cat'
to combine the archives, the result will not be a valid `tar' format
archive.  If you need to retrieve files from an archive that was added
to using the `cat' utility, use the `--ignore-zeros' (`-i') option.
*Note Ignore Zeros::, for further information on dealing with archives
improperly combined using the `cat' shell utility.

   You must specify the source archives using `--file=ARCHIVE-NAME'
(`-f ARCHIVE-NAME') (*note file::).  If you do not specify the target
archive, `tar' uses the value of the environment variable `TAPE', or,
if this has not been set, the default archive name.


File: tar.info,  Node: delete,  Next: compare,  Prev: concatenate,  Up: Advanced tar

Removing Archive Members Using `--delete'
-----------------------------------------

     _(This message will disappear, once this node revised.)_

   You can remove members from an archive by using the `--delete'
option.  Specify the name of the archive with `--file=ARCHIVE-NAME'
(`-f ARCHIVE-NAME') and then specify the names of the members to be
deleted; if you list no member names, nothing will be deleted.  The
`--verbose' (`-v') option will cause `tar' to print the names of the
members as they are deleted.  As with `--extract' (`--get', `-x'), you
must give the exact member names when using `tar --delete'.  `--delete'
will remove all versions of the named file from the archive.  The
`--delete' operation can run very slowly.

   Unlike other operations, `--delete' has no short form.

   This operation will rewrite the archive.  You can only use
`--delete' on an archive if the archive device allows you to write to
any point on the media, such as a disk; because of this, it does not
work on magnetic tapes.  Do not try to delete an archive member from a
magnetic tape; the action will not succeed, and you will be likely to
scramble the archive and damage your tape.  There is no safe way
(except by completely re-writing the archive) to delete files from most
kinds of magnetic tape.  *Note Media::.

   To delete all versions of the file `blues' from the archive
`collection.tar' in the `practice' directory, make sure you are in that
directory, and then,

     $ tar --list --file=collection.tar
     blues
     folk
     jazz
     rock
     practice/blues
     practice/folk
     practice/jazz
     practice/rock
     practice/blues
     $ tar --delete --file=collection.tar blues
     $ tar --list --file=collection.tar
     folk
     jazz
     rock
     $

   The `--delete' option has been reported to work properly when `tar'
acts as a filter from `stdin' to `stdout'.


File: tar.info,  Node: compare,  Prev: delete,  Up: Advanced tar

Comparing Archive Members with the File System
----------------------------------------------

     _(This message will disappear, once this node revised.)_

   The `--compare' (`-d'), or `--diff' operation compares specified
archive members against files with the same names, and then reports
differences in file size, mode, owner, modification date and contents.
You should _only_ specify archive member names, not file names.  If you
do not name any members, then `tar' will compare the entire archive.
If a file is represented in the archive but does not exist in the file
system, `tar' reports a difference.

   You have to specify the record size of the archive when modifying an
archive with a non-default record size.

   `tar' ignores files in the file system that do not have
corresponding members in the archive.

   The following example compares the archive members `rock', `blues'
and `funk' in the archive `bluesrock.tar' with files of the same name
in the file system.  (Note that there is no file, `funk'; `tar' will
report an error message.)

     $ tar --compare --file=bluesrock.tar rock blues funk
     rock
     blues
     tar: funk not found in archive

Depending on the system where you are running `tar' and the version you
are running, `tar' may have a different error message, such as:

     funk: does not exist

   The spirit behind the `--compare' (`--diff', `-d') option is to
check whether the archive represents the current state of files on
disk, more than validating the integrity of the archive media.  For
this later goal, *Note verify::.


File: tar.info,  Node: create options,  Next: extract options,  Prev: Advanced tar,  Up: operations

Options Used by `--create'
==========================

   The previous chapter described the basics of how to use `--create'
(`-c') to create an archive from a set of files.  *Note create::.  This
section described advanced options to be used with `--create'.

* Menu:

* Ignore Failed Read::


File: tar.info,  Node: Ignore Failed Read,  Up: create options

Ignore Fail Read
----------------

`--ignore-failed-read'
     Do not exit with nonzero on unreadable files or directories.


File: tar.info,  Node: extract options,  Next: backup,  Prev: create options,  Up: operations

Options Used by `--extract'
===========================

     _(This message will disappear, once this node revised.)_

   The previous chapter showed how to use `--extract' (`--get', `-x')
to extract an archive into the filesystem.  Various options cause `tar'
to extract more information than just file contents, such as the owner,
the permissions, the modification date, and so forth.  This section
presents options to be used with `--extract' when certain special
considerations arise.  You may review the information presented in
*Note extract:: for more basic information about the `--extract'
operation.

* Menu:

* Reading::                     Options to Help Read Archives
* Writing::                     Changing How `tar' Writes Files
* Scarce::                      Coping with Scarce Resources


File: tar.info,  Node: Reading,  Next: Writing,  Up: extract options

Options to Help Read Archives
-----------------------------

     _(This message will disappear, once this node revised.)_

   Normally, `tar' will request data in full record increments from an
archive storage device.  If the device cannot return a full record,
`tar' will report an error.  However, some devices do not always return
full records, or do not require the last record of an archive to be
padded out to the next record boundary.  To keep reading until you
obtain a full record, or to accept an incomplete record if it contains
an end-of-archive marker, specify the `--read-full-records' (`-B')
option in conjunction with the `--extract' (`--get', `-x') or `--list'
(`-t') operations.  *Note Blocking::.

   The `--read-full-records' (`-B') option is turned on by default when
`tar' reads an archive from standard input, or from a remote machine.
This is because on BSD Unix systems, attempting to read a pipe returns
however much happens to be in the pipe, even if it is less than was
requested.  If this option were not enabled, `tar' would fail as soon
as it read an incomplete record from the pipe.

   If you're not sure of the blocking factor of an archive, you can
read the archive by specifying `--read-full-records' (`-B') and
`--blocking-factor=512-SIZE' (`-b 512-SIZE'), using a blocking factor
larger than what the archive uses.  This lets you avoid having to
determine the blocking factor of an archive.  *Note Blocking Factor::.

* Menu:

* read full records::
* Ignore Zeros::


File: tar.info,  Node: read full records,  Next: Ignore Zeros,  Up: Reading

Reading Full Records
....................

`--read-full-records'

`-B'
     Use in conjunction with `--extract' (`--get', `-x') to read an
     archive which contains incomplete records, or one which has a
     blocking factor less than the one specified.


File: tar.info,  Node: Ignore Zeros,  Prev: read full records,  Up: Reading

Ignoring Blocks of Zeros
........................

   Normally, `tar' stops reading when it encounters a block of zeros
between file entries (which usually indicates the end of the archive).
`--ignore-zeros' (`-i') allows `tar' to completely read an archive
which contains a block of zeros before the end (i.e. a damaged archive,
or one which was created by concatenating several archives together).

   The `--ignore-zeros' (`-i') option is turned off by default because
many versions of `tar' write garbage after the end-of-archive entry,
since that part of the media is never supposed to be read.  GNU `tar'
does not write after the end of an archive, but seeks to maintain
compatiblity among archiving utilities.

`--ignore-zeros'
`-i'
     To ignore blocks of zeros (ie. end-of-archive entries) which may be
     encountered while reading an archive.  Use in conjunction with
     `--extract' (`--get', `-x') or `--list' (`-t').


File: tar.info,  Node: Writing,  Next: Scarce,  Prev: Reading,  Up: extract options

Changing How `tar' Writes Files
-------------------------------

     _(This message will disappear, once this node revised.)_

* Menu:

* Dealing with Old Files::
* Overwrite Old Files::
* Keep Old Files::
* Unlink First::
* Recursive Unlink::
* Modification Times::
* Setting Access Permissions::
* Writing to Standard Output::
* remove files::


File: tar.info,  Node: Dealing with Old Files,  Next: Overwrite Old Files,  Up: Writing

Options Controlling the Overwriting of Existing Files
.....................................................

   When extracting files, if `tar' discovers that the extracted file
already exists, it normally replaces the file by removing it before
extracting it, to prevent confusion in the presence of hard or symbolic
links.  (If the existing file is a symbolic link, it is removed, not
followed.)  However, if a directory cannot be removed because it is
nonempty, `tar' neither removes it nor modifies its ownership,
permissions, or time stamps.

   To be more cautious and prevent existing files from being replaced,
use the `--keep-old-files' (`-k') option.  It causes `tar' to refuse to
replace or update a file that already exists, i.e., a file with the
same name as an archive member prevents extraction of that archive
member.  Instead, it reports an error.

   To be more aggressive about altering existing files, use the
`--overwrite' option.  It causes `tar' to overwrite existing files and
to follow existing symbolic links when extracting.  The
`--overwrite-dir' option is somewhat more conservative than
`--overwrite': it overwrites metadata (ownership, permission, etc.) for
directories, but removes other files before extracting them.

   Some people argue that GNU `tar' should not hesitate to overwrite
files with other files when extracting.  When extracting a `tar'
archive, they expect to see a faithful copy of the state of the
filesystem when the archive was created.  It is debatable that this
would always be a proper behavior.  For example, suppose one has an
archive in which `usr/local' is a link to `usr/local2'.  Since then,
maybe the site removed the link and renamed the whole hierarchy from
`/usr/local2' to `/usr/local'.  Such things happen all the time.  I
guess it would not be welcome at all that GNU `tar' removes the whole
hierarchy just to make room for the link to be reinstated (unless it
_also_ simultaneously restores the full `/usr/local2', of course!  GNU
`tar' is indeed able to remove a whole hierarchy to reestablish a
symbolic link, for example, but _only if_ `--recursive-unlink' is
specified to allow this behavior.  In any case, single files are
silently removed.

   Finally, the `--unlink-first' (`-U') option can improve performance
in some cases by causing `tar' to remove files unconditionally before
extracting them.


File: tar.info,  Node: Overwrite Old Files,  Next: Keep Old Files,  Prev: Dealing with Old Files,  Up: Writing

Overwrite Old Files
...................

`--overwrite'
     Overwrite existing files and directory metadata when extracting
     files from an archive.

     This causes `tar' to write extracted files into the file system
     without regard to the files already on the system; i.e., files
     with the same names as archive members are overwritten when the
     archive is extracted.  It also causes `tar' to extract the
     ownership, permissions, and time stamps onto any preexisting files
     or directories.  If the name of a corresponding file name is a
     symbolic link, the file pointed to by the symbolic link will be
     overwritten instead of the symbolic link itself (if this is
     possible).  Moreover, special devices, empty directories and even
     symbolic links are automatically removed if they are in the way of
     extraction.

     Be careful when using the `--overwrite' option, particularly when
     combined with the `--absolute-names' (`-P') option, as this
     combination can change the contents, ownership or permissions of
     any file on your system.  Also, many systems do not take kindly to
     overwriting files that are currently being executed.

`--overwrite-dir'
     Overwrite the metadata of directories when extracting files from an
     archive, but remove other files before extracting.


File: tar.info,  Node: Keep Old Files,  Next: Unlink First,  Prev: Overwrite Old Files,  Up: Writing

Keep Old Files
..............

`--keep-old-files'
`-k'
     Do not replace existing files from archive.  The
     `--keep-old-files' (`-k') option prevents `tar' from replacing
     existing files with files with the same name from the archive.
     The `--keep-old-files' (`-k') option is meaningless with `--list'
     (`-t').  Prevents `tar' from replacing files in the file system
     during extraction.


File: tar.info,  Node: Unlink First,  Next: Recursive Unlink,  Prev: Keep Old Files,  Up: Writing

Unlink First
............

`--unlink-first'
`-U'
     Remove files before extracting over them.  This can make `tar' run
     a bit faster if you know in advance that the extracted files all
     need to be removed.  Normally this option slows `tar' down
     slightly, so it is disabled by default.


File: tar.info,  Node: Recursive Unlink,  Next: Modification Times,  Prev: Unlink First,  Up: Writing

Recursive Unlink
................

`--recursive-unlink'
     When this option is specified, try removing files and directory
     hierarchies before extracting over them.  _This is a dangerous
     option!_

   If you specify the `--recursive-unlink' option, `tar' removes
_anything_ that keeps you from extracting a file as far as current
permissions will allow it.  This could include removal of the contents
of a full directory hierarchy.


File: tar.info,  Node: Modification Times,  Next: Setting Access Permissions,  Prev: Recursive Unlink,  Up: Writing

Setting Modification Times
..........................

   Normally, `tar' sets the modification times of extracted files to
the modification times recorded for the files in the archive, but
limits the permissions of extracted files by the current `umask'
setting.

   To set the modification times of extracted files to the time when
the files were extracted, use the `--touch' (`-m') option in
conjunction with `--extract' (`--get', `-x').

`--touch'
`-m'
     Sets the modification time of extracted archive members to the time
     they were extracted, not the time recorded for them in the archive.
     Use in conjunction with `--extract' (`--get', `-x').


File: tar.info,  Node: Setting Access Permissions,  Next: Writing to Standard Output,  Prev: Modification Times,  Up: Writing

Setting Access Permissions
..........................

   To set the modes (access permissions) of extracted files to those
recorded for those files in the archive, use `--same-permissions' in
conjunction with the `--extract' (`--get', `-x') operation.

`--preserve-permission'
`--same-permission'
`--ignore-umask'
`-p'
     Set modes of extracted archive members to those recorded in the
     archive, instead of current umask settings.  Use in conjunction
     with `--extract' (`--get', `-x').


File: tar.info,  Node: Writing to Standard Output,  Next: remove files,  Prev: Setting Access Permissions,  Up: Writing

Writing to Standard Output
..........................

   To write the extracted files to the standard output, instead of
creating the files on the file system, use `--to-stdout' (`-O') in
conjunction with `--extract' (`--get', `-x').  This option is useful if
you are extracting files to send them through a pipe, and do not need to
preserve them in the file system.  If you extract multiple members,
they appear on standard output concatenated, in the order they are
found in the archive.

`--to-stdout'
`-O'
     Writes files to the standard output.  Used in conjunction with
     `--extract' (`--get', `-x').  Extract files to standard output.
     When this option is used, instead of creating the files specified,
     `tar' writes the contents of the files extracted to its standard
     output.  This may be useful if you are only extracting the files
     in order to send them through a pipe.  This option is meaningless
     with `--list' (`-t').


File: tar.info,  Node: remove files,  Prev: Writing to Standard Output,  Up: Writing

Removing Files
..............

`--remove-files'
     Remove files after adding them to the archive.


File: tar.info,  Node: Scarce,  Prev: Writing,  Up: extract options

Coping with Scarce Resources
----------------------------

     _(This message will disappear, once this node revised.)_

* Menu:

* Starting File::
* Same Order::


File: tar.info,  Node: Starting File,  Next: Same Order,  Up: Scarce

Starting File
.............

`--starting-file=NAME'
`-K NAME'
     Starts an operation in the middle of an archive.  Use in
     conjunction with `--extract' (`--get', `-x') or `--list' (`-t').

   If a previous attempt to extract files failed due to lack of disk
space, you can use `--starting-file=NAME' (`-K NAME') to start
extracting only after member NAME of the archive.  This assumes, of
course, that there is now free space, or that you are now extracting
into a different file system.  (You could also choose to suspend `tar',
remove unnecessary files from the file system, and then restart the
same `tar' operation.  In this case, `--starting-file=NAME' (`-K NAME')
is not necessary.  *Note Inc Dumps::, *Note interactive::, and
*Note exclude::.)


File: tar.info,  Node: Same Order,  Prev: Starting File,  Up: Scarce

Same Order
..........

`--same-order'
`--preserve-order'
`-s'
     To process large lists of file names on machines with small
     amounts of memory.  Use in conjunction with `--compare' (`--diff',
     `-d'), `--list' (`-t') or `--extract' (`--get', `-x').

   The `--same-order' (`--preserve-order', `-s') option tells `tar'
that the list of file names to be listed or extracted is sorted in the
same order as the files in the archive.  This allows a large list of
names to be used, even on a small machine that would not otherwise be
able to hold all the names in memory at the same time.  Such a sorted
list can easily be created by running `tar -t' on the archive and
editing its output.

   This option is probably never needed on modern computer systems.


File: tar.info,  Node: backup,  Next: Applications,  Prev: extract options,  Up: operations

Backup options
==============

   GNU `tar' offers options for making backups of files before writing
new versions.  These options control the details of these backups.
They may apply to the archive itself before it is created or rewritten,
as well as individual extracted members.  Other GNU programs (`cp',
`install', `ln', and `mv', for example) offer similar options.

   Backup options may prove unexpectedly useful when extracting archives
containing many members having identical name, or when extracting
archives on systems having file name limitations, making different
members appear has having similar names through the side-effect of name
truncation.  (This is true only if we have a good scheme for truncated
backup names, which I'm not sure at all: I suspect work is needed in
this area.)  When any existing file is backed up before being
overwritten by extraction, then clashing files are automatically be
renamed to be unique, and the true name is kept for only the last file
of a series of clashing files.  By using verbose mode, users may track
exactly what happens.

   At the detail level, some decisions are still experimental, and may
change in the future, we are waiting comments from our users.  So,
please do not learn to depend blindly on the details of the backup
features.  For example, currently, directories themselves are never
renamed through using these options, so, extracting a file over a
directory still has good chances to fail.  Also, backup options apply
to created archives, not only to extracted members.  For created
archives, backups will not be attempted when the archive is a block or
character device, or when it refers to a remote file.

   For the sake of simplicity and efficiency, backups are made by
renaming old files prior to creation or extraction, and not by copying.
The original name is restored if the file creation fails.  If a
failure occurs after a partial extraction of a file, both the backup
and the partially extracted file are kept.

`--backup[=METHOD]'
     Back up files that are about to be overwritten or removed.
     Without this option, the original versions are destroyed.

     Use METHOD to determine the type of backups made.  If METHOD is
     not specified, use the value of the `VERSION_CONTROL' environment
     variable.  And if `VERSION_CONTROL' is not set, use the `existing'
     method.

     This option corresponds to the Emacs variable `version-control';
     the same values for METHOD are accepted as in Emacs.  This option
     also allows more descriptive names.  The valid METHODs are:

    `t'
    `numbered'
          Always make numbered backups.

    `nil'
    `existing'
          Make numbered backups of files that already have them, simple
          backups of the others.

    `never'
    `simple'
          Always make simple backups.

`--suffix=SUFFIX'
     Append SUFFIX to each backup file made with `--backup'.  If this
     option is not specified, the value of the `SIMPLE_BACKUP_SUFFIX'
     environment variable is used.  And if `SIMPLE_BACKUP_SUFFIX' is not
     set, the default is `~', just as in Emacs.

   Some people express the desire to _always_ use the `--backup'
option, by defining some kind of alias or script.  This is not as easy
as one may think, due to the fact that old style options should appear
first and consume arguments a bit unpredictably for an alias or script.
But, if you are ready to give up using old style options, you may
resort to using something like (a Bourne shell function here):

     tar () { /usr/local/bin/tar --backup $*; }


File: tar.info,  Node: Applications,  Next: looking ahead,  Prev: backup,  Up: operations

Notable `tar' Usages
====================

     _(This message will disappear, once this node revised.)_

   You can easily use archive files to transport a group of files from
one system to another: put all relevant files into an archive on one
computer system, transfer the archive to another system, and extract
the contents there.  The basic transfer medium might be magnetic tape,
Internet FTP, or even electronic mail (though you must encode the
archive with `uuencode' in order to transport it properly by mail).
Both machines do not have to use the same operating system, as long as
they both support the `tar' program.

   For example, here is how you might copy a directory's contents from
one disk to another, while preserving the dates, modes, owners and
link-structure of all the files therein.  In this case, the transfer
medium is a "pipe", which is one a Unix redirection mechanism:

     $ cd sourcedir; tar -cf - . | (cd targetdir; tar -xf -)

The command also works using short option forms:

     $ cd sourcedir; tar --create --file=- . | (cd targetdir; tar --extract --file=-)

This is one of the easiest methods to transfer a `tar' archive.


File: tar.info,  Node: looking ahead,  Prev: Applications,  Up: operations

Looking Ahead: The Rest of this Manual
======================================

   You have now seen how to use all eight of the operations available to
`tar', and a number of the possible options.  The next chapter explains
how to choose and change file and archive names, how to use files to
store names of other files which you can then call as arguments to
`tar' (this can help you save time if you expect to archive the same
list of files a number of times), and so forth.

   If there are too many files to conveniently list on the command line,
you can list the names in a file, and `tar' will read that file.
*Note files::.

   There are various ways of causing `tar' to skip over some files, and
not archive them.  *Note Choosing::.


File: tar.info,  Node: Backups,  Next: Choosing,  Prev: operations,  Up: Top

Performing Backups and Restoring Files
**************************************

     _(This message will disappear, once this node revised.)_

   GNU `tar' is distributed along with the scripts which the Free
Software Foundation uses for performing backups.  There is no
corresponding scripts available yet for doing restoration of files.
Even if there is a good chance those scripts may be satisfying to you,
they are not the only scripts or methods available for doing backups
and restore.  You may well create your own, or use more sophisticated
packages dedicated to that purpose.

   Some users are enthusiastic about `Amanda' (The Advanced Maryland
Automatic Network Disk Archiver), a backup system developed by James da
Silva `jds@cs.umd.edu' and available on many Unix systems.  This is
free software, and it is available at these places:

     http://www.cs.umd.edu/projects/amanda/amanda.html
     ftp://ftp.cs.umd.edu/pub/amanda

   Here is a possible plan for a future documentation about the
backuping scripts which are provided within the GNU `tar' distribution.

     .* dumps
     . + what are dumps
     
     . + different levels of dumps
     .  - full dump = dump everything
     .  - level 1, level 2 dumps etc, -
     	A level n dump dumps everything changed since the last level
     	n-1 dump (?)
     
     . + how to use scripts for dumps  (ie, the concept)
     .  - scripts to run after editing backup specs (details)
     
     . + Backup Specs, what is it.
     .  - how to customize
     .  - actual text of script  [/sp/dump/backup-specs]
     
     . + Problems
     .  - rsh doesn't work
     .  - rtape isn't installed
     .  - (others?)
     
     . + the --incremental option of tar
     
     . + tapes
     .  - write protection
     .  - types of media
     .   : different sizes and types, useful for different things
     .  - files and tape marks
          one tape mark between files, two at end.
     .  - positioning the tape
          MT writes two at end of write,
            backspaces over one when writing again.

   This chapter documents both the provided FSF scripts and `tar'
options which are more specific to usage as a backup tool.

   To "back up" a file system means to create archives that contain all
the files in that file system.  Those archives can then be used to
restore any or all of those files (for instance if a disk crashes or a
file is accidentally deleted).  File system "backups" are also called
"dumps".

* Menu:

* Full Dumps::                  Using `tar' to Perform Full Dumps
* Inc Dumps::                   Using `tar' to Perform Incremental Dumps
* incremental and listed-incremental::  The Incremental Options
* Backup Levels::               Levels of Backups
* Backup Parameters::           Setting Parameters for Backups and Restoration
* Scripted Backups::            Using the Backup Scripts
* Scripted Restoration::        Using the Restore Script


File: tar.info,  Node: Full Dumps,  Next: Inc Dumps,  Up: Backups

Using `tar' to Perform Full Dumps
=================================

     _(This message will disappear, once this node revised.)_

   Full dumps should only be made when no other people or programs are
modifying files in the filesystem.  If files are modified while `tar'
is making the backup, they may not be stored properly in the archive,
in which case you won't be able to restore them if you have to.  (Files
not being modified are written with no trouble, and do not corrupt the
entire archive.)

   You will want to use the `--label=ARCHIVE-LABEL' (`-V
ARCHIVE-LABEL') option to give the archive a volume label, so you can
tell what this archive is even if the label falls off the tape, or
anything like that.

   Unless the filesystem you are dumping is guaranteed to fit on one
volume, you will need to use the `--multi-volume' (`-M') option.  Make
sure you have enough tapes on hand to complete the backup.

   If you want to dump each filesystem separately you will need to use
the `--one-file-system' (`-l') option to prevent `tar' from crossing
filesystem boundaries when storing (sub)directories.

   The `--incremental' (`-G') option is not needed, since this is a
complete copy of everything in the filesystem, and a full restore from
this backup would only be done onto a completely empty disk.

   Unless you are in a hurry, and trust the `tar' program (and your
tapes), it is a good idea to use the `--verify' (`-W') option, to make
sure your files really made it onto the dump properly.  This will also
detect cases where the file was modified while (or just after) it was
being archived.  Not all media (notably cartridge tapes) are capable of
being verified, unfortunately.

   `--listed-incremental=SNAPSHOT-FILE' (`-g SNAPSHOT-FILE') take a
file name argument always.  If the file doesn't exist, run a level zero
dump, creating the file.  If the file exists, uses that file to see
what has changed.

   `--incremental' (`-G')

   `--incremental' (`-G') handle old GNU-format incremental backup.

   This option should only be used when creating an incremental backup
of a filesystem.  When the `--incremental' (`-G') option is used, `tar'
writes, at the beginning of the archive, an entry for each of the
directories that will be operated on.  The entry for a directory
includes a list of all the files in the directory at the time the dump
was done, and a flag for each file indicating whether the file is going
to be put in the archive.  This information is used when doing a
complete incremental restore.

   Note that this option causes `tar' to create a non-standard archive
that may not be readable by non-GNU versions of the `tar' program.

   The `--incremental' (`-G') option means the archive is an incremental
backup.  Its meaning depends on the command that it modifies.

   If the `--incremental' (`-G') option is used with `--list' (`-t'),
`tar' will list, for each directory in the archive, the list of files in
that directory at the time the archive was created.  This information
is put out in a format that is not easy for humans to read, but which
is unambiguous for a program: each file name is preceded by either a
`Y' if the file is present in the archive, an `N' if the file is not
included in the archive, or a `D' if the file is a directory (and is
included in the archive).  Each file name is terminated by a null
character.  The last file is followed by an additional null and a
newline to indicate the end of the data.

   If the `--incremental' (`-G') option is used with `--extract'
(`--get', `-x'), then when the entry for a directory is found, all
files that currently exist in that directory but are not listed in the
archive _are deleted from the directory_.

   This behavior is convenient when you are restoring a damaged file
system from a succession of incremental backups: it restores the entire
state of the file system to that which obtained when the backup was
made.  If you don't use `--incremental' (`-G'), the file system will
probably fill up with files that shouldn't exist any more.

   `--listed-incremental=SNAPSHOT-FILE' (`-g SNAPSHOT-FILE') handle new
GNU-format incremental backup.  This option handles new GNU-format
incremental backup.  It has much the same effect as `--incremental'
(`-G'), but also the time when the dump is done and the list of
directories dumped is written to the given FILE. When restoring, only
files newer than the saved time are restored, and the directory list is
used to speed up operations.

   `--listed-incremental=SNAPSHOT-FILE' (`-g SNAPSHOT-FILE') acts like
`--incremental' (`-G'), but when used in conjunction with `--create'
(`-c') will also cause `tar' to use the file FILE, which contains
information about the state of the filesystem at the time of the last
backup, to decide which files to include in the archive being created.
That file will then be updated by `tar'.  If the file FILE does not
exist when this option is specified, `tar' will create it, and include
all appropriate files in the archive.

   The file, which is archive independent, contains the date it was last
modified and a list of devices, inode numbers and directory names.
`tar' will archive files with newer mod dates or inode change times,
and directories with an unchanged inode number and device but a changed
directory name.  The file is updated after the files to be archived are
determined, but before the new archive is actually created.

   GNU `tar' actually writes the file twice: once before the data and
written, and once after.


File: tar.info,  Node: Inc Dumps,  Next: incremental and listed-incremental,  Prev: Full Dumps,  Up: Backups

Using `tar' to Perform Incremental Dumps
========================================

     _(This message will disappear, once this node revised.)_

   Performing incremental dumps is similar to performing full dumps,
although a few more options will usually be needed.

   A standard scheme is to do a _monthly_ (full) dump once a month, a
_weekly_ dump once a week of everything since the last monthly and a
_daily_ every day of everything since the last (weekly or monthly) dump.

   Here is a sample script to dump the directory hierarchies `/usr' and
`/var'.

     #! /bin/sh
     tar --create \
      --blocking-factor=126 \
      --file=/dev/rmt/0 \
      --label="`hostname` /usr /var `date +%Y-%m-%d`" \
      --listed-incremental=/var/log/usr-var.snar \
      --verbose \
      /usr /var

   This script uses the file `/var/log/usr-var.snar' as a snapshot to
store information about the previous tar dump.

   The blocking factor 126 is an attempt to make the tape drive stream.
Some tape devices cannot handle 64 kB blocks or larger, and require the
block size to be a multiple of 1 kB; for these devices, 126 is the
largest blocking factor that can be used.


File: tar.info,  Node: incremental and listed-incremental,  Next: Backup Levels,  Prev: Inc Dumps,  Up: Backups

The Incremental Options
=======================

     _(This message will disappear, once this node revised.)_

   `--incremental' (`-G') is used in conjunction with `--create' (`-c'),
`--extract' (`--get', `-x') or `--list' (`-t') when backing up and
restoring file systems.  An archive cannot be extracted or listed with
the `--incremental' (`-G') option specified unless it was created with
the option specified.  This option should only be used by a script, not
by the user, and is usually disregarded in favor of
`--listed-incremental=SNAPSHOT-FILE' (`-g SNAPSHOT-FILE'), which is
described below.

   `--incremental' (`-G') in conjunction with `--create' (`-c') causes
`tar' to write, at the beginning of the archive, an entry for each of
the directories that will be archived.  The entry for a directory
includes a list of all the files in the directory at the time the
archive was created and a flag for each file indicating whether or not
the file is going to be put in the archive.

   Note that this option causes `tar' to create a non-standard archive
that may not be readable by non-GNU versions of the `tar' program.

   `--incremental' (`-G') in conjunction with `--extract' (`--get',
`-x') causes `tar' to read the lists of directory contents previously
stored in the archive, _delete_ files in the file system that did not
exist in their directories when the archive was created, and then
extract the files in the archive.

   This behavior is convenient when restoring a damaged file system from
a succession of incremental backups: it restores the entire state of
the file system to that which obtained when the backup was made.  If
`--incremental' (`-G') isn't specified, the file system will probably
fill up with files that shouldn't exist any more.

   `--incremental' (`-G') in conjunction with `--list' (`-t') causes
`tar' to print, for each directory in the archive, the list of files in
that directory at the time the archive was created.  This information
is put out in a format that is not easy for humans to read, but which
is unambiguous for a program: each file name is preceded by either a
`Y' if the file is present in the archive, an `N' if the file is not
included in the archive, or a `D' if the file is a directory (and is
included in the archive).  Each file name is terminated by a null
character.  The last file is followed by an additional null and a
newline to indicate the end of the data.

   `--listed-incremental=SNAPSHOT-FILE' (`-g SNAPSHOT-FILE') acts like
`--incremental' (`-G'), but when used in conjunction with `--create'
(`-c') will also cause `tar' to use the file SNAPSHOT-FILE, which
contains information about the state of the file system at the time of
the last backup, to decide which files to include in the archive being
created.  That file will then be updated by `tar'.  If the file FILE
does not exist when this option is specified, `tar' will create it, and
include all appropriate files in the archive.

   The file FILE, which is archive independent, contains the date it
was last modified and a list of devices, inode numbers and directory
names.  `tar' will archive files with newer mod dates or inode change
times, and directories with an unchanged inode number and device but a
changed directory name.  The file is updated after the files to be
archived are determined, but before the new archive is actually created.

   Incremental dumps depend crucially on time stamps, so the results are
unreliable if you modify a file's time stamps during dumping (e.g.
with the `--atime-preserve' option), or if you set the clock backwards.

   Despite it should be obvious that a device has a non-volatile value,
NFS devices have non-dependable values when an automounter gets in the
picture.  This led to a great deal of spurious redumping in incremental
dumps, so it is somewhat useless to compare two NFS devices numbers
over time.  So `tar' now considers all NFS devices as being equal when
it comes to comparing directories; this is fairly gross, but there does
not seem to be a better way to go.


File: tar.info,  Node: Backup Levels,  Next: Backup Parameters,  Prev: incremental and listed-incremental,  Up: Backups

Levels of Backups
=================

     _(This message will disappear, once this node revised.)_

   An archive containing all the files in the file system is called a
"full backup" or "full dump".  You could insure your data by creating a
full dump every day.  This strategy, however, would waste a substantial
amount of archive media and user time, as unchanged files are daily
re-archived.

   It is more efficient to do a full dump only occasionally.  To back up
files between full dumps, you can a incremental dump.  A "level one"
dump archives all the files that have changed since the last full dump.

   A typical dump strategy would be to perform a full dump once a week,
and a level one dump once a day.  This means some versions of files
will in fact be archived more than once, but this dump strategy makes
it possible to restore a file system to within one day of accuracy by
only extracting two archives--the last weekly (full) dump and the last
daily (level one) dump.  The only information lost would be in files
changed or created since the last daily backup.  (Doing dumps more than
once a day is usually not worth the trouble).

   GNU `tar' comes with scripts you can use to do full and level-one
dumps.  Using scripts (shell programs) to perform backups and
restoration is a convenient and reliable alternative to typing out file
name lists and `tar' commands by hand.

   Before you use these scripts, you need to edit the file
`backup-specs', which specifies parameters used by the backup scripts
and by the restore script.  Once the backup parameters are set, you can
perform backups or restoration by running the appropriate script.

   The name of the restore script is `restore'.  The names of the level
one and full backup scripts are, respectively, `level-1' and `level-0'.
The `level-0' script also exists under the name `weekly', and the
`level-1' under the name `daily'--these additional names can be changed
according to your backup schedule.

   _Please Note:_ The backup scripts and the restoration scripts are
designed to be used together.  While it is possible to restore files by
hand from an archive which was created using a backup script, and to
create an archive by hand which could then be extracted using the
restore script, it is easier to use the scripts.  *Note Inc Dumps::,
and *Note Inc Dumps::, before making such an attempt.


File: tar.info,  Node: Backup Parameters,  Next: Scripted Backups,  Prev: Backup Levels,  Up: Backups

Setting Parameters for Backups and Restoration
==============================================

     _(This message will disappear, once this node revised.)_

   The file `backup-specs' specifies backup parameters for the backup
and restoration scripts provided with `tar'.  You must edit
`backup-specs' to fit your system configuration and schedule before
using these scripts.

`ADMINISTRATOR'
     The user name of the backup administrator.

`BACKUP_HOUR'
     The hour at which the backups are done.  This can be a number from
     0 to 23, or the string `now'.

`TAPE_FILE'
     The device `tar' writes the archive to.  This device should be
     attached to the host on which the dump scripts are run.

`TAPE_STATUS'
     The command to use to obtain the status of the archive device,
     including error count.  On some tape drives there may not be such a
     command; in that case, simply use `TAPE_STATUS=false'.

`BLOCKING'
     The blocking factor `tar' will use when writing the dump archive.
     *Note Blocking Factor::.

`BACKUP_DIRS'
     A list of file systems to be dumped.  You can include any directory
     name in the list--subdirectories on that file system will be
     included, regardless of how they may look to other networked
     machines.  Subdirectories on other file systems will be ignored.

     The host name specifies which host to run `tar' on, and should
     normally be the host that actually contains the file system.
     However, the host machine must have GNU `tar' installed, and must
     be able to access the directory containing the backup scripts and
     their support files using the same file name that is used on the
     machine where the scripts are run (ie. what `pwd' will print when
     in that directory on that machine).  If the host that contains the
     file system does not have this capability, you can specify another
     host as long as it can access the file system through NFS.

`BACKUP_FILES'
     A list of individual files to be dumped.  These should be
     accessible from the machine on which the backup script is run.

* Menu:

* backup-specs example::        An Example Text of `Backup-specs'
* Script Syntax::               Syntax for `Backup-specs'


File: tar.info,  Node: backup-specs example,  Next: Script Syntax,  Up: Backup Parameters

An Example Text of `Backup-specs'
---------------------------------

     _(This message will disappear, once this node revised.)_

   The following is the text of `backup-specs' as it appears at FSF:

     # site-specific parameters for file system backup.
     
     ADMINISTRATOR=friedman
     BACKUP_HOUR=1
     TAPE_FILE=/dev/nrsmt0
     TAPE_STATUS="mts -t $TAPE_FILE"
     BLOCKING=124
     BACKUP_DIRS="
     	albert:/fs/fsf
     	apple-gunkies:/gd
     	albert:/fs/gd2
     	albert:/fs/gp
     	geech:/usr/jla
     	churchy:/usr/roland
     	albert:/
     	albert:/usr
     	apple-gunkies:/
     	apple-gunkies:/usr
     	gnu:/hack
     	gnu:/u
     	apple-gunkies:/com/mailer/gnu
     	apple-gunkies:/com/archive/gnu"
     
     BACKUP_FILES="/com/mailer/aliases /com/mailer/league*[a-z]"


File: tar.info,  Node: Script Syntax,  Prev: backup-specs example,  Up: Backup Parameters

Syntax for `Backup-specs'
-------------------------

     _(This message will disappear, once this node revised.)_

   `backup-specs' is in shell script syntax.  The following conventions
should be considered when editing the script:

   A quoted string is considered to be contiguous, even if it is on more
than one line.  Therefore, you cannot include commented-out lines
within a multi-line quoted string.  BACKUP_FILES and BACKUP_DIRS are
the two most likely parameters to be multi-line.

   A quoted string typically cannot contain wildcards.  In
`backup-specs', however, the parameters BACKUP_DIRS and BACKUP_FILES
can contain wildcards.


File: tar.info,  Node: Scripted Backups,  Next: Scripted Restoration,  Prev: Backup Parameters,  Up: Backups

Using the Backup Scripts
========================

     _(This message will disappear, once this node revised.)_

   The syntax for running a backup script is:

     `script-name' [TIME-TO-BE-RUN]

   where TIME-TO-BE-RUN can be a specific system time, or can be `now'.
If you do not specify a time, the script runs at the time specified in
`backup-specs'.

   You should start a script with a tape or disk mounted.  Once you
start a script, it prompts you for new tapes or disks as it needs them.
Media volumes don't have to correspond to archive files--a
multi-volume archive can be started in the middle of a tape that
already contains the end of another multi-volume archive.  The
`restore' script prompts for media by its archive volume, so to avoid
an error message you should keep track of which tape (or disk) contains
which volume of the archive.

   The backup scripts write two files on the file system.  The first is
a record file in `/etc/tar-backup/', which is used by the scripts to
store and retrieve information about which files were dumped.  This
file is not meant to be read by humans, and should not be deleted by
them.

   The second file is a log file containing the names of the file
systems and files dumped, what time the backup was made, and any error
messages that were generated, as well as how much space was left in the
media volume after the last volume of the archive was written.  You
should check this log file after every backup.  The file name is
`log-MMM-DDD-YYYY-level-1' or `log-MMM-DDD-YYYY-full'.

   The script also prints the name of each system being dumped to the
standard output.


File: tar.info,  Node: Scripted Restoration,  Prev: Scripted Backups,  Up: Backups

Using the Restore Script
========================

     _(This message will disappear, once this node revised.)_

     *Warning:* The GNU `tar' distribution does _not_ provide any such
     `restore' script yet.  This section is only listed here for
     documentation maintenance purposes.  In any case, all contents is
     subject to change as things develop.

   To restore files that were archived using a scripted backup, use the
`restore' script.  The syntax for the script is:

   where ***** are the file systems to restore from, and ***** is a
regular expression which specifies which files to restore.  If you
specify -all, the script restores all the files in the file system.

   You should start the restore script with the media containing the
first volume of the archive mounted.  The script will prompt for other
volumes as they are needed.  If the archive is on tape, you don't need
to rewind the tape to to its beginning--if the tape head is positioned
past the beginning of the archive, the script will rewind the tape as
needed.

   If you specify `--all' as the FILES argument, the `restore' script
extracts all the files in the archived file system into the active file
system.

     *Warning:* The script will delete files from the active file
     system if they were not in the file system when the archive was
     made.

   *Note Inc Dumps::, and *Note Inc Dumps::, for an explanation of how
the script makes that determination.


File: tar.info,  Node: Choosing,  Next: Date input formats,  Prev: Backups,  Up: Top

Choosing Files and Names for `tar'
**********************************

     _(This message will disappear, once this node revised.)_

   Certain options to `tar' enable you to specify a name for your
archive.  Other options let you decide which files to include or exclude
from the archive, based on when or whether files were modified, whether
the file names do or don't match specified patterns, or whether files
are in specified directories.

* Menu:

* file::                        Choosing the Archive's Name
* Selecting Archive Members::
* files::                       Reading Names from a File
* exclude::                     Excluding Some Files
* Wildcards::
* after::                       Operating Only on New Files
* recurse::                     Descending into Directories
* one::                         Crossing Filesystem Boundaries


File: tar.info,  Node: file,  Next: Selecting Archive Members,  Up: Choosing

Choosing and Naming Archive Files
=================================

     _(This message will disappear, once this node revised.)_

   By default, `tar' uses an archive file name that was compiled when
it was built on the system; usually this name refers to some physical
tape drive on the machine.  However, the person who installed `tar' on
the system may not set the default to a meaningful value as far as most
users are concerned.  As a result, you will usually want to tell `tar'
where to find (or create) the archive.  The `--file=ARCHIVE-NAME' (`-f
ARCHIVE-NAME') option allows you to either specify or name a file to
use as the archive instead of the default archive file location.

`--file=ARCHIVE-NAME'
`-f ARCHIVE-NAME'
     Name the archive to create or operate on.  Use in conjunction with
     any operation.

   For example, in this `tar' command,

     $ tar -cvf collection.tar blues folk jazz

`collection.tar' is the name of the archive.  It must directly follow
the `-f' option, since whatever directly follows `-f' _will_ end up
naming the archive.  If you neglect to specify an archive name, you may
end up overwriting a file in the working directory with the archive you
create since `tar' will use this file's name for the archive name.

   An archive can be saved as a file in the file system, sent through a
pipe or over a network, or written to an I/O device such as a tape,
floppy disk, or CD write drive.

   If you do not name the archive, `tar' uses the value of the
environment variable `TAPE' as the file name for the archive.  If that
is not available, `tar' uses a default, compiled-in archive name,
usually that for tape unit zero (ie. `/dev/tu00').  `tar' always needs
an archive name.

   If you use `-' as an ARCHIVE-NAME, `tar' reads the archive from
standard input (when listing or extracting files), or writes it to
standard output (when creating an archive).  If you use `-' as an
ARCHIVE-NAME when modifying an archive, `tar' reads the original
archive from its standard input and writes the entire new archive to
its standard output.

     $ cd sourcedir; tar -cf - . | (cd targetdir; tar -xf -)

   To specify an archive file on a device attached to a remote machine,
use the following:

     --file=HOSTNAME:/DEV/FILE NAME

`tar' will complete the remote connection, if possible, and prompt you
for a username and password.  If you use `--file=@HOSTNAME:/DEV/FILE
NAME', `tar' will complete the remote connection, if possible, using
your username as the username on the remote machine.

   If the archive file name includes a colon (`:'), then it is assumed
to be a file on another machine.  If the archive file is
`USER@HOST:FILE', then FILE is used on the host HOST.  The remote host
is accessed using the `rsh' program, with a username of USER.  If the
username is omitted (along with the `@' sign), then your user name will
be used.  (This is the normal `rsh' behavior.)  It is necessary for the
remote machine, in addition to permitting your `rsh' access, to have
the `/usr/ucb/rmt' program installed.  If you need to use a file whose
name includes a colon, then the remote tape drive behavior can be
inhibited by using the `--force-local' option.

   When the archive is being created to `/dev/null', GNU `tar' tries to
minimize input and output operations.  The Amanda backup system, when
used with GNU `tar', has an initial sizing pass which uses this feature.


File: tar.info,  Node: Selecting Archive Members,  Next: files,  Prev: file,  Up: Choosing

Selecting Archive Members
=========================

   "File Name arguments" specify which files in the file system `tar'
operates on, when creating or adding to an archive, or which archive
members `tar' operates on, when reading or deleting from an archive.
*Note Operations::.

   To specify file names, you can include them as the last arguments on
the command line, as follows:
     tar OPERATION [OPTION1 OPTION2 ...] [FILE NAME-1 FILE NAME-2 ...]

   If you specify a directory name as a file name argument, all the
files in that directory are operated on by `tar'.

   If you do not specify files when `tar' is invoked with `--create'
(`-c'), `tar' operates on all the non-directory files in the working
directory.  If you specify either `--list' (`-t') or `--extract'
(`--get', `-x'), `tar' operates on all the archive members in the
archive.  If you specify any operation other than one of these three,
`tar' does nothing.

   By default, `tar' takes file names from the command line.  However,
there are other ways to specify file or member names, or to modify the
manner in which `tar' selects the files or members upon which to
operate.  In general, these methods work both for specifying the names
of files and archive members.


File: tar.info,  Node: files,  Next: exclude,  Prev: Selecting Archive Members,  Up: Choosing

Reading Names from a File
=========================

     _(This message will disappear, once this node revised.)_

   Instead of giving the names of files or archive members on the
command line, you can put the names into a file, and then use the
`--files-from=FILE-OF-NAMES' (`-T FILE-OF-NAMES') option to `tar'.
Give the name of the file which contains the list of files to include
as the argument to `--files-from'.  In the list, the file names should
be separated by newlines.  You will frequently use this option when you
have generated the list of files to archive with the `find' utility.

`--files-from=FILE NAME'
`-T FILE NAME'
     Get names to extract or create from file FILE NAME.

   If you give a single dash as a file name for `--files-from', (i.e.,
you specify either `--files-from=-' or `-T -'), then the file names are
read from standard input.

   Unless you are running `tar' with `--create', you can not use both
`--files-from=-' and `--file=-' (`-f -') in the same command.

   The following example shows how to use `find' to generate a list of
files smaller than 400K in length and put that list into a file called
`small-files'.  You can then use the `-T' option to `tar' to specify
the files from that file, `small-files', to create the archive
`little.tgz'.  (The `-z' option to `tar' compresses the archive with
`gzip'; *note gzip:: for more information.)

     $ find . -size -400 -print > small-files
     $ tar -c -v -z -T small-files -f little.tgz

* Menu:

* nul::


File: tar.info,  Node: nul,  Up: files

`NUL' Terminated File Names
---------------------------

   The `--null' option causes `--files-from=FILE-OF-NAMES' (`-T
FILE-OF-NAMES') to read file names terminated by a `NUL' instead of a
newline, so files whose names contain newlines can be archived using
`--files-from'.

`--null'
     Only consider `NUL' terminated file names, instead of files that
     terminate in a newline.

   The `--null' option is just like the one in GNU `xargs' and `cpio',
and is useful with the `-print0' predicate of GNU `find'.  In `tar',
`--null' also causes `--directory=DIRECTORY' (`-C DIRECTORY') options
to be treated as file names to archive, in case there are any files out
there called `-C'.

   This example shows how to use `find' to generate a list of files
larger than 800K in length and put that list into a file called
`long-files'.  The `-print0' option to `find' just just like `-print',
except that it separates files with a `NUL' rather than with a newline.
You can then run `tar' with both the `--null' and `-T' options to
specify that `tar' get the files from that file, `long-files', to
create the archive `big.tgz'.  The `--null' option to `tar' will cause
`tar' to recognize the `NUL' separator between files.

     $ find . -size +800 -print0 > long-files
     $ tar -c -v --null --files-from=long-files --file=big.tar


File: tar.info,  Node: exclude,  Next: Wildcards,  Prev: files,  Up: Choosing

Excluding Some Files
====================

     _(This message will disappear, once this node revised.)_

   To avoid operating on files whose names match a particular pattern,
use the `--exclude=PATTERN' or `--exclude-from=FILE-OF-PATTERNS' (`-X
FILE-OF-PATTERNS') options.

`--exclude=PATTERN'
     Causes `tar' to ignore files that match the PATTERN.

   The `--exclude=PATTERN' option prevents any file or member whose name
matches the shell wildcard (PATTERN) from being operated on.  For
example, to create an archive with all the contents of the directory
`src' except for files whose names end in `.o', use the command `tar
-cf src.tar --exclude='*.o' src'.

   You may give multiple `--exclude' options.

`--exclude-from=FILE'
`-X FILE'
     Causes `tar' to ignore files that match the patterns listed in
     FILE.

   Use the `--exclude-from=FILE-OF-PATTERNS' option to read a list of
patterns, one per line, from FILE; `tar' will ignore files matching
those patterns.  Thus if `tar' is called as `tar -c -X foo .' and the
file `foo' contains a single line `*.o', no files whose names end in
`.o' will be added to the archive.

* Menu:

* controlling pattern-patching with exclude::
* problems with exclude::


File: tar.info,  Node: controlling pattern-patching with exclude,  Next: problems with exclude,  Up: exclude

Controlling Pattern-Matching with the `exclude' Options
-------------------------------------------------------

   Normally, a pattern matches a name if an initial subsequence of the
name's components matches the pattern, where `*', `?', and `[...]' are
the usual shell wildcards, `\' escapes wildcards, and wildcards can
match `/'.

   Other than optionally stripping leading `/' from names (*note
absolute::), patterns and names are used as-is.  For example, trailing
`/' is not trimmed from a user-specified name before deciding whether
to exclude it.

   However, this matching procedure can be altered by the options listed
below.  These options accumulate.  For example:

     --ignore-case --exclude='makefile' --no-ignore-case ---exclude='readme'

   ignores case when excluding `makefile', but not when excluding
`readme'.

`--anchored'
`--no-anchored'
     If anchored (the default), a pattern must match an initial
     subsequence of the name's components.  Otherwise, the pattern can
     match any subsequence.

`--ignore-case'
`--no-ignore-case'
     When ignoring case, upper-case patterns match lower-case names and
     vice versa.  When not ignoring case (the default), matching is
     case-sensitive.

`--wildcards'
`--no-wildcards'
     When using wildcards (the default), `*', `?', and `[...]' are the
     usual shell wildcards, and `\' escapes wildcards.  Otherwise, none
     of these characters are special, and patterns must match names
     literally.

`--wildcards-match-slash'
`--no-wildcards-match-slash'
     When wildcards match slash (the default), a wildcard like `*' in
     the pattern can match a `/' in the name.  Otherwise, `/' is
     matched only by `/'.

   The `--recursion' and `--no-recursion' options (*note recurse::)
also affect how exclude patterns are interpreted.  If recursion is in
effect, a pattern excludes a name if it matches any of the name's
parent directories.


File: tar.info,  Node: problems with exclude,  Prev: controlling pattern-patching with exclude,  Up: exclude

Problems with Using the `exclude' Options
-----------------------------------------

   Some users find `exclude' options confusing.  Here are some common
pitfalls:

   * The main operating mode of `tar' does not act on a path name
     explicitly listed on the command line if one of its file name
     components is excluded.  In the example above, if you create an
     archive and exclude files that end with `*.o', but explicitly name
     the file `dir.o/foo' after all the options have been listed,
     `dir.o/foo' will be excluded from the archive.

   * You can sometimes confuse the meanings of `--exclude=PATTERN' and
     `--exclude-from=FILE-OF-PATTERNS' (`-X FILE-OF-PATTERNS').  Be
     careful: use `--exclude=PATTERN' when files to be excluded are
     given as a pattern on the command line.  Use
     `--exclude-from=FILE-OF-PATTERNS' to introduce the name of a file
     which contains a list of patterns, one per line; each of these
     patterns can exclude zero, one, or many files.

   * When you use `--exclude=PATTERN', be sure to quote the PATTERN
     parameter, so GNU `tar' sees wildcard characters like `*'.  If you
     do not do this, the shell might expand the `*' itself using files
     at hand, so `tar' might receive a list of files instead of one
     pattern, or none at all, making the command somewhat illegal.
     This might not correspond to what you want.

     For example, write:

          $ tar -c -f ARCHIVE.TAR --exclude '*.o' DIRECTORY

     rather than:

          $ tar -c -f ARCHIVE.TAR --exclude *.o DIRECTORY

   * You must use use shell syntax, or globbing, rather than `regexp'
     syntax, when using exclude options in `tar'.  If you try to use
     `regexp' syntax to describe files to be excluded, your command
     might fail.

   * In earlier versions of `tar', what is now the
     `--exclude-from=FILE-OF-PATTERNS' option was called
     `--exclude=PATTERN' instead.  Now, `--exclude=PATTERN' applies to
     patterns listed on the command line and
     `--exclude-from=FILE-OF-PATTERNS' applies to patterns listed in a
     file.



File: tar.info,  Node: Wildcards,  Next: after,  Prev: exclude,  Up: Choosing

Wildcards Patterns and Matching
===============================

   "Globbing" is the operation by which "wildcard" characters, `*' or
`?' for example, are replaced and expanded into all existing files
matching the given pattern.  However, `tar' often uses wildcard
patterns for matching (or globbing) archive members instead of actual
files in the filesystem.  Wildcard patterns are also used for verifying
volume labels of `tar' archives.  This section has the purpose of
explaining wildcard syntax for `tar'.

   A PATTERN should be written according to shell syntax, using wildcard
characters to effect globbing.  Most characters in the pattern stand
for themselves in the matched string, and case is significant: `a' will
match only `a', and not `A'.  The character `?' in the pattern matches
any single character in the matched string.  The character `*' in the
pattern matches zero, one, or more single characters in the matched
string.  The character `\' says to take the following character of the
pattern _literally_; it is useful when one needs to match the `?', `*',
`[' or `\' characters, themselves.

   The character `[', up to the matching `]', introduces a character
class.  A "character class" is a list of acceptable characters for the
next single character of the matched string.  For example, `[abcde]'
would match any of the first five letters of the alphabet.  Note that
within a character class, all of the "special characters" listed above
other than `\' lose their special meaning; for example, `[-\\[*?]]'
would match any of the characters, `-', `\', `[', `*', `?', or `]'.
(Due to parsing constraints, the characters `-' and `]' must either
come _first_ or _last_ in a character class.)

   If the first character of the class after the opening `[' is `!' or
`^', then the meaning of the class is reversed.  Rather than listing
character to match, it lists those characters which are _forbidden_ as
the next single character of the matched string.

   Other characters of the class stand for themselves.  The special
construction `[A-E]', using an hyphen between two letters, is meant to
represent all characters between A and E, inclusive.

   Periods (`.') or forward slashes (`/') are not considered special
for wildcard matches.  However, if a pattern completely matches a
directory prefix of a matched string, then it matches the full matched
string: excluding a directory also excludes all the files beneath it.

   There are some discussions floating in the air and asking for
modifications in the way GNU `tar' accomplishes wildcard matches.  We
perceive any change of semantics in this area as a delicate thing to
impose on GNU `tar' users.  On the other hand, the GNU project should be
progressive enough to correct any ill design: compatibility at all price
is not always a good attitude.  In conclusion, it is _possible_ that
slight amendments be later brought to the previous description.  Your
opinions on the matter are welcome.


File: tar.info,  Node: after,  Next: recurse,  Prev: Wildcards,  Up: Choosing

Operating Only on New Files
===========================

     _(This message will disappear, once this node revised.)_

   The `--after-date=DATE' (`--newer=DATE', `-N DATE') option causes
`tar' to only work on files whose modification or inode-changed times
are newer than the DATE given.  If DATE starts with `/' or `.', it is
taken to be a file name; the last-modified time of that file is used as
the date.  If you use this option when creating or appending to an
archive, the archive will only include new files.  If you use
`--after-date' when extracting an archive, `tar' will only extract
files newer than the DATE you specify.

   If you only want `tar' to make the date comparison based on
modification of the actual contents of the file (rather than inode
changes), then use the `--newer-mtime=DATE' option.

   You may use these options with any operation.  Note that these
options differ from the `--update' (`-u') operation in that they allow
you to specify a particular date against which `tar' can compare when
deciding whether or not to archive the files.

`--after-date=DATE'
`--newer=DATE'
`-N DATE'
     Only store files newer than DATE.

     Acts on files only if their modification or inode-changed times are
     later than DATE.  Use in conjunction with any operation.

     If DATE starts with `/' or `.', it is taken to be a file name; the
     last-modified time of that file is used as the date.

`--newer-mtime=DATE'
     Acts like `--after-date=DATE' (`--newer=DATE', `-N DATE'), but
     only looks at modification times.

   These options limit `tar' to only operating on files which have been
modified after the date specified.  A file is considered to have
changed if the contents have been modified, or if the owner,
permissions, and so forth, have been changed.  (For more information on
how to specify a date, see *Note Date input formats::; remember that the
entire date argument must be quoted if it contains any spaces.)

   Gurus would say that `--after-date=DATE' (`--newer=DATE', `-N DATE')
tests both the `mtime' (time the contents of the file were last
modified) and `ctime' (time the file's status was last changed: owner,
permissions, etc) fields, while `--newer-mtime=DATE' tests only `mtime'
field.

   To be precise, `--after-date=DATE' (`--newer=DATE', `-N DATE')
checks _both_ `mtime' and `ctime' and processes the file if either one
is more recent than DATE, while `--newer-mtime=DATE' only checks
`mtime' and disregards `ctime'.  Neither uses `atime' (the last time the
contents of the file were looked at).

   Date specifiers can have embedded spaces.  Because of this, you may
need to quote date arguments to keep the shell from parsing them as
separate arguments.

     *Please Note:* `--after-date=DATE' (`--newer=DATE', `-N DATE') and
     `--newer-mtime=DATE' should not be used for incremental backups.
     Some files (such as those in renamed directories) are not selected
     properly by these options.  *Note incremental and
     listed-incremental::.


File: tar.info,  Node: recurse,  Next: one,  Prev: after,  Up: Choosing

Descending into Directories
===========================

     _(This message will disappear, once this node revised.)_

Usually, `tar' will recursively explore all directories (either those
given on the command line or through the `--files-from=FILE-OF-NAMES'
(`-T FILE-OF-NAMES') option) for the various files they contain.
However, you may not always want `tar' to act this way.

   The `--no-recursion' option inhibits `tar''s recursive descent into
specified directories.  If you specify `--no-recursion', you can use
the `find' utility for hunting through levels of directories to
construct a list of file names which you could then pass to `tar'.
`find' allows you to be more selective when choosing which files to
archive; see *Note files:: for more information on using `find' with
`tar', or look.

`--no-recursion'
     Prevents `tar' from recursively descending directories.

`--recursion'
     Requires `tar' to recursively descend directories.  This is the
     default.

   When you use `--no-recursion', GNU `tar' grabs directory entries
themselves, but does not descend on them recursively.  Many people use
`find' for locating files they want to back up, and since `tar'
_usually_ recursively descends on directories, they have to use the
`! -d' option to `find' as they usually do not want all the files in a
directory.  They then use the `--files-from=FILE-OF-NAMES' (`-T
FILE-OF-NAMES') option to archive the files located via `find'.

   The problem when restoring files archived in this manner is that the
directories themselves are not in the archive; so the
`--same-permissions' (`--preserve-permissions', `-p') option does not
affect them--while users might really like it to.  Specifying
`--no-recursion' is a way to tell `tar' to grab only the directory
entries given to it, adding no new files on its own.

   The `--no-recursion' option also applies when extracting: it causes
`tar' to extract only the matched directory entries, not the files
under those directories.

   The `--no-recursion' option also affects how exclude patterns are
interpreted (*note controlling pattern-patching with exclude::).


File: tar.info,  Node: one,  Prev: recurse,  Up: Choosing

Crossing Filesystem Boundaries
==============================

     _(This message will disappear, once this node revised.)_

   `tar' will normally automatically cross file system boundaries in
order to archive files which are part of a directory tree.  You can
change this behavior by running `tar' and specifying
`--one-file-system' (`-l').  This option only affects files that are
archived because they are in a directory that is being archived; `tar'
will still archive files explicitly named on the command line or
through `--files-from=FILE-OF-NAMES' (`-T FILE-OF-NAMES'), regardless
of where they reside.

`--one-file-system'
`-l'
     Prevents `tar' from crossing file system boundaries when
     archiving.  Use in conjunction with any write operation.

   The `--one-file-system' option causes `tar' to modify its normal
behavior in archiving the contents of directories.  If a file in a
directory is not on the same filesystem as the directory itself, then
`tar' will not archive that file.  If the file is a directory itself,
`tar' will not archive anything beneath it; in other words, `tar' will
not cross mount points.

   It is reported that using this option, the mount point is is
archived, but nothing under it.

   This option is useful for making full or incremental archival
backups of a file system.  If this option is used in conjunction with
`--verbose' (`-v'), files that are excluded are mentioned by name on the
standard error.

* Menu:

* directory::                   Changing Directory
* absolute::                    Absolute File Names


File: tar.info,  Node: directory,  Next: absolute,  Up: one

Changing the Working Directory
------------------------------

     _(This message will disappear, once this node revised.)_

   To change the working directory in the middle of a list of file
names, either on the command line or in a file specified using
`--files-from=FILE-OF-NAMES' (`-T FILE-OF-NAMES'), use
`--directory=DIRECTORY' (`-C DIRECTORY').  This will change the working
directory to the directory DIRECTORY after that point in the list.

`--directory=DIRECTORY'
`-C DIRECTORY'
     Changes the working directory in the middle of a command line.

   For example,

     $ tar -c -f jams.tar grape prune -C food cherry

will place the files `grape' and `prune' from the current directory
into the archive `jams.tar', followed by the file `cherry' from the
directory `food'.  This option is especially useful when you have
several widely separated files that you want to store in the same
archive.

   Note that the file `cherry' is recorded in the archive under the
precise name `cherry', _not_ `food/cherry'.  Thus, the archive will
contain three files that all appear to have come from the same
directory; if the archive is extracted with plain `tar --extract', all
three files will be written in the current directory.

   Contrast this with the command,

     $ tar -c -f jams.tar grape prune -C food red/cherry

which records the third file in the archive under the name `red/cherry'
so that, if the archive is extracted using `tar --extract', the third
file will be written in a subdirectory named `orange-colored'.

   You can use the `--directory' option to make the archive independent
of the original name of the directory holding the files.  The following
command places the files `/etc/passwd', `/etc/hosts', and `/lib/libc.a'
into the archive `foo.tar':

     $ tar -c -f foo.tar -C /etc passwd hosts -C /lib libc.a

However, the names of the archive members will be exactly what they were
on the command line: `passwd', `hosts', and `libc.a'.  They will not
appear to be related by file name to the original directories where
those files were located.

   Note that `--directory' options are interpreted consecutively.  If
`--directory' specifies a relative file name, it is interpreted
relative to the then current directory, which might not be the same as
the original current working directory of `tar', due to a previous
`--directory' option.

   When using `--files-from' (*note files::), you can put `-C' options
in the file list.  Unfortunately, you cannot put `--directory' options
in the file list.  (This interpretation can be disabled by using the
`--null' option.)


File: tar.info,  Node: absolute,  Prev: directory,  Up: one

Absolute File Names
-------------------

     _(This message will disappear, once this node revised.)_

`-P'
`--absolute-names'
     Do not strip leading slashes from file names, and permit file names
     containing a `..' file name component.

   By default, GNU `tar' drops a leading `/' on input or output, and
complains about file names containing a `..' component.  This option
turns off this behavior.

   When `tar' extracts archive members from an archive, it strips any
leading slashes (`/') from the member name.  This causes absolute
member names in the archive to be treated as relative file names.  This
allows you to have such members extracted wherever you want, instead of
being restricted to extracting the member in the exact directory named
in the archive.  For example, if the archive member has the name
`/etc/passwd', `tar' will extract it as if the name were really
`etc/passwd'.

   File names containing `..' can cause problems when extracting, so
`tar' normally warns you about such files when creating an archive, and
rejects attempts to extracts such files.

   Other `tar' programs do not do this.  As a result, if you create an
archive whose member names start with a slash, they will be difficult
for other people with a non-GNU `tar' program to use.  Therefore, GNU
`tar' also strips leading slashes from member names when putting
members into the archive.  For example, if you ask `tar' to add the
file `/bin/ls' to an archive, it will do so, but the member name will
be `bin/ls'.

   If you use the `--absolute-names' (`-P') option, `tar' will do none
of these transformations.

   To archive or extract files relative to the root directory, specify
the `--absolute-names' (`-P') option.

   Normally, `tar' acts on files relative to the working
directory--ignoring superior directory names when archiving, and
ignoring leading slashes when extracting.

   When you specify `--absolute-names' (`-P'), `tar' stores file names
including all superior directory names, and preserves leading slashes.
If you only invoked `tar' from the root directory you would never need
the `--absolute-names' (`-P') option, but using this option may be more
convenient than switching to root.

`--absolute-names'
     Preserves full file names (including superior directory names) when
     archiving files.  Preserves leading slash when extracting files.

   `tar' prints out a message about removing the `/' from file names.
This message appears once per GNU `tar' invocation.  It represents
something which ought to be told; ignoring what it means can cause very
serious surprises, later.

   Some people, nevertheless, do not want to see this message.  Wanting
to play really dangerously, one may of course redirect `tar' standard
error to the sink.  For example, under `sh':

     $ tar -c -f archive.tar /home 2> /dev/null

Another solution, both nicer and simpler, would be to change to the `/'
directory first, and then avoid absolute notation.  For example:

     $ (cd / && tar -c -f archive.tar home)
     $ tar -c -f archive.tar -C  / home


File: tar.info,  Node: Date input formats,  Next: Formats,  Prev: Choosing,  Up: Top

Date input formats
******************

   First, a quote:

     Our units of temporal measurement, from seconds on up to months,
     are so complicated, asymmetrical and disjunctive so as to make
     coherent mental reckoning in time all but impossible.  Indeed, had
     some tyrannical god contrived to enslave our minds to time, to
     make it all but impossible for us to escape subjection to sodden
     routines and unpleasant surprises, he could hardly have done
     better than handing down our present system.  It is like a set of
     trapezoidal building blocks, with no vertical or horizontal
     surfaces, like a language in which the simplest thought demands
     ornate constructions, useless particles and lengthy
     circumlocutions.  Unlike the more successful patterns of language
     and science, which enable us to face experience boldly or at least
     level-headedly, our system of temporal calculation silently and
     persistently encourages our terror of time.

     ...  It is as though architects had to measure length in feet,
     width in meters and height in ells; as though basic instruction
     manuals demanded a knowledge of five different languages.  It is
     no wonder then that we often look into our own immediate past or
     future, last Tuesday or a week from Sunday, with feelings of
     helpless confusion.  ...

     -- Robert Grudin, `Time and the Art of Living'.

   This section describes the textual date representations that GNU
programs accept.  These are the strings you, as a user, can supply as
arguments to the various programs.  The C interface (via the `getdate'
function) is not described here.

   Although the date syntax here can represent any possible time since
the year zero, computer integers often cannot represent such a wide
range of time.  On POSIX systems, the clock starts at 1970-01-01
00:00:00 UTC: POSIX does not require support for times before the POSIX
Epoch and times far in the future.  Traditional Unix systems have
32-bit signed `time_t' and can represent times from 1901-12-13 20:45:52
through 2038-01-19 03:14:07 UTC.  Systems with 64-bit signed `time_t'
can represent all the times in the known lifetime of the universe.

* Menu:

* General date syntax::            Common rules.
* Calendar date items::            19 Dec 1994.
* Time of day items::              9:20pm.
* Time zone items::                EST, PDT, GMT, ...
* Day of week items::              Monday and others.
* Relative items in date strings:: next tuesday, 2 years ago.
* Pure numbers in date strings::   19931219, 1440.
* Authors of getdate::             Bellovin, Eggert, Salz, Berets, et al.


File: tar.info,  Node: General date syntax,  Next: Calendar date items,  Up: Date input formats

General date syntax
===================

   A "date" is a string, possibly empty, containing many items
separated by whitespace.  The whitespace may be omitted when no
ambiguity arises.  The empty string means the beginning of today (i.e.,
midnight).  Order of the items is immaterial.  A date string may contain
many flavors of items:

   * calendar date items

   * time of the day items

   * time zone items

   * day of the week items

   * relative items

   * pure numbers.

We describe each of these item types in turn, below.

   A few numbers may be written out in words in most contexts.  This is
most useful for specifying day of the week items or relative items (see
below).  Here is the list: `first' for 1, `next' for 2, `third' for 3,
`fourth' for 4, `fifth' for 5, `sixth' for 6, `seventh' for 7, `eighth'
for 8, `ninth' for 9, `tenth' for 10, `eleventh' for 11 and `twelfth'
for 12.  Also, `last' means exactly -1.

   When a month is written this way, it is still considered to be
written numerically, instead of being "spelled in full"; this changes
the allowed strings.

   In the current implementation, only English is supported for words
and abbreviations like `AM', `DST', `EST', `first', `January',
`Sunday', `tomorrow', and `year'.

   The output of `date' is not always acceptable as a date string, not
only because of the language problem, but also because there is no
standard meaning for time zone items like `IST'.  When using `date' to
generate a date string intended to be parsed later, specify a date
format that is independent of language and that does not use time zone
items other than `UTC' and `Z'.  Here are some ways to do this:

     $ LC_ALL=C TZ=UTC0 date
     Fri Dec 15 19:48:05 UTC 2000
     $ TZ=UTC0 date +"%Y-%m-%d %H:%M:%SZ"
     2000-12-15 19:48:05Z
     $ date --iso-8601=seconds  # a GNU extension
     2000-12-15T11:48:05-0800
     $ date --rfc-822  # a GNU extension
     Fri, 15 Dec 2000 11:48:05 -0800
     $ date +"%Y-%m-%d %H:%M:%S %z"  # %z is a GNU extension.
     2000-12-15 11:48:05 -0800

   Alphabetic case is completely ignored in dates.  Comments may be
introduced between round parentheses, as long as included parentheses
are properly nested.  Hyphens not followed by a digit are currently
ignored.  Leading zeros on numbers are ignored.


File: tar.info,  Node: Calendar date items,  Next: Time of day items,  Prev: General date syntax,  Up: Date input formats

Calendar date items
===================

   A "calendar date item" specifies a day of the year.  It is specified
differently, depending on whether the month is specified numerically or
literally.  All these strings specify the same calendar date:

     1972-09-24     # ISO 8601.
     72-9-24        # Assume 19xx for 69 through 99,
                    # 20xx for 00 through 68.
     72-09-24       # Leading zeros are ignored.
     9/24/72        # Common U.S. writing.
     24 September 1972
     24 Sept 72     # September has a special abbreviation.
     24 Sep 72      # Three-letter abbreviations always allowed.
     Sep 24, 1972
     24-sep-72
     24sep72

   The year can also be omitted.  In this case, the last specified year
is used, or the current year if none.  For example:

     9/24
     sep 24

   Here are the rules.

   For numeric months, the ISO 8601 format `YEAR-MONTH-DAY' is allowed,
where YEAR is any positive number, MONTH is a number between 01 and 12,
and DAY is a number between 01 and 31.  A leading zero must be present
if a number is less than ten.  If YEAR is 68 or smaller, then 2000 is
added to it; otherwise, if YEAR is less than 100, then 1900 is added to
it.  The construct `MONTH/DAY/YEAR', popular in the United States, is
accepted.  Also `MONTH/DAY', omitting the year.

   Literal months may be spelled out in full: `January', `February',
`March', `April', `May', `June', `July', `August', `September',
`October', `November' or `December'.  Literal months may be abbreviated
to their first three letters, possibly followed by an abbreviating dot.
It is also permitted to write `Sept' instead of `September'.

   When months are written literally, the calendar date may be given as
any of the following:

     DAY MONTH YEAR
     DAY MONTH
     MONTH DAY YEAR
     DAY-MONTH-YEAR

   Or, omitting the year:

     MONTH DAY


File: tar.info,  Node: Time of day items,  Next: Time zone items,  Prev: Calendar date items,  Up: Date input formats

Time of day items
=================

   A "time of day item" in date strings specifies the time on a given
day.  Here are some examples, all of which represent the same time:

     20:02:0
     20:02
     8:02pm
     20:02-0500      # In EST (U.S. Eastern Standard Time).

   More generally, the time of the day may be given as
`HOUR:MINUTE:SECOND', where HOUR is a number between 0 and 23, MINUTE
is a number between 0 and 59, and SECOND is a number between 0 and 59.
Alternatively, `:SECOND' can be omitted, in which case it is taken to
be zero.

   If the time is followed by `am' or `pm' (or `a.m.' or `p.m.'), HOUR
is restricted to run from 1 to 12, and `:MINUTE' may be omitted (taken
to be zero).  `am' indicates the first half of the day, `pm' indicates
the second half of the day.  In this notation, 12 is the predecessor of
1: midnight is `12am' while noon is `12pm'.  (This is the zero-oriented
interpretation of `12am' and `12pm', as opposed to the old tradition
derived from Latin which uses `12m' for noon and `12pm' for midnight.)

   The time may alternatively be followed by a time zone correction,
expressed as `SHHMM', where S is `+' or `-', HH is a number of zone
hours and MM is a number of zone minutes.  When a time zone correction
is given this way, it forces interpretation of the time relative to
Coordinated Universal Time (UTC), overriding any previous specification
for the time zone or the local time zone.  The MINUTE part of the time
of the day may not be elided when a time zone correction is used.  This
is the best way to specify a time zone correction by fractional parts
of an hour.

   Either `am'/`pm' or a time zone correction may be specified, but not
both.


File: tar.info,  Node: Time zone items,  Next: Day of week items,  Prev: Time of day items,  Up: Date input formats

Time zone items
===============

   A "time zone item" specifies an international time zone, indicated
by a small set of letters, e.g., `UTC' or `Z' for Coordinated Universal
Time.  Any included periods are ignored.  By following a
non-daylight-saving time zone by the string `DST' in a separate word
(that is, separated by some white space), the corresponding daylight
saving time zone may be specified.

   Time zone items other than `UTC' and `Z' are obsolescent and are not
recommended, because they are ambiguous; for example, `EST' has a
different meaning in Australia than in the United States.  Instead,
it's better to use unambiguous numeric time zone corrections like
`-0500', as described in the previous section.


File: tar.info,  Node: Day of week items,  Next: Relative items in date strings,  Prev: Time zone items,  Up: Date input formats

Day of week items
=================

   The explicit mention of a day of the week will forward the date
(only if necessary) to reach that day of the week in the future.

   Days of the week may be spelled out in full: `Sunday', `Monday',
`Tuesday', `Wednesday', `Thursday', `Friday' or `Saturday'.  Days may
be abbreviated to their first three letters, optionally followed by a
period.  The special abbreviations `Tues' for `Tuesday', `Wednes' for
`Wednesday' and `Thur' or `Thurs' for `Thursday' are also allowed.

   A number may precede a day of the week item to move forward
supplementary weeks.  It is best used in expression like `third
monday'.  In this context, `last DAY' or `next DAY' is also acceptable;
they move one week before or after the day that DAY by itself would
represent.

   A comma following a day of the week item is ignored.


File: tar.info,  Node: Relative items in date strings,  Next: Pure numbers in date strings,  Prev: Day of week items,  Up: Date input formats

Relative items in date strings
==============================

   "Relative items" adjust a date (or the current date if none) forward
or backward.  The effects of relative items accumulate.  Here are some
examples:

     1 year
     1 year ago
     3 years
     2 days

   The unit of time displacement may be selected by the string `year'
or `month' for moving by whole years or months.  These are fuzzy units,
as years and months are not all of equal duration.  More precise units
are `fortnight' which is worth 14 days, `week' worth 7 days, `day'
worth 24 hours, `hour' worth 60 minutes, `minute' or `min' worth 60
seconds, and `second' or `sec' worth one second.  An `s' suffix on
these units is accepted and ignored.

   The unit of time may be preceded by a multiplier, given as an
optionally signed number.  Unsigned numbers are taken as positively
signed.  No number at all implies 1 for a multiplier.  Following a
relative item by the string `ago' is equivalent to preceding the unit
by a multiplier with value -1.

   The string `tomorrow' is worth one day in the future (equivalent to
`day'), the string `yesterday' is worth one day in the past (equivalent
to `day ago').

   The strings `now' or `today' are relative items corresponding to
zero-valued time displacement, these strings come from the fact a
zero-valued time displacement represents the current time when not
otherwise changed by previous items.  They may be used to stress other
items, like in `12:00 today'.  The string `this' also has the meaning
of a zero-valued time displacement, but is preferred in date strings
like `this thursday'.

   When a relative item causes the resulting date to cross a boundary
where the clocks were adjusted, typically for daylight-saving time, the
resulting date and time are adjusted accordingly.


File: tar.info,  Node: Pure numbers in date strings,  Next: Authors of getdate,  Prev: Relative items in date strings,  Up: Date input formats

Pure numbers in date strings
============================

   The precise interpretation of a pure decimal number depends on the
context in the date string.

   If the decimal number is of the form YYYYMMDD and no other calendar
date item (*note Calendar date items::) appears before it in the date
string, then YYYY is read as the year, MM as the month number and DD as
the day of the month, for the specified calendar date.

   If the decimal number is of the form HHMM and no other time of day
item appears before it in the date string, then HH is read as the hour
of the day and MM as the minute of the hour, for the specified time of
the day.  MM can also be omitted.

   If both a calendar date and a time of day appear to the left of a
number in the date string, but no relative item, then the number
overrides the year.


File: tar.info,  Node: Authors of getdate,  Prev: Pure numbers in date strings,  Up: Date input formats

Authors of `getdate'
====================

   `getdate' was originally implemented by Steven M. Bellovin
(<smb@research.att.com>) while at the University of North Carolina at
Chapel Hill.  The code was later tweaked by a couple of people on
Usenet, then completely overhauled by Rich $alz (<rsalz@bbn.com>) and
Jim Berets (<jberets@bbn.com>) in August, 1990.  Various revisions for
the GNU system were made by David MacKenzie, Jim Meyering, Paul Eggert
and others.

   This chapter was originally produced by Franc,ois Pinard
(<pinard@iro.umontreal.ca>) from the `getdate.y' source code, and then
edited by K. Berry (<kb@cs.umb.edu>).


File: tar.info,  Node: Formats,  Next: Media,  Prev: Date input formats,  Up: Top

Controlling the Archive Format
******************************

* Menu:

* Portability::                 Making `tar' Archives More Portable
* Compression::                 Using Less Space through Compression
* Attributes::                  Handling File Attributes
* Standard::                    The Standard Format
* Extensions::                  GNU Extensions to the Archive Format
* cpio::                        Comparison of `tar' and `cpio'


File: tar.info,  Node: Portability,  Next: Compression,  Up: Formats

Making `tar' Archives More Portable
===================================

   Creating a `tar' archive on a particular system that is meant to be
useful later on many other machines and with other versions of `tar' is
more challenging than you might think.  `tar' archive formats have been
evolving since the first versions of Unix.  Many such formats are
around, and are not always compatible with each other.  This section
discusses a few problems, and gives some advice about making `tar'
archives more portable.

   One golden rule is simplicity.  For example, limit your `tar'
archives to contain only regular files and directories, avoiding other
kind of special files.  Do not attempt to save sparse files or
contiguous files as such.  Let's discuss a few more problems, in turn.

* Menu:

* Portable Names::              Portable Names
* dereference::                 Symbolic Links
* old::                         Old V7 Archives
* posix::                       POSIX archives
* Checksumming::                Checksumming Problems
* Large or Negative Values::    Large files, negative time stamps, etc.


File: tar.info,  Node: Portable Names,  Next: dereference,  Up: Portability

Portable Names
--------------

   Use portable file and member names.  A name is portable if it
contains only ASCII letters and digits, `/', `.', `_', and `-'; it
cannot be empty, start with `-' or `//', or contain `/-'.  Avoid deep
directory nesting.  For portability to old Unix hosts, limit your file
name components to 14 characters or less.

   If you intend to have your `tar' archives to be read under MSDOS,
you should not rely on case distinction for file names, and you might
use the GNU `doschk' program for helping you further diagnosing illegal
MSDOS names, which are even more limited than System V's.


File: tar.info,  Node: dereference,  Next: old,  Prev: Portable Names,  Up: Portability

Symbolic Links
--------------

   Normally, when `tar' archives a symbolic link, it writes a block to
the archive naming the target of the link.  In that way, the `tar'
archive is a faithful record of the filesystem contents.
`--dereference' (`-h') is used with `--create' (`-c'), and causes `tar'
to archive the files symbolic links point to, instead of the links
themselves.  When this option is used, when `tar' encounters a symbolic
link, it will archive the linked-to file, instead of simply recording
the presence of a symbolic link.

   The name under which the file is stored in the file system is not
recorded in the archive.  To record both the symbolic link name and the
file name in the system, archive the file under both names.  If all
links were recorded automatically by `tar', an extracted file might be
linked to a file name that no longer exists in the file system.

   If a linked-to file is encountered again by `tar' while creating the
same archive, an entire second copy of it will be stored.  (This
_might_ be considered a bug.)

   So, for portable archives, do not archive symbolic links as such,
and use `--dereference' (`-h'): many systems do not support symbolic
links, and moreover, your distribution might be unusable if it contains
unresolved symbolic links.


File: tar.info,  Node: old,  Next: posix,  Prev: dereference,  Up: Portability

Old V7 Archives
---------------

   Certain old versions of `tar' cannot handle additional information
recorded by newer `tar' programs.  To create an archive in V7 format
(not ANSI), which can be read by these old versions, specify the
`--old-archive' (`-o') option in conjunction with the `--create'
(`-c').  `tar' also accepts `--portability' for this option.  When you
specify it, `tar' leaves out information about directories, pipes,
fifos, contiguous files, and device files, and specifies file ownership
by group and user IDs instead of group and user names.

   When updating an archive, do not use `--old-archive' (`-o') unless
the archive was created with using this option.

   In most cases, a _new_ format archive can be read by an _old_ `tar'
program without serious trouble, so this option should seldom be
needed.  On the other hand, most modern `tar's are able to read old
format archives, so it might be safer for you to always use
`--old-archive' (`-o') for your distributions.


File: tar.info,  Node: posix,  Next: Checksumming,  Prev: old,  Up: Portability

GNU `tar' and POSIX `tar'
-------------------------

   GNU `tar' was based on an early draft of the POSIX 1003.1 `ustar'
standard.  GNU extensions to `tar', such as the support for file names
longer than 100 characters, use portions of the `tar' header record
which were specified in that POSIX draft as unused.  Subsequent changes
in POSIX have allocated the same parts of the header record for other
purposes.  As a result, GNU `tar' is incompatible with the current
POSIX spec, and with `tar' programs that follow it.

   We plan to reimplement these GNU extensions in a new way which is
upward compatible with the latest POSIX `tar' format, but we don't know
when this will be done.

   In the mean time, there is simply no telling what might happen if you
read a GNU `tar' archive, which uses the GNU extensions, using some
other `tar' program.  So if you want to read the archive with another
`tar' program, be sure to write it using the `--old-archive' option
(`-o').

   Traditionally, old `tar's have a limit of 100 characters.  GNU `tar'
attempted two different approaches to overcome this limit, using and
extending a format specified by a draft of some P1003.1.  The first way
was not that successful, and involved `@MaNgLeD@' file names, or such;
while a second approach used `././@LongLink' and other tricks, yielding
better success.  In theory, GNU `tar' should be able to handle file
names of practically unlimited length.  So, if GNU `tar' fails to dump
and retrieve files having more than 100 characters, then there is a bug
in GNU `tar', indeed.

   But, being strictly POSIX, the limit was still 100 characters.  For
various other purposes, GNU `tar' used areas left unassigned in the
POSIX draft.  POSIX later revised P1003.1 `ustar' format by assigning
previously unused header fields, in such a way that the upper limit for
file name length was raised to 256 characters.  However, the actual
POSIX limit oscillates between 100 and 256, depending on the precise
location of slashes in full file name (this is rather ugly).  Since GNU
`tar' use the same fields for quite other purposes, it became
incompatible with the latest POSIX standards.

   For longer or non-fitting file names, we plan to use yet another set
of GNU extensions, but this time, complying with the provisions POSIX
offers for extending the format, rather than conflicting with it.
Whenever an archive uses old GNU `tar' extension format or POSIX
extensions, would it be for very long file names or other specialities,
this archive becomes non-portable to other `tar' implementations.  In
fact, anything can happen.  The most forgiving `tar's will merely
unpack the file using a wrong name, and maybe create another file named
something like `@LongName', with the true file name in it.  `tar's not
protecting themselves may segment violate!

   Compatibility concerns make all this thing more difficult, as we
will have to support _all_ these things together, for a while.  GNU
`tar' should be able to produce and read true POSIX format files, while
being able to detect old GNU `tar' formats, besides old V7 format, and
process them conveniently.  It would take years before this whole area
stabilizes...

   There are plans to raise this 100 limit to 256, and yet produce POSIX
conforming archives.  Past 256, I do not know yet if GNU `tar' will go
non-POSIX again, or merely refuse to archive the file.

   There are plans so GNU `tar' support more fully the latest POSIX
format, while being able to read old V7 format, GNU (semi-POSIX plus
extension), as well as full POSIX.  One may ask if there is part of the
POSIX format that we still cannot support.  This simple question has a
complex answer.  Maybe that, on intimate look, some strong limitations
will pop up, but until now, nothing sounds too difficult (but see
below).  I only have these few pages of POSIX telling about "Extended
tar Format" (P1003.1-1990 - section 10.1.1), and there are references
to other parts of the standard I do not have, which should normally
enforce limitations on stored file names (I suspect things like fixing
what `/' and `<NUL>' means).  There are also some points which the
standard does not make clear, Existing practice will then drive what I
should do.

   POSIX mandates that, when a file name cannot fit within 100 to 256
characters (the variance comes from the fact a `/' is ideally needed as
the 156'th character), or a link name cannot fit within 100 characters,
a warning should be issued and the file _not_ be stored.  Unless some
`--posix' option is given (or `POSIXLY_CORRECT' is set), I suspect that
GNU `tar' should disobey this specification, and automatically switch
to using GNU extensions to overcome file name or link name length
limitations.

   There is a problem, however, which I did not intimately studied yet.
Given a truly POSIX archive with names having more than 100 characters,
I guess that GNU `tar' up to 1.11.8 will process it as if it were an
old V7 archive, and be fooled by some fields which are coded
differently.  So, the question is to decide if the next generation of
GNU `tar' should produce POSIX format by default, whenever possible,
producing archives older versions of GNU `tar' might not be able to read
correctly.  I fear that we will have to suffer such a choice one of
these days, if we want GNU `tar' to go closer to POSIX.  We can rush it.
Another possibility is to produce the current GNU `tar' format by
default for a few years, but have GNU `tar' versions from some 1.POSIX
and up able to recognize all three formats, and let older GNU `tar'
fade out slowly.  Then, we could switch to producing POSIX format by
default, with not much harm to those still having (very old at that
time) GNU `tar' versions prior to 1.POSIX.

   POSIX format cannot represent very long names, volume headers,
splitting of files in multi-volumes, sparse files, and incremental
dumps; these would be all disallowed if `--posix' or `POSIXLY_CORRECT'.
Otherwise, if `tar' is given long names, or `-[VMSgG]', then it should
automatically go non-POSIX.  I think this is easily granted without
much discussion.

   Another point is that only `mtime' is stored in POSIX archives,
while GNU `tar' currently also store `atime' and `ctime'.  If we want
GNU `tar' to go closer to POSIX, my choice would be to drop `atime' and
`ctime' support on average.  On the other hand, I perceive that full
dumps or incremental dumps need `atime' and `ctime' support, so for
those special applications, POSIX has to be avoided altogether.

   A few users requested that `--sparse' (`-S') be always active by
default, I think that before replying to them, we have to decide if we
want GNU `tar' to go closer to POSIX on average, while producing files.
My choice would be to go closer to POSIX in the long run.  Besides
possible double reading, I do not see any point of not trying to save
files as sparse when creating archives which are neither POSIX nor
old-V7, so the actual `--sparse' (`-S') would become selected by
default when producing such archives, whatever the reason is.  So,
`--sparse' (`-S') alone might be redefined to force GNU-format
archives, and recover its previous meaning from this fact.

   GNU-format as it exists now can easily fool other POSIX `tar', as it
uses fields which POSIX considers to be part of the file name prefix.
I wonder if it would not be a good idea, in the long run, to try
changing GNU-format so any added field (like `ctime', `atime', file
offset in subsequent volumes, or sparse file descriptions) be wholly
and always pushed into an extension block, instead of using space in
the POSIX header block.  I could manage to do that portably between
future GNU `tar's.  So other POSIX `tar's might be at least able to
provide kind of correct listings for the archives produced by GNU
`tar', if not able to process them otherwise.

   Using these projected extensions might induce older `tar's to fail.
We would use the same approach as for POSIX.  I'll put out a `tar'
capable of reading POSIXier, yet extended archives, but will not produce
this format by default, in GNU mode.  In a few years, when newer GNU
`tar's will have flooded out `tar' 1.11.X and previous, we could switch
to producing POSIXier extended archives, with no real harm to users, as
almost all existing GNU `tar's will be ready to read POSIXier format.
In fact, I'll do both changes at the same time, in a few years, and
just prepare `tar' for both changes, without effecting them, from
1.POSIX.  (Both changes: 1--using POSIX convention for getting over 100
characters; 2--avoiding mangling POSIX headers for GNU extensions,
using only POSIX mandated extension techniques).

   So, a future `tar' will have a `--posix' flag forcing the usage of
truly POSIX headers, and so, producing archives previous GNU `tar' will
not be able to read.  So, _once_ pretest will announce that feature, it
would be particularly useful that users test how exchangeable will be
archives between GNU `tar' with `--posix' and other POSIX `tar'.

   In a few years, when GNU `tar' will produce POSIX headers by
default, `--posix' will have a strong meaning and will disallow GNU
extensions.  But in the meantime, for a long while, `--posix' in GNU
tar will not disallow GNU extensions like `--label=ARCHIVE-LABEL' (`-V
ARCHIVE-LABEL'), `--multi-volume' (`-M'), `--sparse' (`-S'), or very
long file or link names.  However, `--posix' with GNU extensions will
use POSIX headers with reserved-for-users extensions to headers, and I
will be curious to know how well or bad POSIX `tar's will react to
these.

   GNU `tar' prior to 1.POSIX, and after 1.POSIX without `--posix',
generates and checks `ustar  ', with two suffixed spaces.  This is
sufficient for older GNU `tar' not to recognize POSIX archives, and
consequently, wrongly decide those archives are in old V7 format.  It
is a useful bug for me, because GNU `tar' has other POSIX
incompatibilities, and I need to segregate GNU `tar' semi-POSIX
archives from truly POSIX archives, for GNU `tar' should be somewhat
compatible with itself, while migrating closer to latest POSIX
standards.  So, I'll be very careful about how and when I will do the
correction.


File: tar.info,  Node: Checksumming,  Next: Large or Negative Values,  Prev: posix,  Up: Portability

Checksumming Problems
---------------------

   SunOS and HP-UX `tar' fail to accept archives created using GNU
`tar' and containing non-ASCII file names, that is, file names having
characters with the eight bit set, because they use signed checksums,
while GNU `tar' uses unsigned checksums while creating archives, as per
POSIX standards.  On reading, GNU `tar' computes both checksums and
accept any.  It is somewhat worrying that a lot of people may go around
doing backup of their files using faulty (or at least non-standard)
software, not learning about it until it's time to restore their
missing files with an incompatible file extractor, or vice versa.

   GNU `tar' compute checksums both ways, and accept any on read, so
GNU tar can read Sun tapes even with their wrong checksums.  GNU `tar'
produces the standard checksum, however, raising incompatibilities with
Sun.  That is to say, GNU `tar' has not been modified to _produce_
incorrect archives to be read by buggy `tar''s.  I've been told that
more recent Sun `tar' now read standard archives, so maybe Sun did a
similar patch, after all?

   The story seems to be that when Sun first imported `tar' sources on
their system, they recompiled it without realizing that the checksums
were computed differently, because of a change in the default signing
of `char''s in their compiler.  So they started computing checksums
wrongly.  When they later realized their mistake, they merely decided
to stay compatible with it, and with themselves afterwards.
Presumably, but I do not really know, HP-UX has chosen that their `tar'
archives to be compatible with Sun's.  The current standards do not
favor Sun `tar' format.  In any case, it now falls on the shoulders of
SunOS and HP-UX users to get a `tar' able to read the good archives
they receive.


File: tar.info,  Node: Large or Negative Values,  Prev: Checksumming,  Up: Portability

Large or Negative Values
------------------------

   POSIX `tar' format uses fixed-sized unsigned octal strings to
represent numeric values.  User and group IDs and device major and
minor numbers have unsigned 21-bit representations, and file sizes and
times have unsigned 33-bit representations.  GNU `tar' generates POSIX
representations when possible, but for values outside the POSIX range
it generates two's-complement base-256 strings: uids, gids, and device
numbers have signed 57-bit representations, and file sizes and times
have signed 89-bit representations.  These representations are an
extension to POSIX `tar' format, so they are not universally portable.

   The most common portability problems with out-of-range numeric values
are large files and future or negative time stamps.

   Portable archives should avoid members of 8 GB or larger, as POSIX
`tar' format cannot represent them.

   Portable archives should avoid time stamps from the future.  POSIX
`tar' format can represent time stamps in the range 1970-01-01 00:00:00
through 2242-03-16 12:56:31 UTC.  However, many current hosts use a
signed 32-bit `time_t', or internal time stamp format, and cannot
represent time stamps after 2038-01-19 03:14:07 UTC; so portable
archives must avoid these time stamps for many years to come.

   Portable archives should also avoid time stamps before 1970.  These
time stamps are a common POSIX extension but their `time_t'
representations are negative.  Many traditional `tar' implementations
generate a two's complement representation for negative time stamps
that assumes a signed 32-bit `time_t'; hence they generate archives
that are not portable to hosts with differing `time_t' representations.
GNU `tar' recognizes this situation when it is run on host with a
signed 32-bit `time_t', but it issues a warning, as these time stamps
are nonstandard and unportable.


File: tar.info,  Node: Compression,  Next: Attributes,  Prev: Portability,  Up: Formats

Using Less Space through Compression
====================================

* Menu:

* gzip::                        Creating and Reading Compressed Archives
* sparse::                      Archiving Sparse Files


File: tar.info,  Node: gzip,  Next: sparse,  Up: Compression

Creating and Reading Compressed Archives
----------------------------------------

     _(This message will disappear, once this node revised.)_

`-z'
`--gzip'
`--ungzip'
     Filter the archive through `gzip'.

   Some format parameters must be taken into consideration when
modifying an archive.  Compressed archives cannot be modified.

   You can use `--gzip' and `--gunzip' on physical devices (tape
drives, etc.) and remote files as well as on normal files; data to or
from such devices or remote files is reblocked by another copy of the
`tar' program to enforce the specified (or default) record size.  The
default compression parameters are used; if you need to override them,
avoid the `--gzip' (`--gunzip', `--ungzip', `-z') option and run `gzip'
explicitly.  (Or set the `GZIP' environment variable.)

   The `--gzip' (`--gunzip', `--ungzip', `-z') option does not work
with the `--multi-volume' (`-M') option, or with the `--update' (`-u'),
`--append' (`-r'), `--concatenate' (`--catenate', `-A'), or `--delete'
operations.

   It is not exact to say that GNU `tar' is to work in concert with
`gzip' in a way similar to `zip', say.  Surely, it is possible that
`tar' and `gzip' be done with a single call, like in:

     $ tar cfz archive.tar.gz subdir

to save all of `subdir' into a `gzip''ed archive.  Later you can do:

     $ tar xfz archive.tar.gz

to explode and unpack.

   The difference is that the whole archive is compressed.  With `zip',
archive members are archived individually.  `tar''s method yields
better compression.  On the other hand, one can view the contents of a
`zip' archive without having to decompress it.  As for the `tar' and
`gzip' tandem, you need to decompress the archive to see its contents.
However, this may be done without needing disk space, by using pipes
internally:

     $ tar tfz archive.tar.gz

   About corrupted compressed archives: `gzip''ed files have no
redundancy, for maximum compression.  The adaptive nature of the
compression scheme means that the compression tables are implicitly
spread all over the archive.  If you lose a few blocks, the dynamic
construction of the compression tables becomes unsynchronized, and there
is little chance that you could recover later in the archive.

   There are pending suggestions for having a per-volume or per-file
compression in GNU `tar'.  This would allow for viewing the contents
without decompression, and for resynchronizing decompression at every
volume or file, in case of corrupted archives.  Doing so, we might lose
some compressibility.  But this would have make recovering easier.  So,
there are pros and cons.  We'll see!

`-j'
`--bzip2'
     Filter the archive through `bzip2'.  Otherwise like `--gzip'
     (`--gunzip', `--ungzip', `-z').

`-Z'
`--compress'
`--uncompress'
     Filter the archive through `compress'.  Otherwise like `--gzip'
     (`--gunzip', `--ungzip', `-z').

`--use-compress-program=PROG'
     Filter through PROG (must accept `-d').

   `--compress' (`--uncompress', `-Z') stores an archive in compressed
format.  This option is useful in saving time over networks and space
in pipes, and when storage space is at a premium.  `--compress'
(`--uncompress', `-Z') causes `tar' to compress when writing the
archive, or to uncompress when reading the archive.

   To perform compression and uncompression on the archive, `tar' runs
the `compress' utility.  `tar' uses the default compression parameters;
if you need to override them, avoid the `--compress' (`--uncompress',
`-Z') option and run the `compress' utility explicitly.  It is useful
to be able to call the `compress' utility from within `tar' because the
`compress' utility by itself cannot access remote tape drives.

   The `--compress' (`--uncompress', `-Z') option will not work in
conjunction with the `--multi-volume' (`-M') option or the `--append'
(`-r'), `--update' (`-u') and `--delete' operations.  *Note
Operations::, for more information on these operations.

   If there is no compress utility available, `tar' will report an
error.  *Please note* that the `compress' program may be covered by a
patent, and therefore we recommend you stop using it.

   `--bzip2' (`-j') acts like `--compress' (`--uncompress', `-Z'),
except that it uses the `bzip2' utility.

`--compress'
`--uncompress'
`-z'
`-Z'
     When this option is specified, `tar' will compress (when writing
     an archive), or uncompress (when reading an archive).  Used in
     conjunction with the `--create' (`-c'), `--extract' (`--get',
     `-x'), `--list' (`-t') and `--compare' (`--diff', `-d') operations.

   You can have archives be compressed by using the `--gzip'
(`--gunzip', `--ungzip', `-z') option.  This will arrange for `tar' to
use the `gzip' program to be used to compress or uncompress the archive
wren writing or reading it.

   To use the older, obsolete, `compress' program, use the `--compress'
(`--uncompress', `-Z') option.  The GNU Project recommends you not use
`compress', because there is a patent covering the algorithm it uses.
You could be sued for patent infringement merely by running `compress'.

   I have one question, or maybe it's a suggestion if there isn't a way
to do it now. I would like to use `--gzip' (`--gunzip', `--ungzip',
`-z'), but I'd also like the output to be fed through a program like
GNU `ecc' (actually, right now that's `exactly' what I'd like to use
:-)), basically adding ECC protection on top of compression.  It seems
as if this should be quite easy to do, but I can't work out exactly how
to go about it.  Of course, I can pipe the standard output of `tar'
through `ecc', but then I lose (though I haven't started using it yet,
I confess) the ability to have `tar' use `rmt' for it's I/O (I think).

   I think the most straightforward thing would be to let me specify a
general set of filters outboard of compression (preferably ordered, so
the order can be automatically reversed on input operations, and with
the options they require specifiable), but beggars shouldn't be
choosers and anything you decide on would be fine with me.

   By the way, I like `ecc' but if (as the comments say) it can't deal
with loss of block sync, I'm tempted to throw some time at adding that
capability.  Supposing I were to actually do such a thing and get it
(apparently) working, do you accept contributed changes to utilities
like that?  (Leigh Clayton `loc@soliton.com', May 1995).

   Isn't that exactly the role of the `--use-compress-prog=PROGRAM'
option?  I never tried it myself, but I suspect you may want to write a
PROG script or program able to filter stdin to stdout to way you want.
It should recognize the `-d' option, for when extraction is needed
rather than creation.

   It has been reported that if one writes compressed data (through the
`--gzip' (`--gunzip', `--ungzip', `-z') or `--compress'
(`--uncompress', `-Z') options) to a DLT and tries to use the DLT
compression mode, the data will actually get bigger and one will end up
with less space on the tape.


File: tar.info,  Node: sparse,  Prev: gzip,  Up: Compression

Archiving Sparse Files
----------------------

     _(This message will disappear, once this node revised.)_

`-S'
`--sparse'
     Handle sparse files efficiently.

   This option causes all files to be put in the archive to be tested
for sparseness, and handled specially if they are.  The `--sparse'
(`-S') option is useful when many `dbm' files, for example, are being
backed up.  Using this option dramatically decreases the amount of
space needed to store such a file.

   In later versions, this option may be removed, and the testing and
treatment of sparse files may be done automatically with any special
GNU options.  For now, it is an option needing to be specified on the
command line with the creation or updating of an archive.

   Files in the filesystem occasionally have "holes."  A hole in a file
is a section of the file's contents which was never written.  The
contents of a hole read as all zeros.  On many operating systems,
actual disk storage is not allocated for holes, but they are counted in
the length of the file.  If you archive such a file, `tar' could create
an archive longer than the original.  To have `tar' attempt to
recognize the holes in a file, use `--sparse' (`-S').  When you use the
`--sparse' (`-S') option, then, for any file using less disk space than
would be expected from its length, `tar' searches the file for
consecutive stretches of zeros.  It then records in the archive for the
file where the consecutive stretches of zeros are, and only archives
the "real contents" of the file.  On extraction (using `--sparse'
(`-S') is not needed on extraction) any such files have hols created
wherever the continuous stretches of zeros were found.  Thus, if you
use `--sparse' (`-S'), `tar' archives won't take more space than the
original.

   A file is sparse if it contains blocks of zeros whose existence is
recorded, but that have no space allocated on disk.  When you specify
the `--sparse' (`-S') option in conjunction with the `--create' (`-c')
operation, `tar' tests all files for sparseness while archiving.  If
`tar' finds a file to be sparse, it uses a sparse representation of the
file in the archive.  *Note create::, for more information about
creating archives.

   `--sparse' (`-S') is useful when archiving files, such as dbm files,
likely to contain many nulls.  This option dramatically decreases the
amount of space needed to store such an archive.

     *Please Note:* Always use `--sparse' (`-S') when performing file
     system backups, to avoid archiving the expanded forms of files
     stored sparsely in the system.

     Even if your system has no sparse files currently, some may be
     created in the future.  If you use `--sparse' (`-S') while making
     file system backups as a matter of course, you can be assured the
     archive will never take more space on the media than the files
     take on disk (otherwise, archiving a disk filled with sparse files
     might take hundreds of tapes).

   `tar' ignores the `--sparse' (`-S') option when reading an archive.

`--sparse'
`-S'
     Files stored sparsely in the file system are represented sparsely
     in the archive.  Use in conjunction with write operations.

   However, users should be well aware that at archive creation time,
GNU `tar' still has to read whole disk file to locate the "holes", and
so, even if sparse files use little space on disk and in the archive,
they may sometimes require inordinate amount of time for reading and
examining all-zero blocks of a file.  Although it works, it's painfully
slow for a large (sparse) file, even though the resulting tar archive
may be small.  (One user reports that dumping a `core' file of over 400
megabytes, but with only about 3 megabytes of actual data, took about 9
minutes on a Sun Sparcstation ELC, with full CPU utilization.)

   This reading is required in all cases and is not related to the fact
the `--sparse' (`-S') option is used or not, so by merely _not_ using
the option, you are not saving time(1).

   Programs like `dump' do not have to read the entire file; by
examining the file system directly, they can determine in advance
exactly where the holes are and thus avoid reading through them.  The
only data it need read are the actual allocated data blocks.  GNU `tar'
uses a more portable and straightforward archiving approach, it would
be fairly difficult that it does otherwise.  Elizabeth Zwicky writes to
`comp.unix.internals', on 1990-12-10:

     What I did say is that you cannot tell the difference between a
     hole and an equivalent number of nulls without reading raw blocks.
     `st_blocks' at best tells you how many holes there are; it
     doesn't tell you _where_.  Just as programs may, conceivably, care
     what `st_blocks' is (care to name one that does?), they may also
     care where the holes are (I have no examples of this one either,
     but it's equally imaginable).

     I conclude from this that good archivers are not portable.  One can
     arguably conclude that if you want a portable program, you can in
     good conscience restore files with as many holes as possible,
     since you can't get it right.

   ---------- Footnotes ----------

   (1) Well!  We should say the whole truth, here.  When `--sparse'
(`-S') is selected while creating an archive, the current `tar'
algorithm requires sparse files to be read twice, not once.  We hope to
develop a new archive format for saving sparse files in which one pass
will be sufficient.


File: tar.info,  Node: Attributes,  Next: Standard,  Prev: Compression,  Up: Formats

Handling File Attributes
========================

     _(This message will disappear, once this node revised.)_

   When `tar' reads files, this causes them to have the access times
updated.  To have `tar' attempt to set the access times back to what
they were before they were read, use the `--atime-preserve' option.

   Handling of file attributes

`--atime-preserve'
     Preserve access times on files that are read.  This doesn't work
     for files that you don't own, unless you're root, and it doesn't
     interact with incremental dumps nicely (*note Backups::), and it
     can set access or modification times incorrectly if other programs
     access the file while `tar' is running; but it is good enough for
     some purposes.

`-m'
`--touch'
     Do not extract file modified time.

     When this option is used, `tar' leaves the modification times of
     the files it extracts as the time when the files were extracted,
     instead of setting it to the time recorded in the archive.

     This option is meaningless with `--list' (`-t').

`--same-owner'
     Create extracted files with the same ownership they have in the
     archive.

     This is the default behavior for the superuser, so this option is
     meaningful only for non-root users, when `tar' is executed on
     those systems able to give files away.  This is considered as a
     security flaw by many people, at least because it makes quite
     difficult to correctly account users for the disk space they
     occupy.  Also, the `suid' or `sgid' attributes of files are easily
     and silently lost when files are given away.

     When writing an archive, `tar' writes the user id and user name
     separately.  If it can't find a user name (because the user id is
     not in `/etc/passwd'), then it does not write one.  When restoring,
     and doing a `chmod' like when you use `--same-permissions'
     (`--preserve-permissions', `-p'), it tries to look the name (if
     one was written) up in `/etc/passwd'.  If it fails, then it uses
     the user id stored in the archive instead.

`--no-same-owner'
     Do not attempt to restore ownership when extracting.  This is the
     default behavior for ordinary users, so this option has an effect
     only for the superuser.

`--numeric-owner'
     The `--numeric-owner' option allows (ANSI) archives to be written
     without user/group name information or such information to be
     ignored when extracting.  It effectively disables the generation
     and/or use of user/group name information.  This option forces
     extraction using the numeric ids from the archive, ignoring the
     names.

     This is useful in certain circumstances, when restoring a backup
     from an emergency floppy with different passwd/group files for
     example.  It is otherwise impossible to extract files with the
     right ownerships if the password file in use during the extraction
     does not match the one belonging to the filesystem(s) being
     extracted.  This occurs, for example, if you are restoring your
     files after a major crash and had booted from an emergency floppy
     with no password file or put your disk into another machine to do
     the restore.

     The numeric ids are _always_ saved into `tar' archives.  The
     identifying names are added at create time when provided by the
     system, unless `--old-archive' (`-o') is used.  Numeric ids could
     be used when moving archives between a collection of machines using
     a centralized management for attribution of numeric ids to users
     and groups.  This is often made through using the NIS capabilities.

     When making a `tar' file for distribution to other sites, it is
     sometimes cleaner to use a single owner for all files in the
     distribution, and nicer to specify the write permission bits of the
     files as stored in the archive independently of their actual value
     on the file system.  The way to prepare a clean distribution is
     usually to have some Makefile rule creating a directory, copying
     all needed files in that directory, then setting ownership and
     permissions as wanted (there are a lot of possible schemes), and
     only then making a `tar' archive out of this directory, before
     cleaning everything out.  Of course, we could add a lot of options
     to GNU `tar' for fine tuning permissions and ownership.  This is
     not the good way, I think.  GNU `tar' is already crowded with
     options and moreover, the approach just explained gives you a
     great deal of control already.

`-p'
`--same-permissions'
`--preserve-permissions'
     Extract all protection information.

     This option causes `tar' to set the modes (access permissions) of
     extracted files exactly as recorded in the archive.  If this option
     is not used, the current `umask' setting limits the permissions on
     extracted files.

     This option is meaningless with `--list' (`-t').

`--preserve'
     Same as both `--same-permissions' (`--preserve-permissions', `-p')
     and `--same-order' (`--preserve-order', `-s').

     The `--preserve' option has no equivalent short option name.  It
     is equivalent to `--same-permissions' (`--preserve-permissions',
     `-p') plus `--same-order' (`--preserve-order', `-s').


File: tar.info,  Node: Standard,  Next: Extensions,  Prev: Attributes,  Up: Formats

The Standard Format
===================

     _(This message will disappear, once this node revised.)_

   While an archive may contain many files, the archive itself is a
single ordinary file.  Like any other file, an archive file can be
written to a storage device such as a tape or disk, sent through a pipe
or over a network, saved on the active file system, or even stored in
another archive.  An archive file is not easy to read or manipulate
without using the `tar' utility or Tar mode in GNU Emacs.

   Physically, an archive consists of a series of file entries
terminated by an end-of-archive entry, which consists of 512 zero
bytes.  A file entry usually describes one of the files in the archive
(an "archive member"), and consists of a file header and the contents
of the file.  File headers contain file names and statistics, checksum
information which `tar' uses to detect file corruption, and information
about file types.

   Archives are permitted to have more than one member with the same
member name.  One way this situation can occur is if more than one
version of a file has been stored in the archive.  For information
about adding new versions of a file to an archive, see *Note update::.

   In addition to entries describing archive members, an archive may
contain entries which `tar' itself uses to store information.
*Note label::, for an example of such an archive entry.

   A `tar' archive file contains a series of blocks.  Each block
contains `BLOCKSIZE' bytes.  Although this format may be thought of as
being on magnetic tape, other media are often used.

   Each file archived is represented by a header block which describes
the file, followed by zero or more blocks which give the contents of
the file.  At the end of the archive file there may be a block filled
with binary zeros as an end-of-file marker.  A reasonable system should
write a block of zeros at the end, but must not assume that such a
block exists when reading an archive.

   The blocks may be "blocked" for physical I/O operations.  Each
record of N blocks (where N is set by the `--blocking-factor=512-SIZE'
(`-b 512-SIZE') option to `tar') is written with a single `write ()'
operation.  On magnetic tapes, the result of such a write is a single
record.  When writing an archive, the last record of blocks should be
written at the full size, with blocks after the zero block containing
all zeros.  When reading an archive, a reasonable system should
properly handle an archive whose last record is shorter than the rest,
or which contains garbage records after a zero block.

   The header block is defined in C as follows.  In the GNU `tar'
distribution, this is part of file `src/tar.h':

     /* GNU tar Archive Format description.
     
        Copyright (C) 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996,
        1997, 2000, 2001 Free Software Foundation, Inc.
     
        This program is free software; you can redistribute it and/or modify it
        under the terms of the GNU General Public License as published by the
        Free Software Foundation; either version 2, or (at your option) any later
        version.
     
        This program is distributed in the hope that it will be useful, but
        WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
        Public License for more details.
     
        You should have received a copy of the GNU General Public License along
        with this program; if not, write to the Free Software Foundation, Inc.,
        59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
     
     /* If OLDGNU_COMPATIBILITY is not zero, tar produces archives which, by
        default, are readable by older versions of GNU tar.  This can be
        overriden by using --posix; in this case, POSIXLY_CORRECT in environment
        may be set for enforcing stricter conformance.  If OLDGNU_COMPATIBILITY
        is zero or undefined, tar will eventually produces archives which, by
        default, POSIX compatible; then either using --posix or defining
        POSIXLY_CORRECT enforces stricter conformance.
     
        This #define will disappear in a few years.  FP, June 1995.  */
     #define OLDGNU_COMPATIBILITY 1
     
     /* tar Header Block, from POSIX 1003.1-1990.  */
     
     /* POSIX header.  */
     
     struct posix_header
     {                               /* byte offset */
       char name[100];               /*   0 */
       char mode[8];                 /* 100 */
       char uid[8];                  /* 108 */
       char gid[8];                  /* 116 */
       char size[12];                /* 124 */
       char mtime[12];               /* 136 */
       char chksum[8];               /* 148 */
       char typeflag;                /* 156 */
       char linkname[100];           /* 157 */
       char magic[6];                /* 257 */
       char version[2];              /* 263 */
       char uname[32];               /* 265 */
       char gname[32];               /* 297 */
       char devmajor[8];             /* 329 */
       char devminor[8];             /* 337 */
       char prefix[155];             /* 345 */
                                     /* 500 */
     };
     
     #define TMAGIC   "ustar"        /* ustar and a null */
     #define TMAGLEN  6
     #define TVERSION "00"           /* 00 and no null */
     #define TVERSLEN 2
     
     /* Values used in typeflag field.  */
     #define REGTYPE  '0'            /* regular file */
     #define AREGTYPE '\0'           /* regular file */
     #define LNKTYPE  '1'            /* link */
     #define SYMTYPE  '2'            /* reserved */
     #define CHRTYPE  '3'            /* character special */
     #define BLKTYPE  '4'            /* block special */
     #define DIRTYPE  '5'            /* directory */
     #define FIFOTYPE '6'            /* FIFO special */
     #define CONTTYPE '7'            /* reserved */
     
     /* Bits used in the mode field, values in octal.  */
     #define TSUID    04000          /* set UID on execution */
     #define TSGID    02000          /* set GID on execution */
     #define TSVTX    01000          /* reserved */
                                     /* file permissions */
     #define TUREAD   00400          /* read by owner */
     #define TUWRITE  00200          /* write by owner */
     #define TUEXEC   00100          /* execute/search by owner */
     #define TGREAD   00040          /* read by group */
     #define TGWRITE  00020          /* write by group */
     #define TGEXEC   00010          /* execute/search by group */
     #define TOREAD   00004          /* read by other */
     #define TOWRITE  00002          /* write by other */
     #define TOEXEC   00001          /* execute/search by other */
     
     /* tar Header Block, GNU extensions.  */
     
     /* In GNU tar, SYMTYPE is for to symbolic links, and CONTTYPE is for
        contiguous files, so maybe disobeying the `reserved' comment in POSIX
        header description.  I suspect these were meant to be used this way, and
        should not have really been `reserved' in the published standards.  */
     
     /* *BEWARE* *BEWARE* *BEWARE* that the following information is still
        boiling, and may change.  Even if the OLDGNU format description should be
        accurate, the so-called GNU format is not yet fully decided.  It is
        surely meant to use only extensions allowed by POSIX, but the sketch
        below repeats some ugliness from the OLDGNU format, which should rather
        go away.  Sparse files should be saved in such a way that they do *not*
        require two passes at archive creation time.  Huge files get some POSIX
        fields to overflow, alternate solutions have to be sought for this.  */
     
     /* Descriptor for a single file hole.  */
     
     struct sparse
     {                               /* byte offset */
       char offset[12];              /*   0 */
       char numbytes[12];            /*  12 */
                                     /*  24 */
     };
     
     /* Sparse files are not supported in POSIX ustar format.  For sparse files
        with a POSIX header, a GNU extra header is provided which holds overall
        sparse information and a few sparse descriptors.  When an old GNU header
        replaces both the POSIX header and the GNU extra header, it holds some
        sparse descriptors too.  Whether POSIX or not, if more sparse descriptors
        are still needed, they are put into as many successive sparse headers as
        necessary.  The following constants tell how many sparse descriptors fit
        in each kind of header able to hold them.  */
     
     #define SPARSES_IN_EXTRA_HEADER  16
     #define SPARSES_IN_OLDGNU_HEADER 4
     #define SPARSES_IN_SPARSE_HEADER 21
     
     /* The GNU extra header contains some information GNU tar needs, but not
        foreseen in POSIX header format.  It is only used after a POSIX header
        (and never with old GNU headers), and immediately follows this POSIX
        header, when typeflag is a letter rather than a digit, so signaling a GNU
        extension.  */
     
     struct extra_header
     {                               /* byte offset */
       char atime[12];               /*   0 */
       char ctime[12];               /*  12 */
       char offset[12];              /*  24 */
       char realsize[12];            /*  36 */
       char longnames[4];            /*  48 */
       char unused_pad1[68];         /*  52 */
       struct sparse sp[SPARSES_IN_EXTRA_HEADER];
                                     /* 120 */
       char isextended;              /* 504 */
                                     /* 505 */
     };
     
     /* Extension header for sparse files, used immediately after the GNU extra
        header, and used only if all sparse information cannot fit into that
        extra header.  There might even be many such extension headers, one after
        the other, until all sparse information has been recorded.  */
     
     struct sparse_header
     {                               /* byte offset */
       struct sparse sp[SPARSES_IN_SPARSE_HEADER];
                                     /*   0 */
       char isextended;              /* 504 */
                                     /* 505 */
     };
     
     /* The old GNU format header conflicts with POSIX format in such a way that
        POSIX archives may fool old GNU tar's, and POSIX tar's might well be
        fooled by old GNU tar archives.  An old GNU format header uses the space
        used by the prefix field in a POSIX header, and cumulates information
        normally found in a GNU extra header.  With an old GNU tar header, we
        never see any POSIX header nor GNU extra header.  Supplementary sparse
        headers are allowed, however.  */
     
     struct oldgnu_header
     {                               /* byte offset */
       char unused_pad1[345];        /*   0 */
       char atime[12];               /* 345 */
       char ctime[12];               /* 357 */
       char offset[12];              /* 369 */
       char longnames[4];            /* 381 */
       char unused_pad2;             /* 385 */
       struct sparse sp[SPARSES_IN_OLDGNU_HEADER];
                                     /* 386 */
       char isextended;              /* 482 */
       char realsize[12];            /* 483 */
                                     /* 495 */
     };
     
     /* OLDGNU_MAGIC uses both magic and version fields, which are contiguous.
        Found in an archive, it indicates an old GNU header format, which will be
        hopefully become obsolescent.  With OLDGNU_MAGIC, uname and gname are
        valid, though the header is not truly POSIX conforming.  */
     #define OLDGNU_MAGIC "ustar  "  /* 7 chars and a null */
     
     /* The standards committee allows only capital A through capital Z for
        user-defined expansion.  */
     
     /* This is a dir entry that contains the names of files that were in the
        dir at the time the dump was made.  */
     #define GNUTYPE_DUMPDIR 'D'
     
     /* Identifies the *next* file on the tape as having a long linkname.  */
     #define GNUTYPE_LONGLINK 'K'
     
     /* Identifies the *next* file on the tape as having a long name.  */
     #define GNUTYPE_LONGNAME 'L'
     
     /* This is the continuation of a file that began on another volume.  */
     #define GNUTYPE_MULTIVOL 'M'
     
     /* For storing filenames that do not fit into the main header.  */
     #define GNUTYPE_NAMES 'N'
     
     /* This is for sparse files.  */
     #define GNUTYPE_SPARSE 'S'
     
     /* This file is a tape/volume header.  Ignore it on extraction.  */
     #define GNUTYPE_VOLHDR 'V'
     
     /* tar Header Block, overall structure.  */
     
     /* tar files are made in basic blocks of this size.  */
     #define BLOCKSIZE 512
     
     enum archive_format
     {
       DEFAULT_FORMAT,               /* format to be decided later */
       V7_FORMAT,                    /* old V7 tar format */
       OLDGNU_FORMAT,                /* GNU format as per before tar 1.12 */
       POSIX_FORMAT,                 /* restricted, pure POSIX format */
       GNU_FORMAT                    /* POSIX format with GNU extensions */
     };
     
     union block
     {
       char buffer[BLOCKSIZE];
       struct posix_header header;
       struct extra_header extra_header;
       struct oldgnu_header oldgnu_header;
       struct sparse_header sparse_header;
     };
     
     /* End of Format description.  */

   All characters in header blocks are represented by using 8-bit
characters in the local variant of ASCII.  Each field within the
structure is contiguous; that is, there is no padding used within the
structure.  Each character on the archive medium is stored contiguously.

   Bytes representing the contents of files (after the header block of
each file) are not translated in any way and are not constrained to
represent characters in any character set.  The `tar' format does not
distinguish text files from binary files, and no translation of file
contents is performed.

   The `name', `linkname', `magic', `uname', and `gname' are
null-terminated character strings.  All other fields are zero-filled
octal numbers in ASCII.  Each numeric field of width W contains W minus
2 digits, a space, and a null, except `size', and `mtime', which do not
contain the trailing null.

   The `name' field is the file name of the file, with directory names
(if any) preceding the file name, separated by slashes.

   The `mode' field provides nine bits specifying file permissions and
three bits to specify the Set UID, Set GID, and Save Text ("sticky")
modes.  Values for these bits are defined above.  When special
permissions are required to create a file with a given mode, and the
user restoring files from the archive does not hold such permissions,
the mode bit(s) specifying those special permissions are ignored.
Modes which are not supported by the operating system restoring files
from the archive will be ignored.  Unsupported modes should be faked up
when creating or updating an archive; e.g. the group permission could
be copied from the _other_ permission.

   The `uid' and `gid' fields are the numeric user and group ID of the
file owners, respectively.  If the operating system does not support
numeric user or group IDs, these fields should be ignored.

   The `size' field is the size of the file in bytes; linked files are
archived with this field specified as zero.

   The `mtime' field is the modification time of the file at the time
it was archived.  It is the ASCII representation of the octal value of
the last time the file was modified, represented as an integer number of
seconds since January 1, 1970, 00:00 Coordinated Universal Time.

   The `chksum' field is the ASCII representation of the octal value of
the simple sum of all bytes in the header block.  Each 8-bit byte in
the header is added to an unsigned integer, initialized to zero, the
precision of which shall be no less than seventeen bits.  When
calculating the checksum, the `chksum' field is treated as if it were
all blanks.

   The `typeflag' field specifies the type of file archived.  If a
particular implementation does not recognize or permit the specified
type, the file will be extracted as if it were a regular file.  As this
action occurs, `tar' issues a warning to the standard error.

   The `atime' and `ctime' fields are used in making incremental
backups; they store, respectively, the particular file's access time
and last inode-change time.

   The `offset' is used by the `--multi-volume' (`-M') option, when
making a multi-volume archive.  The offset is number of bytes into the
file that we need to restart at to continue the file on the next tape,
i.e., where we store the location that a continued file is continued at.

   The following fields were added to deal with sparse files.  A file
is "sparse" if it takes in unallocated blocks which end up being
represented as zeros, i.e., no useful data.  A test to see if a file is
sparse is to look at the number blocks allocated for it versus the
number of characters in the file; if there are fewer blocks allocated
for the file than would normally be allocated for a file of that size,
then the file is sparse.  This is the method `tar' uses to detect a
sparse file, and once such a file is detected, it is treated
differently from non-sparse files.

   Sparse files are often `dbm' files, or other database-type files
which have data at some points and emptiness in the greater part of the
file.  Such files can appear to be very large when an `ls -l' is done
on them, when in truth, there may be a very small amount of important
data contained in the file.  It is thus undesirable to have `tar' think
that it must back up this entire file, as great quantities of room are
wasted on empty blocks, which can lead to running out of room on a tape
far earlier than is necessary.  Thus, sparse files are dealt with so
that these empty blocks are not written to the tape.  Instead, what is
written to the tape is a description, of sorts, of the sparse file:
where the holes are, how big the holes are, and how much data is found
at the end of the hole.  This way, the file takes up potentially far
less room on the tape, and when the file is extracted later on, it will
look exactly the way it looked beforehand.  The following is a
description of the fields used to handle a sparse file:

   The `sp' is an array of `struct sparse'.  Each `struct sparse'
contains two 12-character strings which represent an offset into the
file and a number of bytes to be written at that offset.  The offset is
absolute, and not relative to the offset in preceding array element.

   The header can hold four of these `struct sparse' at the moment; if
more are needed, they are not stored in the header.

   The `isextended' flag is set when an `extended_header' is needed to
deal with a file.  Note that this means that this flag can only be set
when dealing with a sparse file, and it is only set in the event that
the description of the file will not fit in the allotted room for
sparse structures in the header.  In other words, an extended_header is
needed.

   The `extended_header' structure is used for sparse files which need
more sparse structures than can fit in the header.  The header can fit
4 such structures; if more are needed, the flag `isextended' gets set
and the next block is an `extended_header'.

   Each `extended_header' structure contains an array of 21 sparse
structures, along with a similar `isextended' flag that the header had.
There can be an indeterminate number of such `extended_header's to
describe a sparse file.

`REGTYPE'
`AREGTYPE'
     These flags represent a regular file.  In order to be compatible
     with older versions of `tar', a `typeflag' value of `AREGTYPE'
     should be silently recognized as a regular file.  New archives
     should be created using `REGTYPE'.  Also, for backward
     compatibility, `tar' treats a regular file whose name ends with a
     slash as a directory.

`LNKTYPE'
     This flag represents a file linked to another file, of any type,
     previously archived.  Such files are identified in Unix by each
     file having the same device and inode number.  The linked-to name
     is specified in the `linkname' field with a trailing null.

`SYMTYPE'
     This represents a symbolic link to another file.  The linked-to
     name is specified in the `linkname' field with a trailing null.

`CHRTYPE'
`BLKTYPE'
     These represent character special files and block special files
     respectively.  In this case the `devmajor' and `devminor' fields
     will contain the major and minor device numbers respectively.
     Operating systems may map the device specifications to their own
     local specification, or may ignore the entry.

`DIRTYPE'
     This flag specifies a directory or sub-directory.  The directory
     name in the `name' field should end with a slash.  On systems where
     disk allocation is performed on a directory basis, the `size' field
     will contain the maximum number of bytes (which may be rounded to
     the nearest disk block allocation unit) which the directory may
     hold.  A `size' field of zero indicates no such limiting.  Systems
     which do not support limiting in this manner should ignore the
     `size' field.

`FIFOTYPE'
     This specifies a FIFO special file.  Note that the archiving of a
     FIFO file archives the existence of this file and not its contents.

`CONTTYPE'
     This specifies a contiguous file, which is the same as a normal
     file except that, in operating systems which support it, all its
     space is allocated contiguously on the disk.  Operating systems
     which do not allow contiguous allocation should silently treat this
     type as a normal file.

`A' ... `Z'
     These are reserved for custom implementations.  Some of these are
     used in the GNU modified format, as described below.

   Other values are reserved for specification in future revisions of
the P1003 standard, and should not be used by any `tar' program.

   The `magic' field indicates that this archive was output in the
P1003 archive format.  If this field contains `TMAGIC', the `uname' and
`gname' fields will contain the ASCII representation of the owner and
group of the file respectively.  If found, the user and group IDs are
used rather than the values in the `uid' and `gid' fields.

   For references, see ISO/IEC 9945-1:1990 or IEEE Std 1003.1-1990,
pages 169-173 (section 10.1) for `Archive/Interchange File Format'; and
IEEE Std 1003.2-1992, pages 380-388 (section 4.48) and pages 936-940
(section E.4.48) for `pax - Portable archive interchange'.


File: tar.info,  Node: Extensions,  Next: cpio,  Prev: Standard,  Up: Formats

GNU Extensions to the Archive Format
====================================

     _(This message will disappear, once this node revised.)_

   The GNU format uses additional file types to describe new types of
files in an archive.  These are listed below.

`GNUTYPE_DUMPDIR'
`'D''
     This represents a directory and a list of files created by the
     `--incremental' (`-G') option.  The `size' field gives the total
     size of the associated list of files.  Each file name is preceded
     by either a `Y' (the file should be in this archive) or an `N'.
     (The file is a directory, or is not stored in the archive.)  Each
     file name is terminated by a null.  There is an additional null
     after the last file name.

`GNUTYPE_MULTIVOL'
`'M''
     This represents a file continued from another volume of a
     multi-volume archive created with the `--multi-volume' (`-M')
     option.  The original type of the file is not given here.  The
     `size' field gives the maximum size of this piece of the file
     (assuming the volume does not end before the file is written out).
     The `offset' field gives the offset from the beginning of the
     file where this part of the file begins.  Thus `size' plus
     `offset' should equal the original size of the file.

`GNUTYPE_SPARSE'
`'S''
     This flag indicates that we are dealing with a sparse file.  Note
     that archiving a sparse file requires special operations to find
     holes in the file, which mark the positions of these holes, along
     with the number of bytes of data to be found after the hole.

`GNUTYPE_VOLHDR'
`'V''
     This file type is used to mark the volume header that was given
     with the `--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option when
     the archive was created.  The `name' field contains the `name'
     given after the `--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL')
     option.  The `size' field is zero.  Only the first file in each
     volume of an archive should have this type.

   You may have trouble reading a GNU format archive on a non-GNU
system if the options `--incremental' (`-G'), `--multi-volume' (`-M'),
`--sparse' (`-S'), or `--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') were
used when writing the archive.  In general, if `tar' does not use the
GNU-added fields of the header, other versions of `tar' should be able
to read the archive.  Otherwise, the `tar' program will give an error,
the most likely one being a checksum error.


File: tar.info,  Node: cpio,  Prev: Extensions,  Up: Formats

Comparison of `tar' and `cpio'
==============================

     _(This message will disappear, once this node revised.)_

   The `cpio' archive formats, like `tar', do have maximum pathname
lengths.  The binary and old ASCII formats have a max path length of
256, and the new ASCII and CRC ASCII formats have a max path length of
1024.  GNU `cpio' can read and write archives with arbitrary pathname
lengths, but other `cpio' implementations may crash unexplainedly
trying to read them.

   `tar' handles symbolic links in the form in which it comes in BSD;
`cpio' doesn't handle symbolic links in the form in which it comes in
System V prior to SVR4, and some vendors may have added symlinks to
their system without enhancing `cpio' to know about them.  Others may
have enhanced it in a way other than the way I did it at Sun, and which
was adopted by AT&T (and which is, I think, also present in the `cpio'
that Berkeley picked up from AT&T and put into a later BSD release--I
think I gave them my changes).

   (SVR4 does some funny stuff with `tar'; basically, its `cpio' can
handle `tar' format input, and write it on output, and it probably
handles symbolic links.  They may not have bothered doing anything to
enhance `tar' as a result.)

   `cpio' handles special files; traditional `tar' doesn't.

   `tar' comes with V7, System III, System V, and BSD source; `cpio'
comes only with System III, System V, and later BSD (4.3-tahoe and
later).

   `tar''s way of handling multiple hard links to a file can handle
file systems that support 32-bit inumbers (e.g., the BSD file system);
`cpio's way requires you to play some games (in its "binary" format,
i-numbers are only 16 bits, and in its "portable ASCII" format, they're
18 bits--it would have to play games with the "file system ID" field of
the header to make sure that the file system ID/i-number pairs of
different files were always different), and I don't know which `cpio's,
if any, play those games.  Those that don't might get confused and
think two files are the same file when they're not, and make hard links
between them.

   `tar's way of handling multiple hard links to a file places only one
copy of the link on the tape, but the name attached to that copy is the
_only_ one you can use to retrieve the file; `cpio's way puts one copy
for every link, but you can retrieve it using any of the names.

     What type of check sum (if any) is used, and how is this
     calculated.

   See the attached manual pages for `tar' and `cpio' format.  `tar'
uses a checksum which is the sum of all the bytes in the `tar' header
for a file; `cpio' uses no checksum.

     If anyone knows why `cpio' was made when `tar' was present at the
     unix scene,

   It wasn't.  `cpio' first showed up in PWB/UNIX 1.0; no
generally-available version of UNIX had `tar' at the time.  I don't
know whether any version that was generally available _within AT&T_ had
`tar', or, if so, whether the people within AT&T who did `cpio' knew
about it.

   On restore, if there is a corruption on a tape `tar' will stop at
that point, while `cpio' will skip over it and try to restore the rest
of the files.

   The main difference is just in the command syntax and header format.

   `tar' is a little more tape-oriented in that everything is blocked
to start on a record boundary.

     Is there any differences between the ability to recover crashed
     archives between the two of them. (Is there any chance of
     recovering crashed archives at all.)

   Theoretically it should be easier under `tar' since the blocking
lets you find a header with some variation of `dd skip=NN'.  However,
modern `cpio''s and variations have an option to just search for the
next file header after an error with a reasonable chance of resyncing.
However, lots of tape driver software won't allow you to continue past
a media error which should be the only reason for getting out of sync
unless a file changed sizes while you were writing the archive.

     If anyone knows why `cpio' was made when `tar' was present at the
     unix scene, please tell me about this too.

   Probably because it is more media efficient (by not blocking
everything and using only the space needed for the headers where `tar'
always uses 512 bytes per file header) and it knows how to archive
special files.

   You might want to look at the freely available alternatives.  The
major ones are `afio', GNU `tar', and `pax', each of which have their
own extensions with some backwards compatibility.

   Sparse files were `tar'red as sparse files (which you can easily
test, because the resulting archive gets smaller, and GNU `cpio' can no
longer read it).


File: tar.info,  Node: Media,  Next: Free Software Needs Free Documentation,  Prev: Formats,  Up: Top

Tapes and Other Archive Media
*****************************

     _(This message will disappear, once this node revised.)_

   A few special cases about tape handling warrant more detailed
description.  These special cases are discussed below.

   Many complexities surround the use of `tar' on tape drives.  Since
the creation and manipulation of archives located on magnetic tape was
the original purpose of `tar', it contains many features making such
manipulation easier.

   Archives are usually written on dismountable media--tape cartridges,
mag tapes, or floppy disks.

   The amount of data a tape or disk holds depends not only on its size,
but also on how it is formatted.  A 2400 foot long reel of mag tape
holds 40 megabytes of data when formatted at 1600 bits per inch.  The
physically smaller EXABYTE tape cartridge holds 2.3 gigabytes.

   Magnetic media are re-usable--once the archive on a tape is no longer
needed, the archive can be erased and the tape or disk used over.
Media quality does deteriorate with use, however.  Most tapes or disks
should be discarded when they begin to produce data errors.  EXABYTE
tape cartridges should be discarded when they generate an "error count"
(number of non-usable bits) of more than 10k.

   Magnetic media are written and erased using magnetic fields, and
should be protected from such fields to avoid damage to stored data.
Sticking a floppy disk to a filing cabinet using a magnet is probably
not a good idea.

* Menu:

* Device::                      Device selection and switching
* Remote Tape Server::
* Common Problems and Solutions::
* Blocking::                    Blocking
* Many::                        Many archives on one tape
* Using Multiple Tapes::        Using Multiple Tapes
* label::                       Including a Label in the Archive
* verify::
* Write Protection::


File: tar.info,  Node: Device,  Next: Remote Tape Server,  Up: Media

Device Selection and Switching
==============================

     _(This message will disappear, once this node revised.)_

`-f [HOSTNAME:]FILE'
`--file=[HOSTNAME:]FILE'
     Use archive file or device FILE on HOSTNAME.

   This option is used to specify the file name of the archive `tar'
works on.

   If the file name is `-', `tar' reads the archive from standard input
(when listing or extracting), or writes it to standard output (when
creating).  If the `-' file name is given when updating an archive,
`tar' will read the original archive from its standard input, and will
write the entire new archive to its standard output.

   If the file name contains a `:', it is interpreted as `hostname:file
name'.  If the HOSTNAME contains an "at" sign (`@'), it is treated as
`user@hostname:file name'.  In either case, `tar' will invoke the
command `rsh' (or `remsh') to start up an `/etc/rmt' on the remote
machine.  If you give an alternate login name, it will be given to the
`rsh'.  Naturally, the remote machine must have an executable
`/etc/rmt'.  This program is free software from the University of
California, and a copy of the source code can be found with the sources
for `tar'; it's compiled and installed by default.

   If this option is not given, but the environment variable `TAPE' is
set, its value is used; otherwise, old versions of `tar' used a default
archive name (which was picked when `tar' was compiled).  The default
is normally set up to be the "first" tape drive or other transportable
I/O medium on the system.

   Starting with version 1.11.5, GNU `tar' uses standard input and
standard output as the default device, and I will not try anymore
supporting automatic device detection at installation time.  This was
failing really in too many cases, it was hopeless.  This is now
completely left to the installer to override standard input and standard
output for default device, if this seems preferable.  Further, I think
_most_ actual usages of `tar' are done with pipes or disks, not really
tapes, cartridges or diskettes.

   Some users think that using standard input and output is running
after trouble.  This could lead to a nasty surprise on your screen if
you forget to specify an output file name--especially if you are going
through a network or terminal server capable of buffering large amounts
of output.  We had so many bug reports in that area of configuring
default tapes automatically, and so many contradicting requests, that
we finally consider the problem to be portably intractable.  We could
of course use something like `/dev/tape' as a default, but this is
_also_ running after various kind of trouble, going from hung processes
to accidental destruction of real tapes.  After having seen all this
mess, using standard input and output as a default really sounds like
the only clean choice left, and a very useful one too.

   GNU `tar' reads and writes archive in records, I suspect this is the
main reason why block devices are preferred over character devices.
Most probably, block devices are more efficient too.  The installer
could also check for `DEFTAPE' in `<sys/mtio.h>'.

`--force-local'
     Archive file is local even if it contains a colon.

`--rsh-command=COMMAND'
     Use remote COMMAND instead of `rsh'.  This option exists so that
     people who use something other than the standard `rsh' (e.g., a
     Kerberized `rsh') can access a remote device.

     When this command is not used, the shell command found when the
     `tar' program was installed is used instead.  This is the first
     found of `/usr/ucb/rsh', `/usr/bin/remsh', `/usr/bin/rsh',
     `/usr/bsd/rsh' or `/usr/bin/nsh'.  The installer may have
     overridden this by defining the environment variable `RSH' _at
     installation time_.

`-[0-7][lmh]'
     Specify drive and density.

`-M'
`--multi-volume'
     Create/list/extract multi-volume archive.

     This option causes `tar' to write a "multi-volume" archive--one
     that may be larger than will fit on the medium used to hold it.
     *Note Multi-Volume Archives::.

`-L NUM'
`--tape-length=NUM'
     Change tape after writing NUM x 1024 bytes.

     This option might be useful when your tape drivers do not properly
     detect end of physical tapes.  By being slightly conservative on
     the maximum tape length, you might avoid the problem entirely.

`-F FILE'
`--info-script=FILE'
`--new-volume-script=FILE'
     Execute `file' at end of each tape.  If `file' exits with nonzero
     status, exit.  This implies `--multi-volume' (`-M').


File: tar.info,  Node: Remote Tape Server,  Next: Common Problems and Solutions,  Prev: Device,  Up: Media

The Remote Tape Server
======================

   In order to access the tape drive on a remote machine, `tar' uses
the remote tape server written at the University of California at
Berkeley.  The remote tape server must be installed as `/etc/rmt' on
any machine whose tape drive you want to use.  `tar' calls `/etc/rmt'
by running an `rsh' or `remsh' to the remote machine, optionally using
a different login name if one is supplied.

   A copy of the source for the remote tape server is provided.  It is
Copyright (C) 1983 by the Regents of the University of California, but
can be freely distributed.  Instructions for compiling and installing
it are included in the `Makefile'.

   Unless you use the `--absolute-names' (`-P') option, GNU `tar' will
not allow you to create an archive that contains absolute file names (a
file name beginning with `/'.) If you try, `tar' will automatically
remove the leading `/' from the file names it stores in the archive.
It will also type a warning message telling you what it is doing.

   When reading an archive that was created with a different `tar'
program, GNU `tar' automatically extracts entries in the archive which
have absolute file names as if the file names were not absolute.  This
is an important feature.  A visitor here once gave a `tar' tape to an
operator to restore; the operator used Sun `tar' instead of GNU `tar',
and the result was that it replaced large portions of our `/bin' and
friends with versions from the tape; needless to say, we were unhappy
about having to recover the file system from backup tapes.

   For example, if the archive contained a file `/usr/bin/computoy',
GNU `tar' would extract the file to `usr/bin/computoy', relative to the
current directory.  If you want to extract the files in an archive to
the same absolute names that they had when the archive was created, you
should do a `cd /' before extracting the files from the archive, or you
should either use the `--absolute-names' (`-P') option, or use the
command `tar -C / ...'.

   Some versions of Unix (Ultrix 3.1 is known to have this problem),
can claim that a short write near the end of a tape succeeded, when it
actually failed.  This will result in the -M option not working
correctly.  The best workaround at the moment is to use a significantly
larger blocking factor than the default 20.

   In order to update an archive, `tar' must be able to backspace the
archive in order to reread or rewrite a record that was just read (or
written).  This is currently possible only on two kinds of files: normal
disk files (or any other file that can be backspaced with `lseek'), and
industry-standard 9-track magnetic tape (or any other kind of tape that
can be backspaced with the `MTIOCTOP' `ioctl'.

   This means that the `--append' (`-r'), `--update' (`-u'),
`--concatenate' (`--catenate', `-A'), and `--delete' commands will not
work on any other kind of file.  Some media simply cannot be
backspaced, which means these commands and options will never be able
to work on them.  These non-backspacing media include pipes and
cartridge tape drives.

   Some other media can be backspaced, and `tar' will work on them once
`tar' is modified to do so.

   Archives created with the `--multi-volume' (`-M'),
`--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL'), and `--incremental'
(`-G') options may not be readable by other version of `tar'.  In
particular, restoring a file that was split over a volume boundary will
require some careful work with `dd', if it can be done at all.  Other
versions of `tar' may also create an empty file whose name is that of
the volume header.  Some versions of `tar' may create normal files
instead of directories archived with the `--incremental' (`-G') option.


File: tar.info,  Node: Common Problems and Solutions,  Next: Blocking,  Prev: Remote Tape Server,  Up: Media

Some Common Problems and their Solutions
========================================

errors from system:
permission denied
no such file or directory
not owner

errors from `tar':
directory checksum error
header format error

errors from media/system:
i/o error
device busy


File: tar.info,  Node: Blocking,  Next: Many,  Prev: Common Problems and Solutions,  Up: Media

Blocking
========

     _(This message will disappear, once this node revised.)_

   "Block" and "record" terminology is rather confused, and it is also
confusing to the expert reader.  On the other hand, readers who are new
to the field have a fresh mind, and they may safely skip the next two
paragraphs, as the remainder of this manual uses those two terms in a
quite consistent way.

   John Gilmore, the writer of the public domain `tar' from which GNU
`tar' was originally derived, wrote (June 1995):

     The nomenclature of tape drives comes from IBM, where I believe
     they were invented for the IBM 650 or so.  On IBM mainframes, what
     is recorded on tape are tape blocks.  The logical organization of
     data is into records.  There are various ways of putting records
     into blocks, including `F' (fixed sized records), `V' (variable
     sized records), `FB' (fixed blocked: fixed size records, N to a
     block), `VB' (variable size records, N to a block), `VSB'
     (variable spanned blocked: variable sized records that can occupy
     more than one block), etc.  The `JCL' `DD RECFORM=' parameter
     specified this to the operating system.

     The Unix man page on `tar' was totally confused about this.  When
     I wrote `PD TAR', I used the historically correct terminology
     (`tar' writes data records, which are grouped into blocks).  It
     appears that the bogus terminology made it into POSIX (no surprise
     here), and now Franc,ois has migrated that terminology back into
     the source code too.

   The term "physical block" means the basic transfer chunk from or to
a device, after which reading or writing may stop without anything
being lost.  In this manual, the term "block" usually refers to a disk
physical block, _assuming_ that each disk block is 512 bytes in length.
It is true that some disk devices have different physical blocks, but
`tar' ignore these differences in its own format, which is meant to be
portable, so a `tar' block is always 512 bytes in length, and "block"
always mean a `tar' block.  The term "logical block" often represents
the basic chunk of allocation of many disk blocks as a single entity,
which the operating system treats somewhat atomically; this concept is
only barely used in GNU `tar'.

   The term "physical record" is another way to speak of a physical
block, those two terms are somewhat interchangeable.  In this manual,
the term "record" usually refers to a tape physical block, _assuming_
that the `tar' archive is kept on magnetic tape.  It is true that
archives may be put on disk or used with pipes, but nevertheless, `tar'
tries to read and write the archive one "record" at a time, whatever
the medium in use.  One record is made up of an integral number of
blocks, and this operation of putting many disk blocks into a single
tape block is called "reblocking", or more simply, "blocking".  The
term "logical record" refers to the logical organization of many
characters into something meaningful to the application.  The term
"unit record" describes a small set of characters which are transmitted
whole to or by the application, and often refers to a line of text.
Those two last terms are unrelated to what we call a "record" in GNU
`tar'.

   When writing to tapes, `tar' writes the contents of the archive in
chunks known as "records".  To change the default blocking factor, use
the `--blocking-factor=512-SIZE' (`-b 512-SIZE') option.  Each record
will then be composed of 512-SIZE blocks.  (Each `tar' block is 512
bytes.  *Note Standard::.)  Each file written to the archive uses at
least one full record.  As a result, using a larger record size can
result in more wasted space for small files.  On the other hand, a
larger record size can often be read and written much more efficiently.

   Further complicating the problem is that some tape drives ignore the
blocking entirely.  For these, a larger record size can still improve
performance (because the software layers above the tape drive still
honor the blocking), but not as dramatically as on tape drives that
honor blocking.

   When reading an archive, `tar' can usually figure out the record
size on itself.  When this is the case, and a non-standard record size
was used when the archive was created, `tar' will print a message about
a non-standard blocking factor, and then operate normally.  On some
tape devices, however, `tar' cannot figure out the record size itself.
On most of those, you can specify a blocking factor (with
`--blocking-factor=512-SIZE' (`-b 512-SIZE')) larger than the actual
blocking factor, and then use the `--read-full-records' (`-B') option.
(If you specify a blocking factor with `--blocking-factor=512-SIZE'
(`-b 512-SIZE') and don't use the `--read-full-records' (`-B') option,
then `tar' will not attempt to figure out the recording size itself.)
On some devices, you must always specify the record size exactly with
`--blocking-factor=512-SIZE' (`-b 512-SIZE') when reading, because
`tar' cannot figure it out.  In any case, use `--list' (`-t') before
doing any extractions to see whether `tar' is reading the archive
correctly.

   `tar' blocks are all fixed size (512 bytes), and its scheme for
putting them into records is to put a whole number of them (one or
more) into each record.  `tar' records are all the same size; at the
end of the file there's a block containing all zeros, which is how you
tell that the remainder of the last record(s) are garbage.

   In a standard `tar' file (no options), the block size is 512 and the
record size is 10240, for a blocking factor of 20.  What the
`--blocking-factor=512-SIZE' (`-b 512-SIZE') option does is sets the
blocking factor, changing the record size while leaving the block size
at 512 bytes.  20 was fine for ancient 800 or 1600 bpi reel-to-reel
tape drives; most tape drives these days prefer much bigger records in
order to stream and not waste tape.  When writing tapes for myself,
some tend to use a factor of the order of 2048, say, giving a record
size of around one megabyte.

   If you use a blocking factor larger than 20, older `tar' programs
might not be able to read the archive, so we recommend this as a limit
to use in practice.  GNU `tar', however, will support arbitrarily large
record sizes, limited only by the amount of virtual memory or the
physical characteristics of the tape device.

* Menu:

* Format Variations::           Format Variations
* Blocking Factor::             The Blocking Factor of an Archive


File: tar.info,  Node: Format Variations,  Next: Blocking Factor,  Up: Blocking

Format Variations
-----------------

     _(This message will disappear, once this node revised.)_

   Format parameters specify how an archive is written on the archive
media.  The best choice of format parameters will vary depending on the
type and number of files being archived, and on the media used to store
the archive.

   To specify format parameters when accessing or creating an archive,
you can use the options described in the following sections.  If you do
not specify any format parameters, `tar' uses default parameters.  You
cannot modify a compressed archive.  If you create an archive with the
`--blocking-factor=512-SIZE' (`-b 512-SIZE') option specified
(*note Blocking Factor::), you must specify that blocking-factor when
operating on the archive.  *Note Formats::, for other examples of
format parameter considerations.


File: tar.info,  Node: Blocking Factor,  Prev: Format Variations,  Up: Blocking

The Blocking Factor of an Archive
---------------------------------

     _(This message will disappear, once this node revised.)_

   The data in an archive is grouped into blocks, which are 512 bytes.
Blocks are read and written in whole number multiples called "records".
The number of blocks in a record (ie. the size of a record in units of
512 bytes) is called the "blocking factor".  The
`--blocking-factor=512-SIZE' (`-b 512-SIZE') option specifies the
blocking factor of an archive.  The default blocking factor is
typically 20 (ie.  10240 bytes), but can be specified at installation.
To find out the blocking factor of an existing archive, use `tar --list
--file=ARCHIVE-NAME'.  This may not work on some devices.

   Records are separated by gaps, which waste space on the archive
media.  If you are archiving on magnetic tape, using a larger blocking
factor (and therefore larger records) provides faster throughput and
allows you to fit more data on a tape (because there are fewer gaps).
If you are archiving on cartridge, a very large blocking factor (say
126 or more) greatly increases performance. A smaller blocking factor,
on the other hand, may be useful when archiving small files, to avoid
archiving lots of nulls as `tar' fills out the archive to the end of
the record.  In general, the ideal record size depends on the size of
the inter-record gaps on the tape you are using, and the average size
of the files you are archiving.  *Note create::, for information on
writing archives.

   Archives with blocking factors larger than 20 cannot be read by very
old versions of `tar', or by some newer versions of `tar' running on
old machines with small address spaces.  With GNU `tar', the blocking
factor of an archive is limited only by the maximum record size of the
device containing the archive, or by the amount of available virtual
memory.

   Also, on some systems, not using adequate blocking factors, as
sometimes imposed by the device drivers, may yield unexpected
diagnostics.  For example, this has been reported:

     Cannot write to /dev/dlt: Invalid argument

In such cases, it sometimes happen that the `tar' bundled by the system
is aware of block size idiosyncrasies, while GNU `tar' requires an
explicit specification for the block size, which it cannot guess.  This
yields some people to consider GNU `tar' is misbehaving, because by
comparison, `the bundle `tar' works OK'.  Adding `-b 256', for example,
might resolve the problem.

   If you use a non-default blocking factor when you create an archive,
you must specify the same blocking factor when you modify that archive.
Some archive devices will also require you to specify the blocking
factor when reading that archive, however this is not typically the
case.  Usually, you can use `--list' (`-t') without specifying a
blocking factor--`tar' reports a non-default record size and then lists
the archive members as it would normally.  To extract files from an
archive with a non-standard blocking factor (particularly if you're not
sure what the blocking factor is), you can usually use the
`--read-full-records' (`-B') option while specifying a blocking factor
larger then the blocking factor of the archive (ie. `tar --extract
--read-full-records --blocking-factor=300'.  *Note list::, for more
information on the `--list' (`-t') operation.  *Note Reading::, for a
more detailed explanation of that option.

`--blocking-factor=NUMBER'
`-b NUMBER'
     Specifies the blocking factor of an archive.  Can be used with any
     operation, but is usually not necessary with `--list' (`-t').

   Device blocking

`-b BLOCKS'
`--blocking-factor=BLOCKS'
     Set record size to BLOCKS * 512 bytes.

     This option is used to specify a "blocking factor" for the archive.
     When reading or writing the archive, `tar', will do reads and
     writes of the archive in records of BLOCK*512 bytes.  This is true
     even when the archive is compressed.  Some devices requires that
     all write operations be a multiple of a certain size, and so, `tar'
     pads the archive out to the next record boundary.

     The default blocking factor is set when `tar' is compiled, and is
     typically 20.  Blocking factors larger than 20 cannot be read by
     very old versions of `tar', or by some newer versions of `tar'
     running on old machines with small address spaces.

     With a magnetic tape, larger records give faster throughput and fit
     more data on a tape (because there are fewer inter-record gaps).
     If the archive is in a disk file or a pipe, you may want to specify
     a smaller blocking factor, since a large one will result in a large
     number of null bytes at the end of the archive.

     When writing cartridge or other streaming tapes, a much larger
     blocking factor (say 126 or more) will greatly increase
     performance.  However, you must specify the same blocking factor
     when reading or updating the archive.

     Apparently, Exabyte drives have a physical block size of 8K bytes.
     If we choose our blocksize as a multiple of 8k bytes, then the
     problem seems to dissapper.  Id est, we are using block size of
     112 right now, and we haven't had the problem since we switched...

     With GNU `tar' the blocking factor is limited only by the maximum
     record size of the device containing the archive, or by the amount
     of available virtual memory.

     However, deblocking or reblocking is virtually avoided in a special
     case which often occurs in practice, but which requires all the
     following conditions to be simultaneously true:
        * the archive is subject to a compression option,

        * the archive is not handled through standard input or output,
          nor redirected nor piped,

        * the archive is directly handled to a local disk, instead of
          any special device,

        * `--blocking-factor=512-SIZE' (`-b 512-SIZE') is not
          explicitly specified on the `tar' invocation.

     In previous versions of GNU `tar', the `--compress-block' option
     (or even older: `--block-compress') was necessary to reblock
     compressed archives.  It is now a dummy option just asking not to
     be used, and otherwise ignored.  If the output goes directly to a
     local disk, and not through stdout, then the last write is not
     extended to a full record size.  Otherwise, reblocking occurs.
     Here are a few other remarks on this topic:

        * `gzip' will complain about trailing garbage if asked to
          uncompress a compressed archive on tape, there is an option
          to turn the message off, but it breaks the regularity of
          simply having to use `PROG -d' for decompression.  It would
          be nice if gzip was silently ignoring any number of trailing
          zeros.  I'll ask Jean-loup Gailly, by sending a copy of this
          message to him.

        * `compress' does not show this problem, but as Jean-loup
          pointed out to Michael, `compress -d' silently adds garbage
          after the result of decompression, which tar ignores because
          it already recognized its end-of-file indicator.  So this bug
          may be safely ignored.

        * `gzip -d -q' will be silent about the trailing zeros indeed,
          but will still return an exit status of 2 which tar reports
          in turn.  `tar' might ignore the exit status returned, but I
          hate doing that, as it weakens the protection `tar' offers
          users against other possible problems at decompression time.
          If `gzip' was silently skipping trailing zeros _and_ also
          avoiding setting the exit status in this innocuous case, that
          would solve this situation.

        * `tar' should become more solid at not stopping to read a pipe
          at the first null block encountered.  This inelegantly breaks
          the pipe.  `tar' should rather drain the pipe out before
          exiting itself.

`-i'
`--ignore-zeros'
     Ignore blocks of zeros in archive (means EOF).

     The `--ignore-zeros' (`-i') option causes `tar' to ignore blocks
     of zeros in the archive.  Normally a block of zeros indicates the
     end of the archive, but when reading a damaged archive, or one
     which was created by concatenating several archives together, this
     option allows `tar' to read the entire archive.  This option is
     not on by default because many versions of `tar' write garbage
     after the zeroed blocks.

     Note that this option causes `tar' to read to the end of the
     archive file, which may sometimes avoid problems when multiple
     files are stored on a single physical tape.

`-B'
`--read-full-records'
     Reblock as we read (for reading 4.2BSD pipes).

     If `--read-full-records' (`-B') is used, `tar' will not panic if an
     attempt to read a record from the archive does not return a full
     record.  Instead, `tar' will keep reading until it has obtained a
     full record.

     This option is turned on by default when `tar' is reading an
     archive from standard input, or from a remote machine.  This is
     because on BSD Unix systems, a read of a pipe will return however
     much happens to be in the pipe, even if it is less than `tar'
     requested.  If this option was not used, `tar' would fail as soon
     as it read an incomplete record from the pipe.

     This option is also useful with the commands for updating an
     archive.

   Tape blocking

   When handling various tapes or cartridges, you have to take care of
selecting a proper blocking, that is, the number of disk blocks you put
together as a single tape block on the tape, without intervening tape
gaps.  A "tape gap" is a small landing area on the tape with no
information on it, used for decelerating the tape to a full stop, and
for later regaining the reading or writing speed.  When the tape driver
starts reading a record, the record has to be read whole without
stopping, as a tape gap is needed to stop the tape motion without
loosing information.

   Using higher blocking (putting more disk blocks per tape block) will
use the tape more efficiently as there will be less tape gaps.  But
reading such tapes may be more difficult for the system, as more memory
will be required to receive at once the whole record.  Further, if
there is a reading error on a huge record, this is less likely that the
system will succeed in recovering the information.  So, blocking should
not be too low, nor it should be too high.  `tar' uses by default a
blocking of 20 for historical reasons, and it does not really matter
when reading or writing to disk.  Current tape technology would easily
accommodate higher blockings.  Sun recommends a blocking of 126 for
Exabytes and 96 for DATs.  We were told that for some DLT drives, the
blocking should be a multiple of 4Kb, preferably 64Kb (`-b 128') or 256
for decent performance.  Other manufacturers may use different
recommendations for the same tapes.  This might also depends of the
buffering techniques used inside modern tape controllers.  Some imposes
a minimum blocking, or a maximum blocking.  Others request blocking to
be some exponent of two.

   So, there is no fixed rule for blocking.  But blocking at read time
should ideally be the same as blocking used at write time.  At one place
I know, with a wide variety of equipment, they found it best to use a
blocking of 32 to guarantee that their tapes are fully interchangeable.

   I was also told that, for recycled tapes, prior erasure (by the same
drive unit that will be used to create the archives) sometimes lowers
the error rates observed at rewriting time.

   I might also use `--number-blocks' instead of `--block-number', so
`--block' will then expand to `--blocking-factor' unambiguously.


File: tar.info,  Node: Many,  Next: Using Multiple Tapes,  Prev: Blocking,  Up: Media

Many Archives on One Tape
=========================

   Most tape devices have two entries in the `/dev' directory, or
entries that come in pairs, which differ only in the minor number for
this device.  Let's take for example `/dev/tape', which often points to
the only or usual tape device of a given system.  There might be a
corresponding `/dev/nrtape' or `/dev/ntape'.  The simpler name is the
_rewinding_ version of the device, while the name having `nr' in it is
the _no rewinding_ version of the same device.

   A rewinding tape device will bring back the tape to its beginning
point automatically when this device is opened or closed.  Since `tar'
opens the archive file before using it and closes it afterwards, this
means that a simple:

     $ tar cf /dev/tape DIRECTORY

will reposition the tape to its beginning both prior and after saving
DIRECTORY contents to it, thus erasing prior tape contents and making
it so that any subsequent write operation will destroy what has just
been saved.

   So, a rewinding device is normally meant to hold one and only one
file.  If you want to put more than one `tar' archive on a given tape,
you will need to avoid using the rewinding version of the tape device.
You will also have to pay special attention to tape positioning.
Errors in positioning may overwrite the valuable data already on your
tape.  Many people, burnt by past experiences, will only use rewinding
devices and limit themselves to one file per tape, precisely to avoid
the risk of such errors.  Be fully aware that writing at the wrong
position on a tape loses all information past this point and most
probably until the end of the tape, and this destroyed information
_cannot_ be recovered.

   To save DIRECTORY-1 as a first archive at the beginning of a tape,
and leave that tape ready for a second archive, you should use:

     $ mt -f /dev/nrtape rewind
     $ tar cf /dev/nrtape DIRECTORY-1

   "Tape marks" are special magnetic patterns written on the tape
media, which are later recognizable by the reading hardware.  These
marks are used after each file, when there are many on a single tape.
An empty file (that is to say, two tape marks in a row) signal the
logical end of the tape, after which no file exist.  Usually,
non-rewinding tape device drivers will react to the close request issued
by `tar' by first writing two tape marks after your archive, and by
backspacing over one of these.  So, if you remove the tape at that time
from the tape drive, it is properly terminated.  But if you write
another file at the current position, the second tape mark will be
erased by the new information, leaving only one tape mark between files.

   So, you may now save DIRECTORY-2 as a second archive after the first
on the same tape by issuing the command:

     $ tar cf /dev/nrtape DIRECTORY-2

and so on for all the archives you want to put on the same tape.

   Another usual case is that you do not write all the archives the same
day, and you need to remove and store the tape between two archive
sessions.  In general, you must remember how many files are already
saved on your tape.  Suppose your tape already has 16 files on it, and
that you are ready to write the 17th.  You have to take care of skipping
the first 16 tape marks before saving DIRECTORY-17, say, by using these
commands:

     $ mt -f /dev/nrtape rewind
     $ mt -f /dev/nrtape fsf 16
     $ tar cf /dev/nrtape DIRECTORY-17

   In all the previous examples, we put aside blocking considerations,
but you should do the proper things for that as well.  *Note Blocking::.

* Menu:

* Tape Positioning::            Tape Positions and Tape Marks
* mt::                          The `mt' Utility


File: tar.info,  Node: Tape Positioning,  Next: mt,  Up: Many

Tape Positions and Tape Marks
-----------------------------

     _(This message will disappear, once this node revised.)_

   Just as archives can store more than one file from the file system,
tapes can store more than one archive file.  To keep track of where
archive files (or any other type of file stored on tape) begin and end,
tape archive devices write magnetic "tape marks" on the archive media.
Tape drives write one tape mark between files, two at the end of all
the file entries.

   If you think of data as a series of records "rrrr"'s, and tape marks
as "*"'s, a tape might look like the following:

     rrrr*rrrrrr*rrrrr*rr*rrrrr**-------------------------

   Tape devices read and write tapes using a read/write "tape head"--a
physical part of the device which can only access one point on the tape
at a time.  When you use `tar' to read or write archive data from a
tape device, the device will begin reading or writing from wherever on
the tape the tape head happens to be, regardless of which archive or
what part of the archive the tape head is on.  Before writing an
archive, you should make sure that no data on the tape will be
overwritten (unless it is no longer needed).  Before reading an
archive, you should make sure the tape head is at the beginning of the
archive you want to read.  (The `restore' script will find the archive
automatically.  *Note mt::, for an explanation of the tape moving
utility.

   If you want to add new archive file entries to a tape, you should
advance the tape to the end of the existing file entries, backspace
over the last tape mark, and write the new archive file.  If you were
to add two archives to the example above, the tape might look like the
following:

     rrrr*rrrrrr*rrrrr*rr*rrrrr*rrr*rrrr**----------------


File: tar.info,  Node: mt,  Prev: Tape Positioning,  Up: Many

The `mt' Utility
----------------

     _(This message will disappear, once this node revised.)_

   *Note Blocking Factor::.

   You can use the `mt' utility to advance or rewind a tape past a
specified number of archive files on the tape.  This will allow you to
move to the beginning of an archive before extracting or reading it, or
to the end of all the archives before writing a new one.

   The syntax of the `mt' command is:

     mt [-f TAPENAME] OPERATION [NUMBER]

   where TAPENAME is the name of the tape device, NUMBER is the number
of times an operation is performed (with a default of one), and
OPERATION is one of the following:

`eof'
`weof'
     Writes NUMBER tape marks at the current position on the tape.

`fsf'
     Moves tape position forward NUMBER files.

`bsf'
     Moves tape position back NUMBER files.

`rewind'
     Rewinds the tape. (Ignores NUMBER).

`offline'
`rewoff1'
     Rewinds the tape and takes the tape device off-line. (Ignores
     NUMBER).

`status'
     Prints status information about the tape unit.

   If you don't specify a TAPENAME, `mt' uses the environment variable
`TAPE'; if `TAPE' is not set, `mt' uses the device `/dev/rmt12'.

   `mt' returns a 0 exit status when the operation(s) were successful,
1 if the command was unrecognized, and 2 if an operation failed.

   If you use `--extract' (`--get', `-x') with the
`--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option specified, `tar'
will read an archive label (the tape head has to be positioned on it)
and print an error if the archive label doesn't match the ARCHIVE-NAME
specified.  ARCHIVE-NAME can be any regular expression.  If the labels
match, `tar' extracts the archive.  *Note label::.  `tar --list
--label' will cause `tar' to print the label.


File: tar.info,  Node: Using Multiple Tapes,  Next: label,  Prev: Many,  Up: Media

Using Multiple Tapes
====================

     _(This message will disappear, once this node revised.)_

   Often you might want to write a large archive, one larger than will
fit on the actual tape you are using.  In such a case, you can run
multiple `tar' commands, but this can be inconvenient, particularly if
you are using options like `--exclude=PATTERN' or dumping entire
filesystems.  Therefore, `tar' supports multiple tapes automatically.

   Use `--multi-volume' (`-M') on the command line, and then `tar' will,
when it reaches the end of the tape, prompt for another tape, and
continue the archive.  Each tape will have an independent archive, and
can be read without needing the other.  (As an exception to this, the
file that `tar' was archiving when it ran out of tape will usually be
split between the two archives; in this case you need to extract from
the first archive, using `--multi-volume' (`-M'), and then put in the
second tape when prompted, so `tar' can restore both halves of the
file.)

   GNU `tar' multi-volume archives do not use a truly portable format.
You need GNU `tar' at both end to process them properly.

   When prompting for a new tape, `tar' accepts any of the following
responses:

`?'
     Request `tar' to explain possible responses

`q'
     Request `tar' to exit immediately.

`n FILE NAME'
     Request `tar' to write the next volume on the file FILE NAME.

`!'
     Request `tar' to run a subshell.

`y'
     Request `tar' to begin writing the next volume.

   (You should only type `y' after you have changed the tape; otherwise
`tar' will write over the volume it just finished.)

   If you want more elaborate behavior than this, give `tar' the
`--info-script=SCRIPT-NAME' (`--new-volume-script=SCRIPT-NAME', `-F
SCRIPT-NAME') option.  The file SCRIPT-NAME is expected to be a program
(or shell script) to be run instead of the normal prompting procedure.
If the program fails, `tar' exits; otherwise, `tar' begins writing the
next volume.  The behavior of the `n' response to the normal
tape-change prompt is not available if you use
`--info-script=SCRIPT-NAME' (`--new-volume-script=SCRIPT-NAME', `-F
SCRIPT-NAME').

   The method `tar' uses to detect end of tape is not perfect, and
fails on some operating systems or on some devices.  You can use the
`--tape-length=1024-SIZE' (`-L 1024-SIZE') option if `tar' can't detect
the end of the tape itself.  This option selects `--multi-volume'
(`-M') automatically.  The SIZE argument should then be the usable size
of the tape.  But for many devices, and floppy disks in particular,
this option is never required for real, as far as we know.

   The volume number used by `tar' in its tape-change prompt can be
changed; if you give the `--volno-file=FILE-OF-NUMBER' option, then
FILE-OF-NUMBER should be an unexisting file to be created, or else, a
file already containing a decimal number.  That number will be used as
the volume number of the first volume written.  When `tar' is finished,
it will rewrite the file with the now-current volume number.  (This
does not change the volume number written on a tape label, as per
*Note label::, it _only_ affects the number used in the prompt.)

   If you want `tar' to cycle through a series of tape drives, then you
can use the `n' response to the tape-change prompt.  This is error
prone, however, and doesn't work at all with
`--info-script=SCRIPT-NAME' (`--new-volume-script=SCRIPT-NAME', `-F
SCRIPT-NAME').  Therefore, if you give `tar' multiple
`--file=ARCHIVE-NAME' (`-f ARCHIVE-NAME') options, then the specified
files will be used, in sequence, as the successive volumes of the
archive.  Only when the first one in the sequence needs to be used
again will `tar' prompt for a tape change (or run the info script).

   Multi-volume archives

   With `--multi-volume' (`-M'), `tar' will not abort when it cannot
read or write any more data.  Instead, it will ask you to prepare a new
volume.  If the archive is on a magnetic tape, you should change tapes
now; if the archive is on a floppy disk, you should change disks, etc.

   Each volume of a multi-volume archive is an independent `tar'
archive, complete in itself.  For example, you can list or extract any
volume alone; just don't specify `--multi-volume' (`-M').  However, if
one file in the archive is split across volumes, the only way to extract
it successfully is with a multi-volume extract command `--extract
--multi-volume' (`-xM') starting on or before the volume where the file
begins.

   For example, let's presume someone has two tape drives on a system
named `/dev/tape0' and `/dev/tape1'.  For having GNU `tar' to switch to
the second drive when it needs to write the second tape, and then back
to the first tape, etc., just do either of:

     $ tar --create --multi-volume --file=/dev/tape0 --file=/dev/tape1 FILES
     $ tar cMff /dev/tape0 /dev/tape1 FILES

* Menu:

* Multi-Volume Archives::       Archives Longer than One Tape or Disk
* Tape Files::                  Tape Files


File: tar.info,  Node: Multi-Volume Archives,  Next: Tape Files,  Up: Using Multiple Tapes

Archives Longer than One Tape or Disk
-------------------------------------

     _(This message will disappear, once this node revised.)_

   To create an archive that is larger than will fit on a single unit of
the media, use the `--multi-volume' (`-M') option in conjunction with
the `--create' (`-c') option (*note create::).  A "multi-volume"
archive can be manipulated like any other archive (provided the
`--multi-volume' (`-M') option is specified), but is stored on more
than one tape or disk.

   When you specify `--multi-volume' (`-M'), `tar' does not report an
error when it comes to the end of an archive volume (when reading), or
the end of the media (when writing).  Instead, it prompts you to load a
new storage volume.  If the archive is on a magnetic tape, you should
change tapes when you see the prompt; if the archive is on a floppy
disk, you should change disks; etc.

   You can read each individual volume of a multi-volume archive as if
it were an archive by itself.  For example, to list the contents of one
volume, use `--list' (`-t'), without `--multi-volume' (`-M') specified.
To extract an archive member from one volume (assuming it is described
that volume), use `--extract' (`--get', `-x'), again without
`--multi-volume' (`-M').

   If an archive member is split across volumes (ie. its entry begins on
one volume of the media and ends on another), you need to specify
`--multi-volume' (`-M') to extract it successfully.  In this case, you
should load the volume where the archive member starts, and use `tar
--extract --multi-volume'--`tar' will prompt for later volumes as it
needs them.  *Note extracting archives::, for more information about
extracting archives.

   `--info-script=SCRIPT-NAME' (`--new-volume-script=SCRIPT-NAME', `-F
SCRIPT-NAME') is like `--multi-volume' (`-M'), except that `tar' does
not prompt you directly to change media volumes when a volume is
full--instead, `tar' runs commands you have stored in SCRIPT-NAME.  For
example, this option can be used to eject cassettes, or to broadcast
messages such as `Someone please come change my tape' when performing
unattended backups.  When SCRIPT-NAME is done, `tar' will assume that
the media has been changed.

   Multi-volume archives can be modified like any other archive.  To add
files to a multi-volume archive, you need to only mount the last volume
of the archive media (and new volumes, if needed).  For all other
operations, you need to use the entire archive.

   If a multi-volume archive was labeled using `--label=ARCHIVE-LABEL'
(`-V ARCHIVE-LABEL') (*note label::) when it was created, `tar' will not
automatically label volumes which are added later.  To label subsequent
volumes, specify `--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') again in
conjunction with the `--append' (`-r'), `--update' (`-u') or
`--concatenate' (`--catenate', `-A') operation.

`--multi-volume'
`-M'
     Creates a multi-volume archive, when used in conjunction with
     `--create' (`-c').  To perform any other operation on a
     multi-volume archive, specify `--multi-volume' (`-M') in
     conjunction with that operation.

`--info-script=PROGRAM-FILE'
`-F PROGRAM-FILE'
     Creates a multi-volume archive via a script.  Used in conjunction
     with `--create' (`-c').

   Beware that there is _no_ real standard about the proper way, for a
`tar' archive, to span volume boundaries.  If you have a multi-volume
created by some vendor's `tar', there is almost no chance you could
read all the volumes with GNU `tar'.  The converse is also true: you
may not expect multi-volume archives created by GNU `tar' to be fully
recovered by vendor's `tar'.  Since there is little chance that, in
mixed system configurations, some vendor's `tar' will work on another
vendor's machine, and there is a great chance that GNU `tar' will work
on most of them, your best bet is to install GNU `tar' on all machines
between which you know exchange of files is possible.


File: tar.info,  Node: Tape Files,  Prev: Multi-Volume Archives,  Up: Using Multiple Tapes

Tape Files
----------

     _(This message will disappear, once this node revised.)_

   To give the archive a name which will be recorded in it, use the
`--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option.  This will write a
special block identifying VOLUME-LABEL as the name of the archive to
the front of the archive which will be displayed when the archive is
listed with `--list' (`-t').  If you are creating a multi-volume
archive with `--multi-volume' (`-M'), then the volume label will have
`Volume NNN' appended to the name you give, where NNN is the number of
the volume of the archive.  (If you use the `--label=ARCHIVE-LABEL'
(`-V ARCHIVE-LABEL') option when reading an archive, it checks to make
sure the label on the tape matches the one you give.  *Note label::.

   When `tar' writes an archive to tape, it creates a single tape file.
If multiple archives are written to the same tape, one after the
other, they each get written as separate tape files.  When extracting,
it is necessary to position the tape at the right place before running
`tar'.  To do this, use the `mt' command.  For more information on the
`mt' command and on the organization of tapes into a sequence of tape
files, see *Note mt::.

   People seem to often do:

     --label="SOME-PREFIX `date +SOME-FORMAT`"

   or such, for pushing a common date in all volumes or an archive set.


File: tar.info,  Node: label,  Next: verify,  Prev: Using Multiple Tapes,  Up: Media

Including a Label in the Archive
================================

     _(This message will disappear, once this node revised.)_

`-V NAME'
`--label=NAME'
     Create archive with volume name NAME.

   This option causes `tar' to write out a "volume header" at the
beginning of the archive.  If `--multi-volume' (`-M') is used, each
volume of the archive will have a volume header of `NAME Volume N',
where N is 1 for the first volume, 2 for the next, and so on.

   To avoid problems caused by misplaced paper labels on the archive
media, you can include a "label" entry--an archive member which
contains the name of the archive--in the archive itself.  Use the
`--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option in conjunction with
the `--create' (`-c') operation to include a label entry in the archive
as it is being created.

   If you create an archive using both `--label=ARCHIVE-LABEL' (`-V
ARCHIVE-LABEL') and `--multi-volume' (`-M'), each volume of the archive
will have an archive label of the form `ARCHIVE-LABEL Volume N', where
N is 1 for the first volume, 2 for the next, and so on.

   If you list or extract an archive using `--label=ARCHIVE-LABEL' (`-V
ARCHIVE-LABEL'), `tar' will print an error if the archive label doesn't
match the ARCHIVE-LABEL specified, and will then not list nor extract
the archive.  In those cases, ARCHIVE-LABEL argument is interpreted as
a globbing-style pattern which must match the actual magnetic volume
label.  *Note exclude::, for a precise description of how match is
attempted(1).  If the switch `--multi-volume' (`-M') is being used, the
volume label matcher will also suffix ARCHIVE-LABEL by ` Volume [1-9]*'
if the initial match fails, before giving up.  Since the volume
numbering is automatically added in labels at creation time, it sounded
logical to equally help the user taking care of it when the archive is
being read.

   The `--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') was once called
`--volume', but is not available under that name anymore.

   To find out an archive's label entry (or to find out if an archive
has a label at all), use `tar --list --verbose'.  `tar' will print the
label first, and then print archive member information, as in the
example below:

     $ tar --verbose --list --file=iamanarchive
     V--------- 0 0        0 1992-03-07 12:01 iamalabel--Volume Header--
     -rw-rw-rw- ringo user 40 1990-05-21 13:30 iamafilename

`--label=ARCHIVE-LABEL'
`-V ARCHIVE-LABEL'
     Includes an "archive-label" at the beginning of the archive when
     the archive is being created, when used in conjunction with the
     `--create' (`-c') option.  Checks to make sure the archive label
     matches the one specified (when used in conjunction with the
     `--extract' (`--get', `-x') option.

   To get a common information on all tapes of a series, use the
`--label=ARCHIVE-LABEL' (`-V ARCHIVE-LABEL') option.  For having this
information different in each series created through a single script
used on a regular basis, just manage to get some date string as part of
the label.  For example:

     $ tar cfMV /dev/tape "Daily backup for `date +%Y-%m-%d`"
     $ tar --create --file=/dev/tape --multi-volume \
          --volume="Daily backup for `date +%Y-%m-%d`"

   Also note that each label has its own date and time, which
corresponds to when GNU `tar' initially attempted to write it, often
soon after the operator launches `tar' or types the carriage return
telling that the next tape is ready.  Comparing date labels does give
an idea of tape throughput only if the delays for rewinding tapes and
the operator switching them were negligible, which is usually not the
case.

   ---------- Footnotes ----------

   (1) Previous versions of `tar' used full regular expression
matching, or before that, only exact string matching, instead of
wildcard matchers.  We decided for the sake of simplicity to use a
uniform matching device through `tar'.


File: tar.info,  Node: verify,  Next: Write Protection,  Prev: label,  Up: Media

Verifying Data as It is Stored
==============================

`-W'
`--verify'
     Attempt to verify the archive after writing.

   This option causes `tar' to verify the archive after writing it.
Each volume is checked after it is written, and any discrepancies are
recorded on the standard error output.

   Verification requires that the archive be on a back-space-able
medium.  This means pipes, some cartridge tape drives, and some other
devices cannot be verified.

   You can insure the accuracy of an archive by comparing files in the
system with archive members.  `tar' can compare an archive to the file
system as the archive is being written, to verify a write operation, or
can compare a previously written archive, to insure that it is up to
date.

   To check for discrepancies in an archive immediately after it is
written, use the `--verify' (`-W') option in conjunction with the
`--create' (`-c') operation.  When this option is specified, `tar'
checks archive members against their counterparts in the file system,
and reports discrepancies on the standard error.

   To verify an archive, you must be able to read it from before the end
of the last written entry.  This option is useful for detecting data
errors on some tapes.  Archives written to pipes, some cartridge tape
drives, and some other devices cannot be verified.

   One can explicitly compare an already made archive with the file
system by using the `--compare' (`--diff', `-d') option, instead of
using the more automatic `--verify' (`-W') option.  *Note compare::.

   Note that these two options have a slightly different intent.  The
`--compare' (`--diff', `-d') option how identical are the logical
contents of some archive with what is on your disks, while the
`--verify' (`-W') option is really for checking if the physical
contents agree and if the recording media itself is of dependable
quality.  So, for the `--verify' (`-W') operation, `tar' tries to
defeat all in-memory cache pertaining to the archive, while it lets the
speed optimization undisturbed for the `--compare' (`--diff', `-d')
option.  If you nevertheless use `--compare' (`--diff', `-d') for media
verification, you may have to defeat the in-memory cache yourself,
maybe by opening and reclosing the door latch of your recording unit,
forcing some doubt in your operating system about the fact this is
really the same volume as the one just written or read.

   The `--verify' (`-W') option would not be necessary if drivers were
indeed able to detect dependably all write failures.  This sometimes
require many magnetic heads, some able to read after the writes
occurred.  One would not say that drivers unable to detect all cases
are necessarily flawed, as long as programming is concerned.

   The `--verify' (`-W') option will not work in conjunction with the
`--multi-volume' (`-M') option or the `--append' (`-r'), `--update'
(`-u') and `--delete' operations.  *Note Operations::, for more
information on these operations.

   Also, since `tar' normally strips leading `/' from file names (*note
absolute::), a command like `tar --verify -cf /tmp/foo.tar /etc' will
work as desired only if the working directory is `/', as `tar' uses the
archive's relative member names (e.g., `etc/motd') when verifying the
archive.


File: tar.info,  Node: Write Protection,  Prev: verify,  Up: Media

Write Protection
================

   Almost all tapes and diskettes, and in a few rare cases, even disks
can be "write protected", to protect data on them from being changed.
Once an archive is written, you should write protect the media to
prevent the archive from being accidentally overwritten or deleted.
(This will protect the archive from being changed with a tape or floppy
drive--it will not protect it from magnet fields or other physical
hazards).

   The write protection device itself is usually an integral part of the
physical media, and can be a two position (write enabled/write
disabled) switch, a notch which can be popped out or covered, a ring
which can be removed from the center of a tape reel, or some other
changeable feature.


File: tar.info,  Node: Free Software Needs Free Documentation,  Next: Copying This Manual,  Prev: Media,  Up: Top

Free Software Needs Free Documentation
**************************************

   The biggest deficiency in the free software community today is not in
the software--it is the lack of good free documentation that we can
include with the free software.  Many of our most important programs do
not come with free reference manuals and free introductory texts.
Documentation is an essential part of any software package; when an
important free software package does not come with a free manual and a
free tutorial, that is a major gap.  We have many such gaps today.

   Consider Perl, for instance.  The tutorial manuals that people
normally use are non-free.  How did this come about?  Because the
authors of those manuals published them with restrictive terms--no
copying, no modification, source files not available--which exclude
them from the free software world.

   That wasn't the first time this sort of thing happened, and it was
far from the last.  Many times we have heard a GNU user eagerly
describe a manual that he is writing, his intended contribution to the
community, only to learn that he had ruined everything by signing a
publication contract to make it non-free.

   Free documentation, like free software, is a matter of freedom, not
price.  The problem with the non-free manual is not that publishers
charge a price for printed copies--that in itself is fine.  (The Free
Software Foundation sells printed copies of manuals, too.)  The problem
is the restrictions on the use of the manual.  Free manuals are
available in source code form, and give you permission to copy and
modify.  Non-free manuals do not allow this.

   The criteria of freedom for a free manual are roughly the same as for
free software.  Redistribution (including the normal kinds of
commercial redistribution) must be permitted, so that the manual can
accompany every copy of the program, both on-line and on paper.

   Permission for modification of the technical content is crucial too.
When people modify the software, adding or changing features, if they
are conscientious they will change the manual too--so they can provide
accurate and clear documentation for the modified program.  A manual
that leaves you no choice but to write a new manual to document a
changed version of the program is not really available to our community.

   Some kinds of limits on the way modification is handled are
acceptable.  For example, requirements to preserve the original
author's copyright notice, the distribution terms, or the list of
authors, are ok.  It is also no problem to require modified versions to
include notice that they were modified.  Even entire sections that may
not be deleted or changed are acceptable, as long as they deal with
nontechnical topics (like this one).  These kinds of restrictions are
acceptable because they don't obstruct the community's normal use of
the manual.

   However, it must be possible to modify all the _technical_ content
of the manual, and then distribute the result in all the usual media,
through all the usual channels.  Otherwise, the restrictions obstruct
the use of the manual, it is not free, and we need another manual to
replace it.

   Please spread the word about this issue.  Our community continues to
lose manuals to proprietary publishing.  If we spread the word that
free software needs free reference manuals and free tutorials, perhaps
the next person who wants to contribute by writing documentation will
realize, before it is too late, that only free manuals contribute to
the free software community.

   If you are writing documentation, please insist on publishing it
under the GNU Free Documentation License or another free documentation
license.  Remember that this decision requires your approval--you don't
have to let the publisher decide.  Some commercial publishers will use
a free license if you insist, but they will not propose the option; it
is up to you to raise the issue and say firmly that this is what you
want.  If the publisher you are dealing with refuses, please try other
publishers.  If you're not sure whether a proposed license is free,
write to <licensing@gnu.org>.

   You can encourage commercial publishers to sell more free, copylefted
manuals and tutorials by buying them, and particularly by buying copies
from the publishers that paid for their writing or for major
improvements.  Meanwhile, try to avoid buying non-free documentation at
all.  Check the distribution terms of a manual before you buy it, and
insist that whoever seeks your business must respect your freedom.
Check the history of the book, and try reward the publishers that have
paid or pay the authors to work on it.

   The Free Software Foundation maintains a list of free documentation
published by other publishers, at
<http://www.fsf.org/doc/other-free-books.html>.


File: tar.info,  Node: Copying This Manual,  Next: Index,  Prev: Free Software Needs Free Documentation,  Up: Top

Copying This Manual
*******************

* Menu:

* GNU Free Documentation License::  License for copying this manual


File: tar.info,  Node: GNU Free Documentation License,  Up: Copying This Manual

GNU Free Documentation License
==============================

                        Version 1.1, March 2000

     Copyright (C) 2000 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307, USA
     
     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     written document "free" in the sense of freedom: to assure everyone
     the effective freedom to copy and redistribute it, with or without
     modifying it, either commercially or noncommercially.  Secondarily,
     this License preserves for the author and publisher a way to get
     credit for their work, while not being considered responsible for
     modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work that contains a
     notice placed by the copyright holder saying it can be distributed
     under the terms of this License.  The "Document", below, refers to
     any such manual or work.  Any member of the public is a licensee,
     and is addressed as "you".

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter
     section of the Document that deals exclusively with the
     relationship of the publishers or authors of the Document to the
     Document's overall subject (or to related matters) and contains
     nothing that could fall directly within that overall subject.
     (For example, if the Document is in part a textbook of
     mathematics, a Secondary Section may not explain any mathematics.)
     The relationship could be a matter of historical connection with
     the subject or with related matters, or of legal, commercial,
     philosophical, ethical or political position regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, whose contents can be viewed and edited directly
     and straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup has been designed
     to thwart or discourage subsequent modification by readers is not
     Transparent.  A copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML designed for human modification.
     Opaque formats include PostScript, PDF, proprietary formats that
     can be read and edited only by proprietary word processors, SGML
     or XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies of the Document numbering more than
     100, and the Document's license notice requires Cover Texts, you
     must enclose the copies in covers that carry, clearly and legibly,
     all these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a publicly-accessible
     computer-network location containing a complete Transparent copy
     of the Document, free of added material, which the general
     network-using public has access to download anonymously at no
     charge using public-standard network protocols.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has less than five).

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section entitled "History", and its title, and
          add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.

       K. In any section entitled "Acknowledgments" or "Dedications",
          preserve the section's title, and preserve in the section all
          the substance and tone of each of the contributor
          acknowledgments and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.

       M. Delete any section entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section as "Endorsements" or to
          conflict in title with any Invariant Section.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections entitled
     "History" in the various original documents, forming one section
     entitled "History"; likewise combine any sections entitled
     "Acknowledgments", and any sections entitled "Dedications".  You
     must delete all sections entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, does not as a whole count as a
     Modified Version of the Document, provided no compilation
     copyright is claimed for the compilation.  Such a compilation is
     called an "aggregate", and this License does not apply to the
     other self-contained works thus compiled with the Document, on
     account of their being thus compiled, if they are not themselves
     derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one
     quarter of the entire aggregate, the Document's Cover Texts may be
     placed on covers that surround only the Document within the
     aggregate.  Otherwise they must appear on covers around the whole
     aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License provided that you also include the
     original English version of this License.  In case of a
     disagreement between the translation and the original English
     version of this License, the original English version will prevail.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.

ADDENDUM: How to use this License for your documents
----------------------------------------------------

   To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.1
       or any later version published by the Free Software Foundation;
       with the Invariant Sections being LIST THEIR TITLES, with the
       Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
       A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have no Invariant Sections, write "with no Invariant Sections"
instead of saying which ones are invariant.  If you have no Front-Cover
Texts, write "no Front-Cover Texts" instead of "Front-Cover Texts being
LIST"; likewise for Back-Cover Texts.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: tar.info,  Node: Index,  Prev: Copying This Manual,  Up: Top

Index
*****

* Menu:

* --list with file name arguments:       list.
* -backup:                               backup.
* -suffix:                               backup.
* abbreviations for months:              Calendar date items.
* absolute file names:                   Remote Tape Server.
* Adding archives to an archive:         concatenate.
* Adding files to an Archive:            appending files.
* Age, excluding files by:               after.
* ago in date strings:                   Relative items in date strings.
* am in date strings:                    Time of day items.
* Appending files to an Archive:         appending files.
* archive:                               Definitions.
* Archive creation:                      file.
* archive member:                        Definitions.
* Archive Name:                          file.
* Archives, Appending files to:          appending files.
* Archiving Directories:                 create dir.
* archiving files:                       Top.
* authors of getdate:                    Authors of getdate.
* Avoiding recursion in directories:     recurse.
* backup options:                        backup.
* backup suffix:                         backup.
* backups:                               backup.
* beginning of time, for POSIX:          Date input formats.
* Bellovin, Steven M.:                   Authors of getdate.
* Berets, Jim:                           Authors of getdate.
* Berry, K.:                             Authors of getdate.
* Block number where error occurred:     verbose.
* Blocking Factor:                       Blocking Factor.
* blocking factor:                       Blocking Factor.
* Blocks per record:                     Blocking Factor.
* bug reports:                           Reports.
* Bytes per record:                      Blocking Factor.
* calendar date item:                    Calendar date items.
* case, ignored in dates:                General date syntax.
* cat vs concatenate:                    concatenate.
* Changing directory mid-stream:         directory.
* Character class, excluding characters from: Wildcards.
* Choosing an archive file:              file.
* comments, in dates:                    General date syntax.
* Compressed archives:                   gzip.
* concatenate vs cat:                    concatenate.
* Concatenating Archives:                concatenate.
* corrupted archives <1>:                Full Dumps.
* corrupted archives:                    gzip.
* DAT blocking:                          Blocking Factor.
* date format, ISO 8601:                 Calendar date items.
* date input formats:                    Date input formats.
* day in date strings:                   Relative items in date strings.
* day of week item:                      Day of week items.
* Deleting files from an archive:        delete.
* Deleting from tape archives:           delete.
* Descending directories, avoiding:      recurse.
* Directing output:                      file.
* Directories, Archiving:                create dir.
* Directories, avoiding recursion:       recurse.
* Directory, changing mid-stream:        directory.
* Disk space, running out of:            Scarce.
* displacement of dates:                 Relative items in date strings.
* Double-checking a write operation:     verify.
* dumps, full:                           Full Dumps.
* dumps, incremental:                    Inc Dumps.
* Eggert, Paul:                          Authors of getdate.
* End-of-archive entries, ignoring:      Reading.
* entry:                                 Naming tar Archives.
* epoch, for POSIX:                      Date input formats.
* Error message, block number of:        verbose.
* Exabyte blocking:                      Blocking Factor.
* exclude:                               exclude.
* exclude-from:                          exclude.
* Excluding characters from a character class: Wildcards.
* Excluding file by age:                 after.
* Excluding files by file system:        exclude.
* Excluding files by name and pattern:   exclude.
* existing backup method:                backup.
* exit status:                           Synopsis.
* extraction:                            Definitions.
* Extraction:                            extract.
* FDL, GNU Free Documentation License:   GNU Free Documentation License.
* Feedback from tar:                     verbose.
* file archival:                         Top.
* file name:                             Definitions.
* File Name arguments, alternatives:     files.
* File name arguments, using --list with: list.
* File names, excluding files by:        exclude.
* File names, terminated by NUL:         nul.
* File names, using symbolic links:      dereference.
* File system boundaries, not crossing:  one.
* first in date strings:                 General date syntax.
* Format Options:                        Format Variations.
* Format Parameters:                     Format Variations.
* Format, old style:                     old.
* fortnight in date strings:             Relative items in date strings.
* free documentation:                    Free Software Needs Free Documentation.
* full dumps:                            Full Dumps.
* future time stamps:                    Large or Negative Values.
* general date syntax:                   General date syntax.
* getdate:                               Date input formats.
* Getting more information during the operation: verbose.
* hour in date strings:                  Relative items in date strings.
* Ignoring end-of-archive entries:       Reading.
* incremental dumps:                     Inc Dumps.
* Information during operation:          verbose.
* Information on progress and status of operations: verbose.
* Interactive operation:                 interactive.
* ISO 8601 date format:                  Calendar date items.
* items in date strings:                 General date syntax.
* Labeling an archive:                   label.
* Labeling multi-volume archives:        Multi-Volume Archives.
* Labels on the archive media:           label.
* language, in dates:                    General date syntax.
* Large lists of file names on small machines: Reading.
* large values:                          Large or Negative Values.
* last DAY:                              Day of week items.
* last in date strings:                  General date syntax.
* Lists of file names:                   files.
* MacKenzie, David:                      Authors of getdate.
* member:                                Definitions.
* member name:                           Definitions.
* Members, replacing with other members: append.
* Meyering, Jim:                         Authors of getdate.
* Middle of the archive, starting in the: Scarce.
* midnight in date strings:              Time of day items.
* minute in date strings:                Relative items in date strings.
* minutes, time zone correction by:      Time of day items.
* Modes of extracted files:              Writing.
* Modification time, excluding files by: after.
* Modification times of extracted files: Writing.
* month in date strings:                 Relative items in date strings.
* month names in date strings:           Calendar date items.
* months, written-out:                   General date syntax.
* Multi-volume archives:                 Multi-Volume Archives.
* Naming an archive:                     file.
* negative time stamps:                  Large or Negative Values.
* next DAY:                              Day of week items.
* next in date strings:                  General date syntax.
* noon in date strings:                  Time of day items.
* now in date strings:                   Relative items in date strings.
* ntape device:                          Many.
* NUL terminated file names:             nul.
* Number of blocks per record:           Blocking Factor.
* Number of bytes per record:            Blocking Factor.
* numbered backup method:                backup.
* numbers, written-out:                  General date syntax.
* Old style archives:                    old.
* Old style format:                      old.
* option syntax, traditional:            Old Options.
* Options when reading archives:         Reading.
* Options, archive format specifying:    Format Variations.
* Options, format specifying:            Format Variations.
* ordinal numbers:                       General date syntax.
* Overwriting old files, prevention:     Writing.
* Permissions of extracted files:        Writing.
* Pinard, F.:                            Authors of getdate.
* pm in date strings:                    Time of day items.
* Progress information:                  verbose.
* Protecting old files:                  Writing.
* pure numbers in date strings:          Pure numbers in date strings.
* Reading file names from a file:        files.
* Reading incomplete records:            Reading.
* Record Size:                           Blocking Factor.
* Records, incomplete:                   Reading.
* Recursion in directories, avoiding:    recurse.
* relative items in date strings:        Relative items in date strings.
* remote tape drive:                     Remote Tape Server.
* Removing files from an archive:        delete.
* Replacing members with other members:  append.
* reporting bugs:                        Reports.
* Resurrecting files from an archive:    extract.
* Retrieving files from an archive:      extract.
* return status:                         Synopsis.
* rmt:                                   Remote Tape Server.
* Running out of space:                  Reading.
* Running out of space during extraction: Scarce.
* Salz, Rich:                            Authors of getdate.
* simple backup method:                  backup.
* SIMPLE_BACKUP_SUFFIX:                  backup.
* Small memory:                          Reading.
* Space on the disk, recovering from lack of: Scarce.
* Sparse Files:                          sparse.
* Specifying archive members:            Selecting Archive Members.
* Specifying files to act on:            Selecting Archive Members.
* Standard input and output:             file.
* Standard output, writing extracted files to: Writing.
* Status information:                    verbose.
* Storing archives in compressed format: gzip.
* Symbolic link as file name:            dereference.
* tape blocking:                         Blocking Factor.
* tape marks:                            Many.
* tape positioning:                      Many.
* Tapes, using --delete and:             delete.
* tar:                                   What tar Does.
* tar archive:                           Definitions.
* tar entry:                             Naming tar Archives.
* tar file:                              Naming tar Archives.
* tar to standard input and output:      file.
* this in date strings:                  Relative items in date strings.
* time of day item:                      Time of day items.
* time zone correction:                  Time of day items.
* time zone item <1>:                    General date syntax.
* time zone item:                        Time zone items.
* today in date strings:                 Relative items in date strings.
* tomorrow in date strings:              Relative items in date strings.
* Ultrix 3.1 and write failure:          Remote Tape Server.
* unpacking:                             Definitions.
* Updating an archive:                   update.
* uuencode:                              Applications.
* Verbose operation:                     verbose.
* Verifying a write operation:           verify.
* Verifying the currency of an archive:  compare.
* Version of the tar program:            verbose.
* version-control Emacs variable:        backup.
* VERSION_CONTROL:                       backup.
* week in date strings:                  Relative items in date strings.
* Where is the archive?:                 file.
* Working directory, specifying:         directory.
* Writing extracted files to standard output: Writing.
* Writing new archives:                  file.
* year in date strings:                  Relative items in date strings.
* yesterday in date strings:             Relative items in date strings.



Tag Table:
Node: Top890
Node: Introduction7797
Node: Book Contents8503
Node: Definitions10673
Node: What tar Does12468
Node: Naming tar Archives15228
Node: posix compliance15952
Node: Authors16915
Node: Reports18260
Node: Tutorial18506
Node: assumptions19318
Node: stylistic conventions21793
Node: basic tar options22413
Node: frequent operations26046
Node: Two Frequent Options26692
Node: file tutorial27318
Node: verbose tutorial28401
Node: help tutorial30135
Node: create30489
Node: prepare for examples31985
Node: Creating the archive33690
Node: create verbose36448
Node: short create37260
Node: create dir40203
Node: list42800
Node: list dir45316
Node: extract46371
Node: extracting archives47534
Node: extracting files48015
Node: extract dir50096
Node: failing commands52005
Node: going further53063
Node: tar invocation53205
Node: Synopsis54701
Node: using tar options59115
Node: Styles61715
Node: Mnemonic Options63163
Node: Short Options64997
Ref: Short Options-Footnote-166636
Node: Old Options66853
Ref: Old Options-Footnote-169794
Node: Mixing69964
Ref: Mixing-Footnote-172322
Node: All Options72446
Node: Operation Summary73045
Node: Option Summary74293
Node: Short Option Summary87982
Node: help89256
Ref: help-Footnote-192696
Node: verbose92905
Node: interactive97040
Node: operations99114
Node: Basic tar99369
Ref: Basic tar-Footnote-1102676
Node: Advanced tar102820
Node: Operations103678
Node: current state105634
Node: append106037
Node: appending files108593
Node: multiple110358
Node: update112736
Node: how to update113735
Node: concatenate115506
Node: delete118773
Node: compare120755
Node: create options122400
Node: Ignore Failed Read122797
Node: extract options122988
Node: Reading123894
Node: read full records125472
Node: Ignore Zeros125808
Node: Writing126822
Node: Dealing with Old Files127257
Node: Overwrite Old Files129724
Node: Keep Old Files131181
Node: Unlink First131695
Node: Recursive Unlink132097
Node: Modification Times132645
Node: Setting Access Permissions133426
Node: Writing to Standard Output134053
Node: remove files135135
Node: Scarce135324
Node: Starting File135560
Node: Same Order136390
Node: backup137226
Node: Applications140900
Node: looking ahead142157
Node: Backups142977
Node: Full Dumps145995
Node: Inc Dumps151599
Node: incremental and listed-incremental152879
Node: Backup Levels157060
Node: Backup Parameters159562
Node: backup-specs example161900
Node: Script Syntax162793
Node: Scripted Backups163531
Node: Scripted Restoration165271
Node: Choosing166815
Node: file167757
Node: Selecting Archive Members171255
Node: files172593
Node: nul174191
Node: exclude175564
Node: controlling pattern-patching with exclude176866
Node: problems with exclude178903
Node: Wildcards181117
Node: after184171
Node: recurse187273
Node: one189481
Node: directory191112
Node: absolute193777
Node: Date input formats196909
Node: General date syntax199662
Node: Calendar date items202071
Node: Time of day items204063
Node: Time zone items205884
Node: Day of week items206729
Node: Relative items in date strings207713
Node: Pure numbers in date strings209670
Node: Authors of getdate210645
Node: Formats211388
Node: Portability211924
Node: Portable Names213107
Node: dereference213803
Node: old215186
Node: posix216267
Node: Checksumming226553
Node: Large or Negative Values228468
Node: Compression230446
Node: gzip230750
Node: sparse237830
Ref: sparse-Footnote-1243097
Node: Attributes243393
Node: Standard248795
Node: Extensions271793
Node: cpio274339
Node: Media279082
Node: Device281042
Node: Remote Tape Server285672
Node: Common Problems and Solutions289525
Node: Blocking289909
Node: Format Variations296516
Node: Blocking Factor297444
Node: Many309354
Node: Tape Positioning313143
Node: mt314994
Node: Using Multiple Tapes316824
Node: Multi-Volume Archives321923
Node: Tape Files325976
Node: label327443
Ref: label-Footnote-1331234
Node: verify331469
Node: Write Protection334840
Node: Free Software Needs Free Documentation335663
Node: Copying This Manual340613
Node: GNU Free Documentation License340849
Node: Index360713

End Tag Table
