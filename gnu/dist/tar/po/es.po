# Mensajes en español para GNU tar.
# Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
# Federico Rivas <frivas@arrakis.es>, 1997.
# Enrique Melero <melero@iprolink.ch>, 1997.
# Santiago Vila Doncel <sanvila@unex.es>, 1998, 1999, 2000, 2001.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU tar 1.13.23\n"
"POT-Creation-Date: 2001-09-26 13:54-0700\n"
"PO-Revision-Date: 2001-09-15 19:18+0200\n"
"Last-Translator: Santiago Vila Doncel <sanvila@unex.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: lib/argmatch.c:160
#, c-format
msgid "invalid argument %s for %s"
msgstr "argumento %s inválido para %s"

#: lib/argmatch.c:161
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "argumento %s ambiguo para %s"

#. We try to put synonyms on the same line.  The assumption is that
#. synonyms follow each other
#: lib/argmatch.c:180
msgid "Valid arguments are:"
msgstr "Los argumentos válidos son:"

#: lib/error.c:125 src/rmt.c:93
msgid "Unknown system error"
msgstr "Error del sistema desconocido"

#: lib/getopt.c:693
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s: la opción `%s' es ambigua\n"

#: lib/getopt.c:718
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s: la opción `--%s' no admite ningún argumento\n"

#: lib/getopt.c:723
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s: la opción `%c%s' no admite ningún argumento\n"

#: lib/getopt.c:741 lib/getopt.c:914
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s: la opción `%s' requiere un argumento\n"

#. --option
#: lib/getopt.c:770
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s: opción no reconocida `--%s'\n"

#. +option or -option
#: lib/getopt.c:774
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s: opción no reconocida `%c%s'\n"

#. 1003.2 specifies the format of this message.
#: lib/getopt.c:800
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opción ilegal -- %c\n"

#: lib/getopt.c:803
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s: opción inválida -- %c\n"

#. 1003.2 specifies the format of this message.
#: lib/getopt.c:833 lib/getopt.c:963
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: la opción requiere un argumento -- %c\n"

#: lib/getopt.c:880
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s: la opción `-W %s' es ambigua\n"

#: lib/getopt.c:898
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s: la opción `-W %s' no admite ningún argumento\n"

#: lib/human.c:341
msgid "block size"
msgstr "tamaño del bloque"

#. Get translations for open and closing quotation marks.
#.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  If the catalog has no translation,
#. locale_quoting_style quotes `like this', and
#. clocale_quoting_style quotes "like this".
#.
#. For example, an American English Unicode locale should
#. translate "`" to U+201C (LEFT DOUBLE QUOTATION MARK), and
#. should translate "'" to U+201D (RIGHT DOUBLE QUOTATION
#. MARK).  A British English Unicode locale should instead
#. translate these to U+2018 (LEFT SINGLE QUOTATION MARK) and
#. U+2019 (RIGHT SINGLE QUOTATION MARK), respectively.
#: lib/quotearg.c:268
msgid "`"
msgstr "`"

#: lib/quotearg.c:269
msgid "'"
msgstr "'"

#. If XALLOC_FAIL_FUNC is NULL, or does return, display this message
#. before exiting when memory is exhausted.  Goes through gettext.
#: lib/xmalloc.c:66
msgid "memory exhausted"
msgstr "memoria agotada"

# ¿No es mejor "Total de bytes escritos: "?
# Suena más directo y más similar al original,
# "bytes escritos en total" suena demasiado complejo... Nicolás Lichtmaier.
# Suena algo extraño eso de "total de bytes". "en total" me suena
# mucho más natural. sv
#. Amanda 2.4.1p1 looks for "Total bytes written: [0-9][0-9]*".
#: src/buffer.c:153
#, c-format
msgid "Total bytes written: %s (%sB, %sB/s)\n"
msgstr "Bytes escritos en total: %s (%sB, %sB/s)\n"

#: src/buffer.c:231
msgid "(pipe)"
msgstr "(tubería)"

#: src/buffer.c:246
msgid "Cannot close"
msgstr "No se puede cerrar"

# FIXME. Comunicar al autor. Con suerte quedará como un mensaje
# parecido que hay en fileutils: "fork system call failed".
# La solución de fileutils no me acaba de convencer (era "llamada
# a fork()" ). Yo pondría: "No se puede crear proceso hijo (fork)"
# que responde a la idea del fork y el paréntesis aclara. jmg
# Pero eso sería "Cannot create child process"...
# Yo creo que la solución de fileutils es la mejor.
# Tanto es así que lo pongo igual que allí. sv
# Literalmente es "No puedo bifurcar", pero como sabemos que
# `bifurcar' se refiere a la primitiva `fork()', está bien como está,
# salvo que se debería conservar la mayúscula inicial, y para mi gusto,
# simplificar, respetando el mensaje original: "Fallo en fork()" - gerardo
# Pongo la mayúscula inicial, pero antes de ser tan respetuoso con el original
# consultaré con el autor. sv
#: src/buffer.c:254
msgid "Cannot dup"
msgstr "Falló la llamada al sistema `dup'"

#: src/buffer.c:268 src/buffer.c:275
msgid "Cannot use compressed or remote archives"
msgstr "No se pueden usar archivos comprimidos ni remotos"

# ¿Por qué en todo lugar donde dice "child" se traduce como "proceso hijo" y
# no como "hijo" directamente? nl
# Para que esté más claro. ¿es demasiado libre la traducción? sv
# ¿Gerardo?
# Hola. Hay dos posturas a la hora de traducir:
# a) respetar escrupulosamente el mensaje original y traducir
#       literalmente, o casi.
# b) buscar la mejor interpretación de forma que un hispanohablante lo
#       entienda lo mejor posible, aunque se "corrija" al autor; siempre
#       sin cambiar el sentido o la idea del mensaje, claro.
# Yo prefiero (b) generalmente. Está claro que aquí child se refiere a un
# proceso, un proceso derivado de otro, proceso hijo. Daría igual dejar hijo
# solamente, pero así está mejor expresado. Me gusta más.
#. The new born child tar is here!
#: src/buffer.c:336 src/buffer.c:505
msgid "tar (child)"
msgstr "tar (proceso hijo)"

#. The newborn grandchild tar is here!  Launch the compressor.
#: src/buffer.c:381 src/buffer.c:540
msgid "tar (grandchild)"
msgstr "tar (proceso nieto)"

# ¿No queda más bonita la 1ª comilla abierta así: `record_size'?
# Sí. FIXME. Comunicar al autor. sv
#: src/buffer.c:662
msgid "Invalid value for record_size"
msgstr "El valor de `record_size' no es válido"

#: src/buffer.c:665
msgid "No archive name given"
msgstr "No se ha especificado ningún nombre de archivo"

#: src/buffer.c:675
msgid "Cannot verify multi-volume archives"
msgstr "No se pueden verificar archivos multivolumen"

# ¿Por qué no respetar el original? Couldn't -> No se ha podido,
# Cannot -> No puido, no puido... gerardo
# Porque a continuación hay un montón de "cannot"s.
# No creo que haya que ser tan tan respetuoso con el original. sv
#
# Nota del última hora: El autor ha homogeneizado todo a cannot.
# Esto apoya mi teoría :-)
#: src/buffer.c:683
#, c-format
msgid "Cannot allocate memory for blocking factor %d"
msgstr "No se puede asignar memoria para el factor de bloqueo %d"

#: src/buffer.c:694
msgid "Cannot use multi-volume compressed archives"
msgstr "No se pueden utilizar archivos multivolumen comprimidos"

#: src/buffer.c:696
msgid "Cannot verify compressed archives"
msgstr "No se pueden verificar archivos comprimidos"

#: src/buffer.c:709
msgid "Cannot update compressed archives"
msgstr "No se pueden actualizar archivos comprimidos"

# FIXME: Si la entrada/salida estándar no es un archivo, ¿por qué el
# original se refiere a ella como tal?
#
# En cierto sentido, sí es un archivo, o se puede emplear como tal.
# Tar al menos la trata así, en `tar -f -' (o sin la opción -f en este
# GNU tar)'; luego la E/S std. puede ser un archivo "real" de disco:
# tar ... -f - > arch.tar       gerardo
#
# Esto corresponde a la opción --verify.
# Ejemplos: "tar cWf - ." y "tar xWf -"
# o sea que una traducción correcta se vería más como:
# "No se puede verificar un archivo desde/hacia la entrada/salida estándar"
# o algo así. Quizá "No se puede verificar un archivo tomado de la entrada
# estándar o escrito hacia la salida estándar", pero es un poco largo.. =)
#
#: src/buffer.c:721
msgid "Cannot verify stdin/stdout archive"
msgstr "No se puede verificar la entrada/salida estándar"

# Ojo que esto podría referirse a "is not being labelled NOW" en vez de
# "isn't labelled". Pero no tengo los fuentes para ver la intención
# original. nl
# Si no se sabe eso, se podría dejar de forma más neutra como
# "Archivo no etiquetado para concordancia con `%s'" - gerardo (gag)
# FIXME: Preguntar.
#: src/buffer.c:823
#, c-format
msgid "Archive not labeled to match %s"
msgstr "El archivo no está etiquetado para que coincida con %s"

#: src/buffer.c:826 src/buffer.c:1137
#, c-format
msgid "Volume %s does not match %s"
msgstr "El volumen %s no coincide con %s"

#: src/buffer.c:864
#, c-format
msgid "Write checkpoint %d"
msgstr "Punto de comprobación de escritura %d"

#: src/buffer.c:1033
msgid "At beginning of tape, quitting now"
msgstr "Al principio de la cinta, se terminará ahora"

#: src/buffer.c:1039
msgid "Too many errors, quitting"
msgstr "Demasiados errores, abandono"

#: src/buffer.c:1052
#, c-format
msgid "Read checkpoint %d"
msgstr "Punto de comprobación de lectura %d"

#: src/buffer.c:1146 src/extract.c:1198
#, c-format
msgid "Reading %s\n"
msgstr "Leyendo %s\n"

#: src/buffer.c:1150
msgid "WARNING: No volume header"
msgstr "ATENCIÓN: No hay cabecera de volumen"

#: src/buffer.c:1158
#, c-format
msgid "%s is not continued on this volume"
msgstr "%s no continúa en este volumen"

#: src/buffer.c:1172
#, c-format
msgid "%s is the wrong size (%s != %s + %s)"
msgstr "%s tiene un tamaño erróneo (%s != %s + %s)"

# Sugerencia: está fuera de secuencia -> no está en orden. sv
# Creo recordar que en el CPBackup de Central Point ponía lo de "fuera de
# secuencia". fr
# Buena referencia :-).
# El comentario habrá que conservarlo en la versión final. sv
# Bueno, la verdad es que ahora que lo pienso, me parece una mala
# traducción... ¿opiniones? sv
# Me parece correcta la traducción "literal", pero me gusta
# más tu sugerencia  - gerardo
# El problema es que un volumen individual no puede estar desordenado.
# Lo que está ordenado o no es la sucesión entera.
# Un volumen individual puede estar fuera de lugar, pero no desordenado
# él solito.
# Todavía espero una solución mágica que sea mejor que las dos
# que tenemos hasta ahora.
#: src/buffer.c:1184
msgid "This volume is out of sequence"
msgstr "Este volumen está fuera de secuencia"

#: src/buffer.c:1216
#, c-format
msgid "Unaligned block (%lu bytes) in archive"
msgstr "Bloque no alineado (%lu bytes) dentro del archivo"

#: src/buffer.c:1230
#, c-format
msgid "Record size = %lu blocks"
msgstr "Tamaño del registro = %lu bloques"

#: src/buffer.c:1308
msgid "Cannot backspace archive file; it may be unreadable without -i"
msgstr "No se puede ir hacia atrás en el archivo; puede ser ilegible sin -i"

#: src/buffer.c:1360
#, c-format
msgid "Child died with signal %d"
msgstr "El proceso hijo terminó con la señal %d"

#: src/buffer.c:1363
#, c-format
msgid "Child returned status %d"
msgstr "El proceso hijo devolvió el estado %d"

#: src/buffer.c:1389
#, c-format
msgid "%s: contains invalid volume number"
msgstr "%s: contiene un número de volumen inválido"

#: src/buffer.c:1440
msgid "Volume number overflow"
msgstr "Desbordamiento en el número de volumen"

#: src/buffer.c:1459
#, c-format
msgid "`%s' command failed"
msgstr "La orden `%s' falló"

#: src/buffer.c:1468
#, c-format
msgid "Prepare volume #%d for %s and hit return: "
msgstr "Prepare el volumen #%d para %s y pulse intro: "

#: src/buffer.c:1474
msgid "EOF where user reply was expected"
msgstr ""
"Se encontró un final de fichero mientras se esperaba respuesta del usuario"

#: src/buffer.c:1479 src/buffer.c:1508
msgid "WARNING: Archive is incomplete"
msgstr "ATENCIÓN: El archivo está incompleto"

# Antes de que nadie diga nada:
# shell admite muchas traducciones, caparazón, concha, envoltorio, coraza,
# etc. pero ninguna ha prosperado. Además, algunos nombres son innombrables
# en ciertos países, así que mejor dejarlo como está.
# Y si no se traduce, se queda en *el* shell, es decir, *neutro*.
#
# Ya que volúmenes se acentúa, ¿habría que poner "volumen/volúmenes"
# en lugar de "volumen(es)"?
# No me gusta, ya que sólo es plural con la parte entre paréntesis "(y consecutivos)". fr
# Creo que esta bien así Gerardo. em+
# # Cuidadín. ¿El nombre de archivo se le da *al* volumen? Literalmente
# # dice que da un nuevo nombre *para* el sgute. volumen, pero ¿ese
# # nombre es el del volumen? No entiendo bien el contexto; quizá
# # habría que mirar el código fuente o ver cuándo sale este
# # mensaje.
# # Otra cosa es eso de "abortar". No sé si se habrá tratado en
# # spanglish o en es@li.org, pero suena muy feo, ¿no? Quizá "Sale
# # inmediatamente de tar".
#
# "Print this list" es exactamente "Imprime esta lista" o a lo sumo "Muestra
# esta lista". No veo que diga ayuda en ninguna parte, no creo que un
# traductor deba ser más inteligente que el escritor original.. =) nl
# Yo creo que a veces sí :-) sv
# Sí, un programador no tiene por qué ser buen escritor :-) En un fortune me
# salió una vez: "Los que no saben escribir, escriben manuales". :-)
# A mí aquí me da igual lista que ayuda, de las dos formas se entiende. Manda
# el traductor original. gerardo
# ¿A alguien más le parece mal que ponga ayuda en vez de lista? sv
#: src/buffer.c:1492
msgid ""
" n [name]   Give a new file name for the next (and subsequent) volume(s)\n"
" q          Abort tar\n"
" !          Spawn a subshell\n"
" ?          Print this list\n"
msgstr ""
" n [nombre] Da un nuevo nombre de archivo al siguiente\n"
"            (y consecutivos) volumen(es)\n"
" q          Aborta tar\n"
" !          Lanza un subshell\n"
" ?          Muestra esta ayuda\n"

# "saliendo"->"finalizando". jmg
# Je, je, ¿no has leído, Santiago, el `dardo' de Fdo. Lázaro Carreter sobre
# finalizar? No sé por qué quitar lo de salir, to exit es salir, no acabar.
# Uno se sale del programa, y éste acaba. En realidad, también da igual, de
# cualquier forma se entiende, pero mejor acabar o terminar que finalizar,
# total, son sinónimos. gerardo
#. Quit.
#: src/buffer.c:1503
msgid "No new volume; exiting.\n"
msgstr "No hay volumen nuevo; finalizando.\n"

#: src/compare.c:100 src/compare.c:321 src/compare.c:353
#, c-format
msgid "Could only read %lu of %lu bytes"
msgstr "Sólo se pudieron leer %lu de %lu bytes"

# El autor quería en mensaje muy conciso, y en la traducción se expande a una
# oración completa.. ¿Por qué? Debería ser "Distinto modo".
# Porque el idioma inglés es más corto. Si a cada frase corta le hago
# corresponder siempre una frase corta española, el resultado sonará a indio
# completamente (me refiero a los indios esos de las películas del oeste,
# que solamente hablan con sustantivos, verbos y adjetivos). sv
#: src/compare.c:109 src/compare.c:125 src/compare.c:393
msgid "Contents differ"
msgstr "El contenido es distinto"

# # Como has puesto más arriba: "EOF"->"Fin de fichero". jmg
#: src/compare.c:151 src/compare.c:212 src/compare.c:285 src/compare.c:339
#: src/compare.c:373 src/extract.c:497 src/extract.c:520 src/extract.c:718
#: src/extract.c:861 src/incremen.c:542 src/list.c:205 src/list.c:367
#: src/list.c:1160 src/list.c:1183
msgid "Unexpected EOF in archive"
msgstr "EOF inesperado en el archivo"

# "Verifica ". Supongo que depende de si se concatena en algún
# mensaje. jmg
# FUZZY. Es verdad, habrá que verlo.
#: src/compare.c:434
msgid "Verify "
msgstr "Verificar "

# # ¿Quizá diffed es el participio de diff, siendo esto un verbo tomado
# # del nombre del programa diff? Entonces querría decir que se ha
# # efectuado un diff como si el *fichero* hubiera sido normal. Yo sólo
# # cambiaría "se toma" por "se ha tomado". gag
# Es norma habitual convertir un pasado en un presente en estos casos.
# Realmente, dice lo que hace y no lo que ha hecho. sv
# FIXME. Decirle al autor que estandarice las comillas: ¿'%c' o `%c'?
# De momento lo estandarizo en la traducción.
#: src/compare.c:441
#, c-format
msgid "%s: Unknown file type '%c', diffed as normal file"
msgstr ""
"%s: Tipo de fichero `%c' desconocido, se toma la diferencia\n"
"como fichero normal"

#: src/compare.c:465 src/compare.c:602 src/compare.c:661 src/compare.c:689
msgid "File type differs"
msgstr "El tipo de fichero es distinto"

# El autor quería en mensaje muy conciso, y en la traducción se expande a una
# oración completa.. ¿Por qué? Debería ser "Distinto modo".
# Porque el idioma inglés es más corto. Si a cada frase corta le hago
# corresponder siempre una frase corta española, el resultado sonará a indio
# completamente (me refiero a los indios esos de las películas del oeste,
# que solamente hablan con sustantivos, verbos y adjetivos). sv
#: src/compare.c:471 src/compare.c:616 src/compare.c:667
msgid "Mode differs"
msgstr "El modo es distinto"

#: src/compare.c:478
msgid "Uid differs"
msgstr "El uid es distinto"

#: src/compare.c:480
msgid "Gid differs"
msgstr "El gid es distinto"

#: src/compare.c:484
msgid "Mod time differs"
msgstr "La fecha de modificación es distinta"

#: src/compare.c:488 src/compare.c:697
msgid "Size differs"
msgstr "El tamaño es distinto"

# Creo que este enlace se efectúa al descomprimir un archivo tar.
# No es que nos diga si está enlazado o no lo está, sino si él hace
# el enlace o no lo hace. sv
#: src/compare.c:551
#, c-format
msgid "Not linked to %s"
msgstr "No se enlaza a %s"

#: src/compare.c:580
msgid "Symlink differs"
msgstr "El enlace simbólico es distinto"

#: src/compare.c:610
msgid "Device number differs"
msgstr "El número de dispositivo es distinto"

#: src/compare.c:807
#, c-format
msgid "VERIFY FAILURE: %d invalid header(s) detected"
msgstr "FALLO DE VERIFICACIÓN: %d cabecera(s) inválida(s) detectada(s)"

#: src/create.c:151
msgid "Generating negative octal headers"
msgstr "Generando cabeceras octales negativas"

#: src/create.c:200
#, c-format
msgid "value %s out of %s range %s..%s; substituting %s"
msgstr "valor %s fuera del rango %s %s..%s; se sustituye %s"

#: src/create.c:206
#, c-format
msgid "value %s out of %s range %s..%s"
msgstr "valor %s fuera del rango %s %s..%s"

#: src/create.c:406
msgid "Member names contain `..'"
msgstr "Los nombres contienen `..'"

# FIXME. This might not always work. Is `%.*s' male or female? sv
#: src/create.c:422 src/extract.c:652
#, c-format
msgid "Removing leading `%.*s' from member names"
msgstr "Eliminando la `%.*s' inicial de los nombres"

#: src/create.c:947
#, c-format
msgid "%s: file is unchanged; not dumped"
msgstr "%s: el fichero no ha cambiado; no se vuelca"

# FIXME: Decir al autor que ponga el "itself". sv
#: src/create.c:958
#, c-format
msgid "%s: file is the archive; not dumped"
msgstr "%s: el fichero es el propio archivo; no se vuelca"

#: src/create.c:1098
#, c-format
msgid "%s: file is on a different filesystem; not dumped"
msgstr "%s: el fichero está en un sistema de ficheros distinto; no se vuelca"

#: src/create.c:1299
#, c-format
msgid "%s: File removed before we read it"
msgstr "%s: El fichero fue borrado antes de leerlo"

# "se rellena" debería ser "rellenando". "se rellena" puede entenderse como
# varias cosas, no queda claro que es lo que se esta haciendo, podría indicar
# lo que se suele hacer.. =)   "rellenando con ceros" es perfecto y es
# exactamente lo que está escrito en el original. sv
#
# Que sí, reconozco que la traducción es un poco libre.
# Pero mi intención es que el programa diga lo que va haciendo, no lo que ya
# ha hecho. Ni siquiera el original es consistente en los modos verbales. sv
#: src/create.c:1399
#, c-format
msgid "%s: File shrank by %s bytes; padding with zeros"
msgstr ""
"%s: El tamaño del fichero ha disminuido en %s bytes, se rellena con ceros"

#: src/create.c:1424
#, c-format
msgid "%s: file changed as we read it"
msgstr "%s: el fichero cambió mientras se estaba leyendo"

#: src/create.c:1512
#, c-format
msgid "%s: socket ignored"
msgstr "%s: el `socket' no se tendrá en cuenta"

#: src/create.c:1517
#, c-format
msgid "%s: door ignored"
msgstr "%s: no se tendrá en cuenta la puerta"

#: src/create.c:1546
#, c-format
msgid "%s: Unknown file type; file ignored"
msgstr "%s: Tipo de fichero desconocido; no se tendrá en cuenta"

#: src/delete.c:190 src/list.c:151 src/update.c:152
msgid "This does not look like a tar archive"
msgstr "Esto no parece un archivo tar"

#: src/delete.c:195 src/list.c:156 src/update.c:157
msgid "Skipping to next header"
msgstr "Saltando a la siguiente cabecera"

#: src/delete.c:258
msgid "Deleting non-header from archive"
msgstr "Borrando no-cabecera del archivo"

#: src/extract.c:193
#, c-format
msgid "%s: time stamp %s is %lu s in the future"
msgstr "%s: la marca de tiempo %s está %lu s en el futuro"

#: src/extract.c:340
#, c-format
msgid "%s: Unexpected inconsistency when making directory"
msgstr "%s: Inconsistencia inesperada al crear el directorio"

#: src/extract.c:578
#, c-format
msgid "%s: Directory renamed before its status could be extracted"
msgstr ""
"%s: El directorio fue renombrado antes de que se pudiera extraer su estado"

#: src/extract.c:635
#, c-format
msgid "%s: Member name contains `..'"
msgstr "%s: El nombre contiene `..'"

#: src/extract.c:666
#, c-format
msgid "%s: Was unable to backup this file"
msgstr "%s: No se pudo hacer copia de seguridad de este fichero"

#: src/extract.c:806
msgid "Extracting contiguous files as regular files"
msgstr "Extrayendo ficheros contiguos como ficheros regulares"

# ¿Enlaces fuertes? Aquí los profes. de Sistemas Operativos y otros
# dicen "enlaces duros", y creo que los libros también lo ponen así. gag
# Es una cuestión todavía no dirimida.
# ¿Tienes algún dato más? ¿Qué dicen los libros? sv
# Enlaces duros. Lo acabo de mirar en un libro. gag
#: src/extract.c:1007
msgid "Attempting extraction of symbolic links as hard links"
msgstr "Intentando la extracción de enlaces simbólicos como enlaces duros"

#: src/extract.c:1207
#, c-format
msgid "%s: Cannot extract -- file is continued from another volume"
msgstr "%s: No se puede extraer -- el fichero es continuación de otro volumen"

# Me queda la duda de si lo que es visible es el error o el nombre largo... sv
#: src/extract.c:1216
msgid "Visible long name error"
msgstr "Error de nombre largo visible"

# FIXME. Lo de las comillas '%c'.
# Como antes, lo estandarizo en la traducción a pesar de todo.
#: src/extract.c:1224
#, c-format
msgid "%s: Unknown file type '%c', extracted as normal file"
msgstr "%s: Tipo de fichero `%c' desconocido, se extrae como fichero normal"

#: src/extract.c:1311
msgid "Error is not recoverable: exiting now"
msgstr "El error no es recuperable: salida ahora"

#: src/incremen.c:252
#, c-format
msgid "%s: Directory has been renamed"
msgstr "%s: El directorio ha sido renombrado"

#: src/incremen.c:264
#, c-format
msgid "%s: Directory is new"
msgstr "%s: El directorio es nuevo"

#: src/incremen.c:404
msgid "Invalid time stamp"
msgstr "Marca de tiempo inválida"

#: src/incremen.c:407
msgid "Time stamp out of range"
msgstr "Marca de tiempo fuera de rango"

#: src/incremen.c:428
msgid "Invalid device number"
msgstr "Número de dispositivo inválido"

#: src/incremen.c:432
msgid "Device number out of range"
msgstr "Número de dispositivo fuera de rango"

#: src/incremen.c:440
msgid "Invalid inode number"
msgstr "Número de nodo-i inválido"

#: src/incremen.c:444
msgid "Inode number out of range"
msgstr "Número de nodo-i fuera de rango"

#: src/incremen.c:568
#, c-format
msgid "%s: Deleting %s\n"
msgstr "%s: Borrando %s\n"

#: src/incremen.c:573
#, c-format
msgid "%s: Cannot remove"
msgstr "%s: No se puede borrar"

#: src/list.c:109
#, c-format
msgid "%s: Omitting"
msgstr "%s: Se omite"

#: src/list.c:125
#, c-format
msgid "block %s: ** Block of NULs **\n"
msgstr "bloque %s: ** Bloque de NULos **\n"

#: src/list.c:139
#, c-format
msgid "block %s: ** End of File **\n"
msgstr "bloque %s: ** Fin de Fichero **\n"

#: src/list.c:553
#, c-format
msgid "Blanks in header where numeric %s value expected"
msgstr "Hay blancos en la cabecera cuando se esperaba el valor numérico %s"

#: src/list.c:606
#, c-format
msgid "Archive octal value %.*s is out of %s range; assuming two's complement"
msgstr ""
"El valor octal %.*s del archivo está fuera del rango %s;\n"
"se supone complemento a dos"

#: src/list.c:616
#, c-format
msgid "Archive octal value %.*s is out of %s range"
msgstr "El valor octal %.*s del archivo está fuera del rango %s"

#: src/list.c:632
msgid "Archive contains obsolescent base-64 headers"
msgstr "El archivo contiene cabeceras base-64 obsoletas"

#: src/list.c:645
#, c-format
msgid "Archive signed base-64 string %s is out of %s range"
msgstr "La cadena firmada en base-64 %s del archivo está fuera del rango %s"

#: src/list.c:676
#, c-format
msgid "Archive base-256 value is out of %s range"
msgstr "El valor en base-256 del archivo está fuera del rango %s"

#: src/list.c:703
#, c-format
msgid "Archive contains %.*s where numeric %s value expected"
msgstr "El archivo contiene %.*s donde se esperaba el valor numérico %s"

#: src/list.c:724
#, c-format
msgid "Archive value %s is out of %s range %s..%s"
msgstr "El valor del archivo %s está fuera del rango %s %s..%s"

#: src/list.c:916 src/list.c:1135
#, c-format
msgid "block %s: "
msgstr "bloque %s: "

# FIXME. Hay otro que se parece muchísimo. sv
#: src/list.c:946
msgid "Visible longname error"
msgstr "Error de nombre largo visible"

#: src/list.c:1074
#, c-format
msgid " link to %s\n"
msgstr " enlace a %s\n"

#: src/list.c:1082
#, c-format
msgid " unknown file type %s\n"
msgstr " tipo de fichero desconocido `%s'\n"

#: src/list.c:1100
msgid "--Volume Header--\n"
msgstr "--Cabecera de Volumen--\n"

#: src/list.c:1108
#, c-format
msgid "--Continued at byte %s--\n"
msgstr "--Continúa en el byte %s--\n"

#: src/list.c:1112
msgid "--Mangled file names--\n"
msgstr "--Nombres de fichero modificados--\n"

#: src/list.c:1140
msgid "Creating directory:"
msgstr "Creando el directorio:"

# Como has puesto más arriba: "EOF"->"Fin de fichero".
# "Fin de fichero inesperado en los nombres modificados.".
# ¿No se referirá al autor a "mangled filenames"?... jmg
# FIXME. Preguntárselo.
#: src/mangle.c:54
msgid "Unexpected EOF in mangled names"
msgstr "EOF inesperado en los nombres modificados"

#: src/mangle.c:90 src/misc.c:368 src/misc.c:386
#, c-format
msgid "%s: Cannot rename to %s"
msgstr "%s: No se puede renombrar a %s"

#: src/mangle.c:93
#, c-format
msgid "Renamed %s to %s"
msgstr "Se renombra %s como %s"

#: src/mangle.c:110
#, c-format
msgid "%s: Cannot symlink to %s"
msgstr "%s: No se puede crear un enlace simbólico a %s"

#: src/mangle.c:113
#, c-format
msgid "Symlinked %s to %s"
msgstr "Se enlaza %s simbólicamente a %s"

# ¿desmutilador? sv. (Perdona mi ignorancia: ¿qué significa?)
# No lo sé, tengo que consultar. Lo encontré en un diccionario raro. fr
# Bueno, yo tampoco sé lo que es, pero "mangling" me suena a:
# "proceso mediante el cual se codifican ciertos nombres de cierta manera."
# Por ejemplo, "name mangling" es lo que hace Linux cuando se instala
# con umsdos. (¿Lo has visto alguna vez?).
# También se habla de "mangling" a la forma que tiene el C++ de incluir
# los nombres de las funciones (o de las clases quizá) en un archivo
# objeto ( .o ).
# Bueno, en realidad no lo sé, pero espero haberte dado alguna idea.
# A ver qué dice Enrique u otro revisor. sv
# Sigo en blanco. fr
# La traducción mas acertada creo que es esta :) , el uso que conozco
# de mangled esta relacionado con codificar o transformar el nombre de una
# función C++ dentro de una biblioteca, de manera que se pueda deshacer la
# referencia a la función al compilar o enlazar dinámicamente, obteniendo
# la función que corresponde al aplicar la sobrecarga de operadores. em+
# # Todo eso es así, lo malo es encontrar la palabra simple más
# # adecuada y  mantenerla. Por ejemplo, antes hemos dicho "mutilar", en
# # otros mensajes; y ahora "desenredar".
#: src/mangle.c:117
#, c-format
msgid "Unknown demangling command %s"
msgstr "Orden desconocida para recuperar el nombre original de %s"

#: src/misc.c:359
#, c-format
msgid "Renaming %s to %s\n"
msgstr "Se renombra %s como %s\n"

#: src/misc.c:391
#, c-format
msgid "Renaming %s back to %s\n"
msgstr "Se vuelve a renombrar %s como %s\n"

#: src/misc.c:471
msgid "Cannot save working directory"
msgstr "No se puede guardar el directorio de trabajo"

#: src/misc.c:477
msgid "Cannot change working directory"
msgstr "No se puede cambiar el directorio de trabajo"

# FIXME: Intraducible.
#: src/misc.c:521 src/misc.c:530
#, c-format
msgid "%s: Cannot %s"
msgstr "%s: No se puede %s"

#: src/misc.c:539
#, c-format
msgid "%s: Warning: Cannot %s"
msgstr "%s: Atención: No se puede %s"

#: src/misc.c:554
#, c-format
msgid "%s: Cannot change mode to %s"
msgstr "%s: No se puede cambiar el modo a %s"

#: src/misc.c:562
#, c-format
msgid "%s: Cannot change ownership to uid %lu, gid %lu"
msgstr "%s: No se puede cambiar el propietario a uid %lu, gid %lu"

#: src/misc.c:594
#, c-format
msgid "%s: Cannot hard link to %s"
msgstr "%s: No se puede crear un enlace duro a %s"

# Idem em`+
# # Ver mensaje anterior
# Mejor: "... bytes, en el archivo %s". De lo de file y archive,
# creo que podría optarse por una convención (p.ej. file->fichero,
# y archive->archivo). En este .po unas veces se hace de una forma y
# otras de otra. jmg
# FIXME. Consultar al autor.
#: src/misc.c:646 src/misc.c:674
#, c-format
msgid "%s: Read error at byte %s, reading %lu bytes"
msgstr "%s: Error de lectura en el byte %s, leyendo %lu bytes"

# Idem em`+
# # Ver mensaje anterior
# Mejor: "... bytes, en el archivo %s". De lo de file y archive,
# creo que podría optarse por una convención (p.ej. file->fichero,
# y archive->archivo). En este .po unas veces se hace de una forma y
# otras de otra. jmg
# FIXME. Consultar al autor.
#: src/misc.c:657
#, c-format
msgid "%s: Warning: Read error at byte %s, reading %lu bytes"
msgstr "%s: Atención: Error de lectura en el byte %s, leyendo %lu bytes"

#: src/misc.c:714
#, c-format
msgid "%s: Cannot seek to %s"
msgstr "%s: No se puede desplazar a %s"

#: src/misc.c:730
#, c-format
msgid "%s: Warning: Cannot seek to %s"
msgstr "%s: Atención: No se puede desplazar a %s"

#: src/misc.c:739
#, c-format
msgid "%s: Cannot create symlink to %s"
msgstr "%s: No se puede crear el enlace simbólico a %s"

#: src/misc.c:797
#, c-format
msgid "%s: Wrote only %lu of %lu bytes"
msgstr "%s: Sólo se escribieron %lu de %lu bytes"

#: src/misc.c:821
msgid "child process"
msgstr "proceso hijo"

#: src/misc.c:830
msgid "interprocess channel"
msgstr "canal de interproceso"

#: src/names.c:369 src/names.c:418 src/names.c:460
msgid "Missing file name after -C"
msgstr "Falta el nombre del fichero después de -C"

#: src/names.c:604 src/names.c:616
#, c-format
msgid "%s: Not found in archive"
msgstr "%s: No se encuentra en el archivo"

#: src/rmt.c:145
msgid "rmtd: Cannot allocate buffer space\n"
msgstr "rmtd: No se puede asignar espacio para el búfer\n"

#: src/rmt.c:147
msgid "Cannot allocate buffer space"
msgstr "No se puede asignar espacio para el búfer"

#: src/rmt.c:255 src/tar.c:288 tests/genfile.c:61
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "Pruebe `%s --help' para más información.\n"

#: src/rmt.c:259
#, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Manipulate a tape drive, accepting commands from a remote process.\n"
"\n"
"  --version  Output version info.\n"
"  --help  Output this help.\n"
msgstr ""
"Modo de empleo: %s [OPCIÓN]\n"
"Manipula una unidad de cinta, aceptando órdenes de un proceso remoto.\n"
"\n"
"  --version  Muestra la versión.\n"
"  --help     Muestra esta ayuda.\n"

# Por favor, no me digáis cómo se traduce bug.
# Gerardo lo ha visto traducido en un libro como "pulgas", y yo
# lo he visto como "chinche" en la "Investigación y Ciencia".
# Está claro que así no vamos a ninguna parte.
# Yo diría simplemente `fallos [ocultos]'. Es lo que significa, en realidad,
# en el contexto informático, razones históricas aparte de bichos anidando
# al calorcito de los tubos de vacío de los primeros computadores. gerardo
# De "ocultos" nada... Este vamos a dejarlo, ¿vale? sv
# Tú mandas, pero ¿cómo que de ocultos nada? Si no fueran ocultos, el progra-
# ma no vería la luz aún, ¿no? Pero observa que he puesto el `ocultos' entre
# corchetes. Yo pondría "bug -> fallo" simplemente. Comunicar fallos a... gerardo
# ¿Que no vería la luz si no fueran ocultos? Ja, ja, ja, ja...
# Mira por ejemplo en http://nl.debian.org/Bugs.
# ¿No tendría sentido catalogarlos entonces?
#: src/rmt.c:266 src/tar.c:452
msgid ""
"\n"
"Report bugs to <bug-tar@gnu.org>.\n"
msgstr ""
"\n"
"Comunicar `bugs' a <bug-tar@gnu.org>.\n"

#: src/rmt.c:299 src/tar.c:1135 tests/genfile.c:135
msgid ""
"This program comes with NO WARRANTY, to the extent permitted by law.\n"
"You may redistribute it under the terms of the GNU General Public License;\n"
"see the file named COPYING for details."
msgstr ""
"Este programa viene sin NINGUNA GARANTÍA, hasta donde permite la ley.\n"
"Puede redistribuirse bajo los términos de la Licencia Pública General de "
"GNU;\n"
"vea el fichero llamado COPYING para más información."

#: src/rmt.c:398 src/rmt.c:518 src/rmt.c:528
msgid "Seek offset out of range"
msgstr "Desplazamiento fuera de rango"

#: src/rmt.c:411
msgid "Seek direction out of range"
msgstr "Dirección de desplazamiento fuera de rango"

# FIXME. Este es el único eof en minúsculas.
# # Como has puesto más arriba: "EOF"->"Fin de fichero". jmg
#: src/rmt.c:450
msgid "rmtd: Premature eof\n"
msgstr "rmtd: EOF prematuro\n"

#: src/rmt.c:452
msgid "Premature end of file"
msgstr "Fin de fichero prematuro"

# "no reconocida" me parecía muy suave para "garbage". sv
# OJO: Casi el mismo mensaje.
#: src/rmt.c:560
#, c-format
msgid "rmtd: Garbage command %c\n"
msgstr "rmtd: Orden ininteligible %c\n"

#: src/rmt.c:562
msgid "Garbage command"
msgstr "Orden ininteligible"

#: src/rtapelib.c:283
msgid "exec/tcp: Service not available"
msgstr "exec/tcp: Servicio no disponible"

#: src/rtapelib.c:287
msgid "stdin"
msgstr "entrada estándar (stdin)"

#: src/rtapelib.c:290
msgid "stdout"
msgstr "salida estándar (stdout)"

#. Bad problems if we get here.
#. In a previous version, _exit was used here instead of exit.
#: src/rtapelib.c:500
msgid "Cannot execute remote shell"
msgstr "No se puede ejecutar un shell remoto"

#: src/tar.c:69
#, c-format
msgid "Options `-%s' and `-%s' both want standard input"
msgstr "Las opciones `-%s' y `-%s' requieren entrada estándar"

# Yo usaría "recuperar", en vez de "restablecer". Lo de repetir "archivo"
# dos veces en la misma frase no me suena bien, así que pondría "... a
# partir de aquél". jmg
# El original también repite. sv
#
# ¡CUIDADO! sólo no debe llevar tilde en ".. juntos en un solo archivo..."
# `Solo' sólo lleva acento cuando equivale al adverbio de modo `solamente',
# y aun así no es obligatorio ponérselo si no hay ambigüedad (lo siento,
# muchachos, pero saqué sobresaliente en Lingüística de COU :-D ) gerardo
# Lo cambio, pero "no es obligatorio" no es lo mismo que "está mal". sv
#: src/tar.c:292
msgid ""
"GNU `tar' saves many files together into a single tape or disk archive, and\n"
"can restore individual files from the archive.\n"
msgstr ""
"GNU `tar' guarda varios ficheros juntos en un solo archivo en cinta o disco, "
"y\n"
"puede restablecer ficheros individuales a partir del archivo.\n"

#: src/tar.c:296
#, c-format
msgid ""
"\n"
"Usage: %s [OPTION]... [FILE]...\n"
"\n"
"Examples:\n"
"  %s -cf archive.tar foo bar  # Create archive.tar from files foo and bar.\n"
"  %s -tvf archive.tar         # List all files in archive.tar verbosely.\n"
"  %s -xf archive.tar          # Extract all files from archive.tar.\n"
msgstr ""
"\n"
"Modo de empleo: %s [OPCIÓN]... [FICHERO]...\n"
"\n"
"Ejemplos:\n"
" %s -cf archivo.tar fu fa # Crea archivo.tar con los ficheros fu y fa.\n"
" %s -tvf archivo.tar      # Lista en detalle todos los ficheros de archivo."
"tar\n"
" %s -xf archivo.tar       # Extrae todos los ficheros de archivo.tar.\n"

# Es cierto que en la traducción se repite obligatorio, pero es que eso
# mismo ocurre en el original, por lo tanto, lo dejo así.
#: src/tar.c:303
msgid ""
"\n"
"If a long option shows an argument as mandatory, then it is mandatory\n"
"for the equivalent short option also.  Similarly for optional arguments.\n"
msgstr ""
"\n"
"Si una opción larga muestra un argumento como obligatorio, entonces es\n"
"obligatorio también para la opción corta equivalente. Lo mismo ocurre con\n"
"los argumentos opcionales.\n"

#: src/tar.c:308
msgid ""
"\n"
"Main operation mode:\n"
"  -t, --list              list the contents of an archive\n"
"  -x, --extract, --get    extract files from an archive\n"
"  -c, --create            create a new archive\n"
"  -d, --diff, --compare   find differences between archive and file system\n"
"  -r, --append            append files to the end of an archive\n"
"  -u, --update            only append files newer than copy in archive\n"
"  -A, --catenate          append tar files to an archive\n"
"      --concatenate       same as -A\n"
"      --delete            delete from the archive (not on mag tapes!)\n"
msgstr ""
"\n"
"Modo de operación principal:\n"
"  -t, --list              lista el contenido de un archivo\n"
"  -x, --extract, --get    extrae ficheros de un archivo\n"
"  -c, --create            crea un nuevo archivo\n"
"  -d, --diff, --compare   encuentra las diferencias entre el archivo y el\n"
"                          sistema de ficheros\n"
"  -r, --append            añade ficheros al final de un archivo\n"
"  -u, --update            sólo añade ficheros más recientes que la copia "
"del\n"
"                          archivo\n"
"  -A, --catenate          añade ficheros tar a un archivo\n"
"      --concatenate       igual que -A\n"
"      --delete            borra de un archivo (¡no en cintas magnéticas!)\n"

# ¿archivos nonzero? sv
# Estupendo Gerardo, se me había pasado, como tantas cosas em+
# # ¡Nooorl! Quiere decir que el programa tar no acaba o sale (exit())
# # devolviendo al sistema un "status" distinto de cero cuando
# # encuentre ficheros ilegibles. (¡Uf! Ahora a ver cómo se pone esto en
# # media línea.) gag
#
#: src/tar.c:321
#, fuzzy
msgid ""
"\n"
"Operation modifiers:\n"
"  -W, --verify               attempt to verify the archive after writing it\n"
"      --remove-files         remove files after adding them to the archive\n"
"  -k, --keep-old-files       don't replace existing files when extracting\n"
"      --overwrite            overwrite existing files when extracting\n"
"      --overwrite-dir        overwrite directory metadata when extracting\n"
"  -U, --unlink-first         remove each file prior to extracting over it\n"
"      --recursive-unlink     empty hierarchies prior to extracting "
"directory\n"
"  -S, --sparse               handle sparse files efficiently\n"
"  -O, --to-stdout            extract files to standard output\n"
"  -G, --incremental          handle old GNU-format incremental backup\n"
"  -g, --listed-incremental=FILE\n"
"                             handle new GNU-format incremental backup\n"
"      --ignore-failed-read   do not exit with nonzero on unreadable files\n"
msgstr ""
"\n"
"Modificadores de operación:\n"
"  -W, --verify               intenta verificar el archivo después de "
"escribirlo\n"
"      --remove-files         borra los ficheros después de añadirlos al "
"archivo\n"
"  -k, --keep-old-files       no sobreescribe los ficheros existentes al "
"extraer\n"
"      --overwrite            sobreescribe los ficheros existentes al "
"extraer\n"
"  -U, --unlik-first          borra cada fichero antes de extraer sobre él\n"
"  -S, --sparse               maneja archivos dispersos eficientemente\n"
"  -O, --to-stdout            extrae ficheros hacia la salida estándar\n"
"  -G, --incremental          maneja copias de seguridad incrementales en\n"
"                             formato GNU antiguo\n"
"  -g, --listed-incremental=FICHERO\n"
"                             maneja copias de seguridad incrementales en\n"
"                             el nuevo formato de GNU\n"
"      --ignore-failed-read   no termina con estado de error cuando "
"encuentra\n"
"                             archivos ilegibles\n"

# FUZZY. Tenía un fuzzy. Averiguar por qué. sv
# Sugerencia: para archivos -> para los archivos. sv
# Sugerencia: Estandarizar la traducción de "added files". sv
# En el  --mode=CHANGES  no sé qué poner... sv
# En vez de "force"->"establece", yo dejaría el significado
# original ->"fuerza". jmg
# force es forzar, ¡no establecer! nl
# Gerardo, ¿qué opinas de "forzar"? sv
# Hombre, desde luego to force es forzar u obligar; la verdad es que no sé
# por qué el autor original dice "force" y no "set". Quizá porque si no se
# pusieran estas opciones los ficheros tendrían otros atributos que vendrían
# impuestos por el umask, el UID/GID del usuario, etc., y con esto se "fuerza",
# se cambia esta situación. No es lo mismo que establecer, que sería poner
# esos atributos partiendo de cero. Creo que ése es el matiz, y para conservar-
# lo habría que poner "fuerza NOMBRE como propietario...", etc., o bien
# "obliga a que sea NOMBRE el propietario...", etc. gerardo
# # usa -> emplea - gerardo
#: src/tar.c:338
msgid ""
"\n"
"Handling of file attributes:\n"
"      --owner=NAME             force NAME as owner for added files\n"
"      --group=NAME             force NAME as group for added files\n"
"      --mode=CHANGES           force (symbolic) mode CHANGES for added "
"files\n"
"      --atime-preserve         don't change access times on dumped files\n"
"  -m, --modification-time      don't extract file modified time\n"
"      --same-owner             try extracting files with the same ownership\n"
"      --no-same-owner          extract files as yourself\n"
"      --numeric-owner          always use numbers for user/group names\n"
"  -p, --same-permissions       extract permissions information\n"
"      --no-same-permissions    do not extract permissions information\n"
"      --preserve-permissions   same as -p\n"
"  -s, --same-order             sort names to extract to match archive\n"
"      --preserve-order         same as -s\n"
"      --preserve               same as both -p and -s\n"
msgstr ""
"\n"
"Manejo de los atributos de los ficheros:\n"
"      --owner=NOMBRE           establece NOMBRE como propietario para los\n"
"                               ficheros que se añaden\n"
"      --group=NOMBRE           establece NOMBRE como grupo para los ficheros "
"que\n"
"                               se añaden\n"
"      --mode=CAMBIOS           establece CAMBIOS como modo (simbólico) para "
"los\n"
"                               ficheros que se añaden\n"
"      --atime-preserve         no cambia la fecha de acceso en los ficheros\n"
"                               volcados\n"
"  -m, --modification-time      no extrae la fecha de modificación de "
"ficheros\n"
"      --same-owner             intenta extraer ficheros con el mismo "
"propietario\n"
"      --no-same-owner          extrae los fichero como uno mismo\n"
"      --numeric-owner          siempre utiliza números para nombres de\n"
"                               usuario/grupo\n"
"  -p, --same-permissions       extrae la información de los permisos\n"
"      --no-same-permissions    no extrae la información de los permisos\n"
"      --preserve-permissions   igual que -p\n"
"  -s, --same-order             ordena los nombres a extraer para coincidir "
"con\n"
"                               el archivo\n"
"      --preserve-order         igual que -s\n"
"      --preserve               igual que -p y -s a la vez\n"

# Una chorradita, si se me permite; estamos usando ISO-8859-1,
# ¿verdad? Y en ISO-Latin1 existe un carácter que representa la
# multiplicación, ¿verdad? Ya saben , el aspa: '×' ('\327'). Pues
# ¿por qué no usarlo (está bien, "utilizarlo" ;-) en vez de la equis
# en NUM x 1024 -> NUM × 1024?
# En otra parte dices que pones (C) en vez de © porque © no se ve bien en
# la consola. Pues no dirás eso del aspa, que se ve mejor aún que la equis:
# x × - gerardo
# Efectivamente, pero no es transportable, el que use tar bajo DJGPP
# le saldría un churro pues el aspa no existe en la tabla 850. sv
#: src/tar.c:356
msgid ""
"\n"
"Device selection and switching:\n"
"  -f, --file=ARCHIVE             use archive file or device ARCHIVE\n"
"      --force-local              archive file is local even if has a colon\n"
"      --rsh-command=COMMAND      use remote COMMAND instead of rsh\n"
"  -[0-7][lmh]                    specify drive and density\n"
"  -M, --multi-volume             create/list/extract multi-volume archive\n"
"  -L, --tape-length=NUM          change tape after writing NUM x 1024 bytes\n"
"  -F, --info-script=FILE         run script at end of each tape (implies -"
"M)\n"
"      --new-volume-script=FILE   same as -F FILE\n"
"      --volno-file=FILE          use/update the volume number in FILE\n"
msgstr ""
"\n"
"Selección de dispositivos y conmutadores:\n"
"  -f, --file=ARCHIVO             utiliza el archivo o dispositivo ARCHIVO\n"
"      --force-local              el archivo es local incluso si tiene dos "
"puntos\n"
"      --rsh-command=ORDEN        utiliza la ORDEN remota en vez de rsh\n"
"  -[0-7][lmh]                    especifica unidad y densidad\n"
"  -M, --multi-volume             crea/lista/extrae un archivo multivolumen\n"
"  -L, --tape-length=NUM          cambia la cinta después de escribir NUM x "
"1024\n"
"                                 bytes\n"
"  -F, --info-script=FICHERO      ejecuta el script al final de cada cinta\n"
"                                  (implica -M)\n"
"      --new-volume-script=FICH   igual que -F FICH\n"
"      --volno-file=ARCHIVO       utiliza/actualiza el número de volumen en\n"
"                                 ARCHIVO\n"

# ¿rebloquea? ¿existe esa palabra? sv
# Que opine el pueblo, no lo sé. fr
# # ¿Existe bloquear? Pues si es así, también existe rebloquear =
# # volver a bloquear. Y requetebloquear, etc. En un artículo de Martin
# # Gardner se preguntaba cuál era la palabra española más larga, y la
# # respuesta era que cualquiera que pudiera ir precedida por
# # requetequetequete... (longitud infinita). Pelín ssagerao, ¿no? gag
# ignore no es ignorar, es "no hacer caso"
# se puede usar: no tener en cuenta, descartar, no tener efecto,
# pasar por alto,
# ignorar es "not to know". sv
# ¿Y cuando se ignora a una persona ;-)? fr
# Lo mismo: Está mal dicho, se dice que no le haces caso a esa persona.
# Si no me crees busca "ignore" en algún buen diccionario.
# O mira la lista de pifias de Ángel Álvarez directamente.
# La tengo en ftp.unex.es.
# Lo siento, Santiago, hemos sido derrotados; "ignorar" ya viene en los
# diccionarios de español, y creo que hasta en el DRAE, con el significado
# que tiene en inglés "to ignore"; aunque nosotros podemos ignorarlo ;-)
# y seguir en la ortodoxia castellana :-) gerardo
# Seguiremos en la ortodoxia, pero aún así, no puedo creerme que venga
# en el DRAE. ¿Estás seguro? sv
# No, no me compré el DRAE. Pregúntalo a spanglish (si te atreves ;-) gerardo
# ¿para pipes de BSD? sv
# # conducciones de BSD. gag
# Como has puesto más arriba: "EOF"->"Fin de fichero".
# Me suena mejor "descartar" que "pasar por alto", para "ignore".
# Respecto a pipes, lo de más arriba: "...en canales (pipes) de...". jmg
# Sigo en mis 13 y en esto no hay quien me baje del burro: BLOQUES x 512 bytes
# debe ser BLOQUES × 512 bytes. gerardo
#: src/tar.c:369
msgid ""
"\n"
"Device blocking:\n"
"  -b, --blocking-factor=BLOCKS   BLOCKS x 512 bytes per record\n"
"      --record-size=SIZE         SIZE bytes per record, multiple of 512\n"
"  -i, --ignore-zeros             ignore zeroed blocks in archive (means "
"EOF)\n"
"  -B, --read-full-records        reblock as we read (for 4.2BSD pipes)\n"
msgstr ""
"\n"
"Bloques de dispositivos:\n"
"  -b, --blocking-factor=BLOQUES  BLOQUES x 512 bytes por registro\n"
"      --record-size=TAMAÑO       TAMAÑO bytes por registro, múltiplo de 512\n"
"  -i, --ignore-zeros             pasa por alto bloques de ceros en archivo\n"
"                                 (significan EOF)\n"
"  -B, --read-full-records        rebloquea mientras se lee (en tuberías\n"
"                                 de 4.2BSD)\n"

# Nota: La diferencia entre un PATRÓN y una EXPREG es que
# el primero se refiere a un "globbing pattern", es decir, patrones
# de expansión de nombres de ficheros, como * y ?, mientras que
# el segundo se refiera a expresiones regulares como las de grep,
# es decir, ^, $, ., *, etc.
#: src/tar.c:377
msgid ""
"\n"
"Archive format selection:\n"
"  -V, --label=NAME                   create archive with volume name NAME\n"
"              PATTERN                at list/extract time, a globbing "
"PATTERN\n"
"  -o, --old-archive, --portability   write a V7 format archive\n"
"      --posix                        write a POSIX format archive\n"
"  -j, --bzip2                        filter the archive through bzip2\n"
"  -z, --gzip, --ungzip               filter the archive through gzip\n"
"  -Z, --compress, --uncompress       filter the archive through compress\n"
"      --use-compress-program=PROG    filter through PROG (must accept -d)\n"
msgstr ""
"\n"
"Selección de formato de archivo:\n"
"  -V, --label=NOMBRE                 crea un archivo con nombre de volumen\n"
"                                     NOMBRE\n"
"              PATRÓN                 en el momento de listar/extraer, "
"utiliza un\n"
"                                     PATRÓN\n"
"  -o, --old-archive, --portability   escribe un archivo con formato V7\n"
"      --posix                        escribe un archivo con formato POSIX\n"
"  -j, --bzip2                        filtra el archivo a través de bzip2\n"
"  -z, --gzip, --ungzip               filtra el archivo a través de gzip\n"
"  -Z, --compress, --uncompress       filtra el archivo a través de compress\n"
"      --use-compress-program=PROG    filtra a través de PROG (debe aceptar -"
"d)\n"

# He cambiado el "desde" por "del", si te suena raro, se puede cambiar el
# orden: "obtiene del archivo NOMBRE los nombres a crear o extraer". sv
# De todas formas, lo de los nombres "a extraer" es un vicio moderno
# que me encantaría poder evitar. sv
# [ Ahora mismo lo único que se me ocurre es cambiar completamente la frase:
# "extrae o crea los nombres obtenidos del archivo NOMBRE" o algo así. sv ]
# A mí me suena bien, pero no sé... fr
# ¿globbing = globales? sv
# Me parece una buena traducción, es algo que engloba a un grupo. fr
#
# globbing es, por ejemplo, lo que hace el shell cuando pones asteriscos:
# Cuando haces "cat *", el shell se encarga de expandir el *
# en lo que corresponda, y se lo da a cat ya traducido.
# Esto más que globalizar me suena a expandir, no sé.
# Si quieres déjalo que lo vea otro. sv
# Vid. mi comentario del mensaje anterior. gerardo
# quita -> elimina. sv
#: src/tar.c:389
msgid ""
"\n"
"Local file selection:\n"
"  -C, --directory=DIR          change to directory DIR\n"
"  -T, --files-from=NAME        get names to extract or create from file "
"NAME\n"
"      --null                   -T reads null-terminated names, disable -C\n"
"      --exclude=PATTERN        exclude files, given as a PATTERN\n"
"  -X, --exclude-from=FILE      exclude patterns listed in FILE\n"
"      --anchored               exclude patterns match file name start "
"(default)\n"
"      --no-anchored            exclude patterns match after any /\n"
"      --ignore-case            exclusion ignores case\n"
"      --no-ignore-case         exclusion is case sensitive (default)\n"
"      --wildcards              exclude patterns use wildcards (default)\n"
"      --no-wildcards           exclude patterns are plain strings\n"
"      --wildcards-match-slash  exclude pattern wildcards match "
"'/' (default)\n"
"      --no-wildcards-match-slash exclude pattern wildcards do not match '/'\n"
"  -P, --absolute-names         don't strip leading `/'s from file names\n"
"  -h, --dereference            dump instead the files symlinks point to\n"
"      --no-recursion           avoid descending automatically in "
"directories\n"
"  -l, --one-file-system        stay in local file system when creating "
"archive\n"
"  -K, --starting-file=NAME     begin at file NAME in the archive\n"
msgstr ""
"\n"
"Selección de fichero local:\n"
"  -C, --directory DIR         cambia al directorio DIR\n"
"  -T, --files-from=NOMBRE     obtiene los nombres a extraer o crear del\n"
"                              archivo NOMBRE\n"
"      --null                  -T lee nombres terminados en cero, deshabilita "
"-C\n"
"      --exclude=PATRÓN        excluye ficheros, dados como un PATRÓN\n"
"  -X, --exclude-from=FICHERO  excluye patrones listados en FICHERO\n"
"      --anchored              los patrones de exclusión encajan desde el\n"
"                              comienzo del nombre de fichero "
"(predeterminado)\n"
"      --no-anchored           los patrones de exclusión encajan después de\n"
"                              cualquier /\n"
"      --ignore-case           la exclusión considera iguales minúsculas y\n"
"                              mayúsculas\n"
"      --no-ignore-case        la exclusión distingue minúsculas de "
"mayúsculas\n"
"                              (predeterminado)\n"
"      --wildcards             los patrones de exclusión incluyen comodines\n"
"                              (predeterminado)\n"
"      --no-wildcards          los patrones de exclusión son cadenas "
"normales\n"
"      --wildcards-match-slash los comodines de los patrones de exclusión\n"
"                              encajan con '/' (predeterminado)\n"
"      --wildcards-match-slash los comodines de los patrones de exclusión\n"
"                              no encajan con '/'\n"
"  -P, --absolute-names        no elimina las '/'s iniciales de los nombres "
"de\n"
"                              fichero\n"
"  -h, --dereference           vuelca en su lugar los ficheros a los que "
"apuntan\n"
"                              los enlaces simbólicos.\n"
"      --no-recurse            evita descender automáticamente en "
"directorios\n"
"  -l, --one-file-system       permanece en el sistema de ficheros local\n"
"                              cuando se crea el archivo\n"
"  -K, --starting-file=NOMBRE  comienza en el fichero NOMBRE del archivo\n"

# # "más nuevos"->"más recientes". En el info de tar1.11.8 explica un poco más las
# # opciones --newer-*, sin limitar a "store", sino hablando en general de
# # cualquier operación. En el --newer-mtime debería ser --newer-mtime=DATE, y
# # dice que "limita la operación a los ficheros modificados después de la
# # fecha DATE"... ¿?. jmg
#: src/tar.c:412
msgid ""
"  -N, --newer=DATE             only store files newer than DATE\n"
"      --newer-mtime=DATE       compare date and time when data changed only\n"
"      --after-date=DATE        same as -N\n"
msgstr ""
"  -N, --newer=FECHA           sólo almacena los ficheros más recientes que "
"FECHA\n"
"      --newer-mtime=FECHA     compara la fecha y hora en que los datos "
"cambiaron\n"
"      --after-date=FECHA      igual que -N\n"

#: src/tar.c:418
msgid ""
"      --backup[=CONTROL]       backup before removal, choose version "
"control\n"
"      --suffix=SUFFIX          backup before removal, override usual suffix\n"
msgstr ""
"      --backup[=CONTROL]      copia de seguridad antes de eliminar, elige\n"
"                              el control de versión\n"
"      --suffix=SUFIJO         copia de seguridad antes de eliminar, pasa "
"por\n"
"                              alto el sufijo habitual\n"

# # print -> ¿muestra o imprime? Prefiero muestra, pero manténgase
# # siempre; ¡al menos en un mismo mensaje! gag
# Lo de "prolijamente" suena regular. En diffutils hay una laaarga discusión
# sobre ello. Yo usaría "verbosely"->"detalladamente" o "con detalle". jmg
# los bytes totales escritos -> el total de bytes escritos. nl
# O los bytes escritos en total, bien. gerardo
#: src/tar.c:422
msgid ""
"\n"
"Informative output:\n"
"      --help            print this help, then exit\n"
"      --version         print tar program version number, then exit\n"
"  -v, --verbose         verbosely list files processed\n"
"      --checkpoint      print directory names while reading the archive\n"
"      --totals          print total bytes written while creating archive\n"
"  -R, --block-number    show block number within archive with each message\n"
"  -w, --interactive     ask for confirmation for every action\n"
"      --confirmation    same as -w\n"
msgstr ""
"\n"
"Salida de información:\n"
"     --help           muestra esta ayuda, y finaliza\n"
"     --version        informa de la versión y finaliza\n"
" -v, --verbose        lista prolijamente los ficheros procesados\n"
"     --checkpoint     muestra los nombres de directorio al leer el archivo\n"
"     --totals         muestra los bytes escritos en total al crear el "
"archivo\n"
" -R, --block-number   muestra el número de bloque en el archivo con cada "
"mensaje\n"
" -w, --interactive    pide confirmación para cada acción\n"
"     --confirmation   igual que -w\n"

# # la versión de control -> el control de versión
# # nil: numeradas... simples... (en plural)
# # never, simPle (falta una pe): backup -> copia de seguridad. gag
# Estoy de acuerdo con lo de gag (más arriba usas eso mismo). jmg
#: src/tar.c:434
msgid ""
"\n"
"The backup suffix is `~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control may be set with --backup or VERSION_CONTROL, values "
"are:\n"
"\n"
"  t, numbered     make numbered backups\n"
"  nil, existing   numbered if numbered backups exist, simple otherwise\n"
"  never, simple   always make simple backups\n"
msgstr ""
"\n"
"El sufijo de respaldo es `~', a menos que se especifique con --suffix\n"
"o con SIMPLE_BACKUP_SUFFIX. El control de versiones puede establecerse\n"
"con --backup o con VERSION_CONTROL, los valores son:\n"
"\n"
"  t, numbered     hace copias de seguridad numeradas\n"
"  nil, existing   numerada si existen copias de seguridad numeradas, "
"simples\n"
"                  en otro caso\n"
"  never, simple   siempre hace copias de seguridad simples\n"

# ARCHIVO puede ser FICHERO (¡no ARCHIVO!)...
# por defecto -> por omisión, de forma predeterminada
# HOST -> HUÉSPED, ANFITRIÓN (aquí estoy más perdido que el barco 'el
# arroz, ya lo sé; como con shell y script). gag
#: src/tar.c:443
#, c-format
msgid ""
"\n"
"GNU tar cannot read nor produce `--posix' archives.  If POSIXLY_CORRECT\n"
"is set in the environment, GNU extensions are disallowed with `--posix'.\n"
"Support for POSIX is only partially implemented, don't count on it yet.\n"
"ARCHIVE may be FILE, HOST:FILE or USER@HOST:FILE; DATE may be a textual "
"date\n"
"or a file name starting with `/' or `.', in which case the file's date is "
"used.\n"
"*This* `tar' defaults to `-f%s -b%d'.\n"
msgstr ""
"\n"
"GNU tar no puede leer ni generar archivos `--posix'. Si POSIXLY_CORRECT "
"está\n"
"definido en el entorno, las extensiones GNU se deshabilitan con `--posix'.\n"
"El soporte para POSIX está sólo parcialmente implementado, no se debe "
"contar \n"
"con él aún.\n"
"ARCHIVO puede ser FICHERO, HOST:FICHERO o USUARIO@HOST:FICHERO; FECHA puede "
"ser\n"
"una fecha textual, o un nombre de fichero que comience con `/' o con `.', "
"en\n"
"cuyo caso se utiliza la fecha del fichero.\n"
"*Este* `tar' utiliza `-f%s -b%d' por omisión.\n"

#: src/tar.c:478
msgid "You may not specify more than one `-Acdtrux' option"
msgstr "No se puede especificar más de una opción `-Acdtrux'"

#: src/tar.c:487
msgid "Conflicting compression options"
msgstr "Opciones de compresión en conflicto"

#: src/tar.c:555
#, c-format
msgid "Old option `%c' requires an argument."
msgstr "La opción antigua `%c' requiere un argumento"

# Nota aclaratoria: (Gerardo)
# Incluida no lleva tilde.
# Ni ruido ni huida ni güiro (un instrumento musical cubano).
# Sí se parte en in-clu-i-da, pero sin tilde. No existe el hiato.
# Mira en un diccionario `ruido' a ver si tiene tilde, y considera si
# no es el mismo caso (Rui-do no: ru-i-do).
#
# Más arriba has usado "implies"->"implica", así que aquí
# sería "implied by"->"implicada por", o modificar lo otro. jmg
# Pero es que implica suena bien pero implicada por suena fatal. sv
#: src/tar.c:600
msgid "Obsolete option, now implied by --blocking-factor"
msgstr "Opción obsoleta, ahora incluida en --blocking-factor"

# Pregunta: ¿qué es reemplazado/a el nombre o la opción? sv
# Creo que es el nombre. fr
# # El nombre de la opción; lo que pasa es que en el mensaje en español
# # no se entiende muy bien. Quizá: nombre obsoleto de la opción
# # remplazado por -- ... gag
#: src/tar.c:604
msgid "Obsolete option name replaced by --blocking-factor"
msgstr "Nombre de opción obsoleta reemplazado por --blocking-factor"

#: src/tar.c:615
msgid "Invalid blocking factor"
msgstr "Factor de bloqueo inválido"

# # Ver msj. anterior
#: src/tar.c:621
msgid "Obsolete option name replaced by --read-full-records"
msgstr "Nombre de opción obsoleta reemplazado por --read-full-records"

#: src/tar.c:696
msgid "Warning: the -I option is not supported; perhaps you meant -j or -T?"
msgstr "Atención: no se admite la opción -I; ¿no será -j o -T?"

#: src/tar.c:726
msgid "Invalid tape length"
msgstr "Longitud de cinta inválida"

#: src/tar.c:733
msgid "Obsolete option name replaced by --touch"
msgstr "Nombre de opción obsoleta reemplazado por --touch"

# No sé cómo traducir threshold. fr
# Yo tampoco (los diccionarios los tengo en casa...). sv
# Lo buscaré en un diccionario "güeno". fr
# Es "umbral", pero no sé qué c$%&# es la fecha umbral. :-( gag
# A ver si te vale así. sv
# ¿Qué tal os suena "fecha límite"?. jmg
#: src/tar.c:754
msgid "More than one threshold date"
msgstr "Se ha especificado más de una fecha tope"

#: src/tar.c:764
msgid "Date file not found"
msgstr "No se encontró la fecha del fichero"

#: src/tar.c:772
#, c-format
msgid "Substituting %s for unknown date format %s"
msgstr "Sustituyendo %s por el formato de fecha desconocido %s"

#: src/tar.c:783 src/tar.c:989 src/tar.c:994
msgid "Conflicting archive format options"
msgstr "Opciones de formato de archivo en conflicto"

#: src/tar.c:795
msgid "Obsolete option name replaced by --absolute-names"
msgstr "Nombre de opción obsoleta reemplazado por --absolute-names"

#: src/tar.c:807
msgid "Obsolete option name replaced by --block-number"
msgstr "Nombre de opción obsoleta reemplazado por --block-number"

#: src/tar.c:880
msgid "Warning: the -y option is not supported; perhaps you meant -j?"
msgstr "Atención: no se admite la opción -y; ¿no será -j?"

#: src/tar.c:893
msgid "Obsolete option name replaced by --backup"
msgstr "Nombre de opción obsoleta reemplazado por --backup"

#: src/tar.c:928
#, c-format
msgid "%s: Invalid group"
msgstr "%s: Grupo inválido"

#: src/tar.c:937
msgid "Invalid mode given on option"
msgstr "Se ha especificado un modo no válido en la opción"

#: src/tar.c:980
msgid "Invalid owner"
msgstr "Propietario inválido"

# ¿No queda más bonita la 1ª comilla abierta así: `record_size'?
# Sí. FIXME. Comunicar al autor. sv
#: src/tar.c:1009
msgid "Invalid record size"
msgstr "El tamaño del registro es inválido"

#: src/tar.c:1012
#, c-format
msgid "Record size must be a multiple of %d."
msgstr "El tamaño del registro debe ser múltiplo de %d."

#: src/tar.c:1117
msgid "Options `-[0-7][lmh]' not supported by *this* tar"
msgstr "*Esta* versión de tar no admite las opciones `-[0-7][lmh]'"

#: src/tar.c:1140
msgid "Written by John Gilmore and Jay Fenlason."
msgstr "Escrito por John Gilmore y Jay Fenlason."

#: src/tar.c:1166
msgid "GNU features wanted on incompatible archive format"
msgstr "Se requieren características de GNU en formato de archivo incompatible"

# requieren -> necesitan. gerardo
#: src/tar.c:1183
msgid "Multiple archive files requires `-M' option"
msgstr "Los archivos múltiples requieren la opción `-M'"

#: src/tar.c:1188
msgid "Cannot combine --listed-incremental with --newer"
msgstr "No se puede combinar --listed-incremental con --newer"

#: src/tar.c:1203
#, c-format
msgid "%s: Volume label is too long (limit is %lu bytes)"
msgstr "%s: La etiqueta de volumen es demasiado larga (el límite es %lu bytes)"

# Me gusta más al verrés: cobarde rechazo [de la pradera] a... gerardo
#: src/tar.c:1220
msgid "Cowardly refusing to create an empty archive"
msgstr "Rechazo cobarde a crear un archivo vacío"

#: src/tar.c:1241
msgid "Options `-Aru' are incompatible with `-f -'"
msgstr "Las opciones `-Aru' son incompatibles con `-f -'"

#: src/tar.c:1305
msgid "You must specify one of the `-Acdtrux' options"
msgstr "Se debe especificar una de las opciones `-Acdtrux'"

#: src/tar.c:1350
msgid "Error in writing to standard output"
msgstr "Error al escribir en la salida estándar"

# Antes decía:
# "La salida con error se demora por los errores anteriores
#
# Quiere decir que hubo errores, pero tar pudo seguir adelante, sin
# embargo va a salir con un estado de error por esos errores que ya pasaron.
# Una traducción:
# "Salida con error demorada desde errores anteriores" (Nicolás L.)
#: src/tar.c:1352
msgid "Error exit delayed from previous errors"
msgstr "Salida con error demorada desde errores anteriores"

# Eso de ¡vaya tela! ¿es una interjección que se entiende en todo el mundo
# hispanoparlante? No vaya a ser específico de Andalucía/Extremadura y...
# ¡oye, déjalo, así expandimos nuestra lengua! gerardo
# Inaceptable, alguien fuera de España no tiene idea de que diablos quiere
# decir ¡vaya tela!. Habrá que buscar alguna interhección de asco/sorpresa
# que sea más `portable'. nl
# Tenéis razón. Habrá que preguntar.
# ¡Ya lo tengo! "¡Carajo!" X-D Eso se utiliza en Colombia, México y otros
# sitios de por ahí a troche y moche, y creo que ni siquiera se entiende como
# "miembro viril masculino". Y en España creo que también se emplea, ¿no?
# (Vaale, vaaale, ¿y qué tal su eufemismo `caramba' o `caray', más neutros
# y cursis, para que no se enfade nadie? Aunque para cursis: `cáspita',
# `caracoles', `cónchales'; no diréis que no os doy opciones.) Por cierto,
# creo que la coma sobra (incluso en el original). gerardo
#: src/update.c:83
#, c-format
msgid "%s: File shrank by %s bytes"
msgstr "%s: El tamaño del fichero ha disminuido en %s bytes"

# Acepto sugerencias para el `test suite'. sv
# "test suite"="paquete/conjunto de pruebas/análisis", en cualquier
# combinación. jmg
#: tests/genfile.c:65
msgid "Generate data files for GNU tar test suite.\n"
msgstr "Genera ficheros de datos para el conjunto de pruebas de GNU tar.\n"

#: tests/genfile.c:66
#, c-format
msgid ""
"\n"
"Usage: %s [OPTION]...\n"
msgstr ""
"\n"
"Modo de empleo: %s [OPCIÓN]...\n"

#: tests/genfile.c:69
msgid ""
"If a long option shows an argument as mandatory, then it is mandatory\n"
"for the equivalent short option also.\n"
"\n"
"  -l, --file-length=LENGTH   LENGTH of generated file\n"
"  -p, --pattern=PATTERN      PATTERN is `default' or `zeros'\n"
"      --help                 display this help and exit\n"
"      --version              output version information and exit\n"
msgstr ""
"Los argumentos obligatorios para las opciones largas son también "
"obligatorios\n"
"para las opciones cortas.\n"
"\n"
"  -l, --file-length=LONGITUD  LONGITUD del fichero generado\n"
"  -p, --pattern=PATRÓN        PATRÓN es `default' o `zeros'\n"
"      --help                  muestra esta ayuda y sale\n"
"      --version               informa de la versión y finaliza\n"

#. Note to translator: Please translate "F. Pinard" to "François
#. Pinard" if "ç" (c-with-cedilla) is available in the
#. translation's character set and encoding.
#: tests/genfile.c:143
msgid "Written by F. Pinard."
msgstr "Escrito por François Pinard."

#~ msgid "%d garbage bytes ignored at end of archive"
#~ msgstr "%d bytes superfluos no se tendrán en cuenta al final del archivo"

#~ msgid "Ambiguous pattern `%s'"
#~ msgstr "El patrón `%s' es ambiguo"

#~ msgid "Unknown pattern `%s'"
#~ msgstr "El patrón `%s' es desconocido"

# Me encantaría poder incluir tos propuestas de usar el \372 ( aspa ) y
# el (C) , veremos si lo hacemos algún día. em+
# Estaría bien cambiar el '(C)' por '©', que es otro carácter de
# ISO-Latin1. Como los yanquis usan el ASCII (US ISO-646), que es de
# 7 bits, no lo pueden usar; nosotros sí. gerardo
# Pues eso: que si os encanta, ¿por qué no lo hacéis? ¿Cuál es el problema?
# Bueno, vale, de acuerdo... sv
#~ msgid "Copyright %d Free Software Foundation, Inc."
#~ msgstr "© %d Free Software Foundation, Inc."

#~ msgid ""
#~ "This is free software; see the source for copying conditions.  There is "
#~ "NO\n"
#~ "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR "
#~ "PURPOSE.\n"
#~ msgstr ""
#~ "Esto es software libre; vea el código fuente para las condiciones de "
#~ "copia.\n"
#~ "No hay NINGUNA garantía; ni siquiera de COMERCIABILIDAD o IDONEIDAD PARA "
#~ "UN\n"
#~ "FIN DETERMINADO.\n"

#~ msgid "Write to compression program short %lu bytes"
#~ msgstr "La escritura al programa de compresión acorta %lu bytes"

#~ msgid "Removing `%.*s' prefix from member names"
#~ msgstr "Eliminando el prefijo `%.*s' de los nombres"

#~ msgid "Removing leading `/' from link names"
#~ msgstr "Eliminando la `/' inicial de los nombres de los enlaces"

#~ msgid "Archive contains future timestamp %s"
#~ msgstr "El archivo contiene la marca de tiempo en el futuro %s"

#~ msgid "%s: Cannot symlink %s %s"
#~ msgstr "%s: No se puede crear el enlace simbólico %s %s"

#~ msgid "Invalid group given on option"
#~ msgstr "Se ha especificado un grupo no válido en la opción"

#~ msgid "Invalid owner given on option"
#~ msgstr "Se ha especificado un propietario no válido en la opción"

#~ msgid "Cannot close file descriptor"
#~ msgstr "No se puede cerrar el descriptor de fichero"

#~ msgid "Cannot properly duplicate %s"
#~ msgstr "No se puede duplicar %s correctamente"

#~ msgid "(child) Pipe to stdin"
#~ msgstr "(proceso hijo) Se abre una tubería desde la entrada estándar"

#~ msgid "Archive to stdout"
#~ msgstr "Archivo hacia la salida estándar"

#~ msgid "((child)) Pipe to stdout"
#~ msgstr "((proceso hijo)) Se abre una tubería hacia la salida estándar"

#~ msgid "(grandchild) Pipe to stdin"
#~ msgstr "(proceso nieto) Se abre una tubería desde la entrada estándar"

#~ msgid "(child) Pipe to stdout"
#~ msgstr "(proceso hijo) Se vuelca el resultado por la salida estándar"

# ¿Qué será esto? ¿Quizás un fallo en el mensaje original? Porque "to"
# no es "desde", sino "hacia", que yo sepa. Pero `archivo hacia la
# salida estándar' no pega mucho. Está en otros mensajes, como el
# siguiente; no lo entiendo. - gerardo
# FIXME. Tienes razón. Es muy raro.
#~ msgid "Archive to stdin"
#~ msgstr "Archivo desde la entrada estándar"

#~ msgid "((child)) Pipe to stdin"
#~ msgstr "((proceso hijo)) Se abre una tubería desde la entrada estándar"

#~ msgid "(grandchild) Pipe to stdout"
#~ msgstr "(proceso nieto) Se abre una tubería hacia la salida estándar"

#~ msgid "Only wrote %lu of %lu bytes to %s"
#~ msgstr "Sólo se escribieron %lu de %lu bytes en %s"

# FIXME: No queda claro si es al cerrar, cerrando, cierre, o qué. sv
#~ msgid "WARNING: %s: close (%d, %d)"
#~ msgstr "ATENCIÓN: %s: se cierra (%d, %d)"

#~ msgid "Cannot allocate memory for diff buffer of %lu bytes"
#~ msgstr ""
#~ "No se puede asignar memoria para el búfer de diferencias de %lu bytes"

# # Como has puesto más arriba: "EOF"->"Fin de fichero". jmg
#~ msgid "Unexpected EOF on archive file"
#~ msgstr "EOF inesperado en archivo"

# Lo mismo que con stat() em+
# # seek() es otra función. seek = "hacer seek()" ¡Estos
# # angloparlantes!
#~ msgid "Cannot seek to %s in file %s"
#~ msgstr "No se puede acceder a la posición %s en el fichero %s"

#~ msgid "Wrote %s of %s bytes to file %s"
#~ msgstr "Se escribieron %s de %s bytes en el fichero %s"

#~ msgid "lseek error at byte %s in file %s"
#~ msgstr "Error de lectura en el byte %s en el fichero %s"

# "se rellena" debería ser "rellenando". "se rellena" puede entenderse como
# varias cosas, no queda claro que es lo que se esta haciendo, podría indicar
# lo que se suele hacer.. =)   "rellenando con ceros" es perfecto y es
# exactamente lo que está escrito en el original. sv
#
# Que sí, reconozco que la traducción es un poco libre.
# Pero mi intención es que el programa diga lo que va haciendo, no lo que ya
# ha hecho. Ni siquiera el original es consistente en los modos verbales. sv
#~ msgid "File %s shrunk, padding with zeros"
#~ msgstr "El tamaño del fichero %s ha disminuido, se rellena con ceros"

# OK em+
# Can't = no se puede; couldn't: no se ha podido. gag
# O no se pudo. sv
# Esa forma verbal se debería usar para cosas ocurridas hace mucho más tiempo.
# No pude hacer la Primera Comunión vestido de hombre-rana, no he podido
# escribir esta frase en caracteres jeroglíficos. gag
#
#~ msgid "Cannot reposition archive file"
#~ msgstr "No se puede reposicionar el archivo"

#~ msgid "%s: Cannot change access and modification times"
#~ msgstr "%s: No se pueden cambiar las fechas de acceso y modificación"

#~ msgid "%s: Cannot lchown to uid %lu gid %lu"
#~ msgstr ""
#~ "%s: No se puede cambiar el propietario y grupo con `lchown' a uid %lu gid "
#~ "%lu"

#~ msgid "%s: Cannot chown to uid %lu gid %lu"
#~ msgstr ""
#~ "%s: No se puede cambiar el propietario y grupo con `chown' a uid %lu gid %"
#~ "lu"

#~ msgid "%s: lseek error at byte %s"
#~ msgstr "%s: error de desplazamiento en el byte %s"

#~ msgid "%s: Could only write %s of %s bytes"
#~ msgstr "%s: Sólo se pudieron escribir %s de %s bytes"

#~ msgid "Error while deleting %s"
#~ msgstr "Error al borrar %s"

# # Como has puesto más arriba: "EOF"->"Fin de fichero". jmg
#~ msgid "EOF in archive file"
#~ msgstr "EOF en el archivo"

#~ msgid "Only wrote %lu of %lu bytes to file %s"
#~ msgstr "Sólo se escribieron %lu de %lu bytes al archivo %s"

#~ msgid "Renaming previous %s to %s\n"
#~ msgstr "Se renombra el anterior %s como %s\n"

#~ msgid "%s: Cannot rename for backup"
#~ msgstr "%s: No se puede renombrar para hacer una copia de seguridad"

#~ msgid "%s: Cannot rename from backup"
#~ msgstr "%s: No se puede renombrar de la copia de seguridad"

# FIXME. No es traducible.
#~ msgid "Cannot %s %s"
#~ msgstr "No se puede %s %s"

#~ msgid "Read error at byte %s reading %lu bytes in file %s"
#~ msgstr "Error de lectura en el byte %s leyendo %lu bytes en el fichero %s"

# Antes de que nadie diga nada:
#
# Si a alguien no le gusta la palabra tubería (que aparece en algunos
# libros sobre MS-DOS y es la que venimos usando desde el principio) que
# haga una propuesta seria de cambio, pero que sepa que abriríamos la caja
# de Pandora, pues hay muchas palabras posibles para pipe: tubería,
# conducto, cañería, canal, etc.
#
# En cuanto a poner (pipe) entre paréntesis, es una mala costumbre que
# deberíamos desterrar ya. Eso se hace en los libros la primera vez, pero
# aquí no sólo no hay primera vez, sino que el mismo mensaje puede
# aparecer *varias* veces, y entonces sí que es una paliza.
# Ejemplo de paliza: "tubería rota" en libc. Sale muchísimo y no es
# cuestión de ver (pipe) cuarenta veces al día...
#~ msgid "Cannot open pipe"
#~ msgstr "No se puede abrir la tubería"

#~ msgid "Cannot open archive %s"
#~ msgstr "No se puede abrir el archivo %s"

#~ msgid "Cannot exec %s"
#~ msgstr "No se puede ejecutar %s"

# lo mismo de antes. sv
#~ msgid "Child cannot fork"
#~ msgstr "El proceso hijo no puede bifurcarse"

#~ msgid "Cannot read from compression program"
#~ msgstr "No se puede leer del programa de compresión"

#~ msgid "Cannot write to compression program"
#~ msgstr "No se puede escribir al programa de compresión"

#~ msgid "Cannot write to %s"
#~ msgstr "No se puede escribir en %s"

#~ msgid "Read error on %s"
#~ msgstr "Error de lectura en %s"

#~ msgid "WARNING: Cannot truncate %s"
#~ msgstr "ATENCIÓN: No se puede truncar %s"

#~ msgid "While waiting for child"
#~ msgstr "Mientras se esperaba al hijo"

# Estos errores son para el debug del programa. A quien le pueda
# interesar sabe lo que quiere decir em+
# # ¡Otras veces se ha puesto bifurcar sin el (fork)! Esto es difícil,
# # porque también podría ponerse: "No se puede hacer fork()", ya que
# # fork() es un punto de entrada a una primitiva Unix; vaya, una
# # función. gag
# FIXME. Hablar con el autor.
# # en fileutils-3.16.es.po, el autor cambió el "Cannot fork" por "fork
# # system call failed", con lo que podría pasar lo mismo ahora. Si no
# # hay cambios, yo preferiría: "¡No se puede crear proceso hijo (fork)!"
# # jmg
#~ msgid "Cannot fork!"
#~ msgstr "¡No se puede bifurcar!"

#~ msgid "Cannot exec a shell %s"
#~ msgstr "No se puede ejecutar un shell %s"

#~ msgid "Cannot open %s"
#~ msgstr "No se puede abrir %s"

#~ msgid "Cannot read %s"
#~ msgstr "No se puede leer %s"

#~ msgid "Error while closing %s"
#~ msgstr "Error al cerrar %s"

#~ msgid "Cannot read link %s"
#~ msgstr "No se puede leer el enlace %s"

#~ msgid "Could not rewind archive file for verify"
#~ msgstr "No se pudo rebobinar el archivo para verificar"

#~ msgid "Removing leading `/' from archive names"
#~ msgstr "Eliminando la `/' inicial de los nombres del archivo"

#~ msgid "Cannot add file %s"
#~ msgstr "No se puede añadir el fichero %s"

#~ msgid "Cannot add directory %s"
#~ msgstr "No se puede añadir el directorio %s"

#~ msgid "Cannot open directory %s"
#~ msgstr "No se puede abrir el directorio %s"

#~ msgid "%s: Could not write to file"
#~ msgstr "%s: No se pudo escribir en el fichero"

#~ msgid "%s: Could not create file"
#~ msgstr "%s: No se pudo crear el fichero"

#~ msgid "%s: Error while closing"
#~ msgstr "%s: Error al cerrar"

#~ msgid "%s: Could not make node"
#~ msgstr "%s: No se pudo crear el nodo"

# Pongo comitas porque no es una palabra española.
# A quien no le guste que abra el debate sobre cuándo sí y cuándo no
# deben ponerse comitas en es@li.org.
#~ msgid "%s: Could not make fifo"
#~ msgstr "%s: No se pudo crear el `fifo'"

#~ msgid "%s: Could not create directory"
#~ msgstr "%s: No se pudo crear el directorio"

#~ msgid "Added write and execute permission to directory %s"
#~ msgstr "Añadidos permisos de escritura y ejecución al directorio %s"

#~ msgid "Cannot open file %s"
#~ msgstr "No se puede abrir el fichero %s"

#~ msgid "Cannot change to directory %s"
#~ msgstr "No se puede cambiar al directorio %s"

#~ msgid "Cannot read confirmation from user"
#~ msgstr "No se puede leer la confirmación del usuario"

#~ msgid ""
#~ "\n"
#~ "Usage: %s [OPTION]... [FILE]...\n"
#~ msgstr ""
#~ "\n"
#~ "Modo de empleo: %s [OPCIÓN]... [FICHERO]...\n"

#~ msgid "Invalid date format `%s'"
#~ msgstr "Formato de fecha inválido `%s'"

# Me encantaría poder incluir tos propuestas de usar el \372 ( aspa ) y
# el (C) , veremos si lo hacemos algún día. em+
# # Estaría bien cambiar el '(C)' por '©', que es otro carácter de
# # ISO-Latin1. Como los yanquis usan el ASCII (US ISO-646), que es de
# # 7 bits, no lo pueden usar; nosotros sí. Incluso "Copyright" por
# # "Derechos de copia". Ya lo de FSF por Fundación del Logical Libre
# # es demasiado, ¿verdad? :-) gag
# < ¿Puede alguien explicarme por qué no se hace ya, o no se ha hecho
# antes? ¿Qué diferencia hay, bajo el punto de vista de ser caracteres
# válidos, entre 'ó' y 'ß' o entre 'ñ' y '¤' o entre 'º' y '©' o entre
# '¿' y '¼'? Lo único que se me ocurre es que es algo difícil introducir
# esos caracteres porque no están en el teclado del PC. No hay más que
# irse a una terminal o teclado con tecla de Componer o usar el Emacs con
# C-q ooo (ooo = número octal) con la tabla (man iso_8859_1) al lado.
# ¿Alguien tiene otra explicación?
#
# Se ven peor. Estas cosas deben ser bien legibles desde consola, y el
# Copyright ese © no se ve demasiado bien. sv
# Nostoy dacuerdo. Protesto enérgicamente. gerardo
# No tendría ningún inconveniente en usar ese carácter si el objetivo final
# fuera que apareciese por una láser de 300ppp, pero el objetivo es que se
# vea por consola, y con la poca resolución que tiene no es un Copyright
# hecho y derecho sino una C dentro de algo que parece más bien un cuadrado
# con los bordes redondeados. Incluso el (C) Sinclair Research...
# se veía mejor que el de los PCs. sv
# Bueno, eso es un problema del tipo de letra, no del traductor. Además (C)
# es el sucedáneo legal del ©, como TeX cuando no se puede poner como \TeX{}.
# Pero es un sucedáneo, no el original. Es un copyright light. A más a más,
# como dicen los catalanes, que ya aparece delante la palabra Copyright, por
# lo que no debe haber ambigüedad. gerardo
#
# Hombre, el objetivo del traductor es que se entienda, y por ser (C)
# el "sucedáneo legal", como tú le dices, es razonable usarlo.
# En cambio la "ñ" no tiene sucedáneo legal, por lo que poner
# "espagna" o "espa~na" sería completamente inaceptable.
# Y si lo miras bien, todos son sucedáneos, pues las letras no "son"
# pixelizadas. Lo que yo digo es que © no es un sucedáneo más bonito que (C)
# para el símbolo de copyright. sv
#~ msgid ""
#~ "\n"
#~ "Copyright 1988, 92,93,94,95,96,97,98, 1999 Free Software Foundation, "
#~ "Inc.\n"
#~ msgstr ""
#~ "\n"
#~ "Copyright 1988, 92,93,94,95,96,97,98, 1999 Free Software Foundation, "
#~ "Inc.\n"

# Tengo que plantearme seriamente si pongo "fin de fichero" siempre
# siempre en vez de EOF. sv
#
# Según gag y jmg, hay que decir: "no está en un límite de bloque", pues
# no estamos hablando de un bloque concreto (el bloque) sino de uno cualquiera.
# FIXME: Entonces tal vez el original debería decir "on a block boundary". sv
#~ msgid "Archive %s EOF not on block boundary"
#~ msgstr "El fin del archivo %s no está en un límite de bloque"

# ¿por qué convertir las oraciones unimembres en bimembres? Ya vi
# otro caso en donde se hace y no veo por qué. Bien podría quedar como:
# "Nombre de fichero %s%s demasiado largo". nl
# Algunas de esas frases suenan a "indio" sv
# Hombre, esto no es una novela (del Oeste :-), la forma "india" es
# más literal y más corta, lo que quizá sea más apropiado para mensajes
# concisos como éstos; pero en realidad es más agradable de leer así.
# El traductor manda. gerardo
#~ msgid "File name %s%s too long"
#~ msgstr "El nombre de fichero %s%s es demasiado largo"

#~ msgid "Hmm, this doesn't look like a tar archive"
#~ msgstr "Mmm, esto no parece un archivo tar"

#~ msgid "Skipping to next file header"
#~ msgstr "Saltando a la siguiente cabecera de fichero"

#~ msgid "Cannot determine initial working directory"
#~ msgstr "No se puede determinar el directorio de trabajo inicial"

# FIXME. Comunicar al autor que estos dos mensajes se parecen "demasiado". sv
#~ msgid "Could not get current directory"
#~ msgstr "No se pudo obtener el directorio actual"

#~ msgid "Could not get current directory: %s"
#~ msgstr "No se pudo obtener el directorio actual: %s"

#~ msgid "File name %s/%s too long"
#~ msgstr "El nombre del fichero %s/%s es demasiado largo"

#~ msgid "%s: invalid timestamp `%s' ignored"
#~ msgstr "%s: no se tendrá en cuenta la marca de fecha `%s' inválida"

#~ msgid "%s: out-of-range timestamp `%s' ignored"
#~ msgstr "%s: no se tendrá en cuenta la marca de fecha `%s' fuera de rango"

#~ msgid "Cannot chdir to %s"
#~ msgstr "No se puede cambiar al directorio %s"

#~ msgid "Arithmetic overflow"
#~ msgstr "Sobrepasamiento aritmético"

# Se vuelca la *memoria* del proceso en un fichero llamado `core'.
#~ msgid " (core dumped)"
#~ msgstr " (memoria volcada)"

#~ msgid "Data differs"
#~ msgstr "Los datos son distintos"

#~ msgid "File does not exist"
#~ msgstr "El fichero no existe"

# Uff, a lo mejor se asusta el usuario si ponemos 'no se pudo leer con stat()
# el estado del fichero em+
# # stat() es una primitiva Unix que acaba de fallar; también podría
# # ser: "No se puede hacer stat() del fichero %s", o "stat() ha fallado..."
# # Aunque tal como está es más descriptivo para el neófito, desde
# # luego. gag
#~ msgid "Cannot stat file %s"
#~ msgstr "No se puede leer el estado del fichero %s"

# Nota: En Unix, se llama fichero *regular* al que no es ni un directorio,
# ni un dispositivo (de bloques o de caracteres) ni un fifo, etc.
# Uno puede pensar que son los ficheros "normales", pero eso depende,
# pues un directorio es de lo más "normal"...
#~ msgid "Not a regular file"
#~ msgstr "No es un fichero regular"

#~ msgid "Does not exist"
#~ msgstr "No existe"

#~ msgid "No such file or directory"
#~ msgstr "No existe el fichero o el directorio"

#~ msgid "Mode or device-type changed"
#~ msgstr "El modo o el tipo de dispositivo ha cambiado"

#~ msgid "No longer a directory"
#~ msgstr "Ya no es un directorio"

#~ msgid "Removing drive spec from names in the archive"
#~ msgstr ""
#~ "Eliminando las especificaciones de unidad de los nombres que hay en el "
#~ "archivo"

# Lo mismo. sv
# Sugerencia: Sendero -> Ruta, camino. sv
# Lo siento, no me salía la palabra. Esperaba correción. fr
# Siempre he estado usando ruta en otras traducciones em+
# # Esta vez sugiero "camino", por seguir la terminología de
# # Microsoft, ya que da lo mismo, ¿no? gag
# Quedaría igualmente claro si no se hace referencia a ruta:
# "... de los nombres absolutos en el archivo". jmg
#~ msgid "Removing leading `/' from absolute path names in the archive"
#~ msgstr ""
#~ "Borrando la `/' inicial de los nombres absolutos de ruta en el archivo"

#~ msgid "Amount actually written is (I hope) %d.\n"
#~ msgstr "La cantidad realmente escrita (esperemos) es %d.\n"

#~ msgid "%d at %d\n"
#~ msgstr "%d en %d\n"
