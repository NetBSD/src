/* This file is is generated by a shell script.  DO NOT EDIT! */

/* 32 bit ELF emulation code for m68kelfnbsd
   Copyright (C) 1991-2022 Free Software Foundation, Inc.
   Written by Steve Chamberlain <sac@cygnus.com>
   ELF support by Ian Lance Taylor <ian@cygnus.com>

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#define TARGET_IS_m68kelfnbsd

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "getopt.h"
#include "bfdlink.h"
#include "ctf-api.h"
#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"
#include <ldgram.h>
#include "elf-bfd.h"
#include "ldelf.h"
#include "ldelfgen.h"

/* Declare functions used by various EXTRA_EM_FILEs.  */
static void gldm68kelfnbsd_before_parse (void);
static void gldm68kelfnbsd_before_plugin_all_symbols_read
  (void);
static void gldm68kelfnbsd_after_open (void);
static void gldm68kelfnbsd_before_allocation (void);
static void gldm68kelfnbsd_after_allocation (void);


#include "elf32-m68k.h"

#define GOT_HANDLING_SINGLE   (0)
#define GOT_HANDLING_NEGATIVE (1)
#define GOT_HANDLING_MULTIGOT (2)
#define GOT_HANDLING_TARGET_DEFAULT GOT_HANDLING_SINGLE

/* How to generate GOT.  */
static int got_handling = GOT_HANDLING_DEFAULT;

#ifdef SUPPORT_EMBEDDED_RELOCS
static void check_sections (bfd *, asection *, void *);
#endif

/* This function is run after all the input files have been opened.  */

static void
m68k_elf_after_open (void)
{
  /* Call the standard elf routine.  */
  gldm68kelfnbsd_after_open ();

#ifdef SUPPORT_EMBEDDED_RELOCS
  if (command_line.embedded_relocs
      && (!bfd_link_relocatable (&link_info)))
    {
      bfd *abfd;

      /* In the embedded relocs mode we create a .emreloc section for each
	 input file with a nonzero .data section.  The BFD backend will fill in
	 these sections with magic numbers which can be used to relocate the
	 data section at run time.  */
      for (abfd = link_info.input_bfds; abfd != NULL; abfd = abfd->link.next)
	{
	  asection *datasec;

	  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
	    einfo (_("%F%P: %pB: all input objects must be ELF "
		     "for --embedded-relocs\n"));

	  datasec = bfd_get_section_by_name (abfd, ".data");

	  /* Note that we assume that the reloc_count field has already
	     been set up.  We could call bfd_get_reloc_upper_bound, but
	     that returns the size of a memory buffer rather than a reloc
	     count.  We do not want to call bfd_canonicalize_reloc,
	     because although it would always work it would force us to
	     read in the relocs into BFD canonical form, which would waste
	     a significant amount of time and memory.  */
	  if (datasec != NULL && datasec->reloc_count > 0)
	    {
	      asection *relsec;

	      relsec = bfd_make_section_with_flags (abfd, ".emreloc",
						    (SEC_ALLOC
						    | SEC_LOAD
						    | SEC_HAS_CONTENTS
						    | SEC_IN_MEMORY));
	      if (relsec == NULL
		  || !bfd_set_section_alignment (relsec, 2)
		  || !bfd_set_section_size (relsec, datasec->reloc_count * 12))
		einfo (_("%F%P: %pB: can not create .emreloc section: %E\n"));
	    }

	  /* Double check that all other data sections are empty, as is
	     required for embedded PIC code.  */
	  bfd_map_over_sections (abfd, check_sections, datasec);
	}
    }
#endif /* SUPPORT_EMBEDDED_RELOCS */
}

#ifdef SUPPORT_EMBEDDED_RELOCS
/* Check that of the data sections, only the .data section has
   relocs.  This is called via bfd_map_over_sections.  */

static void
check_sections (bfd *abfd, asection *sec, void *datasec)
{
  if ((bfd_section_flags (sec) & SEC_DATA)
      && sec != datasec
      && sec->reloc_count != 0)
    einfo (_("%X%P: %pB: section %s has relocs; can not use --embedded-relocs\n"),
	   abfd, bfd_section_name (sec));
}

#endif /* SUPPORT_EMBEDDED_RELOCS */

/* This function is called after the section sizes and offsets have
   been set.  */

static void
m68k_elf_after_allocation (void)
{
  /* Call the standard elf routine.  */
  gldm68kelfnbsd_after_allocation ();

#ifdef SUPPORT_EMBEDDED_RELOCS
  if (command_line.embedded_relocs
      && (!bfd_link_relocatable (&link_info)))
    {
      bfd *abfd;

      /* If we are generating embedded relocs, call a special BFD backend
	 routine to do the work.  */
      for (abfd = link_info.input_bfds; abfd != NULL; abfd = abfd->link.next)
	{
	  asection *datasec, *relsec;
	  char *errmsg;

	  datasec = bfd_get_section_by_name (abfd, ".data");

	  if (datasec == NULL || datasec->reloc_count == 0)
	    continue;

	  relsec = bfd_get_section_by_name (abfd, ".emreloc");
	  ASSERT (relsec != NULL);

	  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	    {
	      if (! bfd_m68k_elf32_create_embedded_relocs (abfd, &link_info,
							   datasec, relsec,
							   &errmsg))
		{
		  if (errmsg == NULL)
		    einfo (_("%X%P: %pB: can not create "
			     "runtime reloc information: %E\n"),
			   abfd);
		  else
		    einfo (_("%X%P: %pB: can not create "
			     "runtime reloc information: %s\n"),
			   abfd, errmsg);
		}
	    }
	  else
	    abort ();
	}
    }
#endif /* SUPPORT_EMBEDDED_RELOCS */
}

/* This is a convenient point to tell BFD about target specific flags.
   After the output has been created, but before inputs are read.  */

static void
elf_m68k_create_output_section_statements (void)
{
  bfd_elf_m68k_set_target_options (&link_info, got_handling);
}


static void
gldm68kelfnbsd_before_parse (void)
{
  ldfile_set_output_arch ("m68k", bfd_arch_m68k);
  input_flags.dynamic = true;
  config.has_shared = true;
  config.separate_code = false;
  link_info.check_relocs_after_open_input = true;
  link_info.relro = DEFAULT_LD_Z_RELRO;
  link_info.separate_code = DEFAULT_LD_Z_SEPARATE_CODE;
  link_info.warn_execstack = DEFAULT_LD_WARN_EXECSTACK;
  link_info.no_warn_rwx_segments = ! DEFAULT_LD_WARN_RWX_SEGMENTS;
  link_info.default_execstack = DEFAULT_LD_EXECSTACK;
}


/* These variables are used to implement target options */

static char *audit; /* colon (typically) separated list of libs */
static char *depaudit; /* colon (typically) separated list of libs */


/* This is called before calling plugin 'all symbols read' hook.  */

static void
gldm68kelfnbsd_before_plugin_all_symbols_read (void)
{
  ldelf_before_plugin_all_symbols_read (true, false,
				        false,
					false,
					32, "/Users/sidqian/Downloads/summer/L2S/netbsd-src/build/obj/tooldir.Darwin-22.1.0-x86_64");
}

/* This is called after all the input files have been opened.  */

static void
gldm68kelfnbsd_after_open (void)
{
  ldelf_after_open (true, false,
		    false, false, 32, "/Users/sidqian/Downloads/summer/L2S/netbsd-src/build/obj/tooldir.Darwin-22.1.0-x86_64");
}


/* This is called after the sections have been attached to output
   sections, but before any sizes or addresses have been set.  */

static void
gldm68kelfnbsd_before_allocation (void)
{
  ldelf_before_allocation (audit, depaudit, NULL);
}


static void
gldm68kelfnbsd_after_allocation (void)
{
  int need_layout = bfd_elf_discard_info (link_info.output_bfd, &link_info);

  if (need_layout < 0)
    einfo (_("%X%P: .eh_frame/.stab edit: %E\n"));
  else
    ldelf_map_segments (need_layout);
}

static char *
gldm68kelfnbsd_get_script (int *isfile)
{
  *isfile = 0;

  if (bfd_link_relocatable (&link_info) && config.build_constructors)
    return
"/* Script for -Ur */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
 /* For some reason, the Solaris linker makes bad executables\n\
  if gld -r is used and the intermediate file has sections starting\n\
  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld\n\
  bug.  But for now assigning the zero vmas works.  */\n\
SECTIONS\n\
{\n\
  .interp       0 : { *(.interp) }\n\
  .note.gnu.build-id 0: { *(.note.gnu.build-id) }\n\
  .hash         0 : { *(.hash) }\n\
  .gnu.hash     0 : { *(.gnu.hash) }\n\
  .dynsym       0 : { *(.dynsym) }\n\
  .dynstr       0 : { *(.dynstr) }\n\
  .gnu.version  0 : { *(.gnu.version) }\n\
  .gnu.version_d 0: { *(.gnu.version_d) }\n\
  .gnu.version_r 0: { *(.gnu.version_r) }\n\
  .rela.init    0 : { *(.rela.init) }\n\
  .rela.text    0 : { *(.rela.text) }\n"
"  .rela.fini    0 : { *(.rela.fini) }\n\
  .rela.rodata  0 : { *(.rela.rodata) }\n\
  .rela.data.rel.ro 0 : { *(.rela.data.rel.ro) }\n\
  .rela.data    0 : { *(.rela.data) }\n\
  .rela.tdata	0 : { *(.rela.tdata) }\n\
  .rela.tbss	0 : { *(.rela.tbss) }\n\
  .rela.ctors   0 : { *(.rela.ctors) }\n\
  .rela.dtors   0 : { *(.rela.dtors) }\n\
  .rela.got     0 : { *(.rela.got) }\n\
  .rela.bss     0 : { *(.rela.bss) }\n\
  .rela.iplt    0 :\n\
    {\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt     0 :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init         0 :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt          0 : { *(.plt) }\n\
  .iplt         0 : { *(.iplt) }\n\
  .text         0 :\n"
"  {\n\
    *(.text)\n\
    *(.text .stub)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini         0 :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  .rodata       0 : { *(.rodata) }\n\
  .rodata1      0 : { *(.rodata1) }\n\
  .eh_frame_hdr 0 : { *(.eh_frame_hdr) }\n\
  .eh_frame     0 : ONLY_IF_RO { KEEP (*(.eh_frame)) }\n\
  .gcc_except_table 0 : ONLY_IF_RO { *(.gcc_except_table) }\n\
  .gnu_extab 0 : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges 0 : ONLY_IF_RO { *(.exception_ranges) }\n\
  /* Exception handling  */\n\
  .eh_frame     0 : ONLY_IF_RW { KEEP (*(.eh_frame)) }\n\
  .gnu_extab    0 : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table 0 : ONLY_IF_RW { *(.gcc_except_table) }\n\
  .exception_ranges 0 : ONLY_IF_RW { *(.exception_ranges) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	0 :\n"
"   {\n\
     *(.tdata)\n\
   }\n\
  .tbss		0 : { *(.tbss) }\n\
  .jcr          0 : { KEEP (*(.jcr)) }\n\
  .dynamic      0 : { *(.dynamic) }\n\
  .got          0 : { *(.got) }\n\
  .data         0 :\n\
  {\n\
    *(.data)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1        0 : { *(.data1) }\n\
  .bss          0 :\n\
  {\n\
   *(.bss)\n\
  }\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n"
"  .gnu.build.attributes : { *(.gnu.build.attributes) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
}\n\n"
  ; else if (bfd_link_relocatable (&link_info)) return
"/* Script for -r */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
 /* For some reason, the Solaris linker makes bad executables\n\
  if gld -r is used and the intermediate file has sections starting\n\
  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld\n\
  bug.  But for now assigning the zero vmas works.  */\n\
SECTIONS\n\
{\n\
  .interp       0 : { *(.interp) }\n\
  .note.gnu.build-id 0: { *(.note.gnu.build-id) }\n\
  .hash         0 : { *(.hash) }\n\
  .gnu.hash     0 : { *(.gnu.hash) }\n\
  .dynsym       0 : { *(.dynsym) }\n\
  .dynstr       0 : { *(.dynstr) }\n\
  .gnu.version  0 : { *(.gnu.version) }\n\
  .gnu.version_d 0: { *(.gnu.version_d) }\n\
  .gnu.version_r 0: { *(.gnu.version_r) }\n\
  .rela.init    0 : { *(.rela.init) }\n\
  .rela.text    0 : { *(.rela.text) }\n"
"  .rela.fini    0 : { *(.rela.fini) }\n\
  .rela.rodata  0 : { *(.rela.rodata) }\n\
  .rela.data.rel.ro 0 : { *(.rela.data.rel.ro) }\n\
  .rela.data    0 : { *(.rela.data) }\n\
  .rela.tdata	0 : { *(.rela.tdata) }\n\
  .rela.tbss	0 : { *(.rela.tbss) }\n\
  .rela.ctors   0 : { *(.rela.ctors) }\n\
  .rela.dtors   0 : { *(.rela.dtors) }\n\
  .rela.got     0 : { *(.rela.got) }\n\
  .rela.bss     0 : { *(.rela.bss) }\n\
  .rela.iplt    0 :\n\
    {\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt     0 :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init         0 :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt          0 : { *(.plt) }\n\
  .iplt         0 : { *(.iplt) }\n\
  .text         0 :\n"
"  {\n\
    *(.text)\n\
    *(.text .stub)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini         0 :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  .rodata       0 : { *(.rodata) }\n\
  .rodata1      0 : { *(.rodata1) }\n\
  .eh_frame_hdr 0 : { *(.eh_frame_hdr) }\n\
  .eh_frame     0 : ONLY_IF_RO { KEEP (*(.eh_frame)) }\n\
  .gcc_except_table 0 : ONLY_IF_RO { *(.gcc_except_table) }\n\
  .gnu_extab 0 : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges 0 : ONLY_IF_RO { *(.exception_ranges) }\n\
  /* Exception handling  */\n\
  .eh_frame     0 : ONLY_IF_RW { KEEP (*(.eh_frame)) }\n\
  .gnu_extab    0 : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table 0 : ONLY_IF_RW { *(.gcc_except_table) }\n\
  .exception_ranges 0 : ONLY_IF_RW { *(.exception_ranges) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	0 :\n"
"   {\n\
     *(.tdata)\n\
   }\n\
  .tbss		0 : { *(.tbss) }\n\
  .jcr          0 : { KEEP (*(.jcr)) }\n\
  .dynamic      0 : { *(.dynamic) }\n\
  .got          0 : { *(.got) }\n\
  .data         0 :\n\
  {\n\
    *(.data)\n\
  }\n\
  .data1        0 : { *(.data1) }\n\
  .bss          0 :\n\
  {\n\
   *(.bss)\n\
  }\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes) }\n"
"  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
}\n\n"
  ; else if (!config.text_read_only) return
"/* Script for -N */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x2000)); . = SEGMENT_START(\"text-segment\", 0x2000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n"
"  .rela.fini      : { *(.rela.fini) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rela.iplt      :\n\
    {\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n"
"  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n"
"  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = .;\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n"
"  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (!config.magic_demand_paged) return
"/* Script for -n */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x2000)); . = SEGMENT_START(\"text-segment\", 0x2000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n"
"  .rela.fini      : { *(.rela.fini) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rela.iplt      :\n\
    {\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n"
"  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n"
"  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n"
"  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_pie (&link_info)
             && link_info.combreloc
             && link_info.separate_code
             && (link_info.flags & DF_BIND_NOW)) return
"/* Script for -pie -z combreloc -z separate-code -z relro -z now */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n"
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n"
"    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n"
"  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n"
"  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_pie (&link_info)
             && link_info.combreloc
             && link_info.relro
             && (link_info.flags & DF_BIND_NOW)) return
"/* Script for -pie -z combreloc -z relro -z now */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.dyn       :\n\
    {\n"
"      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n"
"    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n"
"  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n"
"    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_pie (&link_info)
             && link_info.separate_code
             && link_info.combreloc) return
"/* Script for -pie -z combreloc -z separate-code */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n"
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n"
"    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n"
"  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n"
"  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_pie (&link_info)
             && link_info.combreloc) return
"/* Script for -pie -z combreloc */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.dyn       :\n\
    {\n"
"      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n"
"    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n"
"  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n"
"    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_pie (&link_info)
             && link_info.separate_code) return
"/* Script for -pie -z separate-code */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rela.fini      : { *(.rela.fini) }\n"
"  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rela.iplt      :\n\
    {\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  .text           :\n"
"  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n"
"  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n"
"    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_pie (&link_info)) return
"/* Script for -pie */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n"
"  .rela.fini      : { *(.rela.fini) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rela.iplt      :\n\
    {\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  .text           :\n"
"  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n"
"  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n"
"    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_dll (&link_info)
             && link_info.combreloc
             && link_info.separate_code
             && (link_info.flags & DF_BIND_NOW)) return
"/* Script for -shared -z combreloc -z separate-code -z relro -z now */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n"
"      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n"
"    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n"
"  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n"
"    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
  }\n\
  .fini_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  PROVIDE (_edata = .); PROVIDE (edata = .);\n\
  . = .;\n\
  PROVIDE (__bss_start = .);\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  PROVIDE (_end = .); PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_dll (&link_info)
             && link_info.combreloc
             && link_info.relro
             && (link_info.flags & DF_BIND_NOW)) return
"/* Script for -shared -z combreloc -z relro -z now */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n"
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n"
"    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n"
"  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
  }\n\
  .fini_array    :\n\
  {\n"
"    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  PROVIDE (_edata = .); PROVIDE (edata = .);\n\
  . = .;\n\
  PROVIDE (__bss_start = .);\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  PROVIDE (_end = .); PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_dll (&link_info)
             && link_info.combreloc
             && link_info.separate_code) return
"/* Script for -shared -z combreloc -z separate-code */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n"
"      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n"
"    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n"
"  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n"
"    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
  }\n\
  .fini_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  PROVIDE (_edata = .); PROVIDE (edata = .);\n\
  . = .;\n\
  PROVIDE (__bss_start = .);\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  PROVIDE (_end = .); PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_dll (&link_info)
             && link_info.combreloc) return
"/* Script for -shared -z combreloc */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n"
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n"
"    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n"
"  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
  }\n\
  .fini_array    :\n\
  {\n"
"    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  PROVIDE (_edata = .); PROVIDE (edata = .);\n\
  . = .;\n\
  PROVIDE (__bss_start = .);\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  PROVIDE (_end = .); PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_dll (&link_info)
             && link_info.separate_code) return
"/* Script for -shared -z separate-code */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rela.fini      : { *(.rela.fini) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n"
"  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rela.iplt      :\n\
    {\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n"
"    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n"
"  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array    :\n\
  {\n"
"    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
  }\n\
  .fini_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  PROVIDE (_edata = .); PROVIDE (edata = .);\n\
  . = .;\n\
  PROVIDE (__bss_start = .);\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  PROVIDE (_end = .); PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_dll (&link_info)) return
"/* Script for -shared */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rela.fini      : { *(.rela.fini) }\n"
"  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rela.iplt      :\n\
    {\n\
      *(.rela.iplt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n"
"    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n"
"  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
  }\n\
  .fini_array    :\n"
"  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  PROVIDE (_edata = .); PROVIDE (edata = .);\n\
  . = .;\n\
  PROVIDE (__bss_start = .);\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  PROVIDE (_end = .); PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (link_info.combreloc
             && link_info.separate_code
             && (link_info.flags & DF_BIND_NOW)) return
"/* Script for -z combreloc -z separate-code -z relro -z now */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x2000)); . = SEGMENT_START(\"text-segment\", 0x2000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n"
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n"
"  .text           :\n\
  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n"
"  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n"
"    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (link_info.combreloc
             && link_info.relro
             && (link_info.flags & DF_BIND_NOW)) return
"/* Script for -z combreloc -z relro -z now */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x2000)); . = SEGMENT_START(\"text-segment\", 0x2000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.dyn       :\n\
    {\n"
"      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n"
"  .text           :\n\
  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n"
"  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n"
"  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (link_info.combreloc
             && link_info.separate_code) return
"/* Script for -z combreloc -z separate-code */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x2000)); . = SEGMENT_START(\"text-segment\", 0x2000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n"
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n"
"  .text           :\n\
  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n"
"  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n"
"    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (link_info.combreloc) return
"/* Script for -z combreloc */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x2000)); . = SEGMENT_START(\"text-segment\", 0x2000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.dyn       :\n\
    {\n"
"      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n"
"  .text           :\n\
  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n"
"  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n"
"  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (link_info.separate_code) return
"/* Script for -z separate-code */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x2000)); . = SEGMENT_START(\"text-segment\", 0x2000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rela.fini      : { *(.rela.fini) }\n"
"  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rela.iplt      :\n\
    {\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n"
"  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n"
"  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n"
"    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else return
"/* Default linker script, for normal executables */\n\
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-m68k\", \"elf32-m68k\",\n\
	      \"elf32-m68k\")\n\
OUTPUT_ARCH(m68k)\n\
ENTRY(_start)\n\
SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x2000)); . = SEGMENT_START(\"text-segment\", 0x2000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n"
"  .rela.fini      : { *(.rela.fini) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rela.iplt      :\n\
    {\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  } =0x4e714e71\n\
  .plt            : { *(.plt) }\n"
"  .iplt           : { *(.iplt) }\n\
  .text           :\n\
  {\n\
    PROVIDE_HIDDEN (__eprol = .);\n\
    *(.text)\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  } =0x4e714e71\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  } =0x4e714e71\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n"
"  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n"
"  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .dynamic        : { *(.dynamic) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got            : { *(.got.plt) *(.igot.plt) *(.got) *(.igot) }\n\
  .data           :\n\
  {\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
; }
 
#define OPTION_GOT	301


enum elf_options
{
  OPTION_DISABLE_NEW_DTAGS = 400,
  OPTION_ENABLE_NEW_DTAGS,
  OPTION_GROUP,
  OPTION_EH_FRAME_HDR,
  OPTION_NO_EH_FRAME_HDR,
  OPTION_EXCLUDE_LIBS,
  OPTION_HASH_STYLE,
  OPTION_BUILD_ID,
  OPTION_PACKAGE_METADATA,
  OPTION_AUDIT,
  OPTION_COMPRESS_DEBUG
};

static void
gldm68kelfnbsd_add_options
  (int ns, char **shortopts, int nl, struct option **longopts,
   int nrl ATTRIBUTE_UNUSED, struct option **really_longopts ATTRIBUTE_UNUSED)
{
  static const char xtra_short[] = "z:P:";
  static const struct option xtra_long[] = {
    {"audit", required_argument, NULL, OPTION_AUDIT},
    {"Bgroup", no_argument, NULL, OPTION_GROUP},
    {"build-id", optional_argument, NULL, OPTION_BUILD_ID},
    {"package-metadata", optional_argument, NULL, OPTION_PACKAGE_METADATA},
    {"compress-debug-sections", required_argument, NULL, OPTION_COMPRESS_DEBUG},
    {"depaudit", required_argument, NULL, 'P'},
    {"disable-new-dtags", no_argument, NULL, OPTION_DISABLE_NEW_DTAGS},
    {"enable-new-dtags", no_argument, NULL, OPTION_ENABLE_NEW_DTAGS},
    {"eh-frame-hdr", no_argument, NULL, OPTION_EH_FRAME_HDR},
    {"no-eh-frame-hdr", no_argument, NULL, OPTION_NO_EH_FRAME_HDR},
    {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},
    {"hash-style", required_argument, NULL, OPTION_HASH_STYLE},
    
  { "got", required_argument, NULL, OPTION_GOT},

    {NULL, no_argument, NULL, 0}
  };

  *shortopts = (char *) xrealloc (*shortopts, ns + sizeof (xtra_short));
  memcpy (*shortopts + ns, &xtra_short, sizeof (xtra_short));
  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}

#define DEFAULT_BUILD_ID_STYLE	"sha1"

static bool
gldm68kelfnbsd_handle_option (int optc)
{
  switch (optc)
    {
    default:
      return false;

    case OPTION_BUILD_ID:
      free ((char *) ldelf_emit_note_gnu_build_id);
      ldelf_emit_note_gnu_build_id = NULL;
      if (optarg == NULL)
	optarg = DEFAULT_BUILD_ID_STYLE;
      if (strcmp (optarg, "none"))
	ldelf_emit_note_gnu_build_id = xstrdup (optarg);
      break;

    case OPTION_PACKAGE_METADATA:
      free ((char *) ldelf_emit_note_fdo_package_metadata);
      ldelf_emit_note_fdo_package_metadata = NULL;
      if (optarg != NULL && strlen(optarg) > 0)
	ldelf_emit_note_fdo_package_metadata = xstrdup (optarg);
      break;

    case OPTION_COMPRESS_DEBUG:
      if (strcasecmp (optarg, "none") == 0)
	link_info.compress_debug = COMPRESS_DEBUG_NONE;
      else if (strcasecmp (optarg, "zlib") == 0)
	link_info.compress_debug = COMPRESS_DEBUG_GABI_ZLIB;
      else if (strcasecmp (optarg, "zlib-gnu") == 0)
	link_info.compress_debug = COMPRESS_DEBUG_GNU_ZLIB;
      else if (strcasecmp (optarg, "zlib-gabi") == 0)
	link_info.compress_debug = COMPRESS_DEBUG_GABI_ZLIB;
      else
	einfo (_("%F%P: invalid --compress-debug-sections option: `%s'\n"),
	       optarg);
      break;
    case OPTION_AUDIT:
	ldelf_append_to_separated_string (&audit, optarg);
	break;

    case 'P':
	ldelf_append_to_separated_string (&depaudit, optarg);
	break;

    case OPTION_DISABLE_NEW_DTAGS:
      link_info.new_dtags = false;
      break;

    case OPTION_ENABLE_NEW_DTAGS:
      link_info.new_dtags = true;
      break;

    case OPTION_EH_FRAME_HDR:
      link_info.eh_frame_hdr_type = DWARF2_EH_HDR;
      break;

    case OPTION_NO_EH_FRAME_HDR:
      link_info.eh_frame_hdr_type = 0;
      break;

    case OPTION_GROUP:
      link_info.flags_1 |= (bfd_vma) DF_1_GROUP;
      /* Groups must be self-contained.  */
      link_info.unresolved_syms_in_objects = RM_DIAGNOSE;
      link_info.unresolved_syms_in_shared_libs = RM_DIAGNOSE;
      break;

    case OPTION_EXCLUDE_LIBS:
      add_excluded_libs (optarg);
      break;

    case OPTION_HASH_STYLE:
      link_info.emit_hash = false;
      link_info.emit_gnu_hash = false;
      if (strcmp (optarg, "sysv") == 0)
	link_info.emit_hash = true;
      else if (strcmp (optarg, "gnu") == 0)
	link_info.emit_gnu_hash = true;
      else if (strcmp (optarg, "both") == 0)
	{
	  link_info.emit_hash = true;
	  link_info.emit_gnu_hash = true;
	}
      else
	einfo (_("%F%P: invalid hash style `%s'\n"), optarg);
      break;

    case 'z':
      if (strcmp (optarg, "defs") == 0)
	link_info.unresolved_syms_in_objects = RM_DIAGNOSE;
      else if (strcmp (optarg, "undefs") == 0)
	link_info.unresolved_syms_in_objects = RM_IGNORE;
      else if (strcmp (optarg, "muldefs") == 0)
	link_info.allow_multiple_definition = true;
      else if (startswith (optarg, "max-page-size="))
	{
	  char *end;

	  link_info.maxpagesize = strtoul (optarg + 14, &end, 0);
	  if (*end
	      || (link_info.maxpagesize & (link_info.maxpagesize - 1)) != 0)
	    einfo (_("%F%P: invalid maximum page size `%s'\n"),
		   optarg + 14);
	  link_info.maxpagesize_is_set = true;
	}
      else if (startswith (optarg, "common-page-size="))
	{
	  char *end;
	  link_info.commonpagesize = strtoul (optarg + 17, &end, 0);
	  if (*end
	      || (link_info.commonpagesize & (link_info.commonpagesize - 1)) != 0)
	    einfo (_("%F%P: invalid common page size `%s'\n"),
		   optarg + 17);
	  link_info.commonpagesize_is_set = true;
	}
      else if (startswith (optarg, "stack-size="))
	{
	  char *end;
	  link_info.stacksize = strtoul (optarg + 11, &end, 0);
	  if (*end || link_info.stacksize < 0)
	    einfo (_("%F%P: invalid stack size `%s'\n"), optarg + 11);
	  if (!link_info.stacksize)
	    /* Use -1 for explicit no-stack, because zero means
	       'default'.   */
	    link_info.stacksize = -1;
	}
      else if (strcmp (optarg, "execstack") == 0)
	{
	  link_info.execstack = true;
	  link_info.noexecstack = false;
	}
      else if (strcmp (optarg, "noexecstack") == 0)
	{
	  link_info.noexecstack = true;
	  link_info.execstack = false;
	}
      else if (strcmp (optarg, "unique-symbol") == 0)
	link_info.unique_symbol = true;
      else if (strcmp (optarg, "nounique-symbol") == 0)
	link_info.unique_symbol = false;
      else if (strcmp (optarg, "globalaudit") == 0)
	{
	  link_info.flags_1 |= DF_1_GLOBAUDIT;
	}
      else if (startswith (optarg, "start-stop-gc"))
	link_info.start_stop_gc = true;
      else if (startswith (optarg, "nostart-stop-gc"))
	link_info.start_stop_gc = false;
      else if (startswith (optarg, "start-stop-visibility="))
	{
	  if (strcmp (optarg, "start-stop-visibility=default") == 0)
	    link_info.start_stop_visibility = STV_DEFAULT;
	  else if (strcmp (optarg, "start-stop-visibility=internal") == 0)
	    link_info.start_stop_visibility = STV_INTERNAL;
	  else if (strcmp (optarg, "start-stop-visibility=hidden") == 0)
	    link_info.start_stop_visibility = STV_HIDDEN;
	  else if (strcmp (optarg, "start-stop-visibility=protected") == 0)
	    link_info.start_stop_visibility = STV_PROTECTED;
	  else
	    einfo (_("%F%P: invalid visibility in `-z %s'; "
		     "must be default, internal, hidden, or protected"),
		   optarg);
	}
      else if (strcmp (optarg, "global") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_GLOBAL;
      else if (strcmp (optarg, "initfirst") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_INITFIRST;
      else if (strcmp (optarg, "interpose") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_INTERPOSE;
      else if (strcmp (optarg, "loadfltr") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_LOADFLTR;
      else if (strcmp (optarg, "nodefaultlib") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODEFLIB;
      else if (strcmp (optarg, "nodelete") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODELETE;
      else if (strcmp (optarg, "nodlopen") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NOOPEN;
      else if (strcmp (optarg, "nodump") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODUMP;
      else if (strcmp (optarg, "now") == 0)
	{
	  link_info.flags |= (bfd_vma) DF_BIND_NOW;
	  link_info.flags_1 |= (bfd_vma) DF_1_NOW;
	}
      else if (strcmp (optarg, "lazy") == 0)
	{
	  link_info.flags &= ~(bfd_vma) DF_BIND_NOW;
	  link_info.flags_1 &= ~(bfd_vma) DF_1_NOW;
	}
      else if (strcmp (optarg, "origin") == 0)
	{
	  link_info.flags |= (bfd_vma) DF_ORIGIN;
	  link_info.flags_1 |= (bfd_vma) DF_1_ORIGIN;
	}
      else if (strcmp (optarg, "unique") == 0)
	link_info.gnu_flags_1 |= (bfd_vma) DF_GNU_1_UNIQUE;
      else if (strcmp (optarg, "nounique") == 0)
	link_info.gnu_flags_1 &= ~(bfd_vma) DF_GNU_1_UNIQUE;
      else if (strcmp (optarg, "combreloc") == 0)
	link_info.combreloc = true;
      else if (strcmp (optarg, "nocombreloc") == 0)
	link_info.combreloc = false;
      else if (strcmp (optarg, "nocopyreloc") == 0)
	link_info.nocopyreloc = true;
      else if (strcmp (optarg, "relro") == 0)
	link_info.relro = true;
      else if (strcmp (optarg, "norelro") == 0)
	link_info.relro = false;
      else if (strcmp (optarg, "separate-code") == 0)
	link_info.separate_code = true;
      else if (strcmp (optarg, "noseparate-code") == 0)
	link_info.separate_code = false;
      else if (strcmp (optarg, "common") == 0)
	link_info.elf_stt_common = elf_stt_common;
      else if (strcmp (optarg, "nocommon") == 0)
	link_info.elf_stt_common = no_elf_stt_common;
      else if (strcmp (optarg, "text") == 0)
	link_info.textrel_check = textrel_check_error;
      else if (strcmp (optarg, "notext") == 0)
	link_info.textrel_check = textrel_check_none;
      else if (strcmp (optarg, "textoff") == 0)
	link_info.textrel_check = textrel_check_none;
      else
	einfo (_("%P: warning: -z %s ignored\n"), optarg);
      break;
 
    case OPTION_GOT:
      if (strcmp (optarg, "target") == 0)
	got_handling = GOT_HANDLING_TARGET_DEFAULT;
      else if (strcmp (optarg, "single") == 0)
	got_handling = 0;
      else if (strcmp (optarg, "negative") == 0)
	got_handling = 1;
      else if (strcmp (optarg, "multigot") == 0)
	got_handling = 2;
      else
	einfo (_("%P: unrecognized --got argument '%s'\n"), optarg);
      break;

    }

  return true;
}


static void
gldm68kelfnbsd_list_options (FILE * file)
{
 
  fprintf (file, _("  --got=<type>                Specify GOT handling scheme\n"));

}

struct ld_emulation_xfer_struct ld_m68kelfnbsd_emulation =
{
  gldm68kelfnbsd_before_parse,
  syslib_default,
  hll_default,
  ldelf_after_parse,
  gldm68kelfnbsd_before_plugin_all_symbols_read,
  m68k_elf_after_open,
  after_check_relocs_default,
  ldelf_before_place_orphans,
  m68k_elf_after_allocation,
  ldelf_set_output_arch,
  ldemul_default_target,
  gldm68kelfnbsd_before_allocation,
  gldm68kelfnbsd_get_script,
  "m68kelfnbsd",
  "elf32-m68k",
  finish_default,
  elf_m68k_create_output_section_statements,
  ldelf_open_dynamic_archive,
  ldelf_place_orphan,
  NULL,
  NULL,
  gldm68kelfnbsd_add_options,
  gldm68kelfnbsd_handle_option,
  NULL,
  gldm68kelfnbsd_list_options,
  ldelf_load_symbols,
  NULL,
  NULL,
  NULL,
  ldelf_emit_ctf_early,
  ldelf_acquire_strings_for_ctf,
  ldelf_new_dynsym_for_ctf,
  NULL
};
