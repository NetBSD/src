.\" om.tmac
.ig
Mom -- a typesetting/document-processing macro set for groff.

Copyright (C) 2002, 2003 Free Software Foundation, Inc.
     Written by Peter Schaffter (peter@faustus.dyn.ca)

This file is part of groff.

groff is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

groff is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with groff; see the file COPYING.  If not, write to the Free Software
Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

Version 1.3-a
-------------
Antoine de St-Exupéry asserted that elegance in engineering is
achieved not when there is nothing left to add, but when there is
nothing left to take away.

By those standards, mom is a Rube Goldberg contraption.  She was
created over the years while groff, and my understanding of it,
changed and evolved.  However, I'm a firm believer in "if it
ain't broke, don't fix it," so I'm leaving any major clean-up
of redundancies and whatnot for a rainy day.

Inasmuch as possible, macros that turn a feature on or off follow
a similar style.  Invoking the macro without an argument turns
the feature on.  Invoking it with any other argument turns it off.
Use of the argument OFF is recommended, but not required; users
may find other conventions preferable (e.g. NO, X, END, QUIT, etc.).

"<anything>" in the description of arguments that can be passed
to a macro means that any argument turns the feature off.
..
\#
\# ====================================================================
\#
\# Check which version of groff is being run
.if (\n[.x]\n[.y] < 118) \
.  ab You need GNU troff version 1.18 or higher to run this version of mom.
\# Check that GNU troff is being run
.if !\n[.g]=1 \
.  ab The mom macros require that you be running GNU troff.
.if \n(.C \
.   ab The groff mom macros do not work in compatibility mode.
\# Add supplementary styles
.sty \n[.fp] L       \"  Light Roman
.sty \n[.fp] LI      \"  Light Italic
.sty \n[.fp] LCD     \"  Light Condensed Roman
.sty \n[.fp] LCDI    \"  Light Condensed Italic
.sty \n[.fp] LEX     \"  Light Extended Roman
.sty \n[.fp] LEXI    \"  Light Extended Italic
.sty \n[.fp] CD      \"  Medium/Book Condensed Roman
.sty \n[.fp] CDI     \"  Medium/Book Condensed Italic
.sty \n[.fp] EX      \"  Medium/Book Extended Roman
.sty \n[.fp] EXI     \"  Medium/Book Extended Italic
.sty \n[.fp] DB      \"  DemiBold Roman
.sty \n[.fp] DBI     \"  DemiBold Italic
.sty \n[.fp] BCD     \"  Bold Condensed Roman
.sty \n[.fp] BCDI    \"  Bold Condensed Italic
.sty \n[.fp] BEX     \"  Bold Extended Roman
.sty \n[.fp] BEXI    \"  Bold Extended Italic
.sty \n[.fp] HV      \"  Heavy Roman
.sty \n[.fp] HVI     \"  Heavy Italic
.sty \n[.fp] HVCD    \"  Heavy Condensed Roman
.sty \n[.fp] HVCDI   \"  Heavy Condensed Italic
.sty \n[.fp] HVEX    \"  Heavy Extended Roman
.sty \n[.fp] HVEXI   \"  Heavy Extended Italic
.sty \n[.fp] BL      \"  Black Roman
.sty \n[.fp] BLI     \"  Black Italic
.sty \n[.fp] BLCD    \"  Black Condensed Roman
.sty \n[.fp] BLCDI   \"  Black Condensed Italic
.sty \n[.fp] BLEX    \"  Black Extended Roman
.sty \n[.fp] BLEXI   \"  Black Extended Italic
.sty \n[.fp] UBL     \"  Ultra-Black Roman
.sty \n[.fp] UBLI    \"  Ultra-Black Italic
\#
\# ====================================================================
\#
\# TYPESETTING MACROS, STRINGS, AND ALIASES
\# ========================================
\#
\# +++ALIASES+++
\#
\# Alias .als as ALIAS, and .aln (number registers) as ALIASN
\#
.als      ALIAS           als
.als      ALIASN          aln
\#
\#
\# ALIASES FOR GROFF REQUESTS
\# --------------------------
\#
.ALIAS    MAC             de
.ALIAS    BR              br
.ALIAS    SP              sp
.ALIAS    PAGELENGTH      pl
.ALIAS    SPREAD          brp
.ALIAS    ESC_CHAR        ec
.ALIAS    STRING          ds
\#
\# ALIASES FOR NUMBER REGISTERS
\# ----------------------------
\#
.ALIASN  #PT_SIZE        .ps    \"fractional point size in units
.ALIASN  #DIVER_DEPTH     dn    \"diversion depth
.ALIASN  #DIVER_WIDTH     dl    \"diversion width
.ALIASN  #TRAP_DISTANCE  .t     \"distance to next trap
.ALIASN  #LEAD           .v     \"line space (.vs, not .ls)
.ALIASN  #PAGE_LENGTH    .p     \"page length
.ALIASN  #NUM_ARGS       .$     \"number of arguments passed to a macro
.ALIASN  #INDENT         .i     \"value of current indent
\#
\# ====================================================================
\#
\# MISCELLANEOUS
\# =============
.nr #L_MARGIN \n(.o  \" Tabs, etc require #L_MARGIN
.cflags 4 /\(en      \" So slash and en-dashes get broken
.warn 8192
\#
.ig
About the warn level
--------------------

There's a lot of testing for the presence of number registers and
strings in this macro file.  Many of the registers and strings
pop into and out of existence on the fly.  For convenience, I
often use

    .if \\n[whatever]    and    .if !\\n[whatever]

to test "if the register exists and is (not) empty."  Groff,
encountering such tests when called with the -ww options, emits

    warning: number register whatever not defined.

Groff also warns about strings similarly tested for.

The warn level, above, is high in order to shut off those
warnings.  If you're futzing in this file and need more verbose
warnings, either comment out ".warn 8192" or set the warnlevel
to the one you need (but be ready for lots of what I've just
described).
..
\#
\# ====================================================================
\#
\# +++PAGE LAYOUT+++
\#
\# Macros that control the physical layout of the page: paper size
\# and margins.
\#
\# PAGE WIDTH
\# ----------
\# *Argument:
\#   <width of printer sheet>
\# *Function:
\#   Stores user supplied page width in register #PAGE_WIDTH.
\# *Notes:
\#   #PAGE_WIDTH is used to establish the default LL (and right margin).
\#   Requires unit of measure.
\#
.MAC PAGEWIDTH END
.    br
.    nr #PAGE_WIDTH \\$1
.    if !r#L_MARGIN \{ .L_MARGIN \\n(.o \}
.    if !r#R_MARGIN \{ .R_MARGIN 1i \}
.END
\#
\#
\# L_MARGIN
\# --------
\# *Argument:
\#   <offset from page left>
\# *Function:
\#   Stores user supplied page offset in register #L_MARGIN.
\#   Sets .po to user supplied offset.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC L_MARGIN END
.    br
.    nr #L_MARGIN (\\$1)
.    po \\n[#L_MARGIN]u
.END
\#
\#
\# R_MARGIN
\# --------
\# *Argument:
\#   <width of right margin>
\# *Function:
\#   Stores user supplied right margin in register #R_MARGIN.
\# *Notes:
\#   This is a pseudo-margin.  Right margin is actually a function of
\#   line length.  The macro calculates line length from the page offset
\#   and the value plugged into #R_MARGIN.
\#
\#   N.B. -- PAGEWIDTH and L_MARGIN have to be defined before R_MARGIN.
\#
\#   Requires unit of measure.
\#
.MAC R_MARGIN END
.    br
.    nr #R_MARGIN (\\$1)
.    ll \\n[#PAGE_WIDTH]u-\\n[#L_MARGIN]u-\\n[#R_MARGIN]u
.    ta \\n(.lu
.    nr #L_LENGTH \\n(.l
.END
\#
\#
\# T_MARGIN
\# --------
\# *Argument:
\#   <distance to advance from top of page>
\# *Function:
\#   Stores the user supplied top margin in register #T_MARGIN.
\#   Advances user supplied depth from the top of the page.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC T_MARGIN END
.    nr #T_MARGIN (\\$1)
.    nr #TOP 1
.    if !\\n[#DOCS] \{\
.       sp |\\n[#T_MARGIN]u-1v
.    \}
.    wh 0i DO_T_MARGIN
.END
\#
\#
\# B_MARGIN
\# --------
\# *Argument:
\#   <space to leave at the bottom of the page>
\# *Function:
\#   Stores the user supplied bottom margin in register #B_MARGIN.
\# *Notes:
\#   Requires unit of measure.
\#
.MAC B_MARGIN END
.    br
.    nr #B_MARGIN (\\$1)
.    nr #ORIGINAL_B_MARGIN \\n[#B_MARGIN]
.    nr #B_MARGIN_SET 1
.    wh -\\n[#B_MARGIN]u DO_B_MARGIN
.END
\#
\#
\# PAGE
\# ----
\# *Arguments:
\#   <pagewidth>  [pagelength [leftmargin [rightmargin [topmargin [bottommargin]]]]]
\# *Function:
\#   Page set-up.  Collects arguments and passes them to the appropriate
\#   macros.
\# *Notes:
\#   All arguments after pagewidth are optional, but must appear
\#   in the order given above.  (User can fill in as much or as
\#   little as desired.)
\#
\#   All arguments require a unit of measure.
\#
.MAC PAGE END
.    br
.    PAGEWIDTH   \\$1
.    PAGELENGTH  \\$2
.    ie '\\$3''  \{ .L_MARGIN \\n(.o  \}
.    el          \{ .L_MARGIN \\$3    \}
.    ie '\\$4''  \{ .R_MARGIN 1i      \}
.    el          \{ .R_MARGIN \\$4    \}
.    if !'\\$5'' \{ .T_MARGIN \\$5    \}
.    if !'\\$6'' \{ .B_MARGIN \\$6    \}
.END
\#
\# =====================================================================
\#
\# +++PAGE CONTROL+++
\#
\# Generic macros for breaking pages.
\#
\# DO_T_MARGIN
\# -----------
\# *Argument:
\#   <none>
\# *Function:
\#   Plants the top margin at the top of each page.
\# *Notes:
\#   The trap is set in .T_MARGIN or .PAGE
\#
.MAC DO_T_MARGIN END
.    ev T_MARGIN
.    nr #TOP 1
.    sp |\\n[#T_MARGIN]u-1v
.    ev
.    sp -\\n[#T_MARGIN_LEAD_ADJ]u
.END
\#
\#
\# DO_B_MARGIN
\# -----------
\# *Argument:
\#   <none>
\# *Function:
\#   Plants the bottom margin at the bottom of each page.
\# *Notes:
\#   The trap is set in .B_MARGIN or .PAGE.
\#
.MAC DO_B_MARGIN END
.    nr #T_MARGIN_LEAD_ADJ \\n[#LEAD]-12000
.    ev B_MARGIN
.    bp
.    ev
.END
\#
\#
\# NEWPAGE
\# -------
\# *Argument:
\#   <none>
\# *Function:
\#   Breaks to a new page.
\# *Notes:
\#   If a B_MARGIN has been set, processes that, otherwise, just
\#   breaks to a new page.
\#
.MAC NEWPAGE END
.    br
.    nr #NEWPAGE 1
.    ie \\n[#B_MARGIN_SET]=1 \{\
.       ie !\\n[#DOCS]=1 \{\
.          ev NP
.          bp
.          ev
.       \}
.       el \{\
.          if \\n[#COLUMNS]=1 \{ .nr #COL_NUM \\n[#NUM_COLS] \}
.          ie !\\n[#FN_DEPTH] \{\
.             ch FN_OVERFLOW_TRAP
.             DO_B_MARGIN
.             wh -(\\n[#FN_OVERFLOW_TRAP_POS]u) FN_OVERFLOW_TRAP
.          \}
.          el \{\
.             DO_B_MARGIN
.          \}
.       \}
.    \}
.    el \{\
.       DO_B_MARGIN
.    \}
.END
\#
\# =====================================================================
\#
\# +++GENERAL STYLE MACROS+++
\#
\# Macros that are likely to appear together to define general
\# type style: line length, family, font, point size, and line
\# spacing.
\#
\# LINE LENGTH
\# -----------
\# *Argument:
\#   <line length>
\# *Function:
\#   Stores user supplied line length in register #L_LENGTH.
\#   Sets .ll to #L_LENGTHu
\# *Notes:
\#   Requires unit of measure.
\#
.MAC LL END
.    nr #USER_SET_L_LENGTH 1
.    ll \\$1
.    nr #L_LENGTH \\n(.l
.    ta \\n(.lu
.END
\#
\#
\# +++FAMILY AND FONT+++
\#
\# FALLBACK FONT
\# -------------
\# *Argument:
\#   <fallback font> [ ABORT | WARN ] | ABORT | WARN
\# *Function:
\#   Sets register #ABORT_FT_ERRORS to 1, or defines a fallback font
\#   called "dummy" at font position 0.
\# *Notes:
\#   Calls to non-existent families cause mom to continue processing
\#   files using the fallback font until a valid family is entered.
\#
\#   Calls to non-existent fonts generate warnings.  If ABORT is passed
\#   to FALLBACK_FONT, mom stops processing files after the warning.
\#   Otherwise, she continues to process files using the fallback font
\#   after the warning is issued.  The default fallback font is CR; the
\#   default for font warnings is to abort.
\#
.MAC FALLBACK_FONT END
.    if \\n[#NUM_ARGS]=1 \{\
.       if '\\$1'ABORT' \{ .nr #ABORT_FT_ERRORS 1 \}
.       if '\\$1'WARN' \{\
.          if r#ABORT_FT_ERRORS \{ .nr #ABORT_FT_ERRORS 0 \}
.       \}
.       if !'\\$1'ABORT' \{\
.          if !'\\$1'WARN' \{\
.             fp 0 dummy \\$1
.          \}
.       \}
.    \}
.    if \\n[#NUM_ARGS]=2 \{\
.       fp 0 dummy \\$1
.       if '\\$2'ABORT' \{ .nr #ABORT_FT_ERRORS 1 \}
.       if '\\$2'WARN'  \{ .nr #ABORT_FT_ERRORS 0 \}
.    \}
.END
\#
.FALLBACK_FONT CR ABORT
\#
\# FAMILY
\# ------
\# *Argument:
\#   <font family>
\# *Function:
\#   Stores user supplied font family in string $FAMILY.  Sets .fam
\#   to $FAMILY.
\#
.MAC FAMILY END
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam C
.       return
.    \}
.    if \\n[#IGNORE] \{\
.       fam C
.       return
.    \}
.    if (\\n[.x]\\n[.y]\\n[.Y] >= 1192) \{\
.       ds $SAVED_STYLE \\n[.sty]
.    \}
.    ds $FAMILY \\$1
.    ft 0
.    fam \\*[$FAMILY]
.    if (\\n[.x]\\n[.y]\\n[.Y] >= 1192) \{\
.       ft \\*[$SAVED_STYLE]
.       if !F\\n[.fn] \{\
.          ft 0
.       \}
.    \}
.    if \\n[#COLLATE]=1 \{\
.       if !r#START \{ .DOC_FAM \\*[$FAMILY] \}
.    \}
.END
\#
\#
\# FONT
\# ----
\# *Argument:
\#   R | I | B | BI | <other style extension>
\# *Function:
\#  Stores user supplied font in $FONT and sets .ft to $FONT.
\#
.MAC FT END
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie '\\$1'I' \{\
.          if \\n[#UNDERLINE_ITALIC]=1 \{\
.             UNDERLINE
.             return
.          \}
.          if \\n[#ITALIC_MEANS_ITALIC]=1 \{\
.             ds $FONT \\$1
.             ft \\*[$FONT]
.             return
.          \}
.       \}
.       el \{ .UNDERLINE OFF \}
.       return
.    \}
.    ds $FONT \\$1
.    ft 0
.    ft \\*[$FONT]
.    if if (\\n[.x]\\n[.y]\\n[.Y] >= 1192) \{\
.       if '\\n[.sty]'' \{\
.          if !F\\n[.fn] \{\
.             if !S\\*[$FONT] \{\
.                tm1 "[mom]: Font style "\\*[$FONT]" at line \\n(.c has not been registered.
.                ie \\n[#ABORT_FT_ERRORS]=0 \{\
.                   tm1 "       Continuing to process using fallback font.
.                \}
.                el .ab Aborting.
.             \}
.             if \\n[.f]=0 \{\
.                tm1 "[mom]: Either font style "\\*[$FONT]" at line \\n(.c does not exist in family "\\n[.fam]",
.                tm1 "       or family "\\n[.fam]" has not been installed in font/devps.
.                ie \\n[#ABORT_FT_ERRORS]=0 \{\
.                   tm1 "       Continuing to process using fallback font.
.                \}
.                el .ab Aborting.
.             \}
.          \}
.       \}
.    \}
.END
\#
\#
\# POINT SIZE
\# ----------
\# *Arguments:
\#   <point size of type>
\# *Function:
\#   Sets point size to user supplied value in scaled points.
\#   If #AUTO_LEAD is on, sets .vs to #AUTOLEAD_VALUE+#PT_SIZE.
\# *Notes:
\#   Must NOT use a unit of measure.
\#
.MAC PT_SIZE END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    if \\n[#IGNORE]        \{ .return \}
.    nr #PT_SIZE_SET 1
.    ps \\$1
.    if \\n[#AUTO_LEAD] \{\
.       ie \\n[#AUTOLEAD_FACTOR] \{ .vs \\n[#PT_SIZE]u*\\n[#AUTOLEAD_VALUE]u/1000u \}
.       el \{ .vs \\n[#PT_SIZE]u+\\n[#AUTOLEAD_VALUE]u \}
.    \}
.    nr #PT_SIZE_IN_UNITS \\n[.ps]
.END
\#
\#
\# SIZE (inline)
\# -------------
\# *Arguments:
\#   <point size of type>
\# *Function:
\#   Sets point size to user supplied value in scaled points.
\#   Intended to be called inline with \*[SIZE <n><unit>]
\# *Notes:
\#   Can be used with a unit of measure or not.
\#
.MAC SIZE END
\c
.ps \\$1
.END
\#
\#
\# LEADING
\# -------
\# *Argument:
\#   <leading between lines of text>
\# *Function:
\#   Turns off #AUTOLEAD if it's on.
\#   Sets .vs to user supplied value.
\# *Notes:
\#   Does not require unit of measure.  LS automatically turns off AUTOLEAD.
\#
.MAC LS END
.    br
.    nr #OLD_LEAD \\n(.v
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    if \\n[#IGNORE]        \{ .return \}
.    if \\n[#AUTO_LEAD] \{\
.       rr #AUTO_LEAD
.       rr #AUTOLEAD_FACTOR
.    \}
.    vs \\$1
.    if \\n[#TOP] \{\
.       nr #TOP_BASELINE_ADJ \\n(.v-\\n[#OLD_LEAD]
.       sp -\\n[#TOP_BASELINE_ADJ]u
.       rr #TOP
.       rr #TOP_BASELINE_ADJ
.    \}
.END
\#
.MAC RESET_LEAD END
'    vs
.    ch RESET_LEAD
.END
\#
\#
\# AUTOLEAD
\# --------
\# *Argument:
\#   <leading value to add to #PT_SIZE> [FACTOR]
\# *Function:
\#   Stores user supplied auto-lead value in register #AUTOLEAD_VALUE.
\#   Adds #AUT0LEAD_VALUE to #PT_SIZE when invoked to set leading.
\#   All subsequent PT_SIZE requests reset the leading in the same way until
\#   AUTOLEAD is turned off.
\# *Notes:
\#   With the optional FACTOR argument, the current point size is
\#   multiplied by #AUTOLEAD_VALUE instead of the two being added
\#   together.
\#
.MAC AUTOLEAD END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    if \\n[#IGNORE]        \{ .return \}
.    nr #AUTO_LEAD 1
.    nr #OLD_LEAD \\n(.v
.    nr #AUTOLEAD_VALUE (p;\\$1)
.    ie \\n[#NUM_ARGS]=2 \{\
.       if '\\$2'FACTOR' \{\
.          nr #AUTOLEAD_FACTOR 1
.          vs \\n[#PT_SIZE]u*\\n[#AUTOLEAD_VALUE]u/1000u
.       \}
.    \}
.    el \{\
.       vs \\n[#PT_SIZE]u+\\n[#AUTOLEAD_VALUE]u
.    \}
.    if \\n[#TOP] \{\
.       nr #TOP_BASELINE_ADJ \\n(.v-\\n[#OLD_LEAD]
.       sp -\\n[#TOP_BASELINE_ADJ]u
.       rr #TOP
.       rr #TOP_BASELINE_ADJ
.    \}
.END
\#
\#
\# STRINGS FOR INLINE CONTROL OF GENERAL TYPE STYLE
\# ------------------------------------------------
.ds ROM  \EfR
.ds IT   \EfI
.ds BD   \EfB
.ds BDI  \Ef(BI
.ds PREV \EfP
.ds S    \Es
\#
\# =====================================================================
\#
\# +++KERNING+++
\#
\# AUTOMATIC PAIRWISE KERNING
\# --------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns automatic pairwise kerning on or off.
\#
.MAC KERN END
.    ie '\\$1'' \{\
.       kern
.       nr #KERN 1
.    \}
.    el \{\
.       kern 0
.       nr #KERN 0
.    \}
.END
\#
\#
.ig
INLINE KERNING AND HORIZONTAL MOVEMENT
--------------------------------------
Kerning

Inline kerning provides a simple method for users to adjust the
amount of space between any two letters.  It's predicated on a
unit of measure "U", which is 1/36 of the current point size as
returned by \n[.ps].  E.g., if the current point size is 18,
\n[.ps] returns 18000u, therefore U=500u.  Since U remains
proportional relative to the current point size, the amount
of kerning between two letters as expressed in Us remains
visually similar regardless of changes in point size.

N.B.--the amount of inline kerning supplied by \*[BU<n>] or
\*[FU<n>] is added to or subtracted from any kerning that already
takes place between two characters when automatic kerning is
turned on.

In groff v. 1.17.2, it was not possible to pass arguments to macros that
were called with inline escapes, nor thence to evaluate conditional
expressions.  Consequently, each pseudo-escape \[BU<n>] had to be defined
separately with ".char".

As of v. 1.18, one can pass arguments to inline strings/macros,
hence it is now possible to do \*[BU n] where n, inline, is the desired
number of kern units.  The original .char definitions have been left in
for backward compatibility with documents created prior to mom-1.1.3c.
..
\#
.nr #KERN_UNIT 36
.ds BU   \h'-(\En[#PT_SIZE]u/\n[#KERN_UNIT]u*\\$1u)'
.ds FU   \h'(\En[#PT_SIZE]u/\n[#KERN_UNIT]u*\\$1u)'
\#
\# Initialize strings for pre-1.1.3c-style BU and FU
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<37 \{\
.   ds BU\n[#LOOP]  \h'-(\En[#PT_SIZE]u/\n[#KERN_UNIT]u*\n[#LOOP]u)'
.\}
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<37 \{\
.   ds FU\n[#LOOP]  \h'(\En[#PT_SIZE]u/\n[#KERN_UNIT]u*\n[#LOOP]u)'
.\}
.rr #LOOP
\#
.ig
Horizontal movements

BP1...12.75 and FP1...12.75 move backwards or forwards inline by the
specified number of points.
Left in for backward compatibility with mom-1.1.3c, the
preferred methods for inline horizontal movements are now
\*[BCK <n><unit>] and \*[FWD <n><unit>].
..
\#
.ds BCK  \h'-\\$1'
.ds FWD  \h'\\$1'
\#
.ds BP.25    \h'-.25'
.ds BP.5     \h'-.5'
.ds BP.75    \h'-.75'
.ds BP1      \h'-1p'
.ds BP1.25   \h'-1.25p'
.ds BP1.5    \h'-1.5p'
.ds BP1.75   \h'-1.75p'
.ds BP2      \h'-2p'
.ds BP2.25   \h'-2.25p'
.ds BP2.5    \h'-2.5p'
.ds BP2.75   \h'-2.75p'
.ds BP3      \h'-3p'
.ds BP3.25   \h'-3.25p'
.ds BP3.5    \h'-3.5p'
.ds BP3.75   \h'-3.75p'
.ds BP4      \h'-4p'
.ds BP4.25   \h'-4.25p'
.ds BP4.5    \h'-4.5p'
.ds BP4.75   \h'-4.75p'
.ds BP5      \h'-5p'
.ds BP5.25   \h'-5.25p'
.ds BP5.5    \h'-5.5p'
.ds BP5.75   \h'-5.75p'
.ds BP6      \h'-6p'
.ds BP6.25   \h'-6.25p'
.ds BP6.5    \h'-6.5p'
.ds BP6.75   \h'-6.75p'
.ds BP7      \h'-7p'
.ds BP7.25   \h'-7.25p'
.ds BP7.5    \h'-7.5p'
.ds BP7.75   \h'-7.75p'
.ds BP8      \h'-8p'
.ds BP8.25   \h'-8.25p'
.ds BP8.5    \h'-8.5p'
.ds BP8.75   \h'-8.75p'
.ds BP9      \h'-9p'
.ds BP9.25   \h'-9.25p'
.ds BP9.5    \h'-9.5p'
.ds BP9.75   \h'-9.75p'
.ds BP10     \h'-10p'
.ds BP10.25  \h'-10.25p'
.ds BP10.5   \h'-10.5p'
.ds BP10.75  \h'-10.75p'
.ds BP11     \h'-11p'
.ds BP11.25  \h'-11.25p'
.ds BP11.5   \h'-11.5p'
.ds BP11.75  \h'-11.75p'
.ds BP12     \h'-12p'
.ds BP12.25  \h'-12.25p'
.ds BP12.5   \h'-12.5p'
.ds BP12.75  \h'-12.75p'
\#
.ds FP.25    \h'.25'
.ds FP.5     \h'.5'
.ds FP.75    \h'.75'
.ds FP1      \h'1p'
.ds FP1.25   \h'1.25p'
.ds FP1.5    \h'1.5p'
.ds FP1.75   \h'1.75p'
.ds FP2      \h'2p'
.ds FP2.25   \h'2.25p'
.ds FP2.5    \h'2.5p'
.ds FP2.75   \h'2.75p'
.ds FP3      \h'3p'
.ds FP3.25   \h'3.25p'
.ds FP3.5    \h'3.5p'
.ds FP3.75   \h'3.75p'
.ds FP4      \h'4p'
.ds FP4.25   \h'4.25p'
.ds FP4.5    \h'4.5p'
.ds FP4.75   \h'4.75p'
.ds FP5      \h'5p'
.ds FP5.25   \h'5.25p'
.ds FP5.5    \h'5.5p'
.ds FP5.75   \h'5.75p'
.ds FP6      \h'6p'
.ds FP6.25   \h'6.25p'
.ds FP6.5    \h'6.5p'
.ds FP6.75   \h'6.75p'
.ds FP7      \h'7p'
.ds FP7.25   \h'7.25p'
.ds FP7.5    \h'7.5p'
.ds FP7.75   \h'7.75p'
.ds FP8      \h'8p'
.ds FP8.25   \h'8.25p'
.ds FP8.5    \h'8.5p'
.ds FP8.75   \h'8.75p'
.ds FP9      \h'9p'
.ds FP9.25   \h'9.25p'
.ds FP9.5    \h'9.5p'
.ds FP9.75   \h'9.75p'
.ds FP10     \h'10p'
.ds FP10.25  \h'10.25p'
.ds FP10.5   \h'10.5p'
.ds FP10.75  \h'10.75p'
.ds FP11     \h'11p'
.ds FP11.25  \h'11.25p'
.ds FP11.5   \h'11.5p'
.ds FP11.75  \h'11.75p'
.ds FP12     \h'12p'
.ds FP12.25  \h'12.25p'
.ds FP12.5   \h'12.5p'
.ds FP12.75  \h'12.75p'
\#
\#
\# WHOLE LINE KERNING (RW and EW)
\# -----------------------------
\#
.ig
The line kerning macros are special instances of track kerning,
used where a complete line needs to be tightened (or relaxed) in
order to accomodate or remove one or two more characters
than the default justification permits.
..
\#
\# *Argument:
\#   <amount of overall "kerning" (letter spacing) to apply to the line>
\# *Function:
\#   Invokes .tkf (track kerning) for the current font with
\#   1 as both the upper and lower point size limits, so that
\#   the value entered by the user applies regardless of point
\#   size.  RW ("Reduce Whitespace") reduces the amount of space
\#   between all characters by an equal amount.  EW ("Extra
\#   Whitespace") increases the amount of space.
\# *Notes:
\#   Decimal values are acceptable.
\#
.ig
The groff documentation is a tad confusing about what unit of
measure is used in track kerning, only that the width of each
character is increased or decreased by the amount(s) passed as
arguments to .tkf, and something about linear function of point
size.  In fact, with the way I've put this macro together, it
doesn't matter.  All the user needs to know is that a value of
one will produce an unacceptably tight or loose line at most text
point sizes; therefore, effective use of RW and EW is in the
fractional range below 1 (e.g. .25, .5).  Given that RW and EW
are for massaging type, a certain amount of experimentation and
previewing is expected and necessary.

\n(.f holds the current font number, which is acceptable to .tkf.

RW and EW must be reset to 0 to cancel their effect on subsequent
output lines.
..
\#
.MAC RW END
.    if \\n[#BR_AT_LINE_KERN] \{\
.       ie \\n[#JUSTIFY]=1 \{ .brp \}
.       el \{ .br \}
.    \}
.    tkf \\n(.f 1 -\\$1 1 -\\$1
.END
\#
\#
.MAC EW END
.    if \\n[#BR_AT_LINE_KERN] \{\
.       ie \\n[#JUSTIFY]=1 \{ .brp \}
.       el \{ .br \}
.    \}
.    tkf \\n(.f 1 \\$1 1 \\$1
.END
\#
\#
\# BREAK AT LINE KERN
\# ------------------
\# *Arguments:
\#   toggle
\# *Function:
\#   Enables/disables .br's before .RW and .EW
\# *Notes:
\#   Mostly, users will want .br's before any kind of line kerning, but
\#   there may be cases where they don't.  BR_BEFORE_LINE_KERN is off by
\#   default and must be invoked explicitly.
\#
.MAC BR_AT_LINE_KERN END
.    ie '\\$1'' \{ .nr #BR_AT_LINE_KERN  1 \}
.    el         \{ .rr #BR_AT_LINE_KERN \}
.END
\#
\# =====================================================================
\#
\# +++HYPHENATION+++
\#
\# AUTO HYPHENATION
\# ----------------
\# *Arguments:
\#   <none> | <anything> | DEFAULT
\#                 or
\#   LINES <n> | MARGIN <n> | SPACE <n>
\# *Function:
\#   Turns auto hyphenation on or off, resets the hyphenation style
\#   to default, or permits the setting of various hyphenation
\#   parameters.
\# *Notes:
\#   HY, by itself, defaults to .hy 14, i.e. no hyphens after the
\#   first two or before the last two characters of a word, and no
\#   hyphenation of the last line prior to a trap (e.g., at the
\#   bottom of a page).
\#
\#   HY DEFAULT resets the hyphenation style to .hy 14 (see
\#   above) if that behaviour is desired after changes have been
\#   made to LINES, MARGIN, or SPACE.
\#
\#   HY LINES <n> sets the number of allowable consecutive hyphenated lines.
\#
\#   HY MARGIN <n> sets the amount of space (ipPcm) allowed at the end
\#   of a line in QUAD mode before hyphenation is tripped (e.g. if there's
\#   only 6 points left, groff won't try to hyphenate the next word).
\#
\#   HY SPACE sets the amount of extra interword space (ipPcm) that can
\#   be added in JUSTIFY mode to prevent a line from being hyphenated.
\#
.MAC HY END
.    ie '\\$1'' \{\
.       hy 14
.       nr #HYPHENATE 1
.    \}
.    el \{\
.       if !'\\$1'LINES'  \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if !'\\$1'MARGIN' \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if !'\\$1'SPACE'  \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if !'\\$1'DEFAULT'  \{\
.          nh
.          nr #HYPHENATE 0
.       \}
.       if '\\$1'LINES'   \{ .hlm \\$2 \}
.       if '\\$1'MARGIN'  \{ .hym \\$2 \}
.       if '\\$1'SPACE'   \{ .hys \\$2 \}
.       if '\\$1'DEFAULT' \{\
.          hlm -1
.          hym 0
.          hys 0
.       \}
.    \}
.END
\#
\#
\# HYPHENATION PARAMETERS
\# ----------------------
\# *Arguments:
\#   <# of lines> | <size of margin> | <amount of interword space>
\# *Function:
\#   Allows user to specify .HY LINES, MARGIN, and SPACE with a single command.
\#
.MAC HY_SET END
.    nr #HY_SET 1
.    hlm \\$1
.    hym \\$2
.    hys \\$3
.END
\#
\# =====================================================================
\#
\# +++VERTICAL SPACING+++
\#
\# ADVANCE LEAD
\# ------------
\# *Argument:
\#   <user supplied lead to advance below current baseline>
\# *Function:
\#   Creates or modifies register #ALD.  Adds user supplied lead
\#   below current baseline.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC ALD END
.    if \\n(nl=0 \{ .nr #TOP 1 \}
.    if '\\$0'ALD' \{\
.       nr #ALD (\\$1)
.       sp \\n[#ALD]u
.    \}
.    if '\\$0'ADD_SPACE' \{\
.       nr #ALD (\\$1)
.       rs
.       sp \\n[#ALD]u
.    \}
.    if '\\$0'SPACE' \{\
.       sp \\$1u
.    \}
.    if '\\$0'SP' \{\
.       sp \\$1u
.    \}
.END
\#
\#
\# REVERSE LEAD
\# ------------
\# *Argument:
\#   <user supplied lead to reverse above current baseline>
\# *Function:
\#   Creates or modifies register #RLD.  Reverses user supplied
\#   lead above current baseline.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC RLD END
.    nr #RLD (\\$1)
.    sp -\\n[#RLD]u
.END
\#
\# ALD/RLD STRINGS
\# ---------------
.ig
The strings \*[ALD.25]...\*[ALD12.75] and their corresponding
\*[RLD] forms have been left in for backward compatibility with
documents created using mom-1.1.3c or earlier.  The prefered methods
of advancing and reversing on the page inline are \*[UP <n><unit>]
and \*[DOWN <n><unit>].
..
\#
.ds DOWN      \v'\\$1'
.ds UP        \v'-\\$1'
\#
.ds ALD.25    \v'.25p'
.ds ALD.5     \v'.5p'
.ds ALD.75    \v'.75p'
.ds ALD1      \v'1p'
.ds ALD1.25   \v'1.25p'
.ds ALD1.5    \v'1.5p'
.ds ALD1.75   \v'1.75p'
.ds ALD2      \v'2p'
.ds ALD2.25   \v'2.25p'
.ds ALD2.5    \v'2.5p'
.ds ALD2.75   \v'2.75p'
.ds ALD3      \v'3p'
.ds ALD3.25   \v'3.25p'
.ds ALD3.5    \v'3.5p'
.ds ALD3.75   \v'3.75p'
.ds ALD4      \v'4p'
.ds ALD4.25   \v'4.25p'
.ds ALD4.5    \v'4.5p'
.ds ALD4.75   \v'4.75p'
.ds ALD5      \v'5p'
.ds ALD5.25   \v'5.25p'
.ds ALD5.5    \v'5.5p'
.ds ALD5.75   \v'5.75p'
.ds ALD6      \v'6p'
.ds ALD6.25   \v'6.25p'
.ds ALD6.5    \v'6.5p'
.ds ALD6.75   \v'6.75p'
.ds ALD7      \v'7p'
.ds ALD7.25   \v'7.25p'
.ds ALD7.5    \v'7.5p'
.ds ALD7.75   \v'7.75p'
.ds ALD8      \v'8p'
.ds ALD8.25   \v'8.25p'
.ds ALD8.5    \v'8.5p'
.ds ALD8.75   \v'8.75p'
.ds ALD9      \v'9p'
.ds ALD9.25   \v'9.25p'
.ds ALD9.5    \v'9.5p'
.ds ALD9.75   \v'9.75p'
.ds ALD10     \v'10p'
.ds ALD10.25  \v'10.25p'
.ds ALD10.5   \v'10.5p'
.ds ALD10.75  \v'10.75p'
.ds ALD11     \v'11p'
.ds ALD11.25  \v'11.25p'
.ds ALD11.5   \v'11.5p'
.ds ALD11.75  \v'11.75p'
.ds ALD12     \v'12p'
.ds ALD12.25  \v'12.5p'
.ds ALD12.5   \v'12.5p'
.ds ALD12.75  \v'12.75p'
\#
.ds RLD.25    \v'-.25p'
.ds RLD.5     \v'-.5p'
.ds RLD.75    \v'-.75p'
.ds RLD1      \v'-1p'
.ds RLD1.25   \v'-1.25p'
.ds RLD1.5    \v'-1.5p'
.ds RLD1.75   \v'-1.75p'
.ds RLD2      \v'-2p'
.ds RLD2.25   \v'-2.25p'
.ds RLD2.5    \v'-2.5p'
.ds RLD2.75   \v'-2.75p'
.ds RLD3      \v'-3p'
.ds RLD3.25   \v'-3.25p'
.ds RLD3.5    \v'-3.5p'
.ds RLD3.75   \v'-3.75p'
.ds RLD4      \v'-4p'
.ds RLD4.25   \v'-4.25p'
.ds RLD4.5    \v'-4.5p'
.ds RLD4.75   \v'-4.75p'
.ds RLD5      \v'-5p'
.ds RLD5.25   \v'-5.25p'
.ds RLD5.5    \v'-5.5p'
.ds RLD5.75   \v'-5.75p'
.ds RLD6      \v'-6p'
.ds RLD6.25   \v'-6.25p'
.ds RLD6.5    \v'-6.5p'
.ds RLD6.75   \v'-6.75p'
.ds RLD7      \v'-7p'
.ds RLD7.25   \v'-7.25p'
.ds RLD7.5    \v'-7.5p'
.ds RLD7.75   \v'-7.75p'
.ds RLD8      \v'-8p'
.ds RLD8.25   \v'-8.25p'
.ds RLD8.5    \v'-8.5p'
.ds RLD8.75   \v'-8.75p'
.ds RLD9      \v'-9p'
.ds RLD9.25   \v'-9.25p'
.ds RLD9.5    \v'-9.5p'
.ds RLD9.75   \v'-9.75p'
.ds RLD10     \v'-10p'
.ds RLD10.25  \v'-10.25p'
.ds RLD10.5   \v'-10.5p'
.ds RLD10.75  \v'-10.75p'
.ds RLD11     \v'-11p'
.ds RLD11.25  \v'-11.25p'
.ds RLD11.5   \v'-11.5p'
.ds RLD11.75  \v'-11.75p'
.ds RLD12     \v'-12p'
.ds RLD12.25  \v'-12.5p'
.ds RLD12.5   \v'-12.5p'
.ds RLD12.75  \v'-12.75p'
\#
\# =====================================================================
\#
\# +++REFINEMENTS+++
\#
\# AUTOMATIC LIGATURES
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns automatic ligature generation on or off.
\# *Notes:
\#   Ligatures may be supplied manually with \(fi, \(fl, etc.
\#
.MAC LIGATURES END
.    ie '\\$1'' \{\
.       lg
.       nr #LIGATURES 1
.    \}
.    el \{\
.       lg 0
.       nr #LIGATURES 0
.    \}
.END
\#
\#
\# SMARTQUOTES
\# -----------
\# *Arguments:
\#   [ ,, ] | [ << ] | [ >> ] | <anything>
\#   or
\#   [ DA | DE | ES | FR | IT | NL | NO | PT | SV ] | <anything>
\# *Function:
\#   Turns smartquotes on (optionally with a quoting style from the
\#   argument list, or off).
\# *Notes:
\#   The " character is read outside the macro when mom is
\#   processed.  The strings for open/close ($QUOTE<n>) are then
\#   defined in the macro.
\#
\#   (Note to myself: code for " is \N'34'.)
\#
.char " \\*[$QUOTE\\n[#OPEN_CLOSE]]\R'#OPEN_CLOSE (1-\\n[#OPEN_CLOSE])'
\#
.MAC SMARTQUOTES END
.    rr #ARGS_TO_SQ
.    ie '\\$1'' \{\
.       nr #OPEN_CLOSE 0
.       ds $QUOTE0 \\[lq]
.       ds $QUOTE1 \\[rq]
.    \}
.    el \{\
.       if '\\$1',,' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Bq]
.          ds $QUOTE1 \\[lq]
.       \}
.       if '\\$1'<<' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fo]
.          ds $QUOTE1 \\[Fc]
.       \}
.       if '\\$1'>>' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fc]
.          ds $QUOTE1 \\[Fo]
.       \}
.       if '\\$1'DA' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fc]
.          ds $QUOTE1 \\[Fo]
.       \}
.       if '\\$1'DE' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Bq]
.          ds $QUOTE1 \\[lq]
.       \}
.       if '\\$1'ES' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[lq]
.          ds $QUOTE1 \\[rq]
.       \}
.       if '\\$1'FR' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fo]\\|
.          ds $QUOTE1 \\|\\[Fc]
.       \}
.       if '\\$1'IT' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fo]\\|
.          ds $QUOTE1 \\|\\[Fc]
.       \}
.       if '\\$1'NL' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[rq]
.          ds $QUOTE1 \\[rq]
.       \}
.       if '\\$1'NO' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fo]
.          ds $QUOTE1 \\[Fc]
.       \}
.       if '\\$1'PT' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fo]
.          ds $QUOTE1 \\[Fc]
.       \}
.       if '\\$1'SV' \{\
.          nr #ARGS_TO_SQ 1
.          ds $QUOTE0 \\[Fc]
.          ds $QUOTE1 \\[Fc]
.       \}
.       if !r#ARGS_TO_SQ \{\
.          ds $QUOTE0 \\[dq]
.          ds $QUOTE1 \\[dq]
.       \}
.    \}
.END
\#
.ds $QUOTE0 \[dq]
.ds $QUOTE1 \[dq]
\#
\# Strings for foot and inch marks
\#
.ds FOOT \(fm
.ds INCH \(fm\(fm
\#
\# =====================================================================
\#
\# +++LINE BREAKS+++
\#
\# NO-SPACE BREAK
\# --------------
\# *Argument:
\#   <none>
\# *Function:
\#   Breaks a line without advancing.
\# *Notes:
\#   EL is the mnemonic used on older, dedicated typesetting machines
\#   to indicate "process the line, without advancing the galley
\#   medium."  It stands for End Line.
\#
\#   The \c inline must be appended to the end of input lines when in
\#   nofill mode; in fill modes, the \c inline must not be used.
\#
.MAC EL END
.    TRAP OFF
.    if \\n[#PSEUDO_FILL]=1 \&
.    br
.    sp -1v
.    TRAP
.END
\#
\# An inline escape to accomplish the same thing.  Actually
\# preferable, since it works with filled and non-filled copy and
\# doesn't require the user to remember to use (or not use) the \c.
\#
.ds B \h'|0'\c
\#
\# =====================================================================
\#
\# +++FILLING/QUADDING/JUSTIFYING+++
\#
\# JUSTIFY
\# -------
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill on and sets .ad to b.
\# *Notes:
\#   Justifies text left and right.
\#
.MAC JUSTIFY END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       nr #QUAD 1
.       ds $RESTORE_QUAD_VALUE \\*[$QUAD_VALUE]
.    \}
'    ce 0
.    QUAD J
.    if \\n[#PRINT_STYLE]=1 \{ .QUAD L \}
.    nr #PSEUDO_FILL 0
.END
\#
\#
\# QUAD
\# ----
\# *Arguments:
\#   L | LEFT | R | RIGHT | C | CENTER/CENTRE
\# *Function:
\#   Turns fill on and sets .ad to l, r, or c.
\# *Notes:
\#   Terminology is a problem here.  Some people call quad left
\#   left justified, flush left, or flush left/rag right (and the
\#   reverse for quad right).  Quad center is sometimes called rag
\#   both.  For our purposes, all "quad" modes mean that groff fill
\#   mode is enabled.
\#
.MAC QUAD END
.    ds $QUAD_VALUE \\$1
.    if \\n[#TAB_ACTIVE]=0 \{\
.       nr #QUAD 1
.       ds $RESTORE_QUAD_VALUE \\*[$QUAD_VALUE]
.    \}
'    ce 0
'    fi
.    if '\\*[$QUAD_VALUE]'L'       \{\
.       nr #JUSTIFY 0
.       ad l
.    \}
.    if '\\*[$QUAD_VALUE]'LEFT'    \{\
.       nr #JUSTIFY 0
.       ad l
.    \}
.    if '\\*[$QUAD_VALUE]'R'       \{\
.       nr #JUSTIFY 0
.       ad r
.    \}
.    if '\\*[$QUAD_VALUE]'RIGHT'   \{\
.       nr #JUSTIFY 0
.       ad r
.    \}
.    if '\\*[$QUAD_VALUE]'C'       \{\
.       nr #JUSTIFY 0
.       ad c
.    \}
.    if '\\*[$QUAD_VALUE]'CENTER'  \{\
.       nr #JUSTIFY 0
.       ad c
.    \}
.    if '\\*[$QUAD_VALUE]'CENTRE'  \{\
.       nr #JUSTIFY 0
.       ad c
.    \}
.    if '\\*[$QUAD_VALUE]'J'       \{\
.       nr #JUSTIFY 1
.       ad b
.    \}
.    if '\\*[$QUAD_VALUE]'JUSTIFY' \{\
.       nr #JUSTIFY 1
.       ad b
.    \}
.    nr #PSEUDO_FILL 0
.END
\#
\#
\# LEFT, RIGHT, AND CENTER
\# -----------------------
\#
.ig
The purpose of these macros is to allow the user to enter lines of
text that will be quadded LRC *without* the user having to enter .BR
or .br between lines.  For the sake of consistency, all three appear
to behave similarly (from the point of view of the user), although
the underlying primitives don't.  For this reason, LEFT, RIGHT, and
CENTER must be followed by .QUAD [L R C J] or .JUSTIFY to restore
text to groff fill mode.
..
\#
\# LEFT
\# ----
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill mode off.  Allows user to quad lines left without
\#   requiring the .BR or .br macro.
\# *Notes:
\#   LEFT simply turns fill off.  Lines that exceed the current LL will
\#   not be broken, just continued (indefinitely) until a return is
\#   encountered.  Note that this behaviour differs from the RIGHT and
\#   CENTER macros.
\#
.MAC LEFT END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       rr #QUAD
.       ds $RESTORE_QUAD_VALUE LEFT
.    \}
.    ce 0
.    nf
.    nr #PSEUDO_FILL 1
.\" Fix for a little conflict with DOCTYPE LETTER 
.    if '\\n(.z'LETTERHEAD1' \{ .rr #DATE_FIRST \}
.END
\#
\#
\# RIGHT
\# -----
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill on.  Allows user to quad lines right without
\#   requiring the .BR or .br macro.
\# *Notes:
\#   Lines that exceed the current LL will be broken, with the excess
\#   text quadded right.
\#
.MAC RIGHT END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       rr #QUAD
.       ds $RESTORE_QUAD_VALUE RIGHT
.    \}
.    fi
.    rj 100000
.    nr #PSEUDO_FILL 1
.END
\#
\#
\# CENTER
\# ------
\# *Argument:
\#   <none>
\# *Function:
\#   Turns fill on.  Allows user to center lines without
\#   requiring the .BR or .br macro.
\# *Notes:
\#   Lines that exceed the current LL will be broken, with the excess
\#   text centered.
\#
.MAC CENTER END
.    if \\n[#TAB_ACTIVE]=0 \{\
.       rr #QUAD
.       ds $RESTORE_QUAD_VALUE CENTER
.    \}
.    fi
.    ce 100000
.    nr #PSEUDO_FILL 1
.END
\#
\# =====================================================================
\#
\# +++TABS+++
\#
.ig
There are two different kinds of tabs available: typesetting tabs
and string tabs.

Typesetting tabs are set with TAB_SET, which requires a tab number,
an indent (offset) from the left margin and a length (optionally
with a quad direction and an instruction to fill lines).  After tabs
are set with TAB_SET, they are called with .TAB n, where "n"
corresponds to the number passed to TAB_SET as a valid tab number.

String tabs allow the user to mark off tab positions inline.  Tab
indents and lengths are calculated from the beginning and end
positions of the marks.  Up to 19 string tabs may be created,
numbered 1-19.  Once created, they are called with .TAB n,
just like typesetting tabs.

Setting up string tabs is a two-step procedure.  First, the user
enters an input line in which s/he wants to mark off string tabs.
The beginning of a tab is marked with \*[STn], where "n" is
the desired number of the tab.  The end of the the tab is marked
with \*[STnX].  All ST's must have a matching STX.  String tabs
may be nested.

Next, the user invokes .ST n for every string tab defined, and
optionally passes quad information to it.  That done, string tabs
can be called just like typesetting tabs.

String tabs don't preview properly with gxditview.  Use gv instead.
..
\#
\# Strings for string tab inlines
\# ------------------------------
\#
\# Initialize string tab markers numbered 1 to 19.
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<20 \{\
.   ds ST\n[#LOOP] \Ek[#ST\n[#LOOP]_OFFSET]
.\}
\#
.nr #LOOP 0 1
.while \n+[#LOOP]<20 \{\
.   ds ST\n[#LOOP]X \Ek[#ST\n[#LOOP]_MARK]
.\}
.rr #LOOP
\#
\#
\# These are reserved ST numbers for internal use
.ds ST100  \Ek[#ST100_OFFSET]
.ds ST100X \Ek[#ST100_MARK]
.ds ST101  \Ek[#ST101_OFFSET]
.ds ST101X \Ek[#ST101_MARK]
\#
\#
\# QUAD AND SET STRING TABS
\# ------------------------
\# *Arguments:
\#   <stringtab number>  L | R | C | J  [QUAD]
\# *Function:
\#   Creates strings $ST<#>_QUAD_DIR and $ST<#>_FILL, then sets up a
\#   tab based on the collected information.
\# *Notes:
\#   Like TAB_SET, ST invoked without a quad direction will default to LEFT.
\#   If lines should be filled and quadded, use the optional argument QUAD.
\#   N.B. -- indents *must* be turned off before setting string tabs
\#   inside .PAD
\#
.MAC ST END
.    ds $ST\\$1_QUAD_DIR \\$2
.    if \\n[#NUM_ARGS]=3 \{\
.       ds $ST\\$1_FILL QUAD
.    \}
.    nr #ST\\$1_LENGTH \\n[#ST\\$1_MARK]-\\n[#ST\\$1_OFFSET]
.    ie \\n[#IN_TAB] \{\
.       TAB_SET \\$1 \\n[#ST\\$1_OFFSET]u+\\n[#ST_OFFSET]u \\n[#ST\\$1_LENGTH]u \\*[$ST\\$1_QUAD_DIR] \\*[$ST\\$1_FILL]
.    \}
.    el \{\
.       TAB_SET \\$1 \\n[#ST\\$1_OFFSET]u \\n[#ST\\$1_LENGTH]u \\*[$ST\\$1_QUAD_DIR] \\*[$ST\\$1_FILL]
.    \}
.END
\#
\#
\# TAB SET
\# -------
\# *Arguments:
\#   <n>  ident(ipPcm)  length(ipPcm)  [L | R | C | J [QUAD]]
\# *Function:
\#   Creates macros TABn and TAB n, where "n" is any arbitrary number.
\#   TABn is a typesetting tab (i.e. a tab defined as an indent
\#   from the page left offset plus a line length.)
\# *Notes:
\#   n      = arbitrary digit to identify the tab
\#   indent = indent from left margin; unit of measure required
\#   length = length of tab (unit of measure required; can be
\#            \w'<string>'u--if more than one word in string, surround
\#            with double quotes "\w'<three word string>'"
\#   LRCJ   = quad for tab (left, right, center, justified)
\#            If option QUAD afterwards is not given, quad is line for line
\#            (no fill mode), meaning that there's no need for .BR or .br
\#            between lines.
\#   QUAD   = fill tab (so it behaves as if .QUAD LRC or .JUSTIFY
\#            had been given).
\#
\#   N.B. -- indents *must* be turned off before setting tabs
\#
.ig
Examples:
--------

.TAB_SET 1 2P+6p 12P C

means "create a tab numbered 1 that starts 2 picas and 6 points from
the left margin, is 12 picas long, and centre each input line."

.TAB_SET 1 2P+6P 12P C QUAD

means exactly the same thing, except that input lines are joined and
the area delimted by the tab filled with centered text.

TAB n can be called at any time after being set.

Tabs are NOT columnar in behaviour.  If the text inside a
tab runs to several lines, when you call the next tab a break
occurs, meaning that the new tab starts one line below the last
line in the previous tab.  For columnar behaviour, you must
use the multi-column macros in addition to tabs.

If you want tabs to line up bottom-line to bottom-line (most likely
single line tabs), use .TN (provided the tabs are numbered sequentially).
Otherwise, you must use .EL then .TAB <n> if you want them to align.

If you want to reset tabs, you must use .TQ before .TAB_SET.

Note that indents are turned off automatically whenever a new
tab is called with TAB <n>.

Tabs themselves are user-invoked using the TAB macro with a numeric
argument, e.g. TAB 1.

Generally, in order not to get confused, it's a good idea
to make sure all indents are off before setting tabs.
..
\#
.MAC TAB_SET END
.    br
.    nr #TAB_NUMBER \\$1
.    ds $CURRENT_TAB \\n[#TAB_NUMBER]
.    nr #TAB_OFFSET (\\$2)
.    nr #TAB_LENGTH (\\$3)
.    MAC TAB\\n[#TAB_NUMBER] DONE \"Define TAB macro
.        if !\\\\n[#TB+]=1 \{ .br \}
.        if \\\\n[#TB+]=1 \{\
.           EL
.           vpt 0
.           rr #TB+
.        \}
.        in 0
.        nr #TAB_ACTIVE 1
.        nr #CURRENT_TAB \\n[#TAB_NUMBER]
.        ds $CURRENT_TAB \\*[$CURRENT_TAB]
.        nr #TAB_OFFSET\\*[$CURRENT_TAB] \\n[#TAB_OFFSET]
.        nr #ST_OFFSET \\n[#TAB_OFFSET]
.        po \\\\n[#L_MARGIN]u+\\\\n[#TAB_OFFSET\\\\*[$CURRENT_TAB]]u
.        ll \\n[#TAB_LENGTH]u
.        ta \En(.lu
.        ie '\\$5'QUAD' \{\
.           if '\\$4'L' \{ .QUAD L  \}
.           if '\\$4'R' \{ .QUAD R  \}
.           if '\\$4'C' \{ .QUAD C  \}
.           if '\\$4'J' \{ .JUSTIFY \}
.        \}
.        el \{\
.           if '\\$4''  \{ .LEFT    \}
.           if '\\$4'L' \{ .LEFT    \}
.           if '\\$4'R' \{ .RIGHT   \}
.           if '\\$4'C' \{ .CENTER  \}
.           if '\\$4'J' \{ .JUSTIFY \}
.        \}
.        if \\\\n[#TN]=1 \{\
.           TRAP
.           rr #TN
.        \}
.DONE
.    rr #TAB_ACTIVE
.END
\#
\#
\# TAB
\# ---
\# *Arguments:
\#   <tab number to tab into>
\# *Function:
\#   Moves to tab number passed as an argument.
\#
.MAC TAB END
.    ds $TAB_NUMBER \\$1
.    TAB\\*[$TAB_NUMBER]
.    nr #IN_TAB 1
.END
\#
\#
\# TAB NEXT
\# --------
\# *Argument:
\#   <none>
\# *Function:
\#   Automagically moves to TAB<n+1> on the same line as the last
\#   line of the previous tab.
\# *Notes:
\#   The \c inline must be appended to the end of input lines when in
\#   nofill mode; in fill modes, the \c inline must not be used.
\#
.MAC TN END
.    nr #TN 1
.    TRAP OFF
.    sp -1v
.    nr #NEXT_TAB \\n[#CURRENT_TAB]+1
.    TAB\\n[#NEXT_TAB]
.    TRAP
.END
\#
\# An inline escape to accomplish the same thing.  Actually
\# preferable, since it works with filled and non-filled copy and
\# doesn't require the user to remember to use (or not use) the \c.
\#
.ds TB+ "\c\\R'#TB+ 1'\\R'#TN 1'\\R'#NEXT_TAB \\n[#CURRENT_TAB]+1'\\*[TAB\\n[#NEXT_TAB]]\c
\#
\# TAB QUIT
\# --------
\# *Argument:
\#   <none>
\# *Function:
\#   Sets #TAB_ACTIVE to "0" (off).
\#   Resets left margin to value in effect prior to tabs.
\#   Resets line length to value in effect prior to tabs.
\#   Checks #QUAD to see if we were in flush or quad mode
\#   prior to tabs (0=off, 1=on).
\#   Resets QUAD [ L|R|C ], LEFT, RIGHT, CENTER, or JUSTIFY
\#   in effect prior to tabs.
\# *Notes:
\#   TQ *must* come before setting any new tabs if you want the
\#   tabs' indents measured from page left.  Otherwise, the tabs'
\#   indents are measured from the left margin of the tab you're
\#   currently in.
\#
.MAC TQ END
.    br
.    rr #TAB_ACTIVE
.    rr #IN_TAB
.    po \\n[#L_MARGIN]u
.    ll \\n[#L_LENGTH]u
.    ta \\n(.lu
.    ie \\n[#QUAD] \{\
.       ie '\\*[$RESTORE_QUAD_VALUE]'J' \{ .JUSTIFY \}
.       el                              \{ .QUAD \\*[$RESTORE_QUAD_VALUE] \}
.    \}
.    el \{\
.       if '\\*[$RESTORE_QUAD_VALUE]'LEFT'   \{ .LEFT \}
.       if '\\*[$RESTORE_QUAD_VALUE]'RIGHT'  \{ .RIGHT \}
.       if '\\*[$RESTORE_QUAD_VALUE]'CENTER' \{ .CENTER \}
.    \}
.END
\#
\# ====================================================================
\#
\# COLOR HANDLING
\# ==============
\#
\# COLOR
\# -----
\# *Arguments:
\#   <pre-defined NEWCOLOR or XCOLOR>
\# *Function:
\#   Allows the inline escape for setting color to be called
\#   as a macro.
\#
.MAC COLOR END
.ie \\n(.u=1 \{\
\c
\\*[\\$1]\c
.\}
.el \{ \\*[\\$1] \}
.END
\#
\#
\# NEWCOLOR
\# --------
\# *Arguments:
\#   <color name> [<color scheme>] <color definition>
\# *Function:
\#   Based on .defcolor, allows users to name and define colors using
\#   one of the four color schemes rgb, cmy, cmyk and grey.  The new
\#   color is then defined as a string so that it can be called inline
\#   with \*[COLORNAME] or with .COLOR.
\# *Notes:
\#   With only two args, the default color scheme is rgb.
\#
\#   It is highly recommended that users define new colors as
\#   all-cap strings, to differentiate them from x colors, which must
\#   be in lower case.
\#
.MAC NEWCOLOR END
.    if \\n[#NUM_ARGS]=2 \{\
.       defcolor \\$1 rgb \\$2
.    \}
.    if \\n[#NUM_ARGS]=3 \{\
.       if '\\$2'RGB'  .ds $COLOR_SCHEME rgb
.       if '\\$2'CYM'  .ds $COLOR_SCHEME cym
.       if '\\$2'CMYK' .ds $COLOR_SCHEME cmyk
.       if '\\$2'GRAY' .ds $COLOR_SCHEME gray
.       if '\\$2'GREY' .ds $COLOR_SCHEME gray
.       defcolor \\$1  \\*[$COLOR_SCHEME] \\$3
.    \}
.    ds \\$1 \\m[\\$1]
.END
\#
\#
\# XCOLOR
\# ------
\# *Arguments:
\#   <x color name> [<alias>]
\# *Function:
\#   Defines a string of x color name (i.e. a predefined x
\#   color).  If <alias> is given, creates a string of <alias name>
\#   that references the x color name of the first argument.
\# *Notes:
\#   The color name must be a legal color name from rgb.txt, and
\#   must be given entirely in lower case, all one word.
\#
.MAC XCOLOR END
.    ds \\$1 \m[\\$1]
.    if \\n[#NUM_ARGS]=2 .ds \\$2 \m[\\$1]
.END
\#
\# Pre-define xcolors black and white
\#
.ds black \m[black]
.ds BLACK \m[black]
.ds white \m[white]
.ds WHITE \m[WHITE]
\#
\# =====================================================================
\#
\# +++MISCELLANEOUS USEFUL MACROS AND STRINGS+++
\#
\# UNDERLINE
\# ---------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   When on, underlines all letters, words, and digits in a passage,
\#   ignoring punctuation and spaces.
\# *Notes:
\#   Only for use when the font family is COURIER, to simulate
\#   typewriter-style underlining of italic  passages.
\#
.MAC UNDERLINE END
.    ie '\\$1'' \{\
.       nr #UNDERLINE_ON 1
.       char A _A
.       char B _B
.       char C _C
.       char D _D
.       char E _E
.       char F _F
.       char G _G
.       char H _H
.       char I _I
.       char J _J
.       char K _K
.       char L _L
.       char M _M
.       char N _N
.       char O _O
.       char P _P
.       char Q _Q
.       char R _R
.       char S _S
.       char T _T
.       char U _U
.       char V _V
.       char W _W
.       char X _X
.       char Y _Y
.       char Z _Z
.       char \[`A] _\[`A]
.       char \[^A] _\[^A]
.       char \['A] _\['A]
.       char \[:A] _\[:A]
.       char \[oA] _\[oA]
.       char \[~A] _\[~A]
.       char \[AE] _\[AE]
.       char \[`E] _\[`E]
.       char \[^E] _\[^E]
.       char \['E] _\['E]
.       char \[:E] _\[:E]
.       char \[`I] _\[`I]
.       char \[^I] _\[^I]
.       char \['I] _\['I]
.       char \[:I] _\[:I]
.       char \[`O] _\[`O]
.       char \[^O] _\[^O]
.       char \['O] _\['O]
.       char \[:O] _\[:O]
.       char \[~O] _\[~O]
.       char \[/O] _\[/O]
.       char \[`U] _\[`U]
.       char \[^U] _\[^U]
.       char \['U] _\['U]
.       char \[:U] _\[:U]
.       char \[,C] _\[,C]
.       char \[-D] _\[-D]
.       char \[~N] _\[~N]
.       char \[TP] _\[TP]
.       char \['Y] _\['Y]
.       char \[:Y] _\[:Y]
.       char a _a
.       char b _b
.       char c _c
.       char d _d
.       char e _e
.       char f _f
.       char g _g
.       char h _h
.       char i _i
.       char j _j
.       char k _k
.       char l _l
.       char m _m
.       char n _n
.       char o _o
.       char p _p
.       char q _q
.       char r _r
.       char s _s
.       char t _t
.       char u _u
.       char v _v
.       char w _w
.       char x _x
.       char y _y
.       char z _z
.       char \[`a] _\[`a]
.       char \[^a] _\[^a]
.       char \['a] _\['a]
.       char \[:a] _\[:a]
.       char \[oa] _\[oa]
.       char \[~a] _\[~a]
.       char \[ae] _\[ae]
.       char \[`e] _\[`e]
.       char \[^e] _\[^e]
.       char \['e] _\['e]
.       char \[:e] _\[:e]
.       char \[`i] _\[`i]
.       char \[^i] _\[^i]
.       char \['i] _\['i]
.       char \[:i] _\[:i]
.       char \[`o] _\[`o]
.       char \[^o] _\[^o]
.       char \['o] _\['o]
.       char \[:o] _\[:o]
.       char \[~o] _\[~o]
.       char \[/o] _\[/o]
.       char \[`u] _\[`u]
.       char \[^u] _\[^u]
.       char \['u] _\['u]
.       char \[:u] _\[:u]
.       char \[,c] _\[,c]
.       char \[Sd] _\[Sd]
.       char \[~n] _\[~n]
.       char \[Tp] _\[Tp]
.       char \['y] _\['y]
.       char \[:y] _\[:y]
.       char \[ss] _\[ss]
.       char ' _'
.       char 1 _1
.       char 2 _2
.       char 3 _3
.       char 4 _4
.       char 5 _5
.       char 6 _6
.       char 7 _7
.       char 8 _8
.       char 9 _9
.       char 0 _0
.    \}
.    el \{\
.       nr #UNDERLINE_ON 0
.       rchar A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
        a b c d e f g h i j k l m n o p q r s t u v w x y z \
        \[`A] \[^A] \['A] \[:A] \[oA] \[~A] \[AE] \[`E] \[^E] \['E] \[:E] \
        \[`I] \[^I] \['I] \[:I] \[`O] \[^O] \['O] \[:O] \[~O] \[/O] \[`U] \
        \[^U] \['U] \[:U] \[,C] \[-D] \[~N] \[TP] \['Y] \[:Y] \
        \[`a] \[^a] \['a] \[:a] \[oa] \[~a] \[ae] \[`e] \[^e] \['e] \[:e] \[`i] \
        \[^i] \['i] \[:i] \[`o] \[^o] \['o] \[:o] \[~o] \[/o] \[`u] \[^u] \['u] \
        \[:u] \[,c] \[Sd] \[~n] \[Tp] \['y] \[:y] \[ss] \
        ' 1 2 3 4 5 6 7 8 9 0
.    \}
.END
\#
\#
\# UL/ULX
\# ------
\# *Arguments:
\#   <none>
\# *Function:
\#   Underscores all letters, words, and digits in a passage,
\#   ignoring punctuation and spaces.
\# *Notes:
\#   Intended to be called with inline escapes \*[UL] (underline
\#   on) and \*[ULX] (underline off).  Only works when the font family
\#   is COURIER, to simulate typewriter-style underlining of italic
\#   passages.
\#
.MAC UL END
\c\R'#UNDERLINE_ON 1'
.       char A _A
.       char B _B
.       char C _C
.       char D _D
.       char E _E
.       char F _F
.       char G _G
.       char H _H
.       char I _I
.       char J _J
.       char K _K
.       char L _L
.       char M _M
.       char N _N
.       char O _O
.       char P _P
.       char Q _Q
.       char R _R
.       char S _S
.       char T _T
.       char U _U
.       char V _V
.       char W _W
.       char X _X
.       char Y _Y
.       char Z _Z
.       char \[`A] _\[`A]
.       char \[^A] _\[^A]
.       char \['A] _\['A]
.       char \[:A] _\[:A]
.       char \[oA] _\[oA]
.       char \[~A] _\[~A]
.       char \[AE] _\[AE]
.       char \[`E] _\[`E]
.       char \[^E] _\[^E]
.       char \['E] _\['E]
.       char \[:E] _\[:E]
.       char \[`I] _\[`I]
.       char \[^I] _\[^I]
.       char \['I] _\['I]
.       char \[:I] _\[:I]
.       char \[`O] _\[`O]
.       char \[^O] _\[^O]
.       char \['O] _\['O]
.       char \[:O] _\[:O]
.       char \[~O] _\[~O]
.       char \[/O] _\[/O]
.       char \[`U] _\[`U]
.       char \[^U] _\[^U]
.       char \['U] _\['U]
.       char \[:U] _\[:U]
.       char \[,C] _\[,C]
.       char \[-D] _\[-D]
.       char \[~N] _\[~N]
.       char \[TP] _\[TP]
.       char \['Y] _\['Y]
.       char \[:Y] _\[:Y]
.       char a _a
.       char b _b
.       char c _c
.       char d _d
.       char e _e
.       char f _f
.       char g _g
.       char h _h
.       char i _i
.       char j _j
.       char k _k
.       char l _l
.       char m _m
.       char n _n
.       char o _o
.       char p _p
.       char q _q
.       char r _r
.       char s _s
.       char t _t
.       char u _u
.       char v _v
.       char w _w
.       char x _x
.       char y _y
.       char z _z
.       char \[`a] _\[`a]
.       char \[^a] _\[^a]
.       char \['a] _\['a]
.       char \[:a] _\[:a]
.       char \[oa] _\[oa]
.       char \[~a] _\[~a]
.       char \[ae] _\[ae]
.       char \[`e] _\[`e]
.       char \[^e] _\[^e]
.       char \['e] _\['e]
.       char \[:e] _\[:e]
.       char \[`i] _\[`i]
.       char \[^i] _\[^i]
.       char \['i] _\['i]
.       char \[:i] _\[:i]
.       char \[`o] _\[`o]
.       char \[^o] _\[^o]
.       char \['o] _\['o]
.       char \[:o] _\[:o]
.       char \[~o] _\[~o]
.       char \[/o] _\[/o]
.       char \[`u] _\[`u]
.       char \[^u] _\[^u]
.       char \['u] _\['u]
.       char \[:u] _\[:u]
.       char \[,c] _\[,c]
.       char \[Sd] _\[Sd]
.       char \[~n] _\[~n]
.       char \[Tp] _\[Tp]
.       char \['y] _\['y]
.       char \[:y] _\[:y]
.       char \[ss] _\[ss]
.       char ' _'
.       char 1 _1
.       char 2 _2
.       char 3 _3
.       char 4 _4
.       char 5 _5
.       char 6 _6
.       char 7 _7
.       char 8 _8
.       char 9 _9
.       char 0 _0
.END
\#
\#
.MAC ULX END
\c\R'#UNDERLINE_ON 0'
.    rchar A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
     a b c d e f g h i j k l m n o p q r s t u v w x y z \
     \[`A] \[^A] \['A] \[:A] \[oA] \[~A] \[AE] \[`E] \[^E] \['E] \[:E] \
     \[`I] \[^I] \['I] \[:I] \[`O] \[^O] \['O] \[:O] \[~O] \[/O] \[`U] \
     \[^U] \['U] \[:U] \[,C] \[-D] \[~N] \[TP] \['Y] \[:Y] \
     \[`a] \[^a] \['a] \[:a] \[oa] \[~a] \[ae] \[`e] \[^e] \['e] \[:e] \[`i] \
     \[^i] \['i] \[:i] \[`o] \[^o] \['o] \[:o] \[~o] \[/o] \[`u] \[^u] \['u] \
     \[:u] \[,c] \[Sd] \[~n] \[Tp] \['y] \[:y] \[ss] \
     ' 1 2 3 4 5 6 7 8 9 0
.END
\#
\#
\# UNDERSCORE
\# ----------
\# *Arguments:
\#   [points below baseline] "text"
\# *Function:
\#   Places an underscore 2 points under the string if no lead given,
\#   otherwise places underscore under string by user specified amount.
\# *Notes:
\#   When using this macro, the string to be underscored must begin
\#   with double-quotes ("), regardless of whether it's the sole
\#   argument or the second.
\#   E.g.:
\#      .UNDERSCORE "Text to be underscored
\#         or
\#      .UNDERSCORE 2p "Text to be underscored
\#
\#   All text is underscored (including punctuation and spaces).
\#   This is the primary difference between UNDERLINE and UNDERSCORE,
\#   aside from the fact the UNDERLINE only works with Courier.
\#
\#   UNDERSCORE does not work across line breaks.  Each line of
\#   text must be entered separately with UNDERSCORE.  If the
\#   UNDERSCORE begins in the middle of a line and crosses over a
\#   break, the portion before the break must be entered in its own
\#   UNDERSCORE, as must the portion that comes after the break.
\#
.MAC UNDERSCORE END
.    nr #RESTORE_PT_SIZE \\n[#PT_SIZE]
.    ie \\n[#NUM_ARGS]=1 \{ \\$1\\s(12\\v'+2p'\\l'|0'\\v'-2p'\\s[\\n[#RESTORE_PT_SIZE]u] \}
.    el                  \{ \\$2\\s(12\\v'+(\\$1)'\\l'|0'\\v'-(\\$1)'\\s[\\n[#RESTORE_PT_SIZE]u] \}
.    rr #RESTORE_PT_SIZE
.END
\#
\#
\# DOUBLE UNDERSCORE
\# -----------------
\# *Arguments:
\#   [points below baseline] [points distance between rules] "text"
\# *Function:
\#   Same as UNDERSCORE, except it produces a double underscore.  The default
\#   distance between the rules is 2 points.
\# *Notes:
\#   The same double-quote requirement as UNDERSCORE.
\#
.MAC UNDERSCORE2 END
.    nr #RESTORE_PT_SIZE \\n[#PT_SIZE]
.    if \\n[#NUM_ARGS]=1 \{\
.       PRINT \\$1\\s(12\\v'+2p'\\l'|0'\\v'+2p'\\l'|0'\\v'-4p'\\s[\\n[#RESTORE_PT_SIZE]u]
.    \}
.    if \\n[#NUM_ARGS]=2 \{\
.       PRINT \\$2\\s(12\\v'+\\$1'\\l'|0'\\v'+2p'\\l'|0'\\v'-(2p+\\$1)'\\s[\\n[#RESTORE_PT_SIZE]u]
.    \}
.    if \\n[#NUM_ARGS]=3 \{\
.       PRINT \\$3\\s(12\\v'+\\$1'\\l'|0'\\v'+\\$2'\\l'|0'\\v'-(\\$2+\\$1)'\\s[\\n[#RESTORE_PT_SIZE]u]
.    \}
.    rr #RESTORE_PT_SIZE
.END
\#
\#
\# SUPERSCRIPT INLINES
\# -------------------
\# *Function:
\#   Prints everything after invocation as superscript.
\# *Notes:
\#   \*[SUP] and \*[SUPX] turn superscript on and off respectively.
\#   If running type is pseudo-condensed/expanded, invoke the superscript
\#   strings as \*[CONDSUP] or \*[EXTSUP] and turn off with \*[CONDSUPX]
\#   and \*[EXTSUPX] respectively.
\#
.ds SUP \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#SUP_PT_SIZE \En[#PT_SIZE_IN_UNITS]u*6u/10u'\
\s[\En[#PT_SIZE_IN_UNITS]u]\v'-.26m'\s[\En[#SUP_PT_SIZE]u]
\#
.ds SUPX \s[\En[#PT_SIZE_IN_UNITS]u]\v'.26m'
\#
.ds CONDSUP \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#SUP_PT_SIZE \En[#PT_SIZE_IN_UNITS]u*6u/10u'\
\s[\En[#PT_SIZE_IN_UNITS]u]\v'-.3m'\s[\En[#SUP_PT_SIZE]u]\E*[COND_FOR_SUP]
\#
.ds CONDSUPX \s[\En[#PT_SIZE_IN_UNITS]u]\v'.3m'\E*[COND]
\#
.ds EXTSUP \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#SUP_PT_SIZE \En[#PT_SIZE_IN_UNITS]u*6u/10u'\
\s[\En[#PT_SIZE_IN_UNITS]u]\v'-.3m'\s[\En[#SUP_PT_SIZE]u]\E*[EXT_FOR_SUP]
\#
.ds EXTSUPX \s[\En[#PT_SIZE_IN_UNITS]u]\v'.3m'\E*[EXT]
\#
\#
\# SLANT
\# -----
\#
\# SETSLANT
\# --------
\# *Arguments:
\#   <number of degrees> | RESET
\# *Function:
\#   Modifies register #DEGREES for use with \*[SLANT], or resets
\#   it to the default.  Defines string \*[SLANTX]
\# *Notes:
\#   \*[SLANT] permits pseudo-italicizing of a font in cases where
\#   no italic font exists in a particular family.
\#
\#   Default # of degrees is 15.
\#
\#   Do not use unit of measure with arg to SETSLANT.
\#
\#   It may be necessary to adjust the spacing on either side of
\#   [SLANT] and [SLANTX].
\#
\#   In docs, SLANT carries over from para to para.
\#
.nr #DEGREES 15
.ds SLANT \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.ds SLANTX \ER'#SLANT_ON 0'\ES'0'
\#
.MAC SETSLANT END
.    ie '\\$1'RESET' \{\
.       nr #DEGREES 15
.       if \\n[#PRINT_STYLE]=1 \{\
.          if \\n[#UNDERLINE_SLANT] \{ .return \}
.       \}
.       ds SLANT \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.    \}
.    el \{\
.       nr #DEGREES \\$1
.       if \\n[#PRINT_STYLE]=1 \{\
.          if \\n[#UNDERLINE_SLANT] \{ .return \}
.       \}
.       ds SLANT \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.    \}
.    ds SLANTX \ER'#SLANT_ON 0'\ES'0'
.END
\#
\#
\# BOLDER
\# ------
\#
\# SETBOLDER
\# ---------
\# *Arguments:
\#   <amount of emboldening> | RESET
\# *Function:
\#   Modifies register #BOLDER_UNITS for use with \*[BOLDER], or resets
\#   it to the default 700 units.
\# *Notes:
\#   \*[BOLDER] allows pseudo-emboldening of a font where no bold
\#   font exists in a particular family.
\#
\#   Default for SETBOLDER is 700 units.  Do not use unit of measure
\#   with arg to SETBOLDER.
\#
.nr #BOLDER_UNITS 700
\#
.MAC SETBOLDER END
.    if \\n[#IGNORE]=1 \{ .return \}
.    ie '\\$1'RESET' \{ .nr #BOLDER_UNITS 700 \}
.    el \{ .nr #BOLDER_UNITS \\$1 \}
.END
\#
\#
.MAC BOLDER END
\c
.bd \\n(.f \\n[#BOLDER_UNITS]
.END
\#
\#
.MAC BOLDERX END
\c
.bd \\n(.f
.END
\#
\# +++CONDENSE/EXTEND+++
\#
\# CONDENSE/EXTEND
\# ---------------
\# *Arguments:
\#   <percentage to condense/expand type size>
\# *Function:
\#   Stores current point size in z's in #PT_SIZE_IN_UNITS, figures out
\#   new point size (for character width) from arg, and defines string
\#   COND or EXT, which set the type size to the new character width,
\#   and sets the height of type to the value stored in CURRENT_PT_SIZE
\# *Notes:
\#   CONDENSE_OR_EXTEND is invoked from the aliases
\#   CONDENSE and EXTEND.  CONDENSE implies <100, EXTEND
\#   implies >100.  Do not use a percent sign in the argument.
\#
\#   There is no default setting for CONDENSE or EXTEND.
\#   80 is a good approximation of condensed type, 120 is okay
\#   for extended.
\#
\#   The value set by CONDENSE or EXTEND applies to all
\#   subsequent \*[COND] or \*[EXT] escapes until a new value is set.
\#
\#  \*[COND] or \*[EXT] must be turned off before all changes of point
\#  size and reinvoked afterwards (if so desired).  This refers to
\#  changes of point size via control lines AND with via inlines.
\#
.MAC CONDENSE_OR_EXTEND END
.    if '\\$0'CONDENSE' \{\
.       ds $COND_PERCENT \\$1
.       if \\n[#PRINT_STYLE]=1 \{\
.          rm $COND_PERCENT
.          ds $COND_PERCENT 100
.       \}
.       ds COND \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#CONDENSE 1'\
\R'#COND_WIDTH (\En[#PT_SIZE_IN_UNITS]u*\E*[$COND_PERCENT]u)/100'\
\Es[\En[#COND_WIDTH]u]\EH'\En[#PT_SIZE_IN_UNITS]u'
.       ds COND_FOR_SUP \
\R'#COND_WIDTH (\En[#SUP_PT_SIZE]u*\E*[$COND_PERCENT]u)/100'\
\Es[\En[#COND_WIDTH]u]\H'\En[#SUP_PT_SIZE]u'
.    \}
.    if '\\$0'EXTEND' \{\
.       ds $EXT_PERCENT \\$1
.       if \\n[#PRINT_STYLE]=1 \{\
.          rm $EXT_PERCENT
.          ds $EXT_PERCENT 100
.       \}
.       ds EXT \
\R'#PT_SIZE_IN_UNITS \En[.ps]'\
\R'#EXTEND 1'\
\R'#EXT_WIDTH (\En[#PT_SIZE_IN_UNITS]u*\E*[$EXT_PERCENT]u)/100'\
\Es[\En[#EXT_WIDTH]u]\EH'\En[#PT_SIZE_IN_UNITS]u'
.       ds EXT_FOR_SUP \
\R'#EXT_WIDTH (\En[#SUP_PT_SIZE]u*\E*[$EXT_PERCENT]u)/100'\
\Es[\En[#EXT_WIDTH]u]\H'\En[#EXT_PT_SIZE]u'
.    \}
.END
\#
.ds CONDX \ER'#CONDENSE 0'\Es0\R'#PT_SIZE_IN_UNITS \En[.ps]'\H'\En[#PT_SIZE_IN_UNITS]u'
.ds EXTX  \ER'#EXTEND   0'\Es0\R'#PT_SIZE_IN_UNITS \En[.ps]'\H'\En[#PT_SIZE_IN_UNITS]u'
\#
\#
\# +++PAD LINES+++ (insert space)
\#
\# PAD MARKER
\# ----------
\# *Arguments:
\#   <character to use for marking pad points>
\# *Function:
\#   Defines string $PAD_MARKER, used in PAD
\# *Notes:
\#   $PAD_MARKER is normally # (the pound sign).
\#
.MAC PAD_MARKER END
.    ds $PAD_MARKER \\$1
.END
\#
\#
\# PAD
\# ---
\# *Argments:
\#   "<string of text with padding markers inserted>"
\# *Function:
\#   Defines and redefines padding character (default=pound sign
\#   unless padding character has been set with PAD_MARKER)
\#   several times so that when the string is output at the end
\#   of the macro, every # has been converted to an equal-sized
\#   amount of padding (blank space) on a line. # is equivalent to
\#   CompuGraphic's old <IS>.
\# *Notes:
\#   String tabs may be marked off during PAD.
\#
.MAC PAD END
.    if \\n(.u=1 \{ .nr #FILL_MODE 1 \}
.    nf
.    if !d$PAD_MARKER .ds $PAD_MARKER #
.    char \\*[$PAD_MARKER] \R'#PAD_COUNT \En[#PAD_COUNT]+1'
.    ds $FAMILY_FOR_PAD \\n[.fam]
\#.    fp \\n[.fp] \\*[$FONT]
.    fp \\n[.fp] \\n[.sty]
.    ds $FONT_FOR_PAD   \\*[$FONT]
.    nr #SIZE_FOR_PAD   \\n[.ps]
.    ds $PAD_STRING \\$1
.    as $PAD_STRING \Ekp
.    di PAD_STRING
.    fam \\*[$FAMILY_FOR_PAD]
\\f[\\*[$FONT_FOR_PAD]]\\s[\\n[#SIZE_FOR_PAD]u]\\*[$PAD_STRING]
.    br
.    di
.    char \\*[$PAD_MARKER] \R'#SPACE_TO_END \En(.l-\Enp'\R'#PAD_SPACE \En[#SPACE_TO_END]/\En[#PAD_COUNT]'
.    di PAD_STRING
.    fam \\*[$FAMILY_FOR_PAD]
\\f]\\*[$FONT_FOR_PAD]]\\s[\\n[#SIZE_FOR_PAD]u]\\*[$PAD_STRING]
.    br
.    di
.    char \\*[$PAD_MARKER] \h'\En[#PAD_SPACE]u'
.    ie \\n[#SILENT] \{\
.       SILENT
.       fam \\*[$FAMILY_FOR_PAD]
\\f[\\*[$FONT_FOR_PAD]]\\s[\\n[#SIZE_FOR_PAD]u]\\*[$PAD_STRING]
.       br
.       SILENT OFF
.    \}
.    el \{\
.       fam \\*[$FAMILY_FOR_PAD]
\\f[\\*[$FONT_FOR_PAD]]\\s[\\n[#SIZE_FOR_PAD]u]\\*[$PAD_STRING]
.       br
.    \}
.    if \\n[#FILL_MODE]=1 \{\
.       fi
.       rr #FILL_MODE
.    \}
.    rr #PAD_COUNT
.    rr #SPACE_TO_END
.    rr #PAD_SPACE
.    rm $PAD_STRING
.    rm PAD_STRING
.    rchar #
.    if '\\$2'NOBREAK' \{\
.       TRAP OFF
.       EOL
.       TRAP
.    \}
.END
\#
\#
\# +++LEADERS+++
\#
.ig
The leader mechanism is primitive, but it works.  Basically, every
macro in this set that includes a line length also sets a single
groff tab stop at the right hand end of the line.  That way,
whenever Ctrl-A is invoked (always at the end of an input line),
leader of the correct length gets deposited.  Ctrl-A is accessed by
the string LEADER (i.e. inline, as \*[LEADER]).  Leaders within tabs
get their length from the tab line length.
..
\#
\# SET LEADER CHARACTER
\# --------------------
\# *Arguments:
\#   <character to use whenever \*[LEADER] is invoked>
\# *Function:
\#   Set leader character.
\#
.MAC LEADER_CHARACTER END
.    lc \\$1
.END
\#
.ds LEADER 
\#
\# +++DROP CAPS+++
\#
\# DROP CAP FAMILY
\# ---------------
\# *Argument:
\#   <family of drop cap>
\# *Function:
\#   Creates or modifies string $DC_FAM.
\#
.MAC DROPCAP_FAMILY END
.    ds $DC_FAM \\$1
.END
\#
\#
\# DROP CAP FONT
\# -------------
\# *Argument:
\#   <font of drop cap>
\# *Function:
\#   Creates or modifies string $DC_FT.
\#
.MAC DROPCAP_FONT END
.    ds $DC_FT \\$1
.END
\#
\#
\# DROPCAP COLOR
\# -------------
\# *Arguments:
\#   <pre-defined XCOLOR or NEWCOLOR>
\# *Function:
\#   Defines string $DC_COLOR to argument.
\# *Notes:
\#   User must define an XCOLOR or NEWCOLOR before using
\#   DC_COLOR.
\#
.MAC DROPCAP_COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    nr #DC_COLOR 1
.    ds $DC_COLOR \\$1
.END
\#
\#
\# DROP CAP GUTTER
\# ---------------
\# *Argument:
\#   <width of gutter between drop cap and indented text>
\# *Function:
\#   Creates or modifies register #DC_GUT.
\# *Notes:
\#   Requires unit of measure.  Default is 3p.
\#
.MAC DROPCAP_GUTTER END
.    nr #DC_GUT (\\$1)
.END
\#
\#
\# DROP CAP ADJUST
\# ---------------
\# *Argument:
\#   <+|- # of points to in/decrease point size of drop cap letter>
\# *Function:
\#   Creates or modifies string $DC_ADJUST.
\# *Notes:
\#   Despite its best efforts, DROPCAP doesn't always get the point
\#   size of the drop cap critically perfect.  DROPCAP_ADJUST lets
\#   the user add or subtract points (or fractions of points) to
\#   get the size right.
\#
\#   Requires the + or - sign.
\#
.MAC DROPCAP_ADJUST END
.    ds $DC_ADJUST \\$1
.END
\#
\#
\# DROP CAP
\# --------
\# *Arguments:
\#   <dropcap letter> <# of lines> [COND <% to condense> | EXT <% to extend>]
\# *Function:
\#   Calculates point size of dropcap based on # of lines passed as
\#   arg 2.  Sets indent for text based on dropcap width+gutter.
\#   Advances and prints dropcap; reverses and prints indented text
\#   to bottom of dropcap, then resets indent to left margin (plus
\#   any indent that was in effect prior to invoking DROPCAP).
\# *Notes:
\#   Drop caps put a strain on on resource-challenged systems.
\#
\#   Drop caps when using the doc processing macro PP only work with
\#   initial paragraphs (i.e. at doc start, or after heads), only when
\#   DROPCAPS comes immediately after PP, and only when the PRINTSTYLE
\#   is TYPESET.  If these conditions aren't met, DROPCAPS is silently
\#   ignored.
\#
\#   The COND or EXT argument are processed separately from all
\#   other COND or EXT inlines or macros, hence passing COND or
\#   EXT has no effect on running type.
\#
.MAC DROPCAP END
.    if #IGNORE \{ .return \}
.    br
.    if \\n[#DOCS] \{\
.       if \\n[#PRINT_STYLE]=1 \{ .return \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          if \\n[#PP_STYLE]=2 \{ .return \}
.          if \\n[#PP]>1 \{ .return \}
.          ti 0
.       \}
.    \}
.    ds $DROPCAP         \\$1
.    nr #DC_LINES        \\$2-1
.    if \\n[#CONDENSE]=1 \{\
.       ds $RESTORE_COND \\*[$COND_PERCENT]
\\*[CONDX]
.       nr #CONDENSE_WAS_ON 1
.    \}
.    if \\n[#EXTEND]=1 \{\
.       ds $RESTORE_EXT \\*[$EXT_PERCENT]
\\*[EXTX]
.       nr #EXTEND_WAS_ON 1
.    \}
.    if '\\$3'COND'      \{ .CONDENSE \\$4 \}
.    if '\\$3'EXT'       \{ .EXTEND \\$4 \}
.    if !r#DC_GUT        \{ .nr #DC_GUT (3p) \}
.    ds $RESTORE_FAM     \\n[.fam]
.    ds $RESTORE_FT      \\*[$FONT]
.    nr #RESTORE_PT_SIZE \\n[#PT_SIZE]
.    nr #RESTORE_INDENT  \\n(.i
.    SIZESPECS
.    nr #DC_HEIGHT \\n[#DC_LINES]*\\n[#LEAD]+\\n[#CAP_HEIGHT]
.    ie !d$DC_FAM \{ .FAM \\n[.fam] \}
.    el \{ .FAM \\*[$DC_FAM] \}
.    ie !d$DC_FT \{ .FT \\*[$FONT] \}
.    el \{ .FT \\*[$DC_FT] \}
.    while \\n[#GET_DC_HEIGHT]<\\n[#DC_HEIGHT] \{\
.       ps \\n[#PT_SIZE]u+100u
.       SIZESPECS
.       nr #GET_DC_HEIGHT \\n[#CAP_HEIGHT]
.\}
.    if d$DC_ADJUST \{ .ps \\*[$DC_ADJUST]p \}
.    mk x
.    sp \\n[#DC_LINES]v
.    ie \\n[#DC_COLOR]=1 \{\
.       ie !'\\$3'' \{\
.          ie '\\$3'COND' \{ .PRINT \m[\\*[$DC_COLOR]]\\*[COND]\\*[$DROPCAP]\\*[CONDX]\m[] \}
.          el \{ .PRINT \m[\\*[$DC_COLOR]]\\*[EXT]\\*[$DROPCAP]\\*[EXTX]\m[] \}
.       \}
.       el \{ .PRINT \m[\\*[$DC_COLOR]]\\*[$DROPCAP]\m[] \}
.    \}
.    el \{\
.       ie !'\\$3'' \{\
.          ie '\\$3'COND' \{ .PRINT \\*[COND]\\*[$DROPCAP]\\*[CONDX] \}
.          el \{ .PRINT \\*[EXT]\\*[$DROPCAP]\\*[EXTX] \}
.       \}
.       el \{ .PRINT \m[\\*[$DC_COLOR]]\\*[$DROPCAP]\m[] \}
.    \}
.    if '\\$3'COND' \{ \E*[COND] \}
.    if '\\$3'EXT'  \{ \E*[EXT]  \}
.    ie \\n(.i \{ .in +\w'\\*[$DROPCAP]'u+\\n[#DC_GUT]u \}
.    el        \{ .in \w'\\*[$DROPCAP]'u+\\n[#DC_GUT]u \}
.    if '\\$3'COND' \{ \E*[CONDX]\c \}
.    if '\\$3'EXT'  \{ \E*[EXTX]\c \}
.    rt \\nxu
.    FAM \\*[$RESTORE_FAM]
.    FT  \\*[$RESTORE_FT]
.    ps \\n[#RESTORE_PT_SIZE]u
.    if \\n[#CONDENSE_WAS_ON] \{\
.       CONDENSE \\*[$RESTORE_COND]
\\*[COND]\c
.    \}
.    if \\n[#EXTEND_WAS_ON] \{\
.       EXTEND \\*[$RESTORE_EXT]
\\*[EXT]\c
.    \}
.    ie \\n(.u \{ .wh \\n(.du+\\n[#DC_HEIGHT]u-1v DROPCAP_OFF \}
.    el \{ .wh \\n(.du+\\n[#DC_HEIGHT]u DROPCAP_OFF \}
.    rr #CONDENSE_WAS_ON
.    rr #EXTEND_WAS_ON
.    rm $DROPCAP
.    rr #DC_LINES
.    rm $RESTORE_COND
.    rm $RESTORE_EXT
.    rm $RESTORE_FAM
.    rm $RESTORE_FT
.    rr #RESTORE_PT_SIZE
.    rr #RESTORE_INDENT
.    rr #DC_HEIGHT
.    rr #GET_DC_HEIGHT
.    rr x
.END
\#
.MAC DROPCAP_OFF END
'    in \\n[#RESTORE_INDENT]u
.END
\#
\#
\# RULE
\# ----
\# *Argument:
\#   <none>
\# *Function:
\#   Draws a rule the length of the current measure.
\# *Notes:
\#
.MAC RULE END
\c
.    EL
.    if \\n(.u=1 \{\
.       nr #FILL_WAS_ON 1
.       ds $CURRENT_QUAD \\*[$QUAD_VALUE]
.       nf
.    \}
.    ie \\n[#INDENT_ACTIVE] \{\
.       nr #RESTORE_L_LENGTH \\n(.l
.       if \\n[#INDENT_BOTH_ACTIVE] \{ .ll \\n(.lu-\\n[#BL_INDENT]u \}
.       if \\n[#INDENT_LEFT_ACTIVE] \{ .ll \\n(.lu-\\n[#L_INDENT]u \}
.       PRINT \El'\En(.lu'\c
.       ll \\n[#RESTORE_L_LENGTH]u
.       rr #RESTORE_L_LENGTH
.    \}
.    el \{\
.       PRINT \El'\En(.lu'\c
.    \}
.    if r#FILL_WAS_ON \{\
.       fi
.       rr #FILL_WAS_ON
.       QUAD \\*[$CURRENT_QUAD]
.       rm $CURRENT_QUAD
.    \}
.    EL
.END
\#
\# =====================================================================
\#
\# +++WORD AND SENTENCE SPACING+++
\#
\# WORD SPACE CONTROL
\# ------------------
\# *Argument:
\#   <+|->wordspace | DEFAULT
\# *Function:
\#   Increases or decreases interword space by user supplied amount.
\#   If DEFAULT, value is set to 12 (groff default).
\# *Notes:
\#   $WS_CONSTANT is the groff default word space.
\#   $WS_VAR is the user supplied amount by which to in/decrease word space.
\#   $WS is a concatenation of WS_CONSTANT and WS_VAR.
\#
\#   Because the user supplied value requires a literal + or - sign,
\#   the macro argument is stored in a string.
\#
\#   \n[.sss] holds the current sentence space value.
\#
.MAC WS END
.    ds $WS_CONSTANT 12
.    ds $WS_VAR \\$1
.    ie '\\$1'DEFAULT' .ds $WS_VAR +0
.    el                .ds $WS (\\*[$WS_CONSTANT]\\*[$WS_VAR])
.    ie \\n[.sss]=12   \{ .ss \\*[$WS] 12 \}
.    el \{\
.       ss \\*[$WS] (\\*[$WS]\\*[$SS_VAR])
.       SS \\*[$SS_VAR]
.    \}
.END
\#
\#
\# SENTENCE SPACE CONTROL
\# ----------------------
\# *Argument:
\#   <+-sentencespace> | 0 | DEFAULT
\# *Function:
\#   Increases or decreases sentence space by user supplied amount.
\#   If 0, sentence spaces are ignored.  If DEFAULT, value is
\#   set to 12 (groff default).
\# *Notes:
\#   Because the user supplied value requires a literal + or - sign,
\#   the macro argument is stored in a string.
\#
\#   Sentence space applies only to input where sentences are separated
\#   by two spaces (and/or, in fill mode [FLUSH L|R|C or JUSTIFY], an EOL).
\#   Changing .SS when sentences are separated by only one space has
\#   no effect on the space between sentences.
\#
\#   \n[.ss] holds the current wordspace value.
\#   \n[.sss] holds the current sentence space value.
\#
.MAC SS END
.    ie '\\$1'0' \{ .ss \\n[.ss] (\\n[.ss]-\\n[.ss]) \}
.    el \{\
.       ie '\\$1'DEFAULT' \{ .ss \\n[.ss] \}
.       el \{\
.          ds $SS_VAR \\$1
.          ss \\n[.ss] (0\\*[$SS_VAR])
.       \}
.    \}
.END
\#
\#
\# =====================================================================
\#
\# +++INDENTS+++
\#
.ig
There are five styles of indents: left, right, both, temporary,
and hanging.  Each is set/invoked with a different macro.
Indent macros begin with the letter "I", hence .IL means "indent left,"
.IR means "indent right," and so on.

The first time any of the indent macros is used, it requires an
argument--the size of the indent (with a unit of measure).  The
size may also be entered using the \w escape--very useful
for numbered lists using HI.  The unit of measure is required.
Subsequent invocations don't require the argument; the indent
measure remains the same until it's changed by invoking the macro
with an argument again.

If no indents are in effect, the arguments passed to indent macros are
measured from the left and right margins of the page.  If a left indent
or a right indent is already in effect, the arguments passed to
the indent macros are calculated from the current values; in other words,
the arguments are additive.  If you quit an indent and later return
to it, its value will be the value last in effect, unless you pass
it an argument.  If you do pass an argument, it is added to the last
value in effect, unless you cleared the indent with one of
.I<LRB>X/Q macros.

Example
-------

.IL 2P
...some text...
.IL 2P
...some text...
.IQ
...some text...
.IL
...some text...

The first .IL 2P indents text 2P from the left margin.  The second
.IL 2P indents text by an additional 2P, i.e. 4P from the left margin.
.IQ turns the indent off.  The last .IL (which has no argument)
takes its value from the total of all arguments passed to .IL (in
this case, 2P and 2P), therefore it indents 2P+2P from the left
margin, i.e. 4P.  If you wanted the last .IL to indent just 2P,
you'd either have to reset the .IL prior to .IQ (.IL -2P), or pass
the last .IL the argument 2P.

To reverse the sense of an indent added to an indent, you may use
negative values.

Indents can be turned off individually with ILX, IRX, and IBX.
LEFT and RIGHT indents may be combined and manipulated
separately, (e.g. you can have an IL of 2P and an IR of 4P
operative at the same time, and then change, say, the IL to
4P--thereby left indenting 6P--while the IR remains at 4P.

IB automatically turns off IL and IR.  They have to be reinvoked
again when needed. IL and IR automatically turn IB off; it, too,
has to be reinvoked with needed.

All indents can be turned off at once with IQ.  The ILX, IRX, IBX,
and IQ macros simply turn the indents off; the values stored in
the respective indent macros (IL, IR, IB) remain in effect.  If
the user wishes to clear the values, the I<LRB>X macros should be
invoked with the single argument CLEAR.  IQ CLEAR clears out
the values stored for all indent styles.

Indents *must* be turned off before settting string tabs
inside PAD.  Generally, in order not to get confused, it's a
good idea to turn all indents off before setting any tabs.

TI and HI are special cases.  There's no need to turn them off,
since they affect only one line--the first after their
invocation.  Like the other indent styles, the first time
they're invoked, they require a value in iPpcm; each subsequent
invocation without an argument will use the same value.  To
change the value, simply pass a new value.  Values for TI and HI
are *not* additive.

HI presupposes that you already have a left or both indent on.
HI will never hang a line outside the left margin of a document
or column.  In other words, you must have IL or IB on before you
can use HI.
..
\#
\# INDENT LEFT
\# -----------
\#
.MAC IL END
.    if \\n[#INDENT_STYLE_BOTH] \{ .IBX \}
.    nr #INDENT_STYLE_LEFT  1
.    nr #INDENT_ACTIVE      1
.    nr #INDENT_LEFT_ACTIVE 1
.    ie '\\$1'' \{\
.       br
.       in \\n[#L_INDENT]u
.       ta \\n(.lu-\\n[#L_INDENT]u
.    \}
.    el \{\
.       br
.       nr #L_INDENT +(\\$1)
.       in \\n[#L_INDENT]u
.       ta \\n(.lu-\\n[#L_INDENT]u
.    \}
.END
\#
\#
\# +++INDENT RIGHT+++
\#
.MAC IR END
.    if \\n[#INDENT_STYLE_BOTH] \{ .IBX \}
.    nr #INDENT_STYLE_RIGHT   1
.    nr #INDENT_ACTIVE        1
.    nr #INDENT_RIGHT_ACTIVE 1
.    ie '\\$1'' \{\
.       br
.       ie \\n[#TAB_ACTIVE] \{\
.          ll \\n(.lu-\\n[#R_INDENT]u
.          ta \\n(.lu-\\n[#L_INDENT]u
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u-\\n[#R_INDENT]u
.          ta \\n(.lu-\\n[#L_INDENT]u
.       \}
.    \}
.    el \{\
.       br
.       nr #R_INDENT +(\\$1)
.       ie \\n[#TAB_ACTIVE] \{\
.          ll \\n(.lu-\\n[#R_INDENT]u
.          ta \\n(.lu-\\n[#L_INDENT]u
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u-\\n[#R_INDENT]u
.          ta \\n(.lu-\\n[#L_INDENT]u
.       \}
.    \}
.END
\#
\#
\# +++INDENT BOTH+++
\#
.MAC IB END
.    if \\n[#INDENT_STYLE_LEFT]  \{ .ILX \}
.    if \\n[#INDENT_STYLE_RIGHT] \{ .IRX \}
.    nr #INDENT_STYLE_BOTH  1
.    nr #INDENT_ACTIVE      1
.    nr #INDENT_BOTH_ACTIVE 1
.    ie '\\$1'' \{\
.       br
.       in \\n[#BL_INDENT]u
.       ie \\n[#TAB_ACTIVE] \{\
.          ll \\n(.lu-\\n[#BR_INDENT]u
.          ta \\n(.lu-\\n[#BR_INDENT]u
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u-\\n[#BR_INDENT]u
.          ta \\n(.lu-\\n[#BR_INDENT]u
.       \}
.    \}
.    el \{\
.       br
.       nr #BL_INDENT (\\n[#INDENT]+\\$1)
.       ie \\n[#NUM_ARGS]=2 \{ .nr #BR_INDENT +(\\$2) \}
.       el                  \{ .nr #BR_INDENT \\n[#BL_INDENT] \}
.       ie \\n[#TAB_ACTIVE] \{\
.          in \\n[#BL_INDENT]u
.          ll \\n(.lu-\\n[#BR_INDENT]u
.          ta \\n(.lu-\\n[#BL_INDENT]u
.       \}
.       el \{\
.          in \\n[#BL_INDENT]u
.          ll \\n[#L_LENGTH]u-\\n[#BR_INDENT]u
.          ta \\n(.lu-\\n[#BR_INDENT]u
.       \}
.    \}
.END
\#
\#
\# +++TEMPORARY INDENT+++
\#
.MAC TI END
.    br
.    ie '\\$1'' \{\
.       ti \\n[#T_INDENT]u
.       if \\n[#INDENT_LEFT_ACTIVE] \{\
.          ti \\n[#T_INDENT]u+\\n[#L_INDENT]u
.       \}
.       if \\n[#INDENT_BOTH_ACTIVE] \{\
.          ti \\n[#T_INDENT]u+\\n[#BL_INDENT]u
.       \}
.    \}
.    el \{\
.       nr #T_INDENT (\\$1)
.       ti \\n[#T_INDENT]u
.    \}
.END
\#
\#
\# +++HANGING INDENT+++
\#
.MAC HI END
.    ie '\\$1'' \{ .ti -\\n[#HL_INDENT]u \}
.    el \{\
.       nr #HL_INDENT (\\$1)
.       ti -\\n[#HL_INDENT]u
.    \}
.END
\#
\#
\# +++INDENTS OFF+++
\#
.MAC ILX END
.    br
.    in 0
.    rr #INDENT_LEFT_ACTIVE
.    if '\\$1'CLEAR' \{\
.       rr #L_INDENT
.       rr #INDENT_STYLE_LEFT
.    \}
.END
\#
\#
.MAC IRX END
.    br
.    rr #INDENT_RIGHT_ACTIVE
.    ie \\n[#TAB_ACTIVE] \{ .TAB\\n[#CURRENT_TAB] \}
.    el \{\
.       ie \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u
.          ta \\n(.lu
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u
.          ta \\n(.lu
.       \}
.    \}
.    if '\\$1'CLEAR' \{\
.       rr #R_INDENT
.       rr #INDENT_STYLE_RIGHT
.    \}
.END
\#
\#
.MAC IBX END
.    br
.    in 0
.    rr #INDENT_BOTH_ACTIVE
.    ie \\n[#TAB_ACTIVE] \{ .TAB\\n[#CURRENT_TAB] \}
.    el \{\
.       ie \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u
.          ta \\n(.lu
.       \}
.       el \{\
.          ll \\n[#L_LENGTH]u
.          ta \\n(.lu
.       \}
.    \}
.    if '\\$1'CLEAR' \{\
.       rr #BL_INDENT
.       rr #BR_INDENT
.       rr #INDENT_STYLE_BOTH
.    \}
.END
\#
\#
.MAC IX END
.    if '\\$0'IX' \{\
.       if !\\n[#IX_WARN] \{\
.          tm1 "[mom]: Use of .IX is now deprecated.  Use .IQ instead.
.          tm1 "      .IX will continue to behave as before, but to
.          tm1 "       avoid this message, please update your document.
.          nr #IX_WARN 1
.       \}
.    \}
.    br
.    in 0
.    rr #INDENT_LEFT_ACTIVE
.    rr #INDENT_RIGHT_ACTIVE
.    rr #INDENT_BOTH_ACTIVE
.    if \\n[#INDENT_STYLE_RIGHT] \{\
.       ie \\n[#TAB_ACTIVE] \{ .TAB\\n[#CURRENT_TAB] \}
.       el \{\
.          ie \\n[#COLUMNS] \{\
.             ll \\n[#COL_L_LENGTH]u
.             ta \\n(.lu
.          \}
.          el \{\
.             ll \\n[#L_LENGTH]u
.             ta \\n(.lu
.          \}
.       \}
.    \}
.    if \\n[#INDENT_STYLE_BOTH] \{\
.       ie \\n[#TAB_ACTIVE] \{ .TAB\\n[#CURRENT_TAB] \}
.       el \{\
.          ie \\n[#COLUMNS] \{\
.             ll \\n[#COL_L_LENGTH]u
.             ta \\n(.lu
.          \}
.          el \{\
.             ll \\n[#L_LENGTH]u
.             ta \\n(.lu
.          \}
.       \}
.    \}
.    if '\\$1'CLEAR' \{\
.       if \\n[#INDENT_STYLE_RIGHT] \{\
.          ie \\n[#TAB_ACTIVE] \{ .TAB\\n[#CURRENT_TAB] \}
.          el \{\
.             ie \\n[#COLUMNS] \{\
.                ll \\n[#COL_L_LENGTH]u
.                ta \\n(.lu
.             \}
.             el \{\
.                ll \\n[#L_LENGTH]u
.                ta \\n(.lu
.             \}
.          \}
.       \}
.       if \\n[#INDENT_STYLE_BOTH] \{\
.          ie \\n[#TAB_ACTIVE] \{ .TAB\\n[#CURRENT_TAB] \}
.          el \{\
.             ie \\n[#COLUMNS] \{\
.                ll \\n[#COL_L_LENGTH]u
.                ta \\n(.lu
.             \}
.             el \{\
.                ll \\n[#L_LENGTH]u
.                ta \\n(.lu
.             \}
.          \}
.       \}
.       rr #L_INDENT
.       rr #R_INDENT
.       rr #BL_INDENT
.       rr #BR_INDENT
.       rr #T_INDENT
.       rr #H_INDENT
.       rr #INDENT_STYLE_LEFT
.       rr #INDENT_STYLE_RIGHT
.       rr #INDENT_STYLE_BOTH
.    \}
.    rr #INDENT_ACTIVE
.END
\#
\# =====================================================================
\#
\# +++MULTIPLE COLUMNS+++
\#
\# MULTIPLE COLUMNS ON
\# -------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Marks the top of a column set
\#
.MAC MCO END
.mk c
.END
\#
\# MULTIPLE COLUMN RETURN
\# ----------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Returns to the top of a column set
\#
.MAC MCR END
.    TRAP OFF
.    sp |\\ncu
.    TRAP
.END
\#
\# MULTIPLE COLUMNS OFF
\# --------------------
\# *Arguments:
\#   <none> | <lead to advance beneath bottom of deepest column>
\# *Function:
\#   Advances to the end of a column set
\# *Notes:
\#   With no argument, advances to the next baseline (at the current
\#   leading value) beneath the longest column.  With an argument
\#   (which requires a unit of measure), advances arg distance
\#   beneath the baseline of the deepest column.  If the argument
\#   is zero, advances to the baseline of the deepest column.
\#
.MAC MCX END
.    ie '\\$1'' \{\
.       TQ
.       sp |\\n(.hu
.    \}
.    el \{\
.       nr #MCX_ALD (\\$1)
.       TQ
.       ie \\n[#MCX_ALD]=0 \{ .sp |\\n(.hu-1v \}
.       el \{ .sp |\\n(.hu+\\n[#MCX_ALD]u \}
.       rr #MCX_ALD
.    \}
.END
\#
\# =====================================================================
\#
\# +++TYPESETTING SUPPORT MACROS+++
\#
\# TRAP
\# ----
\# *Arguments:
\#   toggle
\# *Function:
\#   Enables/disables traps.
\# *Notes:
\#   EL and TN don't function as advertised on the last line before
\#   a trap (when they break the preceding line, they spring the
\#   trap, and groff won't back up to the line preceding the trap).
\#   TRAP is a kludge to get EL and TN work properly on last lines.
\#   The user simply enloses the offending lines in TRAP OFF/TRAP.
\#
.MAC TRAP END
.    ie '\\$1'' \{ .vpt 1 \}
.    el \{ .vpt 0 \}
.END
\#
\#
\# SILENT
\# ------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Diverts text so that it doesn't print, or turns the function off.
\# *Notes:
\#   Useful for setting up autotabs where you don't want the line with
\#   the tab marks to print.
\#
\#   Also aliased as COMMENT, in case user wants to input a batch of
\#   text that doesn't print.
\#
.MAC SILENT END
.    nr #SILENT 1
.    if \\n[#QUAD] \{ .br \}
.    ie '\\$1'' \{ .di NO_FLASH \}
.    el \{\
.       br
.       di
.       rm NO_FLASH
.       rr #SILENT
.    \}
.END
\#
\#
\# PRINT
\# -----
\# *Function:
\#   Prints anything.  A macro that helps keep my code nicely indented.
\#
.MAC PRINT END
.    nop \\$*
.END
\#
\#
\# CAPS
\# ----
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Converts text to caps, or, if OFF, reverts to normal caps/lc.
\#
.MAC CAPS END
.    ie '\\$1'' \{\
.       tr aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
.       tr à\[`A]
.       tr â\[^A]
.       tr á\['A]
.       tr ä\[:A]
.       tr å\[oA]
.       tr ã\[~A]
.       tr æ\[AE]
.       tr è\[`E]
.       tr ê\[^E]
.       tr é\['E]
.       tr ë\[:E]
.       tr ì\[`I]
.       tr î\[^I]
.       tr í\['I]
.       tr ï\[:I]
.       tr ò\[`O]
.       tr ô\[^O]
.       tr ó\['O]
.       tr ö\[:O]
.       tr õ\[~O]
.       tr ø\[/O]
.       tr ù\[`U]
.       tr û\[^U]
.       tr ú\['U]
.       tr ü\[:U]
.       tr ç\[,C]
.       tr ð\[-D]
.       tr ñ\[~N]
.       tr þ\[TP]
.       tr ý\['Y]
.       tr ÿ\[:Y]
.       nr #CAPS_ON 1
.    \}
.    el \{\
.       tr aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz
.       tr à\[`a]
.       tr â\[^a]
.       tr á\['a]
.       tr ä\[:a]
.       tr å\[oa]
.       tr ã\[~a]
.       tr æ\[ae]
.       tr è\[`e]
.       tr ê\[^e]
.       tr é\['e]
.       tr ë\[:e]
.       tr ì\[`i]
.       tr î\[^i]
.       tr í\['i]
.       tr ï\[:i]
.       tr ò\[`o]
.       tr ô\[^o]
.       tr ó\['o]
.       tr ö\[:o]
.       tr õ\[~o]
.       tr ø\[/o]
.       tr ù\[`u]
.       tr û\[^u]
.       tr ú\['u]
.       tr ü\[:u]
.       tr ç\[,c]
.       tr ð\[Sd]
.       tr ñ\[~n]
.       tr þ\[Tp]
.       tr ý\['y]
.       tr ÿ\[:y]
.       rr #CAPS_ON
.    \}
.END
\#
\# SIZESPECS
\# ---------
\# Argument:
\#   <none>
\# Function:
\#   Gets cap-height, x-height, and descender depth of the
\#   current font at the current point size.
\# *Notes:
\#   The routine is diverted so it remains invisible to output.
\#
.MAC SIZESPECS END
.    di TYPESIZE
E\\R'#CAP_HEIGHT \\n[.cht]'
e\\R'#X_HEIGHT \\n[.cht]'
y\\R'#DESCENDER \\n[.cdp]'
.    br
.    di
.END
\#
\# =====================================================================
\#
\# +++TYPESETTING ALIASES+++
\#
.ALIAS    ADD_SPACE       ALD
.ALIAS    CENTRE          CENTER
.ALIAS    COLOUR          COLOR
.ALIAS    COMMENT         SILENT
.ALIAS    CONDENSE        CONDENSE_OR_EXTEND
.ALIAS    EXTEND          CONDENSE_OR_EXTEND
.ALIAS    FAM             FAMILY
.ALIAS    HYPHENATE       HY
.ALIAS    HYPHENATION     HY
.ALIAS    HYSET           HY_SET
.ALIAS    IBQ             IBX
.ALIAS    ILQ             ILX
.ALIAS    IQ              IX
.ALIAS    IRQ             IRX
.ALIAS    LIG             LIGATURES
.ALIAS    NEWCOLOUR       NEWCOLOR
.ALIAS    PADMARKER       PAD_MARKER
.ALIAS    SP              ALD
.ALIAS    SPACE           ALD
.ALIAS    TABSET          TAB_SET
.ALIAS    TB              TAB
.ALIAS    UNDERSCORE_2    UNDERSCORE2
.ALIAS    XCOLOUR         XCOLOR
\#
\#
\# ====================================================================
\#
\# DOCUMENT PROCESSING MACROS, STRINGS AND ALIASES
\# ===============================================
\#
\# +++PAGE DIMENSIONS+++
\#
\# PAPER SIZE
\# ----------
\# *Arguments:
\#   LETTER | LEGAL | STATEMENT | TABLOID | LEDGER | FOLIO | QUARTO | 10x14 | EXECUTIVE | A3 | A4 | A5 | B4 | B5
\# *Function:
\#   Sets up dimensions for different paper sizes.
\#
.MAC PAPER END
.    ds $PAPER \\$1
.    if '\\*[$PAPER]'LETTER' \{\
.       PAGEWIDTH  8.5i
.       PAGELENGTH 11i
.    \}
.    if '\\*[$PAPER]'LEGAL' \{\
.       PAGEWIDTH  8.5i
.       PAGELENGTH 14i
.    \}
.    if '\\*[$PAPER]'STATEMENT' \{\
.       PAGEWIDTH  5.5i
.       PAGELENGTH 8.5i
.    \}
.    if '\\*[$PAPER]'TABLOID' \{\
.       PAGEWIDTH  11i
.       PAGELENGTH 17i
.    \}
.    if '\\*[$PAPER]'LEDGER' \{\
.       PAGEWIDTH  17i
.       PAGELENGTH 11i
.    \}
.    if '\\*[$PAPER]'FOLIO' \{\
.       PAGEWIDTH  8.5i
.       PAGELENGTH 13i
.    \}
.    if '\\*[$PAPER]'QUARTO' \{\
.       PAGEWIDTH  610p
.       PAGELENGTH 780p
.    \}
.    if '\\*[$PAPER]'10x14' \{\
.       PAGEWIDTH  10i
.       PAGELENGTH 14i
.    \}
.    if '\\*[$PAPER]'EXECUTIVE' \{\
.       PAGEWIDTH  7.25i
.       PAGELENGTH 10.5i
.    \}
.    if '\\*[$PAPER]'A3' \{\
.       PAGEWIDTH  842p
.       PAGELENGTH 1190p
.    \}
.    if '\\*[$PAPER]'A4' \{\
.       PAGEWIDTH  595p
.       PAGELENGTH 842p
.    \}
.    if '\\*[$PAPER]'A5' \{\
.       PAGEWIDTH  421p
.       PAGELENGTH 595p
.    \}
.    if '\\*[$PAPER]'B4' \{\
.       PAGEWIDTH  709p
.       PAGELENGTH 1002p
.    \}
.    if '\\*[$PAPER]'B5' \{\
.       PAGEWIDTH  501p
.       PAGELENGTH 709p
.    \}
.    if !r#L_MARGIN \{ .L_MARGIN \\n(.o \}
.    if !r#R_MARGIN \{ .R_MARGIN 1i \}
.END
\#
\#
\# ====================================================================
\#
\# +++PRINTSTYLE -- TYPEWRITE OR TYPESET+++
\#
\# PRINTSTYLE
\# ----------
\# *Arguments:
\#   TYPESET | TYPEWRITE [SINGLESPACE]
\# *Function:
\#   Sets type specs for typewriter-style or typeset output.
\# *Notes:
\#   Number registers: TYPEWRITE=1, TYPESET=2.
\#
.MAC PRINTSTYLE END
.    if !\\n[#COLLATE]=1 \{\
.       if !d$PAPER \{ .PAPER LETTER \}
.       if '\\$1'TYPEWRITE' \{\
.          nr #PRINT_STYLE 1
.          if !\\n[#DOC_TYPE]=4 \{ .L_MARGIN 6P \}
.          if !\\n[#DOC_TYPE]=4 \{ .R_MARGIN 6P \}
.          TYPEWRITER
.          color 0
.          ie '\\$2'SINGLESPACE' \{\
.             nr #SINGLE_SPACE 1
.             vs 12
.             nr #ORIGINAL_DOC_LEAD \\n(.v
.          \}
.          el \{\
.             vs 24
.             nr #ORIGINAL_DOC_LEAD \\n(.v
.          \}
.          QUAD    L
.          HY      OFF
.          SMARTQUOTES OFF
.          if !\\n[#PP_INDENT] \{\
.             in 3P                 \"Set indent
.             nr #PP_INDENT \\n(.i  \"Read into #PP_INDENT
.             in 0                  \"Remove indent
.          \}
.          HDRFTR_RIGHT_CAPS
.          nr #BOLDER_UNITS 0
.          nr #CONDENSE 0
.          nr #EXTEND 0
.          rm IT
.          rm BD
.          rm BDI
.          rm PREV
.          UNDERLINE_SLANT
.          UNDERLINE_ITALIC
.          UNDERLINE_QUOTES
.          nr #IGNORE_COLUMNS 1
.          char \(em --
.          tr `'
.       \}
.       if '\\$1'TYPESET' \{\
.          nr #PRINT_STYLE 2
.          if !\\n[#DOC_TYPE]=4 \{ .L_MARGIN 6P \}
.          if !\\n[#DOC_TYPE]=4 \{ .R_MARGIN 6P \}
.          FAMILY  T
.          FT      R
.          if !\\n[#DOC_TYPE]=4 \{ .PT_SIZE 12.5 \}
.          if !\\n[#DOC_TYPE]=4 \{ .LS 16 \}
.          JUSTIFY
.          HY
.          HY_SET 2 36p 1p
.          KERN
.          LIG
.          SS 0
.          SMARTQUOTES
.          if !\\n[#PP_INDENT] \{\
.             in 2m                 \"Set indent
.             nr #PP_INDENT \\n(.i  \"Read into #PP_INDENT
.             in 0                  \"Remove indent
.          \}
.          HDRFTR_RIGHT_CAPS
.          rr #IGNORE_COLUMNS
.       \}
.    \}
.END
\#
\#
\# Macros to control behaviour of PRINTSTYLE TYPEWRITE
\#
\# First, a little utility macro.
\#
.MAC TYPEWRITER END
.    fam C
.    ft  R
.    ps  12
.END
\#
\#
\# ITALIC MEANS ITALIC
\# -------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Instructs TYPEWRITE to treat italics as italics, whether
\#   invoked via control lines or inline.
\# *Notes:
\#   ITALIC_MEANS_ITALIC and UNDERLINE_ITALIC are mututally exclusive,
\#   hence invoking the one automatically turns off the other.
\#
.MAC ITALIC_MEANS_ITALIC END
.    if \\n[#PRINT_STYLE]=1 \{\
.       nr #ITALIC_MEANS_ITALIC 1
.       rr #UNDERLINE_ITALIC
.       rm ROM
.       rm IT
.       rm PREV
.       ds ROM  \EfR
.       ds IT   \EfI
.       ds PREV \EfR
.    \}
.END
\#
\#
\# UNDERLINE ITALIC
\# ----------------
\# *Argument:
\#   <none>
\# *Function:
\#   Instructs TYPEWRITE to underline italics, whether invoked
\#   via control lines or inline.
\# *Notes:
\#   UNDERLINE_ITALIC and ITALIC_MEANS_ITALIC are mututally exclusive,
\#   hence invoking the one automatically turns off the other.
\#
\#   UNDERLINE_ITALIC is the default for TYPEWRITE.
\#
.MAC UNDERLINE_ITALIC END
.    if \\n[#PRINT_STYLE]=1 \{\
.       nr #UNDERLINE_ITALIC 1
.       rr #ITALIC_MEANS_ITALIC
.       rm ROM
.       rm IT
.       rm PREV
.       ds ROM  \E*[ULX]
.       ds IT   \E*[UL]
.       ds PREV \E*[ULX]
.    \}
.END
\#
\#
\# UNDERLINE SLANT
\# ---------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Instructs TYPEWRITE to underline occurences of \*[SLANT], or
\#   turns feature off.
\# *Notes:
\#   Users may want \*[SLANT] to mean slant in TYPEWRITE, although
\#   most of the time, \*[SLANT] most likely means the user wanted
\#   italic but didn't have it, ergo the need to tell TYPEWRITE to
\#   treat \*[SLANT] as italic (i.e. underlined).
\#
\#   UNDERLINE_SLANT and SLANT_MEANS_SLANT are mututally exclusive,
\#   hence invoking the one automatically turns off the other.
\#
\#   UNDERLINE_SLANT is the default for TYPEWRITE.
\#
.MAC UNDERLINE_SLANT END
.    if \\n[#PRINT_STYLE]=1 \{\
.       rr #SLANT_MEANS_SLANT
.       nr #UNDERLINE_SLANT 1
.       rm SLANT
.       rm SLANTX
.       ds SLANT  \ER'#SLANT_ON 1'\E*[UL]
.       ds SLANTX \ER'#SLANT_ON 0'\E*[ULX]
.    \}
.END
\#
\#
.MAC SLANT_MEANS_SLANT END
.    if \\n[#PRINT_STYLE]=1 \{\
.       rr #UNDERLINE_SLANT
.       nr #SLANT_MEANS_SLANT 1
.       rm SLANT
.       rm SLANTX
.       ds SLANT  \ER'#SLANT_ON 1'\ES'\En[#DEGREES]'
.       ds SLANTX \ER'#SLANT_ON 0'\ES'0'
.    \}
.END
\#
\#
.MAC IGNORE_COLUMNS END
.    if \\n[#PRINT_STYLE]=1 \{ .nr #NO_COLUMNS 1 \}
.END
\#
\#
\# ====================================================================
\#
\# +++COPY STYLE -- DRAFT OR FINAL+++
\#
\# COPY STYLE
\# ----------
\# *Arguments:
\#   DRAFT | FINAL
\# *Function:
\#   Sets registers that are used to determine what to put
\#   in the default header, and how to number pages.
\# *Notes:
\#   DOCTYPE must come before COPYSTYLE.
\#
.MAC COPYSTYLE END
.    ds $COPY_STYLE \\$1
.    if '\\*[$COPY_STYLE]'DRAFT' \{\
.       nr #COPY_STYLE 1
.       if !d$DRAFT \{ .DRAFT 1 \}
.    \}
.    if '\\*[$COPY_STYLE]'FINAL' \{ .nr #COPY_STYLE 2         \}
.    if !d$CHAPTER_STRING        \{ .CHAPTER_STRING "Chapter" \}
.    if !d$DRAFT_STRING          \{ .DRAFT_STRING "Draft"     \}
.    if !d$REVISION_STRING       \{ .REVISION_STRING "Rev."   \}
.\" Default
.    if \\n[#DOC_TYPE]=1 \{\
.       ie \\n[#COPY_STYLE]=1 \{\
.          ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.          el \{ .PAGENUM_STYLE roman \}
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#DRAFT_WITH_PAGENUM] \{\
.                ds $HDRFTR_CENTER
.             \}
.             el \{\
.                ie '\\*[$REVISION]'' \{\
.                   ds $HDRFTR_CENTER \
                    \\*[$DRAFT_STRING]\\*[$DRAFT]
.                \}
.                el \{\
.                   ds $HDRFTR_CENTER \
                    \\*[$DRAFT_STRING]\\*[$DRAFT], \
                    \\*[$REVISION_STRING] \\*[$REVISION]
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.          el \{ .PAGENUM_STYLE DIGIT \}
.          if r#DRAFT_WITH_PAGENUM \{ .rr #DRAFT_WITH_PAGENUM \}
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ds $HDRFTR_CENTER
.             rr #USER_DEF_HDRFTR_CENTER
.          \}
.       \}
.    \}
.\" Chapter
.    if \\n[#DOC_TYPE]=2 \{\
.\" Copystyle DRAFT
.       ie \\n[#COPY_STYLE]=1 \{\
.          ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.          el \{ .PAGENUM_STYLE roman \}
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#DRAFT_WITH_PAGENUM] \{\
.                ie '\\*[$CHAPTER]'' \{\
.                   ie !'\\*[$CHAPTER_TITLE]'' \{\
.                      ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                   \}
.                   el .ds $HDRFTR_CENTER \\*[$CHAPTER_STRING]
.                \}
.                el \{\
.                   ie !'\\*[$CHAPTER_TITLE]'' \{\
.                      ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                   \}
.                   el .ds $HDRFTR_CENTER \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.                \}
.             \}
.             el \{\
.                ie '\\*[$REVISION]'' \{\
.                   ie '\\*[$CHAPTER]'' \{\
.                      ie !'\\*[$CHAPTER_TITLE]'' \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                   \}
.                   el \{\
.                      ie !'\\*[$CHAPTER_TITLE]'' \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT]
.                         \}
.                      \}
.                   \}
.                \}
.                el \{\
.                   ie '\\*[$CHAPTER]'' \{\
.                      ie !'\\*[$CHAPTER_TITLE]'' \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                      \}
.                   \}
.                   el \{\
.                      ie !'\\*[$CHAPTER_TITLE]'' \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_TITLE], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                      \}
.                      el \{\
.                         ie '\\*[$DRAFT]'' \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                         el \{\
.                            ds $HDRFTR_CENTER \
                             \\*[$CHAPTER_STRING] \\*[$CHAPTER], \
                             \\*[$DRAFT_STRING]\\*[$DRAFT], \
                             \\*[$REVISION_STRING] \\*[$REVISION] 
.                         \}
.                      \}
.                   \}
.                \}
.             \}
.          \}
.       \}
.\" Copystyle FINAL
.       el \{\
.          if r#DRAFT_WITH_PAGENUM \{ .rr #DRAFT_WITH_PAGENUM \}
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.             el \{ .PAGENUM_STYLE DIGIT \}
.             ie '\\*[$CHAPTER]'' \{\
.                ie !'\\*[$CHAPTER_TITLE]'' \{\
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                \}
.                el \{\
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_STRING]
.                \}
.             \}
.             el \{\
.                ie !'\\*[$CHAPTER_TITLE]'' \{\
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_TITLE]
.                \}
.                el \{\
.                   ds $HDRFTR_CENTER \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.                \}
.             \}
.          \}
.       \}
.    \}
.\" Named
.    if \\n[#DOC_TYPE]=3 \{\
.       ie \\n[#COPY_STYLE]=1 \{\
.          ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.          el \{ .PAGENUM_STYLE roman \}
.          ie \\n[#DRAFT_WITH_PAGENUM] \{\
.             ds $HDRFTR_CENTER \\*[$DOC_TYPE]
.          \}
.          el \{\
.             if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.                ie '\\*[$REVISION]'' \{\
.                   ie '\\*[$DRAFT]'' \{\
.                      ds $HDRFTR_CENTER \\*[$DOC_TYPE]
.                   \}
.                   el \{\
.                      ds $HDRFTR_CENTER \
                       \\*[$DOC_TYPE], \
                       \\*[$DRAFT_STRING]\\*[$DRAFT]
.                   \}
.                \}
.                el \{\
.                   ie '\\*[$DRAFT]'' \{\
.                      ds $HDRFTR_CENTER \
                       \\*[$DOC_TYPE], \
                       \\*[$REVISION_STRING] \\*[$REVISION]
.                   \}
.                   el \{\
.                      ds $HDRFTR_CENTER \
                       \\*[$DOC_TYPE], \
                       \\*[$DRAFT_STRING]\\*[$DRAFT], \
                       \\*[$REVISION_STRING] \\*[$REVISION]
.                   \}
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          if r#DRAFT_WITH_PAGENUM \{ .rr #DRAFT_WITH_PAGENUM \}
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 \{\
.             ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.             el \{ .PAGENUM_STYLE DIGIT \}
.             ds $HDRFTR_CENTER \\*[$DOC_TYPE]
.          \}
.       \}
.    \}
.END
\#
\# ====================================================================
\#
\# +++COLLECT DOC INFO -- STRINGS AND REGISTERS FOR REFERENCE MACROS+++
\#
\# *Arguments:
\#   various string/register arguments
\# *Function:
\#   Collect information about documents.
\#
\#
.MAC DOCTITLE END
.    ds $DOC_TITLE \\$1
.END
\#
.MAC TITLE END \"Document title
.    ds $TITLE \\$1
.END
\#
\#
.MAC SUBTITLE END \"Document sub-title
.    ds $SUBTITLE \\$1
.END
\#
\#
.MAC CHAPTER END \"If document is a chapter, the chapter number
.    ds $CHAPTER \\$1
.END
\#
\#
.MAC CHAPTER_TITLE END \" This defines what comes after Chapter #
.    ds $CHAPTER_TITLE \\$1
.END
\#
\#
.MAC DRAFT END \"Draft number
.    ie '\\$1'' .ds $DRAFT 
.    el         .ds $DRAFT " \\$1
.END
\#
\#
.MAC REVISION END \"Revision number
.    ds $REVISION \\$1
.END
\#
\#
.MAC DRAFT_WITH_PAGENUMBER END \"Attach draft/revision strings to page number
.    nr #DRAFT_WITH_PAGENUM 1
.END
\#
\#
.MAC AUTHOR END \"Author.  Enclose all args fully in double quotes.
.    nr #AUTHOR_NUM -1 1
.    while \\n[#NUM_ARGS]>\\n[#AUTHOR_NUM] \{\
.       ds $AUTHOR_\\n+[#AUTHOR_NUM] \\$\\n[#AUTHOR_NUM]
.\}
.    nr #NUM_AUTHORS \\n[#NUM_ARGS]%2 \"Use mod 2 to test if odd or even # of authors
.    ie \\n[#NUM_AUTHORS]=1 \{ .nr #AUTHOR_LINES 0  \}
.    el \{ .nr #AUTHOR_LINES 1 \}
.END
\#
\#
.MAC COPYRIGHT END \"For use on cover page only
.   ds $COPYRIGHT \[co]\\$1
.END
\#
\#
.MAC MISC END \"For use on cover page only; enclose all args in double quotes
.    nr #MISC_NUM -1 1
.    while \\n[#NUM_ARGS]>\\n[#MISC_NUM] \{\
.       ds $MISC_\\n+[#MISC_NUM] \\$\\n[#MISC_NUM]
.\}
.    nr #NUM_MISCS \\n[#NUM_ARGS]
.END
\#
\#
.MAC PAGENUMBER END \"Page # that appears on page one.
.    nr #n%_AT_PAGENUM_SET \\n%
.    nr #PAGE_NUM_ADJ \\$1-\\n[#n%_AT_PAGENUM_SET]
.    rr #n%_AT_PAGENUM_SET
.    nr #PAGE_NUM_SET 1
.END
\#
\# ====================================================================
\#
\# +++TYPE OF DOCUMENT+++
\#
\# DOCUMENT TYPE
\# -------------
\# *Argument:
\#   DEFAULT | CHAPTER | NAMED "<whatever> | LETTER
\# *Function:
\#   Creates strings and sets registers for document types.
\# *Notes:
\#   Number registers: DEFAULT=1, CHAPTER=2, NAMED=3, LETTER=4
\#
.MAC DOCTYPE END
.    if '\\$1'DEFAULT' \{\
.       nr #DOC_TYPE 1
.    \}
.    if '\\$1'CHAPTER' \{\
.       nr #DOC_TYPE 2
.    \}
.    if '\\$1'NAMED' \{\
.       ds $DOC_TYPE \\$2
.       nr #DOC_TYPE 3
.    \}
.    if '\\$1'LETTER' \{\
.       nr #DOC_TYPE 4
.       L_MARGIN 1.125i
.       R_MARGIN 1.125i
.       PT_SIZE 12
.       LS 13.5
.       DOCHEADER OFF
.       PARA_INDENT 3m
.       INDENT_FIRST_PARAS
.       PARA_SPACE
.       ds $SUITE \En[#SUITE]
.       HEADER_MARGIN 3P+6p
.       HEADER_GAP 3P
.       FOOTERS
.       FOOTER_RULE OFF
.       FOOTER_LEFT ""
.       FOOTER_CENTER ""
.       FOOTER_RIGHT_SIZE +0
.       FOOTER_RIGHT "\&.../\E*[$SUITE]
.       FOOTER_ON_FIRST_PAGE
.       em ALL_DONE
.    \}
.END
\#
\# +++LETTER MACROS+++
\#
\# First, create a register to hold incrementing numbers to be
\# appended to LETTERHEAD.
\#
.nr #FIELD 0 1
\#
\# DATE
\# ----
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores date (entered on the line after .DATE) in diversion
\#   LETTERHEAD<n>
\#
.MAC DATE END
.    if !'\\n(.z'' \{ .di \}
.    di LETTERHEAD\\n+[#FIELD]
.    ie \\n[#FIELD]=1 \{\
.       nr #DATE_FIRST 1
.       RIGHT
.    \}
.    el \{\
.       LEFT
.    \}
.END
\#
\#
\# TO
\# --
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores addressee address (entered on the line after .TO) in
\#   diversion LETTERHEAD<n>
\#
.MAC TO END
.    if !'\\n(.z'' \{ .di \}
.    di LETTERHEAD\\n+[#FIELD]
.    LEFT
.END
\#
\#
\# FROM
\# ----
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores addresser address (entered on the line after .FROM) in
\#   diversion LETTERHEAD<n>
\#
.MAC FROM END
.    if !'\\n(.z'' \{ .di \}
.    di LETTERHEAD\\n+[#FIELD]
.    LEFT
.END
\#
\#
\# GREETING
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Stores greeting (entered on the line after .GREETING) in
\#   diversion LETTERHEAD<n>
\#
.MAC GREETING END
.    if !'\\n(.z'' \{ .di \}
.    di LETTERHEAD\\n+[#FIELD]
.    LEFT
.END
\#
\#
\# CLOSING
\# -------
\# *Arguments:
\#   <closing string>
\# *Function:
\#   Stores greeting in diversion CLOSING.
\#
.MAC CLOSING END
.    br
.    nr #CLOSING 1
.    di CLOSING
.    LEFT
.END
\#
\#
\# NO SUITE
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Redefines $FOOTER_RIGHT to blank so that a suite number doesn't
\#   appear at the bottom of letter pages.
\#
.MAC NO_SUITE END
.    FOOTER_RIGHT ""
.END
\#
\# ====================================================================
\#
\# +++DEFAULTS+++
\#
\# TYPE-STYLE CONTROL MACROS
\# -------------------------
\#
.ig
The control macros for family, font, size, quad and color are here
grouped together.  Each (e.g. _FAMILY or _FONT) tests for a calling
alias before performing the action(s) appropriate to the calling
macro.  Defaults for all these guys are set in DEFAULTS, and listed
in the "Control Macros" section of the documentation pertinent to
the macro whose style is to be changed.
..
\#
.MAC _FAMILY END
.    if '\\$0'AUTHOR_FAMILY'                  .ds $AUTHOR_FAM \\$1
.    if '\\$0'BIBLIOGRAPHY_FAMILY'            .ds $BIB_FAM \\$1
.    if '\\$0'BIBLIOGRAPHY_STRING_FAMILY'     .ds $BIB_STRING_FAM \\$1
.    if '\\$0'BLOCKQUOTE_FAMILY'              .ds $BQUOTE_FAM \\$1
.    if '\\$0'CITATION_FAMILY'                .ds $BQUOTE_FAM \\$1
.    if '\\$0'CITE_FAMILY'                    .ds $BQUOTE_FAM \\$1
.    if '\\$0'CHAPTER_TITLE_FAMILY'           .ds $CHAPTER_TITLE_FAM \\$1
.    if '\\$0'COVER_AUTHOR_FAMILY'            .ds $COVER_AUTHOR_FAM \\$1
.    if '\\$0'COVER_CHAPTER_TITLE_FAMILY'     .ds $COVER_CHAPTER_TITLE_FAM \\$1
.    if '\\$0'COVER_COPYRIGHT_FAMILY'         .ds $COVER_COPYRIGHT_FAM \\$1
.    if '\\$0'COVER_DOCTYPE_FAMILY'           .ds $COVER_DOCTYPE_FAM \\$1
.    if '\\$0'COVER_FAMILY'                   .ds $COVER_FAM \\$1
.    if '\\$0'COVER_SUBTITLE_FAMILY'          .ds $COVER_SUBTITLE_FAM \\$1
.    if '\\$0'COVER_TITLE_FAMILY'             .ds $COVER_TITLE_FAM \\$1
.    if '\\$0'DOC_COVER_AUTHOR_FAMILY'        .ds $DOC_COVER_AUTHOR_FAM \\$1
.    if '\\$0'DOC_COVER_CHAPTER_TITLE_FAMILY' .ds $DOC_COVER_CHAPTER_TITLE_FAM \\$1
.    if '\\$0'DOC_COVER_COPYRIGHT_FAMILY'     .ds $DOC_COVER_COPYRIGHT_FAM \\$1
.    if '\\$0'DOC_COVER_DOCTYPE_FAMILY'       .ds $DOC_COVER_DOCTYPE_FAM \\$1
.    if '\\$0'DOC_COVER_FAMILY'               .ds $DOC_COVER_FAM \\$1
.    if '\\$0'DOC_COVER_SUBTITLE_FAMILY'      .ds $DOC_COVER_SUBTITLE_FAM \\$1
.    if '\\$0'DOC_COVER_TITLE_FAMILY'         .ds $DOC_COVER_TITLE_FAM \\$1
.    if '\\$0'DOCHEADER_FAMILY'               .ds $DOCHEADER_FAM \\$1
.    if '\\$0'DOCTYPE_FAMILY'                 .ds $DOCTYPE_FAM \\$1
.    if '\\$0'ENDNOTE_FAMILY'                 .ds $EN_FAM \\$1
.    if '\\$0'ENDNOTE_NUMBER_FAMILY'          .ds $EN_NUMBER_FAM \\$1
.    if '\\$0'ENDNOTE_LINENUMBER_FAMILY'      .ds $EN_LN_FAM \\$1
.    if '\\$0'ENDNOTE_STRING_FAMILY'          .ds $EN_STRING_FAM \\$1
.    if '\\$0'ENDNOTE_TITLE_FAMILY'           .ds $EN_TITLE_FAM \\$1
.    if '\\$0'EPIGRAPH_FAMILY'                .ds $EPI_FAM \\$1
.    if '\\$0'FOOTNOTE_FAMILY'                .ds $FN_FAM \\$1
.    if '\\$0'HDRFTR_CENTER_FAMILY'           .ds $HDRFTR_CENTER_FAM \\$1
.    if '\\$0'HDRFTR_FAMILY' \{\
.       ds $HDRFTR_FAM        \\$1
.       ds $HDRFTR_LEFT_FAM   \\$1
.       ds $HDRFTR_CENTER_FAM \\$1
.       ds $HDRFTR_RIGHT_FAM  \\$1
.    \}
.    if '\\$0'HDRFTR_LEFT_FAMILY'             .ds $HDRFTR_LEFT_FAM \\$1
.    if '\\$0'HDRFTR_RIGHT_FAMILY'            .ds $HDRFTR_RIGHT_FAM \\$1
.    if '\\$0'HEAD_FAMILY'                    .ds $HEAD_FAM \\$1
.    if '\\$0'PAGENUM_FAMILY'                 .ds $PAGE_NUM_FAM \\$1
.    if '\\$0'PARAHEAD_FAMILY'                .ds $PH_FAM \\$1
.    if '\\$0'QUOTE_FAMILY'                   .ds $QUOTE_FAM \\$1
.    if '\\$0'SUBHEAD_FAMILY'                 .ds $SH_FAM \\$1
.    if '\\$0'SUBTITLE_FAMILY'                .ds $SUBTITLE_FAM \\$1
.    if '\\$0'TITLE_FAMILY'                   .ds $TITLE_FAM \\$1
.    if '\\$0'TOC_FAMILY'                     .ds $TOC_FAM \\$1
.    if '\\$0'TOC_FAM'                        .ds $TOC_FAM \\$1
.    if '\\$0'TOC_HEADER_FAMILY'              .ds $TOC_HEADER_FAM \\$1
.    if '\\$0'TOC_HEAD_FAMILY'                .ds $TOC_HEAD_FAM \\$1
.    if '\\$0'TOC_PARAHEAD_FAMILY'            .ds $TOC_PH_FAM \\$1
.    if '\\$0'TOC_PN_FAMILY'                  .ds $TOC_PN_FAM \\$1
.    if '\\$0'TOC_SUBHEAD_FAMILY'             .ds $TOC_SH_FAM \\$1
.    if '\\$0'TOC_TITLE_FAMILY'               .ds $TOC_TITLE_FAM \\$1
.END
\#
\#
.MAC _FONT END
.    if '\\$0'AUTHOR_FONT'                  .ds $AUTHOR_FT \\$1
.    if '\\$0'BIBLIOGRAPHY_FONT'            .ds $BIB_FT \\$1
.    if '\\$0'BIBLIOGRAPHY_STRING_FONT'     .ds $BIB_STRING_FT \\$1
.    if '\\$0'BLOCKQUOTE_FONT'              .ds $BQUOTE_FT \\$1
.    if '\\$0'CITATION_FONT'                .ds $BQUOTE_FT \\$1
.    if '\\$0'CITE_FONT'                    .ds $BQUOTE_FT \\$1
.    if '\\$0'CHAPTER_TITLE_FONT'           .ds $CHAPTER_TITLE_FT \\$1
.    if '\\$0'COVER_AUTHOR_FONT'            .ds $COVER_AUTHOR_FT \\$1
.    if '\\$0'COVER_CHAPTER_TITLE_FONT'     .ds $COVER_CHAPTER_TITLE_FT \\$1
.    if '\\$0'COVER_COPYRIGHT_FONT'         .ds $COVER_COPYRIGHT_FT \\$1
.    if '\\$0'COVER_DOCTYPE_FONT'           .ds $COVER_DOCTYPE_FT \\$1
.    if '\\$0'COVER_SUBTITLE_FONT'          .ds $COVER_SUBTITLE_FT \\$1
.    if '\\$0'COVER_TITLE_FONT'             .ds $COVER_TITLE_FT \\$1
.    if '\\$0'DOC_COVER_AUTHOR_FONT'        .ds $DOC_COVER_AUTHOR_FT \\$1
.    if '\\$0'DOC_COVER_CHAPTER_TITLE_FONT' .ds $DOC_COVER_CHAPTER_TITLE_FT \\$1
.    if '\\$0'DOC_COVER_COPYRIGHT_FONT'     .ds $DOC_COVER_COPYRIGHT_FT \\$1
.    if '\\$0'DOC_COVER_DOCTYPE_FONT'       .ds $DOC_COVER_DOCTYPE_FT \\$1
.    if '\\$0'DOC_COVER_SUBTITLE_FONT'      .ds $DOC_COVER_SUBTITLE_FT \\$1
.    if '\\$0'DOC_COVER_TITLE_FONT'         .ds $DOC_COVER_TITLE_FT \\$1
.    if '\\$0'DOCTYPE_FONT'                 .ds $DOCTYPE_FT \\$1
.    if '\\$0'ENDNOTE_FONT'                 .ds $EN_FT \\$1
.    if '\\$0'ENDNOTE_NUMBER_FONT'          .ds $EN_NUMBER_FT \\$1
.    if '\\$0'ENDNOTE_LINENUMBER_FONT'      .ds $EN_LN_FT \\$1
.    if '\\$0'ENDNOTE_STRING_FONT'          .ds $EN_STRING_FT \\$1
.    if '\\$0'ENDNOTE_TITLE_FONT'           .ds $EN_TITLE_FT \\$1
.    if '\\$0'EPIGRAPH_FONT'                .ds $EPI_FT \\$1
.    if '\\$0'FOOTNOTE_FONT'                .ds $FN_FT \\$1
.    if '\\$0'HDRFTR_CENTER_FONT'           .ds $HDRFTR_CENTER_FT \\$1
.    if '\\$0'HDRFTR_LEFT_FONT'             .ds $HDRFTR_LEFT_FT \\$1
.    if '\\$0'HDRFTR_RIGHT_FONT'            .ds $HDRFTR_RIGHT_FT \\$1
.    if '\\$0'HEAD_FONT'                    .ds $HEAD_FT \\$1
.    if '\\$0'PAGENUM_FONT'                 .ds $PAGE_NUM_FT \\$1
.    if '\\$0'PARAHEAD_FONT'                .ds $PH_FT \\$1
.    if '\\$0'QUOTE_FONT'                   .ds $QUOTE_FT \\$1
.    if '\\$0'SUBHEAD_FONT'                 .ds $SH_FT \\$1
.    if '\\$0'SUBTITLE_FONT'                .ds $SUBTITLE_FT \\$1
.    if '\\$0'TITLE_FONT'                   .ds $TITLE_FT \\$1
.    if '\\$0'TOC_HEADER_FONT'              .ds $TOC_HEADER_FT \\$1
.    if '\\$0'TOC_HEAD_FONT'                .ds $TOC_HEAD_FT \\$1
.    if '\\$0'TOC_PARAHEAD_FONT'            .ds $TOC_PH_FT \\$1
.    if '\\$0'TOC_PN_FONT'                  .ds $TOC_PN_FT \\$1
.    if '\\$0'TOC_SUBHEAD_FONT'             .ds $TOC_SH_FT \\$1
.    if '\\$0'TOC_TITLE_FONT'               .ds $TOC_TITLE_FT \\$1
.END
\#
\#
.MAC _SIZE END
.    if '\\$0'AUTHOR_SIZE'                  .ds $AUTHOR_SIZE_CHANGE \\$1
.    if '\\$0'BIBLIOGRAPHY_STRING_SIZE'     .ds $BIB_STRING_SIZE_CHANGE \\$1
.    if '\\$0'BLOCKQUOTE_SIZE'              .ds $BQUOTE_SIZE_CHANGE \\$1
.    if '\\$0'CITATION_SIZE'                .ds $BQUOTE_SIZE_CHANGE \\$1
.    if '\\$0'CITE_SIZE'                    .ds $BQUOTE_SIZE_CHANGE \\$1
.    if '\\$0'CHAPTER_TITLE_SIZE'           .ds $CHAPTER_TITLE_SIZE_CHANGE \\$1
.    if '\\$0'COVER_AUTHOR_SIZE'            .ds $COVER_AUTHOR_SIZE_CHANGE \\$1
.    if '\\$0'COVER_CHAPTER_TITLE_SIZE'     .ds $COVER_CHAPTER_TITLE_SIZE_CHANGE \\$1
.    if '\\$0'COVER_COPYRIGHT_SIZE'         .ds $COVER_COPYRIGHT_SIZE_CHANGE \\$1
.    if '\\$0'COVER_DOCTYPE_SIZE'           .ds $COVER_DOCTYPE_SIZE_CHANGE \\$1
.    if '\\$0'COVER_SUBTITLE_SIZE'          .ds $COVER_SUBTITLE_SIZE_CHANGE \\$1
.    if '\\$0'COVER_TITLE_SIZE'             .ds $COVER_TITLE_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_AUTHOR_SIZE'        .ds $DOC_COVER_AUTHOR_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_CHAPTER_TITLE_SIZE' .ds $DOC_COVER_CHAPTER_TITLE_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_COPYRIGHT_SIZE'     .ds $DOC_COVER_COPYRIGHT_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_DOCTYPE_SIZE'       .ds $DOC_COVER_DOCTYPE_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_SUBTITLE_SIZE'      .ds $DOC_COVER_SUBTITLE_SIZE_CHANGE \\$1
.    if '\\$0'DOC_COVER_TITLE_SIZE'         .ds $DOC_COVER_TITLE_SIZE_CHANGE \\$1
.    if '\\$0'DOCTYPE_SIZE'                 .ds $DOCTYPE_SIZE_CHANGE \\$1
.    if '\\$0'ENDNOTE_NUMBER_SIZE'          .ds $EN_NUMBER_SIZE_CHANGE \\$1
.    if '\\$0'ENDNOTE_LINENUMBER_SIZE'      .ds $EN_LN_SIZE_CHANGE \\$1
.    if '\\$0'ENDNOTE_STRING_SIZE'          .ds $EN_STRING_SIZE_CHANGE \\$1
.    if '\\$0'ENDNOTE_TITLE_SIZE'           .ds $EN_TITLE_SIZE_CHANGE \\$1 
.    if '\\$0'EPIGRAPH_SIZE'                .ds $EPI_SIZE_CHANGE \\$1
.    if '\\$0'FOOTNOTE_SIZE'                .ds $FN_SIZE_CHANGE \\$1
.    if '\\$0'HDRFTR_CENTER_SIZE'           .ds $HDRFTR_CENTER_SIZE_CHANGE \\$1
.    if '\\$0'HDRFTR_LEFT_SIZE'             .ds $HDRFTR_LEFT_SIZE_CHANGE \\$1
.    if '\\$0'HDRFTR_RIGHT_SIZE'            .ds $HDRFTR_RIGHT_SIZE_CHANGE \\$1
.    if '\\$0'HDRFTR_SIZE'                  .ds $HDRFTR_SIZE_CHANGE \\$1
.    if '\\$0'HEAD_SIZE'                    .ds $HEAD_SIZE_CHANGE \\$1
.    if '\\$0'PAGENUM_SIZE'                 .ds $PAGE_NUM_SIZE_CHANGE \\$1
.    if '\\$0'PARAHEAD_SIZE'                .ds $PH_SIZE_CHANGE \\$1
.    if '\\$0'QUOTE_SIZE'                   .ds $QUOTE_SIZE_CHANGE \\$1
.    if '\\$0'SUBHEAD_SIZE'                 .ds $SH_SIZE_CHANGE \\$1
.    if '\\$0'SUBTITLE_SIZE'                .ds $SUBTITLE_SIZE_CHANGE \\$1
.    if '\\$0'TITLE_SIZE'                   .ds $TITLE_SIZE_CHANGE \\$1
.    if '\\$0'TOC_HEADER_SIZE'              .ds $TOC_HEADER_SIZE_CHANGE \\$1
.    if '\\$0'TOC_HEAD_SIZE'                .ds $TOC_HEAD_SIZE_CHANGE \\$1
.    if '\\$0'TOC_PARAHEAD_SIZE'            .ds $TOC_PH_SIZE_CHANGE \\$1
.    if '\\$0'TOC_PN_SIZE'                  .ds $TOC_PN_SIZE_CHANGE \\$1
.    if '\\$0'TOC_SUBHEAD_SIZE'             .ds $TOC_SH_SIZE_CHANGE \\$1
.    if '\\$0'TOC_TITLE_SIZE'               .ds $TOC_TITLE_SIZE_CHANGE \\$1
.END
\#
\#
.MAC _COLOR END
.    if \\n[#PRINT_STYLE]=1 \{ .return \}
.    if '\\$0'ATTRIBUTE_COLOR' \{\
.       nr #ATTRIBUTE_COLOR 1
.       ds $ATTRIBUTE_COLOR \\$1
.    \}
.    if '\\$0'AUTHOR_COLOR' \{\
.       nr #AUTHOR_COLOR 1
.       ds $AUTHOR_COLOR \\$1
.    \}
.    if '\\$0'BLOCKQUOTE_COLOR' \{\
.       nr #BQUOTE_COLOR 1
.       ds $BQUOTE_COLOR \\$1
.    \}
.    if '\\$0'CITATION_COLOR' \{\
.       nr #BQUOTE_COLOR 1
.       ds $BQUOTE_COLOR \\$1
.    \}
.    if '\\$0'CITE_COLOR' \{\
.       nr #BQUOTE_COLOR 1
.       ds $BQUOTE_COLOR \\$1
.    \}
.    if '\\$0'CHAPTER_TITLE_COLOR' \{\
.       nr #CHAPTER_TITLE_COLOR 1
.       ds $CHAPTER_TITLE_COLOR \\$1
.    \}
.    if '\\$0'COVER_ATTRIBUTE_COLOR' \{\
.       nr #COVER_ATTRIBUTE_COLOR 1
.       ds $COVER_ATTRIBUTE_COLOR \\$1
.    \}
.    if '\\$0'COVER_AUTHOR_COLOR' \{\
.       nr #COVER_AUTHOR_COLOR 1
.       ds $COVER_AUTHOR_COLOR \\$1
.    \}
.    if '\\$0'COVER_CHAPTER_TITLE_COLOR' \{\
.       nr #COVER_CHAPTER_TITLE_COLOR 1
.       ds $COVER_CHAPTER_TITLE_COLOR \\$1
.    \}
.    if '\\$0'COVER_COLOR' \{\
.       nr #COVER_COLOR 1
.       ds $COVER_COLOR \\$1
.    \}
.    if '\\$0'COVER_COPYRIGHT_COLOR' \{\
.       nr #COVER_COPYRIGHT_COLOR 1
.       ds $COVER_COPYRIGHT_COLOR \\$1
.    \}
.    if '\\$0'COVER_MISC_COLOR' \{\
.       nr #COVER_MISC_COLOR 1
.       ds $COVER_MISC_COLOR \\$1
.    \}
.    if '\\$0'COVER_TITLE_COLOR' \{\
.       nr #COVER_TITLE_COLOR 1
.       ds $COVER_TITLE_COLOR \\$1
.    \}
.    if '\\$0'COVER_SUBTITLE_COLOR' \{\
.       nr #COVER_SUBTITLE_COLOR 1
.       ds $COVER_SUBTITLE_COLOR \\$1
.    \}
.    if '\\$0'COVER_DOCTYPE_COLOR' \{\
.       nr #COVER_DOCTYPE_COLOR 1
.       ds $COVER_DOCTYPE_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_ATTRIBUTE_COLOR' \{\
.       nr #DOC_COVER_ATTRIBUTE_COLOR 1
.       ds $DOC_COVER_ATTRIBUTE_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_AUTHOR_COLOR' \{\
.       nr #DOC_COVER_AUTHOR_COLOR 1
.       ds $DOC_COVER_AUTHOR_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_CHAPTER_TITLE_COLOR' \{\
.       nr #DOC_COVER_CHAPTER_TITLE_COLOR 1
.       ds $DOC_COVER_CHAPTER_TITLE_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_COLOR' \{\
.       nr #DOC_COVER_COLOR 1
.       ds $DOC_COVER_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_COPYRIGHT_COLOR' \{\
.       nr #DOC_COVER_COPYRIGHT_COLOR 1
.       ds $DOC_COVER_COPYRIGHT_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_MISC_COLOR' \{\
.       nr #DOC_COVER_MISC_COLOR 1
.       ds $DOC_COVER_MISC_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_TITLE_COLOR' \{\
.       nr #DOC_COVER_TITLE_COLOR 1
.       ds $DOC_COVER_TITLE_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_SUBTITLE_COLOR' \{\
.       nr #DOC_COVER_SUBTITLE_COLOR 1
.       ds $DOC_COVER_SUBTITLE_COLOR \\$1
.    \}
.    if '\\$0'DOC_COVER_DOCTYPE_COLOR' \{\
.       nr #DOC_COVER_DOCTYPE_COLOR 1
.       ds $DOC_COVER_DOCTYPE_COLOR \\$1
.    \}
.    if '\\$0'DOCHEADER_COLOR' \{\
.       nr #DOCHEADER_COLOR 1
.       ds $DOCHEADER_COLOR \\$1
.    \}
.    if '\\$0'DOCTYPE_COLOR' \{\
.       nr #DOCTYPE_COLOR 1
.       ds $DOCTYPE_COLOR \\$1
.    \}
.    if '\\$0'EPIGRAPH_COLOR' \{\
.       nr #EPI_COLOR 1
.       ds $EPI_COLOR \\$1
.    \}
.    if '\\$0'FINIS_COLOR' \{\
.       nr #FINIS_COLOR 1
.       ds $FINIS_COLOR \\$1
.    \}
.    if '\\$0'FOOTNOTE_COLOR' \{\
.       nr #FOOTNOTE_COLOR 1
.       ds $FOOTNOTE_COLOR \\$1
.    \}
.    if '\\$0'HDRFTR_CENTER_COLOR' \{\
.       nr #HDRFTR_CENTER_COLOR 1
.       ds $HDRFTR_CENTER_COLOR \\$1
.    \}
.    if '\\$0'HDRFTR_COLOR' \{\
.       nr #HDRFTR_COLOR 1
.       ds $HDRFTR_COLOR \\$1
.    \}
.    if '\\$0'HDRFTR_LEFT_COLOR' \{\
.       nr #HDRFTR_LEFT_COLOR 1
.       ds $HDRFTR_LEFT_COLOR \\$1
.    \}
.    if '\\$0'HDRFTR_RIGHT_COLOR' \{\
.       nr #HDRFTR_RIGHT_COLOR 1
.       ds $HDRFTR_RIGHT_COLOR \\$1
.    \}
.    if '\\$0'HDRFTR_RULE_COLOR' \{\
.       nr #HDRFTR_RULE_COLOR 1
.       ds $HDRFTR_RULE_COLOR \\$1
.    \}
.    if '\\$0'HEAD_COLOR' \{\
.       nr #HEAD_COLOR 1
.       ds $HEAD_COLOR \\$1
.    \}
.    if '\\$0'LINEBREAK_COLOR' \{\
.       nr #LINEBREAK_COLOR 1
.       ds $LINEBREAK_COLOR \\$1
.    \}
.    if '\\$0'PAGENUM_COLOR' \{\
.       nr #PAGE_NUM_COLOR 1
.       ds $PAGENUM_COLOR \\$1
.    \}
.    if '\\$0'PARAHEAD_COLOR' \{\
.       nr #PH_COLOR 1
.       ds $PH_COLOR \\$1
.    \}
.    if '\\$0'QUOTE_COLOR' \{\
.       nr #QUOTE_COLOR 1
.       ds $QUOTE_COLOR \\$1
.    \}
.    if '\\$0'SUBHEAD_COLOR' \{\
.       nr #SH_COLOR 1
.       ds $SH_COLOR \\$1
.    \}
.    if '\\$0'SUBTITLE_COLOR' \{\
.       nr #SUBTITLE_COLOR 1
.       ds $SUBTITLE_COLOR \\$1
.    \}
.    if '\\$0'TITLE_COLOR' \{\
.       nr #TITLE_COLOR 1
.       ds $TITLE_COLOR \\$1
.    \}
.END
\#
\#
.MAC _QUAD END
.    if '\\$0'BIBLIOGRAPHY_QUAD' \{\
.       ds $BIB_QUAD \\$1
.       if '\\*[$BIB_QUAD]'R' .ab Fatal error: \\$0 must be set to either L or J
.       if '\\*[$BIB_QUAD]'C' .ab Fatal error: \\$0 must be set to either L or J
.    \}
.    if '\\$0'BIBLIOGRAPHY_STRING_QUAD' .ds $BIB_STRING_QUAD \\$1
.    if '\\$0'BLOCKQUOTE_QUAD'          .ds $BQUOTE_QUAD \\$1
.    if '\\$0'CITATION_QUAD'            .ds $BQUOTE_QUAD \\$1
.    if '\\$0'CITE_QUAD'                .ds $BQUOTE_QUAD \\$1
.    if '\\$0'COVER_COPYRIGHT_QUAD'     .ds $COVER_COPYRIGHT_QUAD \\$1
.    if '\\$0'COVER_MISC_QUAD'          .ds $COVER_MISC_QUAD \\$1
.    if '\\$0'DOC_COVER_COPYRIGHT_QUAD' .ds $DOC_COVER_COPYRIGHT_QUAD \\$1
.    if '\\$0'DOC_COVER_MISC_QUAD'      .ds $DOC_COVER_MISC_QUAD \\$1
.    if '\\$0'DOC_QUAD' \{\
.        ds $DOC_QUAD \\$1
.        QUAD \\*[$DOC_QUAD]
.    \}
.    if '\\$0'ENDNOTE_QUAD' \{\
.       ds $EN_QUAD \\$1
.       if '\\*[$EN_QUAD]'R' .ab Fatal error: \\$0 must be set to either L or J
.       if '\\*[$EN_QUAD]'C' .ab Fatal error: \\$0 must be set to either L or J
.    \}
.    if '\\$0'ENDNOTE_STRING_QUAD'      .ds $EN_STRING_QUAD \\$1
.    if '\\$0'ENDNOTE_TITLE_QUAD'       .ds $EN_TITLE_QUAD \\$1
.    if '\\$0'EPIGRAPH_QUAD'            .ds $EPI_QUAD \\$1
.    if '\\$0'FOOTNOTE_QUAD'            .ds $FN_QUAD \\$1
.    if '\\$0'HEAD_QUAD'                .ds $HEAD_QUAD \\$1
.    if '\\$0'SUBHEAD_QUAD'             .ds $SH_QUAD \\$1
.    if '\\$0'TOC_HEADER_QUAD'          .ds $TOC_HEADER_QUAD \\$1
.END
\#
\#
\# DEFAULTS
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Sets up defaults if no values are entered prior to START.
\# *Notes:
\#   The defaults for $CHAPTER_STRING, $DRAFT_STRING, and
\#   $REVISION_STRING are in the COPYSTYLE macro.
\#
.MAC DEFAULTS END
.    if !d$PAPER \{ .PAPER LETTER \}
.    if !\\n[#DOC_TYPE]   \{ .DOCTYPE DEFAULT \}
.    ie \\n[#PAGENUM_STYLE_SET] \{ .PAGENUM_STYLE \\*[$PAGENUM_STYLE] \}
.    el \{\
.       if !\\n[#COPY_STYLE]=1 \{ .PAGENUM_STYLE DIGIT \}
.    \}
.    if !\\n[#COPY_STYLE] \{ .COPYSTYLE FINAL \}
.    if \\n[#DRAFT_WITH_PAGENUM] \{ .COPYSTYLE \\*[$COPY_STYLE] \}
.    if \\n[#DOC_TYPE]=4 \{\
.       if !\\n[#USER_SET_L_LENGTH] \{\
.          R_MARGIN \\n[#R_MARGIN]u
.          rr #USER_SET_L_LENGTH
.       \}
.       if \\n[#PRINT_STYLE]=1 \{ .PRINTSTYLE TYPEWRITE SINGLESPACE \}
.    \}
.    if \\n[#COPY_STYLE]=1 \{\
.       COPYSTYLE DRAFT
.       PAGENUMBER 1
.    \}
.    if !r#DOC_HEADER \{ .DOCHEADER  \}
.    if !r#HEADERS_ON \{ .HEADERS    \}
.    if !r#PAGINATE   \{ .PAGINATE   \}
.    if \\n[#FOOTERS_ON] \{\
.       HEADERS OFF
.       if \\n[#PAGE_NUM_POS_SET]=0 \{ .PAGENUM_POS TOP CENTER \}
.    \}
.    if !r#HEADER_MARGIN \{ .HEADER_MARGIN 4P+6p \}
.    if !r#HEADER_GAP    \{ .HEADER_GAP    3P    \}
.    if \\n[#FOOTERS_ON] \{\
.       if \\n[#PAGINATE]=0 \{\
.          if !r#T_MARGIN \{ .T_MARGIN 6P \}
.       \}
.    \}
.    if \\n[#HEADERS_ON]=0    \{\
.       if \\n[#FOOTERS_ON]=0 \{\
.          if !r#T_MARGIN \{ .T_MARGIN 6P \}
.       \}
.    \}
.    if !r#T_MARGIN          \{ .T_MARGIN \\n[#HEADER_MARGIN]+\\n[#HEADER_GAP] \}
.    if !r#DOCHEADER_ADVANCE \{ .nr #DOCHEADER_ADVANCE \\n[#T_MARGIN] \}
.    if !r#FOOTER_MARGIN     \{ .FOOTER_MARGIN 3P \}
.    if !r#FOOTER_GAP        \{ .FOOTER_GAP    3P \}
.    if !r#B_MARGIN          \{ .B_MARGIN \\n[#FOOTER_MARGIN]u+\\n[#FOOTER_GAP]u \}
.    if (\\n[#FOOTER_MARGIN]+\\n(.v)>\\n[#B_MARGIN] \{\
.       tm1 "[mom]: Your chosen bottom margin for running text is too close to the footer margin.
.       tm1 "       No footers or bottom-of-page page numbers will be printed.
.       tm1 "       Please reset B_MARGIN or FOOTER_MARGIN to allow enough space.
.       tm1 "       If no footers or bottom-of-page page numbers are required,
.       tm1 "       type in .FOOTER_MARGIN 0 before .START
.    \}
.    if !r#HDRFTR_RULE_GAP   \{\
.       if \\n[#HEADERS_ON]  \{ .HDRFTR_RULE_GAP 4p \}
.       if \\n[#FOOTERS_ON]  \{ .HDRFTR_RULE_GAP 4p \}
.    \}
.    if !r#HDRFTR_RULE       \{ .HDRFTR_RULE        \}
.    if !r#PAGE_NUM_SET      \{ .PAGENUMBER 1       \}
.\" Read in number registers and strings for type parameters
.    nr #DOC_L_MARGIN \\n[#L_MARGIN]
.    nr #DOC_L_LENGTH \\n[#L_LENGTH]
.    nr #DOC_R_MARGIN \\n[#PAGE_WIDTH]-(\\n[#DOC_L_MARGIN]+\\n[#L_LENGTH])
.    ds $DOC_FAM      \\*[$FAMILY]
.    nr #DOC_PT_SIZE  \\n[#PT_SIZE]
.    nr #DOC_LEAD     \\n[#LEAD]
.\" #SAVED_DOC_LEAD is set in COLLATE
.    if r#SAVED_DOC_LEAD \{\
.       if !\\n[#DOC_LEAD]=\\n[#SAVED_DOC_LEAD] \{ .nr #RERUN_TRAPS 1 \}
.    \}
.    ie \\n[#ADJ_DOC_LEAD]=1 \{ . \}
.    el \{\
.       if !\\n[#DOC_LEAD_ADJUST_OFF] \{\
.          DOC_LEAD_ADJUST
.       \}
.    \}
.    ds $DOC_QUAD     \\*[$QUAD_VALUE]
.    ds $PP_FT        \\*[$FONT]
.\" Counters
.    nr #PP 0
.    nr #FN_NUMBER 0 1
.    nr #EN_NUMBER 0 1
.    nr #FN_COUNT_FOR_COLS 0 1
.    nr #DONE_ONCE 0 1
.    RESET_HEAD_NUMBER
.    RESET_SUBHEAD_NUMBER
.    RESET_PARAHEAD_NUMBER
.\" General style defaults for both PRINTSTYLEs
.    nr #PP_STYLE 1
.    PARA_INDENT \\n[#PP_INDENT]u
.    if !d$HDRFTR_FAM           \{ .HDRFTR_FAMILY  \\*[$DOC_FAM] \}
.    if !d$HDRFTR_SIZE_CHANGE   \{ .HDRFTR_SIZE    +0            \}
.    if !d$PAGE_NUM_FAM         \{ .PAGENUM_FAMILY \\*[$DOC_FAM] \}
.    if !d$PAGE_NUM_FT          \{ .PAGENUM_FONT   R             \}
.    if !d$PAGE_NUM_SIZE_CHANGE \{ .PAGENUM_SIZE   +0            \}
.    if !r#PAGE_NUM_POS_SET     \{ .PAGENUM_POS BOTTOM CENTER    \}
.    ie \\n[#PAGE_NUM_HYPHENS_SET] \{\
.       if \\n[#PAGE_NUM_HYPHENS]=0  \{ .PAGENUM_HYPHENS OFF \}
.       if \\n[#PAGE_NUM_HYPHENS]=1  \{ .PAGENUM_HYPHENS     \}
.    \}
.    el \{ .PAGENUM_HYPHENS \}
.    if !d$HEAD_QUAD         \{ .HEAD_QUAD CENTER  \}
.    if !r#HEAD_CAPS         \{ .HEAD_CAPS         \}
.    if !r#HEAD_UNDERLINE    \{ .HEAD_UNDERLINE    \}
.    if !d$SH_QUAD           \{ .SUBHEAD_QUAD LEFT \}
.    if !r#HDRFTR_RIGHT_CAPS \{ .HDRFTR_RIGHT_CAPS \}
.    if \\n[#HDRFTR_RIGHT_CAPS]=0 \{\
.       if !d$HDRFTR_RIGHT_SIZE_CHANGE \{ .HDRFTR_RIGHT_SIZE +0 \}
.    \}
.    if !d$FN_FAM               \{ .FOOTNOTE_FAMILY \\*[$DOC_FAM]      \}
.    if !d$FN_FT                \{ .FOOTNOTE_FONT R                    \}
.    if !d$FN_QUAD              \{ .FOOTNOTE_QUAD \\*[$DOC_QUAD]       \}
.    if !r#FN_RULE              \{ .FOOTNOTE_RULE                      \}
.    if !r#FN_MARKERS           \{ .FOOTNOTE_MARKERS                   \}
.    if !\\n[#FN_MARKER_STYLE]  \{ .FOOTNOTE_MARKER_STYLE STAR         \}
.    if !\\n[#EN_MARKER_STYLE]  \{ .ENDNOTE_MARKER_STYLE NUMBER        \}
.    if !d$EN_PN_STYLE          \{ .ENDNOTES_PAGENUM_STYLE digit       \}
.    if !d$EN_FAM               \{ .ENDNOTE_FAMILY \\*[$DOC_FAM]       \}
.    if !d$EN_FT                \{ .ENDNOTE_FONT R                     \}
.    if !d$EN_QUAD              \{ .ENDNOTE_QUAD \\*[$DOC_QUAD]        \}
.    if !d$EN_STRING            \{ .ENDNOTE_STRING "Endnotes"          \}
.    if !d$EN_STRING_FAM        \{ .ENDNOTE_STRING_FAMILY \\*[$EN_FAM] \}
.    if !d$EN_STRING_QUAD       \{ .ENDNOTE_STRING_QUAD CENTER         \}
.    if !r#EN_STRING_UNDERSCORE \{ .ENDNOTE_STRING_UNDERSCORE 2        \}
.    if !r#EN_STRING_CAPS       \{ .ENDNOTE_STRING_CAPS                \}
.    if !d$EN_TITLE \{\
.       ie \\n[#DOC_TYPE]=2 \{\
.          ie '\\*[$CHAPTER]'' \{ .ENDNOTE_TITLE "\\*[$CHAPTER_STRING]" \}
.          el \{ .ENDNOTE_TITLE "\\*[$CHAPTER_STRING] \\*[$CHAPTER]"    \}
.       \}
.       el \{ .ENDNOTE_TITLE "\\*[$TITLE]" \}
.    \}
.    if !d$EN_TITLE_FAM          \{ .ENDNOTE_TITLE_FAMILY \\*[$EN_FAM]  \}
.    if !d$EN_TITLE_QUAD         \{ .ENDNOTE_TITLE_QUAD LEFT            \}
.    if !r#EN_TITLE_UNDERSCORE   \{ .ENDNOTE_TITLE_UNDERSCORE           \}
.    if !d$EN_NUMBER_FAM         \{ .ENDNOTE_NUMBER_FAMILY \\*[$EN_FAM] \}
.    if !r#EN_NUMBERS_ALIGN_LEFT \{\
.       if !r#EN_NUMBERS_ALIGN_RIGHT \{ .ENDNOTE_NUMBERS_ALIGN_RIGHT 2  \}
.    \}
.    if !d$EN_LN_GAP             \{ .ENDNOTE_LINENUMBER_GAP 1.5n              \}
.    if !d$BIB_PN_STYLE          \{ .BIBLIOGRAPHY_PAGENUM_STYLE digit         \}
.    if !d$BIB_FAM               \{ .BIBLIOGRAPHY_FAMILY \\*[$DOC_FAM]        \}
.    if !d$BIB_FT                \{ .BIBLIOGRAPHY_FONT R                      \}
.    if !d$BIB_QUAD              \{ .BIBLIOGRAPHY_QUAD \\*[$DOC_QUAD]         \}
.    if !d$BIB_STRING            \{ .BIBLIOGRAPHY_STRING "Bibliography"       \}
.    if !d$BIB_STRING_FAM        \{ .BIBLIOGRAPHY_STRING_FAMILY \\*[$BIB_FAM] \}
.    if !d$BIB_STRING_QUAD       \{ .BIBLIOGRAPHY_STRING_QUAD CENTER          \}
.    if !r#BIB_STRING_UNDERSCORE \{ .BIBLIOGRAPHY_STRING_UNDERSCORE 2         \}
.    if !r#BIB_STRING_CAPS       \{ .BIBLIOGRAPHY_STRING_CAPS                 \}
.    if !d$TOC_HEADER_STRING     \{ .TOC_HEADER_STRING "Contents"  \}
.    if !d$TOC_HEADER_QUAD       \{ .TOC_HEADER_QUAD LEFT          \}
.    if !d$TOC_PN_STYLE          \{ .TOC_PAGENUM_STYLE roman       \}
.    if !r#TOC_PN_PADDING        \{ .TOC_PADDING   3               \}
.    if !r#TOC_TITLE_INDENT      \{ .TOC_TITLE_INDENT    0         \}
.    if !r#TOC_HEAD_INDENT       \{ .TOC_HEAD_INDENT     18p       \}
.    if !r#TOC_SH_INDENT         \{ .TOC_SUBHEAD_INDENT  30p       \}
.    if !r#TOC_PH_INDENT         \{ .TOC_PARAHEAD_INDENT 42p       \}
.\" String defaults for both PRINTSTYLEs
.    ie \\n[#DOC_TYPE]=1 \{\
.       ie '\\*[$DOC_TITLE]'' \{\
.          if \\n[#USER_DEF_HDRFTR_LEFT]=0  .ds $HDRFTR_LEFT \\*[$AUTHOR_1]
.          rr #USER_DEF_HDRFTR_LEFT
.          if \\n[#USER_DEF_HDRFTR_RIGHT]=0 .ds $HDRFTR_RIGHT \\*[$TITLE]
.          rr #USER_DEF_HDRFTR_RIGHT
.       \}
.       el \{\
.          if \\n[#COPY_STYLE]=1 \{ .DRAFT_WITH_PAGENUMBER \}
.          if \\n[#USER_DEF_HDRFTR_LEFT]=0   .ds $HDRFTR_LEFT \\*[$AUTHOR_1]
.          rr #USER_DEF_HDRFTR_LEFT
.          if \\n[#USER_DEF_HDRFTR_CENTER]=0 .ds $HDRFTR_CENTER \\*[$TITLE]
.          rr #USER_DEF_HDRFTR_CENTER
.          if \\n[#USER_DEF_HDRFTR_RIGHT]=0  .ds $HDRFTR_RIGHT \\*[$DOC_TITLE]
.          rr #USER_DEF_HDRFTR_RIGHT
.       \}
.    \}
.    el \{\
.       if \\n[#USER_DEF_HDRFTR_LEFT]=0  .ds $HDRFTR_LEFT \\*[$AUTHOR_1]
.       rr #USER_DEF_HDRFTR_LEFT
.       if \\n[#USER_DEF_HDRFTR_RIGHT]=0 .ds $HDRFTR_RIGHT \\*[$TITLE]
.       rr #USER_DEF_HDRFTR_RIGHT
.    \}
.    if !d$ATTRIBUTE_STRING         \{ .ATTRIBUTE_STRING "by" \}
.    if !d$FINIS_STRING             \{ .FINIS_STRING "END"    \}
.\" Covers
.    if !r#DOC_COVERS_OFF           \{ .nr #DOC_COVERS 1           \}
.    if !r#COVERS_OFF               \{ .nr #COVERS 1               \}
.    if !d$COVER_COPYRIGHT_QUAD     \{ .COVER_COPYRIGHT_QUAD R     \}
.    if !d$COVER_MISC_QUAD          \{ .COVER_MISC_QUAD L          \}
.    if !d$DOC_COVER_COPYRIGHT_QUAD \{ .DOC_COVER_COPYRIGHT_QUAD R \}
.    if !d$DOC_COVER_MISC_QUAD      \{ .DOC_COVER_MISC_QUAD L      \}
.\" Defaults for printstyle TYPEWRITE
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#UNDERLINE_QUOTES]=1 \{ .UNDERLINE_QUOTES         \}
.       if \\n[#UNDERLINE_QUOTES]=0 \{ .UNDERLINE_QUOTES OFF     \}
.\" +Quotes and blockquotes
.       if !r#Q_OFFSET_VALUE        \{ .QUOTE_INDENT      2      \}
.\" +Epigraphs
.       if !r#EPI_OFFSET_VALUE      \{ .EPIGRAPH_INDENT   2      \}
.\" +Linebreaks
.       if !d$LINEBREAK_CHAR        \{ .LINEBREAK_CHAR    * 3 2p \}
.\" +Footnotes
.       if !d$FN_SIZE_CHANGE        \{ .FOOTNOTE_SIZE     +0     \}
.       if !r#FN_RULE_LENGTH        \{ .FOOTNOTE_RULE_LENGTH 2i  \}
.\" +Paragraph heads
.       if !r#PH_INDENT    \{ .PARAHEAD_INDENT \\n[#PP_INDENT]u/2u \}
.\" +Endnotes
.       if !r#EN_PP_INDENT \{ .ENDNOTE_PARA_INDENT \\n[#PP_INDENT] \}
.\" +Footnotes
.       if !r#FN_RULE_ADJ           \{ .FOOTNOTE_RULE_ADJ  6p    \}
.\" +Slant stuff
.       if !r#SLANT_MEANS_SLANT \{\
.          ie \\n[#UNDERLINE_SLANT]=1 \{ .UNDERLINE_SLANT \}
.          el \{ .UNDERLINE_SLANT OFF \}
.       \}
.    \}
.\" Defaults for printstyle TYPESET
.    if \\n[#PRINT_STYLE]=2 \{\
.       if !d$DOCHEADER_LEAD_ADJ \{\
.          ie !'\\*[$CHAPTER_TITLE]'' \{\
.             ie !'\\*[$CHAPTER_STRING]'' \{\
.                DOCHEADER_LEAD +4
.             \}
.             el \{ .DOCHEADER_LEAD +0 \}
.          \}
.          el \{ .DOCHEADER_LEAD +0 \}
.       \}
.\" +Cover
.       if !d$COVER_LEAD_ADJ \{ .COVER_LEAD +0 \}
.       if !d$COVER_FAM \{ .COVER_FAMILY \\*[$DOC_FAM] \}
.\" (title)
.       if !d$COVER_TITLE_FAM \{\
.          ie !d$COVER_FAM \{ .COVER_TITLE_FAMILY \\*[$DOC_FAM] \}
.          el            \{ .COVER_TITLE_FAMILY \\*[$COVER_FAM] \}
.       \}
.       if !d$COVER_TITLE_FT          \{ .COVER_TITLE_FONT B    \}
.       if !d$COVER_TITLE_SIZE_CHANGE \{ .COVER_TITLE_SIZE +3.5 \}
.\" (chapter title)
.       if !d$COVER_CHAPTER_TITLE_FAM \{\
.          ie !d$COVER_FAM \{ .COVER_CHAPTER_TITLE_FAMILY \\*[$DOC_FAM] \}
.          el            \{ .COVER_CHAPTER_TITLE_FAMILY \\*[$COVER_FAM] \}
.       \}
.       if !d$COVER_CHAPTER_TITLE_FT          \{ .COVER_CHAPTER_TITLE_FONT BI \}
.       if !d$COVER_CHAPTER_TITLE_SIZE_CHANGE \{ .COVER_CHAPTER_TITLE_SIZE +4 \}
.\" (subtitle)
.       if !d$COVER_SUBTITLE_FAM \{\
.          ie !d$COVER_FAM \{ .COVER_SUBTITLE_FAMILY \\*[$DOC_FAM] \}
.          el            \{ .COVER_SUBTITLE_FAMILY \\*[$COVER_FAM] \}
.       \}
.       if !d$COVER_SUBTITLE_FT          \{ .COVER_SUBTITLE_FONT R  \}
.       if !d$COVER_SUBTITLE_SIZE_CHANGE \{ .COVER_SUBTITLE_SIZE +0 \}
.\" (attribution and author[s])
.       if !d$COVER_AUTHOR_FAM \{\
.          ie !d$COVER_FAM \{ .COVER_AUTHOR_FAMILY \\*[$DOC_FAM] \}
.          el      \{ .COVER_AUTHOR_FAMILY \\*[$COVER_FAM] \}
.       \}
.       if !d$COVER_AUTHOR_FT          \{ .COVER_AUTHOR_FONT I  \}
.       if !d$COVER_AUTHOR_SIZE_CHANGE \{ .COVER_AUTHOR_SIZE +0 \}
.\" (doctype if "named")
.       if !d$COVER_DOCTYPE_FAM \{\
.          ie !d$COVER_FAM \{ .COVER_DOCTYPE_FAMILY \\*[$DOC_FAM] \}
.          el            \{ .COVER_DOCTYPE_FAMILY \\*[$COVER_FAM] \}
.       \}
.       if !d$COVER_DOCTYPE_FT          \{ .COVER_DOCTYPE_FONT BI \}
.       if !d$COVER_DOCTYPE_SIZE_CHANGE \{ .COVER_DOCTYPE_SIZE +3 \}
.\" (copyright)
.       if !d$COVER_COPYRIGHT_FAM \{\
.          ie !d$COVER_FAM \{ .COVER_COPYRIGHT_FAMILY \\*[$DOC_FAM] \}
.          el            \{ .COVER_COPYRIGHT_FAMILY \\*[$COVER_FAM] \}
.       \}
.       if !d$COVER_COPYRIGHT_FT          \{ .COVER_COPYRIGHT_FONT R  \}
.       if !d$COVER_COPYRIGHT_SIZE_CHANGE \{ .COVER_COPYRIGHT_SIZE -2 \}
.\" +Doc cover
.       if !d$DOC_COVER_LEAD_ADJ \{ .DOC_COVER_LEAD +0 \}
.       if !d$DOC_COVER_FAM \{ .DOC_COVER_FAMILY \\*[$DOC_FAM] \}
.\" (title)
.       if !d$DOC_COVER_TITLE_FAM \{\
.          ie !d$DOC_COVER_FAM \{ .DOC_COVER_TITLE_FAMILY \\*[$DOC_FAM] \}
.          el            \{ .DOC_COVER_TITLE_FAMILY \\*[$DOC_COVER_FAM] \}
.       \}
.       if !d$DOC_COVER_TITLE_FT          \{ .DOC_COVER_TITLE_FONT B    \}
.       if !d$DOC_COVER_TITLE_SIZE_CHANGE \{ .DOC_COVER_TITLE_SIZE +3.5 \}
.\" (chapter title)
.       if !d$DOC_COVER_CHAPTER_TITLE_FAM \{\
.          ie !d$DOC_COVER_FAM \{ .DOC_COVER_CHAPTER_TITLE_FAMILY \\*[$DOC_FAM] \}
.          el            \{ .DOC_COVER_CHAPTER_TITLE_FAMILY \\*[$DOC_COVER_FAM] \}
.       \}
.       if !d$DOC_COVER_CHAPTER_TITLE_FT          \{ .DOC_COVER_CHAPTER_TITLE_FONT BI \}
.       if !d$DOC_COVER_CHAPTER_TITLE_SIZE_CHANGE \{ .DOC_COVER_CHAPTER_TITLE_SIZE +4 \}
.\" (subtitle)
.       if !d$DOC_COVER_SUBTITLE_FAM \{\
.          ie !d$DOC_COVER_FAM \{ .DOC_COVER_SUBTITLE_FAMILY \\*[$DOC_FAM] \}
.          el            \{ .DOC_COVER_SUBTITLE_FAMILY \\*[$DOC_COVER_FAM] \}
.       \}
.       if !d$DOC_COVER_SUBTITLE_FT          \{ .DOC_COVER_SUBTITLE_FONT R  \}
.       if !d$DOC_COVER_SUBTITLE_SIZE_CHANGE \{ .DOC_COVER_SUBTITLE_SIZE +0 \}
.\" (attribution and author[s])
.       if !d$DOC_COVER_AUTHOR_FAM \{\
.          ie !d$DOC_COVER_FAM \{ .DOC_COVER_AUTHOR_FAMILY \\*[$DOC_FAM] \}
.          el            \{ .DOC_COVER_AUTHOR_FAMILY \\*[$DOC_COVER_FAM] \}
.       \}
.       if !d$DOC_COVER_AUTHOR_FT          \{ .DOC_COVER_AUTHOR_FONT I  \}
.       if !d$DOC_COVER_AUTHOR_SIZE_CHANGE \{ .DOC_COVER_AUTHOR_SIZE +0 \}
.\" (doctype if "named")
.       if !d$DOC_COVER_DOCTYPE_FAM \{\
.          ie !d$DOC_COVER_FAM \{ .DOC_COVER_DOCTYPE_FAMILY \\*[$DOC_FAM] \}
.          el            \{ .DOC_COVER_DOCTYPE_FAMILY \\*[$DOC_COVER_FAM] \}
.       \}
.       if !d$DOC_COVER_DOCTYPE_FT          \{ .DOC_COVER_DOCTYPE_FONT BI \}
.       if !d$DOC_COVER_DOCTYPE_SIZE_CHANGE \{ .DOC_COVER_DOCTYPE_SIZE +3 \}
.\" (copyright)
.       if !d$DOC_COVER_COPYRIGHT_FAM \{\
.          ie !d$DOC_COVER_FAM \{ .DOC_COVER_COPYRIGHT_FAMILY \\*[$DOC_FAM] \}
.          el            \{ .DOC_COVER_COPYRIGHT_FAMILY \\*[$DOC_COVER_FAM] \}
.       \}
.       if !d$DOC_COVER_COPYRIGHT_FT          \{ .DOC_COVER_COPYRIGHT_FONT R  \}
.       if !d$DOC_COVER_COPYRIGHT_SIZE_CHANGE \{ .DOC_COVER_COPYRIGHT_SIZE -2 \}
.\" +Docheader
.       if !d$DOCHEADER_FAM \{ .DOCHEADER_FAMILY \\*[$DOC_FAM] \}
.       if !d$TITLE_FAM \{\
.          ie !d$DOCHEADER_FAM \{ .TITLE_FAMILY \\*[$DOC_FAM]       \}
.          el                  \{ .TITLE_FAMILY \\*[$DOCHEADER_FAM] \}
.       \}
.       if !d$TITLE_FT \{ .TITLE_FONT B \}
.       if !d$TITLE_SIZE_CHANGE \{\
.          ie \\n[#DOC_TYPE]=2 \{ .TITLE_SIZE +4 \}
.          el \{ .TITLE_SIZE +3.5 \}
.       \}
.       if !d$CHAPTER_TITLE_FAM \{\
.          ie !d$DOCHEADER_FAM \{ .CHAPTER_TITLE_FAMILY \\*[$DOC_FAM]       \}
.          el                  \{ .CHAPTER_TITLE_FAMILY \\*[$DOCHEADER_FAM] \}
.       \}
.       if !d$CHAPTER_TITLE_FT          \{ .CHAPTER_TITLE_FONT   BI \}
.       if !d$CHAPTER_TITLE_SIZE_CHANGE \{ .CHAPTER_TITLE_SIZE  +4  \}
.       if !d$SUBTITLE_FAM \{\
.          ie !d$DOCHEADER_FAM \{ .SUBTITLE_FAMILY \\*[$DOC_FAM]       \}
.          el                  \{ .SUBTITLE_FAMILY \\*[$DOCHEADER_FAM] \}
.       \}
.       if !d$SUBTITLE_FT          \{ .SUBTITLE_FONT      R  \}
.       if !d$SUBTITLE_SIZE_CHANGE \{ .SUBTITLE_SIZE     +0  \}
.       if !d$AUTHOR_FAM \{\
.          ie !d$DOCHEADER_FAM \{ .AUTHOR_FAMILY \\*[$DOC_FAM]       \}
.          el                  \{ .AUTHOR_FAMILY \\*[$DOCHEADER_FAM] \}
.       \}
.       if !d$AUTHOR_FT          \{ .AUTHOR_FONT  I \}
.       if !d$AUTHOR_SIZE_CHANGE \{ .AUTHOR_SIZE +0 \}
.       if !d$DOCTYPE_FAM \{\
.          ie !d$DOCHEADER_FAM \{ .DOCTYPE_FAMILY \\*[$DOC_FAM]       \}
.          el                  \{ .DOCTYPE_FAMILY \\*[$DOCHEADER_FAM] \}
.       \}
.       if !d$DOCTYPE_FT           \{ .DOCTYPE_FONT       BI \}
.       if !d$DOCTYPE_SIZE_CHANGE  \{ .DOCTYPE_SIZE       +3 \}
.\" +Headers and footers
.       if !d$HDRFTR_LEFT_FAM      \{ .HDRFTR_LEFT_FAMILY \\*[$DOC_FAM] \}
.       if !d$HDRFTR_LEFT_FT       \{ .HDRFTR_LEFT_FONT R               \}
.       if \\n[#HDRFTR_LEFT_CAPS]  \{\
.          if !d$HDRFTR_LEFT_SIZE_CHANGE \{ .HDRFTR_LEFT_SIZE  -2 \}
.       \}
.       if !d$HDRFTR_LEFT_SIZE_CHANGE \{ .HDRFTR_LEFT_SIZE     -.5           \}
.       if !d$HDRFTR_CENTER_FAM       \{ .HDRFTR_CENTER_FAMILY \\*[$DOC_FAM] \}
.       if !d$HDRFTR_CENTER_FT        \{ .HDRFTR_CENTER_FONT   I             \}
.       if \\n[#HDRFTR_CENTER_CAPS] \{\
.          if !d$HDRFTR_CENTER_SIZE_CHANGE \{ .HDRFTR_CENTER_SIZE -2 \}
.       \}
.       if !d$HDRFTR_CENTER_SIZE_CHANGE \{ .HDRFTR_CENTER_SIZE -.5            \}
.       if !d$HDRFTR_RIGHT_FAM          \{ .HDRFTR_RIGHT_FAMILY \\*[$DOC_FAM] \}
.       if !d$HDRFTR_RIGHT_FT           \{ .HDRFTR_RIGHT_FONT   R             \}
.       if \\n[#HDRFTR_RIGHT_CAPS] \{\
.          if !d$HDRFTR_RIGHT_SIZE_CHANGE \{ .HDRFTR_RIGHT_SIZE -2 \}
.       \}
.       if !d$HDRFTR_RIGHT_SIZE_CHANGE  \{ .HDRFTR_RIGHT_SIZE  -.5              \}
.\" +Heads
.       if !d$HEAD_FAM                  \{ .HEAD_FAMILY        \\*[$DOC_FAM]    \}
.       if !d$HEAD_FT                   \{ .HEAD_FONT          B                \}
.       if !d$HEAD_SIZE_CHANGE          \{ .HEAD_SIZE          +1               \}
.       if !r#HEAD_SPACE                \{ .HEAD_SPACE                          \}
.\" +Subheads
.       if !d$SH_FAM                    \{ .SUBHEAD_FAMILY     \\*[$DOC_FAM]    \}
.       if !d$SH_FT                     \{ .SUBHEAD_FONT       B                \}
.       if !d$SH_SIZE_CHANGE            \{ .SUBHEAD_SIZE       +.5              \}
.\" +Paragraph heads
.       if !d$PH_FAM                    \{ .PARAHEAD_FAMILY    \\*[$DOC_FAM]    \}
.       if !d$PH_FT                     \{ .PARAHEAD_FONT      BI               \}
.       if !d$PH_SIZE_CHANGE            \{ .PARAHEAD_SIZE      -.25             \}
.       if !r#PH_INDENT                 \{ .PARAHEAD_INDENT \\n[#PP_INDENT]u/2u \}
.\" +Quotes
.       if !d$QUOTE_FAM                 \{ .QUOTE_FAMILY       \\*[$DOC_FAM]    \}
.       if !d$QUOTE_FT                  \{ .QUOTE_FONT         I                \}
.       if !d$QUOTE_SIZE_CHANGE         \{ .QUOTE_SIZE         +0               \}
.       if !r#Q_OFFSET_VALUE            \{ .QUOTE_INDENT       3                \}
.\" +Blockquotes
.\"  Note: the leading for quotes and blockquotes is set after .DEFAULTS in START
.       if !d$BQUOTE_FAM                \{ .BLOCKQUOTE_FAMILY  \\*[$DOC_FAM]    \}
.       if !d$BQUOTE_FT                 \{ .BLOCKQUOTE_FONT    R                \}
.       if !d$BQUOTE_SIZE_CHANGE        \{ .BLOCKQUOTE_SIZE    -1               \}
.       if !d$BQUOTE_QUAD               \{ .BLOCKQUOTE_QUAD    LEFT             \}
.\" +Epigraphs
.       if !d$EPI_FAM                   \{ .EPIGRAPH_FAMILY    \\*[$DOC_FAM]    \}
.       if !d$EPI_FT                    \{ .EPIGRAPH_FONT      R                \}
.       if !d$EPI_SIZE_CHANGE           \{ .EPIGRAPH_SIZE      -1.5             \}
.       if !r#EPI_AUTOLEAD              \{ .EPIGRAPH_AUTOLEAD  2                \}
.       if !d$EPI_QUAD                  \{ .EPIGRAPH_QUAD      \\*[$DOC_QUAD]   \}
.       if !r#EPI_OFFSET_VALUE          \{ .EPIGRAPH_INDENT    3                \}
.\" +Linebreaks
.       if !d$LINEBREAK_CHAR            \{ .LINEBREAK_CHAR     * 3 3p           \}
.\" +Footnotes
.       if !r#FN_RULE_LENGTH            \{ .FOOTNOTE_RULE_LENGTH 4P             \}
.       if !r#FN_RULE_ADJ               \{ .FOOTNOTE_RULE_ADJ  3p               \}
.       if !d$FN_SIZE_CHANGE            \{ .FOOTNOTE_SIZE      -2               \}
.       if !r#FN_AUTOLEAD               \{ .FOOTNOTE_AUTOLEAD  2                \}
.\" +Endnotes
.       if !r#EN_PS                     \{ .ENDNOTE_PT_SIZE \\n[#DOC_PT_SIZE]u  \}
.       if !d$EN_STRING_FT              \{ .ENDNOTE_STRING_FONT B               \}
.       if !d$EN_STRING_SIZE_CHANGE     \{ .ENDNOTE_STRING_SIZE +1              \}
.       if !d$EN_TITLE_FT               \{ .ENDNOTE_TITLE_FONT  B               \}
.       if !d$EN_TITLE_SIZE_CHANGE      \{ .ENDNOTE_TITLE_SIZE  +0              \}
.       if !d$EN_NUMBER_FT              \{ .ENDNOTE_NUMBER_FONT B               \}
.       if !d$EN_NUMBER_SIZE_CHANGE     \{ .ENDNOTE_NUMBER_SIZE +0              \}
.       if !r#EN_PP_INDENT              \{ .ENDNOTE_PARA_INDENT 1.5m            \}
.\" +Bibliography
.       if !r#BIB_LIST                  \{ .BIBLIOGRAPHY_TYPE LIST .                \}
.       if !r#BIB_PS                    \{ .BIBLIOGRAPHY_PT_SIZE \\n[#DOC_PT_SIZE]u \}
.       if !d$BIB_STRING_FT             \{ .BIBLIOGRAPHY_STRING_FONT B              \}
.       if !d$BIB_STRING_SIZE_CHANGE    \{ .BIBLIOGRAPHY_STRING_SIZE +1             \}
.\" +Table of contents
.       if !d$TOC_FAM                   \{ .TOC_FAMILY  \\*[$DOC_FAM]           \}
.       if !r#TOC_PS                    \{ .TOC_PT_SIZE \\n[#DOC_PT_SIZE]u      \}
.       if !r#TOC_LEAD                  \{ .TOC_LEAD    \\n[#DOC_LEAD]u ADJUST  \}
.       if !d$TOC_HEADER_FAM            \{ .TOC_HEADER_FAMILY \\*[$TOC_FAM]     \}
.       if !d$TOC_HEADER_SIZE_CHANGE    \{ .TOC_HEADER_SIZE +4                  \}
.       if !d$TOC_HEADER_FT             \{ .TOC_HEADER_FONT  B                  \}
.       if !d$TOC_TITLE_FAM             \{ .TOC_TITLE_FAMILY \\*[$TOC_FAM]      \}
.       if !d$TOC_PN_FAM                \{ .TOC_PN_FAMILY    \\*[$TOC_FAM]      \}
.       if !d$TOC_HEAD_FAM              \{ .TOC_HEAD_FAMILY  \\*[$TOC_FAM]      \}
.       if !d$TOC_SH_FAM                \{ .TOC_SUBHEAD_FAMILY  \\*[$TOC_FAM]   \}
.       if !d$TOC_PH_FAM                \{ .TOC_PARAHEAD_FAMILY \\*[$TOC_FAM]   \}
.       if !d$TOC_TITLE_FT              \{ .TOC_TITLE_FONT    BI                \}
.       if !d$TOC_PN_FT                 \{ .TOC_PN_FONT       R                 \}
.       if !d$TOC_HEAD_FT               \{ .TOC_HEAD_FONT     B                 \}
.       if !d$TOC_SH_FT                 \{ .TOC_SUBHEAD_FONT  R                 \}
.       if !d$TOC_PH_FT                 \{ .TOC_PARAHEAD_FONT I                 \}
.       if !d$TOC_TITLE_SIZE_CHANGE     \{ .TOC_TITLE_SIZE    +.5               \}
.       if !d$TOC_PN_SIZE_CHANGE        \{ .TOC_PN_SIZE       +0                \}
.       if !d$TOC_HEAD_SIZE_CHANGE      \{ .TOC_HEAD_SIZE     +.5               \}
.       if !d$TOC_SH_SIZE_CHANGE        \{ .TOC_SUBHEAD_SIZE  +0                \}
.       if !d$TOC_PH_SIZE_CHANGE        \{ .TOC_PARAHEAD_SIZE +0                \}
.    \}
.\" +Refer support
.    if !r#ENDNOTE_REFS \{ .nr #FN_REFS 1 \} 
.    if '\\*[$REF_FN_INDENT]'' \{\
.       if \\n[#PRINT_STYLE]=1 \{ .INDENT_REFS FOOTNOTE 2m   \}
.       if \\n[#PRINT_STYLE]=2 \{ .INDENT_REFS FOOTNOTE 1.5m \}
.    \}
.    if '\\*[$REF_EN_INDENT]'' \{\
.       if \\n[#PRINT_STYLE]=1 \{ .INDENT_REFS ENDNOTE 2m   \}
.       if \\n[#PRINT_STYLE]=2 \{ .INDENT_REFS ENDNOTE 1.5m \}
.    \}
.    if '\\*[$REF_BIB_INDENT]'' \{\
.       if \\n[#PRINT_STYLE]=1 \{ .INDENT_REFS BIBLIO 2m    \}
.       if \\n[#PRINT_STYLE]=2 \{ .INDENT_REFS BIBLIO 1.5m  :\}
.    \}
.\" Adjust doc leading for PRINTSTYLE TYPESET
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#ADJ_DOC_LEAD]=1 \{ .DOC_LEAD_ADJUST \}
.       el \{ . \}
.    \}
.\" This diversion is to get a value for #FN_AUTOLEAD
.    di NULL
.       ev NULL
.       if \\n[#PRINT_STYLE]=1 \{\
.          ps 12
.          ie \\n[#SINGLE_SPACE]=1 \{ .vs \\n[#ORIGINAL_DOC_LEAD]u \}
.          el \{ .vs \\n[#ORIGINAL_DOC_LEAD]u/2u \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          PT_SIZE  \\n[#DOC_PT_SIZE]u\\*[$FN_SIZE_CHANGE]
.          AUTOLEAD \\n[#FN_AUTOLEAD]
.       \}
.       nr #FN_LEAD \\n[#LEAD]
.       if \\n[#PRINT_STYLE]=2 \{ .LS \\n[#DOC_LEAD]u \}
.       ev
.    di
.    ie !\\n[#COLLATE] \{\
.\" DOC_LEAD adjusted (or not) here
.       TRAPS
.       rr #DOC_LEAD_ADJUST_OFF
.\" Endnote, bibliography and toc leading
.       nr #OK_PROCESS_LEAD 1
.       nr #RESTORE_DOC_LEAD \\n(.v
.       nr #RESTORE_B_MARGIN \\n[#B_MARGIN]
.       if \\n[#PRINT_STYLE]=1 \{\
.          ie \\n[#SINGLE_SPACE] \{\
.             ENDNOTE_LEAD 12 ADJUST
.             BIBLIOGRAPHY_LEAD 12 ADJUST
.          \}
.          el \{\
.             ie \\n[#EN_SINGLESPACE] \{ .ENDNOTE_LEAD 12 ADJUST \}
.             el \{ .ENDNOTE_LEAD 24 ADJUST \}
.             ie \\n[#BIB_SINGLESPACE] \{ .BIBLIOGRAPHY_LEAD 12 ADJUST \}
.             el \{ .BIBLIOGRAPHY_LEAD 24 ADJUST \}
.          \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          ie !d$EN_LEAD \{ .ENDNOTE_LEAD 14 ADJUST \}
.          el \{ .ENDNOTE_LEAD \\*[$EN_LEAD] \\*[$ADJUST_EN_LEAD] \}
.          ie !d$BIB_LEAD \{ .BIBLIOGRAPHY_LEAD 14 ADJUST \}
.          el \{ .BIBLIOGRAPHY_LEAD \\*[$BIB_LEAD] \\*[$ADJUST_BIB_LEAD] \}
.          ie !d$TOC_LEAD \{ .TOC_LEAD \\n[#RESTORE_DOC_LEAD]u \}
.          el \{ .TOC_LEAD \\*[$TOC_LEAD] \\*[$ADJUST_TOC_LEAD] \}
.          rm $ADJUST_EN_LEAD
.          rm $ADJUST_BIB_LEAD
.          rm $ADJUST_TOC_LEAD
.       \}
.       ie !d$BIB_SPACE \{ .BIBLIOGRAPHY_SPACING 1v \}
.       el \{\
.          if \\n[#DEFER_BIB_SPACING]=1 \{\
.             BIBLIOGRAPHY_SPACING \\*[$BIB_SPACE]
.             rr #DEFER_BIB_SPACING
.          \}
.       \}
.       DOC_LEAD \\n[#RESTORE_DOC_LEAD]u
.       nr #B_MARGIN \\n[#RESTORE_B_MARGIN]
.    \}
.    el \{\
.       if \\n[#COLLATE] \{\
.          if !\\n[#PRINT_STYLE]=1 \{\
.             if \\n[#RERUN_TRAPS] \{ .TRAPS \}
.          \}
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=1 \{ .nr #IGNORE 1 \}
.END
\#
\# ====================================================================
\#
\# +++START THE DOCUMENT+++
\#
\# THE START MACRO
\# ---------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Reads in default document style parameters and any parameter
\#   the user has changed before issuing START.
\#   Using the information gathered in the opening macros,
\#   prints appropriate title (or chapter #), subtitle, author
\#   and document type (if appropriate).
\# *Notes:
\#   The .PRINT \& (zero-width character) is required to get the
\#   subsequent .sp request to work as advertised.
\#
\#   The overall document line length, family, and point-size
\#   are stored in #DOC_L_LENGTH, $DOC_FAM, and #DOC_PT_SIZE for
\#   use in the HEADER and FOOTER macros.
\#
\#  First, define some strings for point sizes
\#
\# Doc cover
.ds $DOC_COVER_AUTHOR_PT_SIZE        \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_AUTHOR_SIZE_CHANGE]
.ds $DOC_COVER_CHAPTER_TITLE_PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_CHAPTER_TITLE_SIZE_CHANGE]
.ds $DOC_COVER_COPYRIGHT_PT_SIZE     \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_COPYRIGHT_SIZE_CHANGE]
.ds $DOC_COVER_DOCTYPE_PT_SIZE       \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_DOCTYPE_SIZE_CHANGE]
.ds $DOC_COVER_SUBTITLE_PT_SIZE      \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_SUBTITLE_SIZE_CHANGE]
.ds $DOC_COVER_TITLE_PT_SIZE         \\n[#DOC_PT_SIZE]u\\*[$DOC_COVER_TITLE_SIZE_CHANGE]
\# Cover
.ds $COVER_AUTHOR_PT_SIZE        \\n[#DOC_PT_SIZE]u\\*[$COVER_AUTHOR_SIZE_CHANGE]
.ds $COVER_CHAPTER_TITLE_PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$COVER_CHAPTER_TITLE_SIZE_CHANGE]
.ds $COVER_COPYRIGHT_PT_SIZE     \\n[#DOC_PT_SIZE]u\\*[$COVER_COPYRIGHT_SIZE_CHANGE]
.ds $COVER_DOCTYPE_PT_SIZE       \\n[#DOC_PT_SIZE]u\\*[$COVER_DOCTYPE_SIZE_CHANGE]
.ds $COVER_SUBTITLE_PT_SIZE      \\n[#DOC_PT_SIZE]u\\*[$COVER_SUBTITLE_SIZE_CHANGE]
.ds $COVER_TITLE_PT_SIZE         \\n[#DOC_PT_SIZE]u\\*[$COVER_TITLE_SIZE_CHANGE]
\# Docheader
.ds $AUTHOR_PT_SIZE         \\n[#DOC_PT_SIZE]u\\*[$AUTHOR_SIZE_CHANGE]
.ds $CHAPTER_TITLE_PT_SIZE  \\n[#DOC_PT_SIZE]u\\*[$CHAPTER_TITLE_SIZE_CHANGE]
.ds $COPYRIGHT_PT_SIZE      \\n[#DOC_PT_SIZE]u\\*[$COPYRIGHT_SIZE_CHANGE]
.ds $DOCTYPE_PT_SIZE        \\n[#DOC_PT_SIZE]u\\*[$DOCTYPE_SIZE_CHANGE]
.ds $SUBTITLE_PT_SIZE       \\n[#DOC_PT_SIZE]u\\*[$SUBTITLE_SIZE_CHANGE]
.ds $TITLE_PT_SIZE          \\n[#DOC_PT_SIZE]u\\*[$TITLE_SIZE_CHANGE]
\#
\# Next, some utility macros for various routines to prevent repetition
\#
.MAC PRINT_AUTHORS END
.    nr #AUTHORS \\n[#AUTHOR_NUM]
.    nr #NEXT_AUTHOR 0 1
.    ie r#DOING_COVER \{\
.       if \\n[#COVER]=1 \{\
.          while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.             ie \\n[#COVER_AUTHOR_COLOR]=1 \{\
.                PRINT \m[\\*[$COVER_AUTHOR_COLOR]]\\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]\m[]
.             \}
.             el \{ .PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]] \}
.\}
.       \}
.       if \\n[#DOC_COVER]=1 \{\
.          while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.             ie \\n[#DOC_COVER_AUTHOR_COLOR]=1 \{\
.                PRINT \m[\\*[$DOC_COVER_AUTHOR_COLOR]]\\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]\m[]
.             \}
.             el \{ .PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]] \}
.\}
.       \}
.    \}
.    el \{\
.       while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.          ie \\n[#AUTHOR_COLOR]=1 \{\
.             PRINT \m[\\*[$AUTHOR_COLOR]]\\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]\m[]
.          \}
.          el \{ .PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]] \}
.\}
.    \}
.END
\#
.MAC DEFAULT_DOCHEADER END
.    CENTER
.    FAMILY  \\*[$TITLE_FAM]
.    FT      \\*[$TITLE_FT]
.    PT_SIZE \\*[$TITLE_PT_SIZE]
.    LS      \\n[#DOCHEADER_LEAD]u
.    ie \\n[#TITLE_COLOR]=1 \{\
.       PRINT \m[\\*[$TITLE_COLOR]]\\*[$TITLE]\m[]
.    \}
.    el \{ .PRINT \\*[$TITLE] \}
.    if !'\\*[$SUBTITLE]'' \{\
.       FAMILY  \\*[$SUBTITLE_FAM]
.       FT      \\*[$SUBTITLE_FT]
.       PT_SIZE \\*[$SUBTITLE_PT_SIZE]
.       ie \\n[#SUBTITLE_COLOR]=1 \{\
.          PRINT \m[\\*[$SUBTITLE_COLOR]]\\*[$TITLE]\m[]
.       \}
.       el \{ .PRINT \\*[$SUBTITLE] \}
.    \}
.    if !'\\*[$AUTHOR_1]'' \{\
.       FAMILY  \\*[$AUTHOR_FAM]
.       FT      \\*[$AUTHOR_FT]
.       PT_SIZE \\*[$AUTHOR_PT_SIZE]
.       if !'\\*[$ATTRIBUTE_STRING]'' \{\
.          ie \\n[#ATTRIBUTE_COLOR]=1 \{\
.             PRINT \m[\\*[$ATTRIBUTE_COLOR]]\\*[$ATTRIBUTE_STRING]\m[]
.          \}
.          el \{ .PRINT \\*[$ATTRIBUTE_STRING] \}
.       \}
.       PRINT_AUTHORS
.    \}
.END
\#
\#
.MAC CHAPTER_DOCHEADER END
.    CENTER
.    FAMILY  \\*[$TITLE_FAM]
.    FT      \\*[$TITLE_FT]
.    PT_SIZE \\*[$TITLE_PT_SIZE]
.    LS      \\n[#DOCHEADER_LEAD]u
.\" Chapter title only
.    ie '\\*[$CHAPTER]'' \{\
.       ie !'\\*[$CHAPTER_TITLE]'' \{\
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$CHAPTER_TITLE_FAM]
.             FT      \\*[$CHAPTER_TITLE_FT]
.             PT_SIZE \\*[$CHAPTER_TITLE_PT_SIZE]
.             LS      \\n[#DOCHEADER_LEAD]u
.          \}
.          ie \\n[#TITLE_COLOR]=1 \{\
.             PRINT \m[\\*[$TITLE_COLOR]]\\*[$CHAPTER_TITLE]\m[]
.          \}
.          el \{ .PRINT \\*[$CHAPTER_TITLE] \}
.       \}
.       el \{\
.          ie \\n[#TITLE_COLOR]=1 \{\
.             PRINT \m[\\*[$TITLE_COLOR]]\\*[$CHAPTER_STRING]\m[]
.          \}
.          el \{ .PRINT \\*[$CHAPTER_STRING] \}
.       \}
.    \}
.\" Chapter string, possibly with a chapter title
.    el \{\
.       ie \\n[#TITLE_COLOR]=1 \{\
.          PRINT \m[\\*[$TITLE_COLOR]]\\*[$CHAPTER_STRING] \\*[$CHAPTER]\m[]
.       \}
.       el \{ .PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER] \}
.       if !'\\*[$CHAPTER_TITLE]'' \{\
.          if \\n[#PRINT_STYLE]=1 \{ .PRINT \\*[$CHAPTER_TITLE] \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$CHAPTER_TITLE_FAM]
.             FT      \\*[$CHAPTER_TITLE_FT]
.             PT_SIZE \\*[$CHAPTER_TITLE_PT_SIZE]
.             LS      \\n[#DOCHEADER_LEAD]u
.             ie \\n[#CHAPTER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$CHAPTER_TITLE_COLOR]]\\*[$CHAPTER_TITLE]\m[]
.             \}
.             el \{ .PRINT \\*[$CHAPTER_TITLE] \}
.             RLD \\n[#DOC_LEAD]u \" Just looks better this way
.          \}
.       \}
.    \}
.END
\#
\#
.MAC NAMED_DOCHEADER END
.    CENTER
.    FAMILY  \\*[$TITLE_FAM]
.    FT      \\*[$TITLE_FT]
.    PT_SIZE \\*[$TITLE_PT_SIZE]
.    LS      \\n[#DOCHEADER_LEAD]u
.    ie \\n[#TITLE_COLOR]=1 \{\
.       PRINT \m[\\*[$TITLE_COLOR]]\\*[$TITLE]\m[]
.    \}
.    el \{ .PRINT \\*[$TITLE] \}
.    if !'\\*[$SUBTITLE]'' \{\
.       FAMILY  \\*[$SUBTITLE_FAM]
.       FT      \\*[$SUBTITLE_FT]
.       PT_SIZE \\*[$SUBTITLE_PT_SIZE]
.       ie \\n[#SUBTITLE_COLOR]=1 \{\
.          PRINT \m[\\*[$SUBTITLE_COLOR]]\\*[$TITLE]\m[]
.       \}
.       el \{ .PRINT \\*[$SUBTITLE] \}
.    \}
.    if !'\\*[$AUTHOR_1]'' \{\
.       FAMILY  \\*[$AUTHOR_FAM]
.       FT      \\*[$AUTHOR_FT]
.       PT_SIZE \\*[$AUTHOR_PT_SIZE]
.       if !'\\*[$ATTRIBUTE_STRING]'' \{\
.          ie \\n[#ATTRIBUTE_COLOR]=1 \{\
.             PRINT \m[\\*[$ATTRIBUTE_COLOR]]\\*[$ATTRIBUTE_STRING]\m[]
.          \}
.          el \{ .PRINT \\*[$ATTRIBUTE_STRING] \}
.       \}
.       PRINT_AUTHORS
.    \}
.    FAMILY  \\*[$DOCTYPE_FAM]
.    FT      \\*[$DOCTYPE_FT]
.    PT_SIZE \\*[$DOCTYPE_PT_SIZE]
.    LS      \\n[#DOCHEADER_LEAD]u
.    ALD     \\n[#DOCHEADER_LEAD]u
.    ie \\n[#DOCTYPE_COLOR]=1 \{\
.       COLOR \\*[$DOCTYPE_COLOR]
.       UNDERSCORE "\\*[$DOC_TYPE]
.    \}
.    el .UNDERSCORE "\\*[$DOC_TYPE]
.END
\#
\#
\# COVER PAGE
\# ----------
\# *Arguments:
\#   TITLE | DOCTITLE | CHAPTER | CHAPTER_TITLE | CHAPTER+TITLE | COVERTITLE ...
\#   ... [ SUBTITLE AUTHOR DOCTYPE COPYRIGHT MISC ]
\# *Function:
\#   Toggles the number register for each cover page element
\#   passed as an argument.
\# *Notes:
\#   TITLE, DOCTITLE, CHAPTER, CHAPTER_TITLE or CHAPTER+TITLE must
\#   be supplied.  After that, users may enter as many or as few of
\#   the arguments as they like; however, the arguments must appear
\#   in the order given above.
\#
\#   If called as DOC_COVER, performs the same operations, but
\#   applies everything to a doc cover.
\#
.MAC COVER END
.    ie '\\$0'DOC_COVER' \{\
.       nr #DOC_COVER 1
.       if '\\$1'TITLE'         \{ .nr #DOC_COVER_TITLE     1 \}
.       if '\\$1'DOCTITLE'      \{ .nr #DOC_COVER_TITLE     2 \}
.       if '\\$1'CHAPTER'       \{ .nr #DOC_COVER_TITLE     3 \}
.       if '\\$1'CHAPTER_TITLE' \{ .nr #DOC_COVER_TITLE     4 \}
.       if '\\$1'CHAPTER+TITLE' \{ .nr #DOC_COVER_TITLE     5 \}
.       if '\\$1'COVERTITLE'    \{ .nr #DOC_COVER_TITLE     6 \}
.       if '\\$2'SUBTITLE'      \{ .nr #DOC_COVER_SUBTITLE  1 \}
.       if '\\$2'AUTHOR'        \{ .nr #DOC_COVER_AUTHOR    1 \}
.       if '\\$2'DOCTYPE'       \{ .nr #DOC_COVER_DOCTYPE   1 \}
.       if '\\$2'COPYRIGHT'     \{ .nr #DOC_COVER_COPYRIGHT 1 \}
.       if '\\$2'MISC'          \{ .nr #DOC_COVER_MISC      1 \}
.       if '\\$3'AUTHOR'        \{ .nr #DOC_COVER_AUTHOR    1 \}
.       if '\\$3'DOCTYPE'       \{ .nr #DOC_COVER_DOCTYPE   1 \}
.       if '\\$3'COPYRIGHT'     \{ .nr #DOC_COVER_COPYRIGHT 1 \}
.       if '\\$3'MISC'          \{ .nr #DOC_COVER_MISC      1 \}
.       if '\\$4'DOCTYPE'       \{ .nr #DOC_COVER_DOCTYPE   1 \}
.       if '\\$4'COPYRIGHT'     \{ .nr #DOC_COVER_COPYRIGHT 1 \}
.       if '\\$4'MISC'          \{ .nr #DOC_COVER_MISC      1 \}
.       if '\\$5'COPYRIGHT'     \{ .nr #DOC_COVER_COPYRIGHT 1 \}
.       if '\\$5'MISC'          \{ .nr #DOC_COVER_MISC      1 \}
.       if '\\$6'MISC'          \{ .nr #DOC_COVER_MISC      1 \}
.    \}
.    el \{\
.       nr #COVER 1
.       if '\\$1'TITLE'         \{ .nr #COVER_TITLE     1 \}
.       if '\\$1'DOCTITLE'      \{ .nr #COVER_TITLE     2 \}
.       if '\\$1'CHAPTER'       \{ .nr #COVER_TITLE     3 \}
.       if '\\$1'CHAPTER_TITLE' \{ .nr #COVER_TITLE     4 \}
.       if '\\$1'CHAPTER+TITLE' \{ .nr #COVER_TITLE     5 \}
.       if '\\$1'COVERTITLE'    \{ .nr #COVER_TITLE     6 \}
.       if '\\$2'SUBTITLE'      \{ .nr #COVER_SUBTITLE  1 \}
.       if '\\$2'AUTHOR'        \{ .nr #COVER_AUTHOR    1 \}
.       if '\\$2'DOCTYPE'       \{ .nr #COVER_DOCTYPE   1 \}
.       if '\\$2'COPYRIGHT'     \{ .nr #COVER_COPYRIGHT 1 \}
.       if '\\$2'MISC'          \{ .nr #COVER_MISC      1 \}
.       if '\\$3'AUTHOR'        \{ .nr #COVER_AUTHOR    1 \}
.       if '\\$3'DOCTYPE'       \{ .nr #COVER_DOCTYPE   1 \}
.       if '\\$3'COPYRIGHT'     \{ .nr #COVER_COPYRIGHT 1 \}
.       if '\\$3'MISC'          \{ .nr #COVER_MISC      1 \}
.       if '\\$4'DOCTYPE'       \{ .nr #COVER_DOCTYPE   1 \}
.       if '\\$4'COPYRIGHT'     \{ .nr #COVER_COPYRIGHT 1 \}
.       if '\\$4'MISC'          \{ .nr #COVER_MISC      1 \}
.       if '\\$5'COPYRIGHT'     \{ .nr #COVER_COPYRIGHT 1 \}
.       if '\\$5'MISC'          \{ .nr #COVER_MISC      1 \}
.       if '\\$6'MISC'          \{ .nr #COVER_MISC      1 \}
.    \}
.END
\#
\#
.MAC COVERTITLE END
.    ie '\\$0'DOC_COVERTITLE' .ds $DOC_COVER_TITLE \\$1
.    el .ds $COVER_TITLE \\$1
.END
\#
\#
\# COVER PAGE LEADING
\# ------------------
\# *Arguments:
\#   <+|- amount by which to in/decrease leading of cover/doc cover>
\# *Function:
\#   Stores user supplied lead in/decrease in string $COVER_LEAD_ADJ
\#   or $DOC_COVER_LEAD_ADJ, depending on whether the macro was called
\#   with an alias (DOC_COVER_LEAD).
\# *Notes:
\#   A unit of measure must be supplied.  Decimal fractions OK.
\#   Default is +0, i.e. same as DOC_LEAD.
\#
.MAC COVER_LEAD END
.    ie '\\$0'DOC_COVER_LEAD' \{\
.       ds $DOC_COVER_LEAD_ADJ \\$1
.    \}
.    el \{\
.       ds $COVER_LEAD_ADJ \\$1
.    \}
.END
\#
\#
\# COVER PAGE START POSITION
\# -------------------------
\# *Arguments:
\#   <distance from page top at which to start cover/doc cover>
\# *Function:
\#   Stores user supplied lead in/decrease in #COVER_START_POS
\#   or #DOC_COVER_START_POS, depending on whether the macro was
\#   called by an alias (DOC_COVER_ADVANCE).
\# *Notes:
\#   A unit of measure must be supplied.  Decimal fractions OK.
\#   If user doesn't invoke this macro, the default starting
\#   position for both covers and doc covers is 1/3 of the way
\#   down the page (setup in DO_COVER).
\#
.MAC COVER_ADVANCE END
.    ie '\\$0'DOC_COVER_ADVANCE' \{\
.       nr #DOC_COVER_START_POS (\\$1)
.    \}
.    el \{\
.       nr #COVER_START_POS (\\$1)
.    \}
.END
\#
\#
\# COVERS - WHETHER TO PRINT
\# -------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes registers #COVERS and #COVERS_OFF, checked for
\#   in DEFAULTS (in START) prior to printing
\#
.MAC COVERS END
.    ie '\\$0'DOC_COVERS' \{\
.       ie '\\$1'' \{\
.          rr #DOC_COVERS_OFF
.          nr #DOC_COVERS 1
.       \}
.       el \{\
.          rr #DOC_COVERS
.          nr #DOC_COVERS_OFF 1
.       \}
.    \}
.    el \{\
.       ie '\\$1'' \{\
.          rr #COVERS_OFF
.          nr #COVERS 1
.       \}
.       el \{\
.          rr #COVERS
.          nr #COVERS_OFF 1
.       \}
.    \}
.END
\#
\#
.MAC DO_COVER END
.    nr #DOING_COVER 1
.    ev COVER
.    evc 0
.    TRAP OFF
.    if \\n[#PAGINATE]=1 \{\
.       nr #PAGINATION_WAS_ON 1
.       rr #PAGINATE
.    \}
.    if \\n[#HEADERS_ON]=1 \{\
.       nr #HEADERS_WERE_ON 1
.       HEADERS OFF
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       nr #FOOTERS_WERE_ON 1
.       FOOTERS OFF
.    \}
.    if \\n[#COLUMNS]=1 \{\
.       nr #COLUMNS_WERE_ON 1
.       rr #COLUMNS
.    \}
.\" Doc cover
.    ie '\\$0'DO_DOC_COVER' \{\
.       if !r#DOC_COVER_START_POS \{\
.          nr #DOC_COVER_START_POS \\n[#PAGE_LENGTH]/3
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          ie \\n[#SINGLE_SPACE]=1 \{ .vs \\n[#DOC_LEAD]u*2u \}
.          el \{ .vs \\n[#DOC_LEAD]u \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          LS \\n[#DOC_LEAD]u\\*[$DOC_COVER_LEAD_ADJ]
.          nr #DOC_COVER_LEAD \\n[#LEAD]
.       \}
.       PRINT \&
.       sp |\\n[#DOC_COVER_START_POS]u-1v
.       if \\n[#DOC_COVER_COLOR]=1 \{\
.          nf
\m[\\*[$DOC_COVER_COLOR]]
.          EOL
.       \}
.       CENTER
.       FAMILY  \\*[$DOC_COVER_TITLE_FAM]
.       FT      \\*[$DOC_COVER_TITLE_FT]
.       PT_SIZE \\*[$DOC_COVER_TITLE_PT_SIZE]
.       LS      \\n[#DOC_COVER_LEAD]u
.       if \\n[#PRINT_STYLE]=1 \{ .TYPEWRITER \}
.       if \\n[#DOC_COVER_TITLE]=1 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             CAPS
.             UNDERSCORE "\\*[$TITLE]"
.             CAPS OFF
.          \}
.          el \{\
.             ie \\n[#DOC_COVER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$DOC_COVER_TITLE_COLOR]]\\*[$TITLE]\m[]
.             \}
.             el \{ .PRINT \\*[$TITLE] \}
.          \}
.       \}
.       if \\n[#DOC_COVER_TITLE]=2 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             CAPS
.             UNDERSCORE "\\*[$DOC_TITLE]"
.             CAPS OFF
.          \}
.          el \{\
.             ie \\n[#DOC_COVER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$DOC_COVER_TITLE_COLOR]]\\*[$DOC_TITLE]\m[]
.             \}
.             el \{ .PRINT \\*[$DOC_TITLE] \}
.          \}
.       \}
.       if \\n[#DOC_COVER_TITLE]=3 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             CAPS
.             PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.             CAPS OFF
.          \}
.          el \{\
.             ie \\n[#DOC_COVER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$DOC_COVER_TITLE_COLOR]]\\*[$CHAPTER_STRING] \\*[$CHAPTER]\m[]
.             \}
.             el \{ .PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER] \}
.          \}
.       \}
.       if \\n[#DOC_COVER_TITLE]=4 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             CAPS
.             UNDERSCORE "\\*[$CHAPTER_TITLE]"
.             CAPS OFF
.          \}
.          el \{\
.             ie \\n[#DOC_COVER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$DOC_COVER_TITLE_COLOR]]\\*[$CHAPTER_TITLE]\m[]
.             \}
.             el \{ .PRINT \\*[$CHAPTER_TITLE] \}
.          \}
.       \}
.       if \\n[#DOC_COVER_TITLE]=5 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             CAPS
.             PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.             CAPS OFF
.          \}
.          el \{\
.             ie \\n[#DOC_COVER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$DOC_COVER_TITLE_COLOR]]\\*[$CHAPTER_STRING] \\*[$CHAPTER]\m[]
.             \}
.             el \{ .PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER] \}
.          \}
.          if !'\\*[$CHAPTER_TITLE]'' \{\
.             ie \\n[#PRINT_STYLE]=1 \{\
.                UNDERSCORE "\\*[$CHAPTER_TITLE]"
.             \}
.             el \{\
.                FAMILY  \\*[$DOC_COVER_CHAPTER_TITLE_FAM]
.                FT      \\*[$DOC_COVER_CHAPTER_TITLE_FT]
.                PT_SIZE \\*[$DOC_COVER_CHAPTER_TITLE_PT_SIZE]
.                ie \\n[#DOC_COVER_CHAPTER_TITLE_COLOR]=1 \{\
.                   PRINT \m[\\*[$DOC_COVER_CHAPTER_TITLE_COLOR]]\\*[$CHAPTER_TITLE]\m[]
.                \}
.                el \{ .PRINT \\*[$CHAPTER_TITLE] \}
.             \}
.          \}
.       \}
.       if \\n[#DOC_COVER_TITLE]=6 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             CAPS
.             UNDERSCORE "\\*[$DOC_COVER_TITLE]"
.             CAPS OFF
.          \}
.          el \{\
.             ie \\n[#DOC_COVER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$DOC_COVER_TITLE_COLOR]]\\*[$DOC_COVER_TITLE]\m[]
.             \}
.             el \{ .PRINT \\*[$DOC_COVER_TITLE] \}
.          \}
.       \}
.       if \\n[#DOC_COVER_SUBTITLE]=1 \{\
.          FAMILY  \\*[$DOC_COVER_SUBTITLE_FAM]
.          FT      \\*[$DOC_COVER_SUBTITLE_FT]
.          PT_SIZE \\*[$DOC_COVER_SUBTITLE_PT_SIZE]
.          if \\n[#PRINT_STYLE]=1 \{ .TYPEWRITER \}
.          ie \\n[#DOC_COVER_SUBTITLE_COLOR]=1 \{\
.             PRINT \m[\\*[$DOC_COVER_SUBTITLE_COLOR]]\\*[$SUBTITLE]\m[]
.          \}
.          el \{ .PRINT \\*[$SUBTITLE] \}
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          if !r#DOC_COVER_SUBTITLE \{ .SP \}
.       \}
.       if \\n[#DOC_COVER_AUTHOR]=1 \{\
.          FAMILY  \\*[$DOC_COVER_AUTHOR_FAM]
.          FT      \\*[$DOC_COVER_AUTHOR_FT]
.          PT_SIZE \\*[$DOC_COVER_AUTHOR_PT_SIZE]
.          if \\n[#PRINT_STYLE]=1 \{\
.             TYPEWRITER
.             vs \\n[#DOC_LEAD]u/2u
.          \}
.          if !'\\*[$ATTRIBUTE_STRING]'' \{\
.             ie \\n[#DOC_COVER_ATTRIBUTE_COLOR]=1 \{\
.                PRINT \m[\\*[$DOC_COVER_ATTRIBUTE_COLOR]]\\*[$ATTRIBUTE_STRING]\m[]
.             \}
.             el \{ .PRINT \\*[$ATTRIBUTE_STRING] \}
.          \}
.          PRINT_AUTHORS
.       \}
.       FAMILY  \\*[$DOC_COVER_DOCTYPE_FAM]
.       FT      \\*[$DOC_COVER_DOCTYPE_FT]
.       PT_SIZE \\*[$DOC_COVER_DOCTYPE_PT_SIZE]
.       SP
.       if \\n[#DOC_COVER_DOCTYPE]=1 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             TYPEWRITER
.             vs \\n[#DOC_LEAD]u
.             UNDERSCORE2 "\\*[$DOC_TYPE]
.          \}
.          el \{\
.             ie \\n[#DOC_COVER_DOCTYPE_COLOR]=1 \{\
.                COLOR \\*[$DOC_COVER_DOCTYPE_COLOR]
.                UNDERSCORE "\\*[$DOC_TYPE]
.             \}
.             el .UNDERSCORE "\\*[$DOC_TYPE]
.          \}
.       \}
.       sp |\\n[#VISUAL_B_MARGIN]u+\\n[#DOC_LEAD]u
.       ie \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          ie \\n[#SINGLE_SPACE]=1 \{ .vs \\n[#DOC_LEAD]u \}
.          el \{ .vs \\n[#DOC_LEAD]u/2u \}
.       \}
.       el \{\
.          FAMILY  \\*[$DOC_COVER_COPYRIGHT_FAM]
.          FT      \\*[$DOC_COVER_COPYRIGHT_FT]
.          AUTOLEAD 2
.          PT_SIZE \\*[$DOC_COVER_COPYRIGHT_PT_SIZE]
.       \}
.       if \\n[#DOC_COVER_COPYRIGHT]=1 \{\
.          QUAD \\*[$DOC_COVER_COPYRIGHT_QUAD]
.          ie \\n[#DOC_COVER_COPYRIGHT_COLOR]=1 \{\
.             PRINT \m[\\*[$DOC_COVER_COPYRIGHT_COLOR]]\\*[$COPYRIGHT]\m[]
.          \}
.          el \{ .PRINT \\*[$COPYRIGHT] \}
.       \}
.       sp |\\n[#VISUAL_B_MARGIN]u+\\n[#DOC_LEAD]u
.       if \\n[#DOC_COVER_MISC]=1 \{\
.          QUAD \\*[$DOC_COVER_MISC_QUAD]
.          nr #MISCS \\n[#MISC_NUM]
.          sp -\\n[#MISCS]+1
.          nr #NEXT_MISC 0 1
.          while \\n[#MISCS]>\\n[#NEXT_MISC] \{\
.             ie \\n[#DOC_COVER_MISC_COLOR]=1 \{\
.                PRINT \m[\\*[$DOC_COVER_MISC_COLOR]]\\*[$MISC_\\n+[#NEXT_MISC]]\m[]
.                br
.             \}
.             el \{\
.                PRINT \\*[$MISC_\\n+[#NEXT_MISC]]
.                br
.             \}
.\}
.       \}
.    \}
.\" Cover
.    el \{\
.       if !r#COVER_START_POS \{\
.          nr #COVER_START_POS \\n[#PAGE_LENGTH]/3
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          ie \\n[#SINGLE_SPACE]=1 \{ .vs \\n[#DOC_LEAD]u*2u \}
.          el \{ .vs \\n[#DOC_LEAD]u \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          LS \\n[#DOC_LEAD]u\\*[$COVER_LEAD_ADJ]
.          nr #COVER_LEAD \\n[#LEAD]
.       \}
.       PRINT \&
.       sp |\\n[#COVER_START_POS]u-1v
.       if \\n[#COVER_COLOR]=1 \{\
.          nf
\m[\\*[$COVER_COLOR]]
.          EOL
.       \}
.       CENTER
.       FAMILY  \\*[$COVER_TITLE_FAM]
.       FT      \\*[$COVER_TITLE_FT]
.       PT_SIZE \\*[$COVER_TITLE_PT_SIZE]
.       LS      \\n[#COVER_LEAD]u
.       if \\n[#PRINT_STYLE]=1 \{ .TYPEWRITER \}
.       if \\n[#COVER_TITLE]=1 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             CAPS
.             UNDERSCORE "\\*[$TITLE]"
.             CAPS OFF
.          \}
.          el \{\
.             ie \\n[#COVER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$COVER_TITLE_COLOR]]\\*[$TITLE]\m[]
.             \}
.             el \{ .PRINT \\*[$TITLE] \}
.          \}
.       \}
.       if \\n[#COVER_TITLE]=2 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             CAPS
.             UNDERSCORE "\\*[$DOC_TITLE]"
.             CAPS OFF
.          \}
.          el \{\
.             ie \\n[#COVER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$COVER_TITLE_COLOR]]\\*[$DOC_TITLE]\m[]
.             \}
.             el \{ .PRINT \\*[$DOC_TITLE] \}
.          \}
.       \}
.       if \\n[#COVER_TITLE]=3 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             CAPS
.             PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.             CAPS OFF
.          \}
.          el \{\
.             ie \\n[#COVER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$COVER_TITLE_COLOR]]\\*[$CHAPTER_STRING] \\*[$CHAPTER]\m[]
.             \}
.             el \{ .PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER] \}
.          \}
.       \}
.       if \\n[#COVER_TITLE]=4 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             CAPS
.             UNDERSCORE "\\*[$CHAPTER_TITLE]"
.             CAPS OFF
.          \}
.          el \{\
.             ie \\n[#COVER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$COVER_TITLE_COLOR]]\\*[$CHAPTER_TITLE]\m[]
.             \}
.             el \{ .PRINT \\*[$CHAPTER_TITLE] \}
.          \}
.       \}
.       if \\n[#COVER_TITLE]=5 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             CAPS
.             PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.             CAPS OFF
.          \}
.          el \{\
.             ie \\n[#COVER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$COVER_TITLE_COLOR]]\\*[$CHAPTER_STRING] \\*[$CHAPTER]\m[]
.             \}
.             el \{ .PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER] \}
.          \}
.          if !'\\*[$CHAPTER_TITLE]'' \{\
.             ie \\n[#PRINT_STYLE]=1 \{\
.                UNDERSCORE "\\*[$CHAPTER_TITLE]"
.             \}
.             el \{\
.                FAMILY  \\*[$COVER_CHAPTER_TITLE_FAM]
.                FT      \\*[$COVER_CHAPTER_TITLE_FT]
.                PT_SIZE \\*[$COVER_CHAPTER_TITLE_PT_SIZE]
.                ie \\n[#COVER_CHAPTER_TITLE_COLOR]=1 \{\
.                   PRINT \m[\\*[$COVER_CHAPTER_TITLE_COLOR]]\\*[$CHAPTER_TITLE]\m[]
.                \}
.                el \{ .PRINT \\*[$CHAPTER_TITLE] \}
.             \}
.          \}
.       \}
.       if \\n[#COVER_TITLE]=6 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             CAPS
.             UNDERSCORE "\\*[$COVER_TITLE]"
.             CAPS OFF
.          \}
.          el \{\
.             ie \\n[#COVER_TITLE_COLOR]=1 \{\
.                PRINT \m[\\*[$COVER_TITLE_COLOR]]\\*[$COVER_TITLE]\m[]
.             \}
.             el \{ .PRINT \\*[$COVER_TITLE] \}
.          \}
.       \}
.       if \\n[#COVER_SUBTITLE]=1 \{\
.          FAMILY  \\*[$COVER_SUBTITLE_FAM]
.          FT      \\*[$COVER_SUBTITLE_FT]
.          PT_SIZE \\*[$COVER_SUBTITLE_PT_SIZE]
.          if \\n[#PRINT_STYLE]=1 \{ .TYPEWRITER \}
.          ie \\n[#COVER_SUBTITLE_COLOR]=1 \{\
.             PRINT \m[\\*[$COVER_SUBTITLE_COLOR]]\\*[$SUBTITLE]\m[]
.          \}
.          el \{ .PRINT \\*[$SUBTITLE] \}
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          if !r#COVER_SUBTITLE \{ .SP \}
.       \}
.       if \\n[#COVER_AUTHOR]=1 \{\
.          FAMILY  \\*[$COVER_AUTHOR_FAM]
.          FT      \\*[$COVER_AUTHOR_FT]
.          PT_SIZE \\*[$COVER_AUTHOR_PT_SIZE]
.          if \\n[#PRINT_STYLE]=1 \{\
.             TYPEWRITER
.             vs \\n[#DOC_LEAD]u/2u
.          \}
.          if !'\\*[$ATTRIBUTE_STRING]'' \{\
.             ie \\n[#COVER_ATTRIBUTE_COLOR]=1 \{\
.                PRINT \m[\\*[$COVER_ATTRIBUTE_COLOR]]\\*[$ATTRIBUTE_STRING]\m[]
.             \}
.             el \{ .PRINT \\*[$ATTRIBUTE_STRING] \}
.          \}
.          PRINT_AUTHORS
.       \}
.       FAMILY  \\*[$COVER_DOCTYPE_FAM]
.       FT      \\*[$COVER_DOCTYPE_FT]
.       PT_SIZE \\*[$COVER_DOCTYPE_PT_SIZE]
.       SP
.       if \\n[#COVER_DOCTYPE]=1 \{\
.          ie \\n[#PRINT_STYLE]=1 \{\
.             TYPEWRITER
.             vs \\n[#DOC_LEAD]u
.             UNDERSCORE2 "\\*[$DOC_TYPE]
.          \}
.          el \{\
.             ie \\n[#COVER_DOCTYPE_COLOR]=1 \{\
.                COLOR \\*[$COVER_DOCTYPE_COLOR]
.                UNDERSCORE "\\*[$DOC_TYPE]
.             \}
.             el .UNDERSCORE "\\*[$DOC_TYPE]
.          \}
.       \}
.       sp |\\n[#VISUAL_B_MARGIN]u+\\n[#DOC_LEAD]u
.       ie \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          ie \\n[#SINGLE_SPACE]=1 \{ .vs \\n[#DOC_LEAD]u \}
.          el \{ .vs \\n[#DOC_LEAD]u/2u \}
.       \}
.       el \{\
.          FAMILY  \\*[$COVER_COPYRIGHT_FAM]
.          FT      \\*[$COVER_COPYRIGHT_FT]
.          AUTOLEAD 2
.          PT_SIZE \\*[$COVER_COPYRIGHT_PT_SIZE]
.       \}
.       if \\n[#COVER_COPYRIGHT]=1 \{\
.          QUAD \\*[$COVER_COPYRIGHT_QUAD]
.          ie \\n[#COVER_COPYRIGHT_COLOR]=1 \{\
.             PRINT \m[\\*[$COVER_COPYRIGHT_COLOR]]\\*[$COPYRIGHT]\m[]
.          \}
.          el \{ .PRINT \\*[$COPYRIGHT] \}
.       \}
.       sp |\\n[#VISUAL_B_MARGIN]u+\\n[#DOC_LEAD]u
.       if \\n[#COVER_MISC]=1 \{\
.          QUAD \\*[$COVER_MISC_QUAD]
.          nr #MISCS \\n[#MISC_NUM]
.          sp -\\n[#MISCS]+1
.          nr #NEXT_MISC 0 1
.          while \\n[#MISCS]>\\n[#NEXT_MISC] \{\
.             ie \\n[#COVER_MISC_COLOR]=1 \{\
.                PRINT \m[\\*[$COVER_MISC_COLOR]]\\*[$MISC_\\n+[#NEXT_MISC]]\m[]
.                br
.             \}
.             el \{\
.                PRINT \\*[$MISC_\\n+[#NEXT_MISC]]
.                br
.             \}
.\}
.       \}
.    \}
.    EOL
.    TRAP
.    NEWPAGE
.    ev
.    if \\n[#PAGINATION_WAS_ON] \{\
.       rr #PAGINATION_WAS_ON
.       PAGINATE
.       PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]-1
.    \}
.    if \\n[#HEADERS_WERE_ON] \{\
.       rr #HEADERS_WERE_ON
.       HEADERS
.    \}
.    if \\n[#FOOTERS_WERE_ON] \{\
.       rr #FOOTERS_WERE_ON
.       FOOTERS
.    \}
.    if \\n[#COLUMNS_WERE_ON]=1 \{\
.       rr #COLUMNS_WERE_ON 1
.       nr #COLUMNS 1
.    \}
.    rr #DOING_COVER
.END
\#
\#
.MAC START END
.    if !\\n[#PRINT_STYLE] \{\
.       PRINTSTYLE TYPEWRITE
.       PRINT \&
.       po 6P
.       ll 39P
.       ta \\n(.lu
.       sp |1i-1v
.       CENTER
.       PRINT "You neglected to enter a PRINTSTYLE"
.       fl
.       ab PRINTSTYLE missing
.    \}
.    nr #DOCS 1
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#COLLATE] \{\
.       COPYSTYLE \\*[$COPY_STYLE]
.       nr #HEADERS_ON \\n[#HEADER_STATE]
.       if \\n[#PAGE_NUM_V_POS]=1 \{ .nr #PAGINATE \\n[#PAGINATION_STATE] \}
.       sp |\\n[#HEADER_MARGIN]u
.       PRINT \&
.       if !'\\*[$RESTORE_PAGENUM_STYLE]'' \{\
.          PAGENUM_STYLE \\*[$RESTORE_PAGENUM_STYLE]
.          rm $RESTORE_PAGENUM_STYLE
.       \}
.    \}
.    DEFAULTS
.\" Quote and blockquote default leads are the same as #DOC_LEAD, so
.\" they have to be set after DEFAULTS (where DOC_LEAD is finalized)
.    if !r#Q_AUTOLEAD     \{ .nr #Q_LEAD \\n[#DOC_LEAD]    \}
.    if !r#BQ_AUTOLEAD    \{ .nr #BQ_LEAD \\n[#DOC_LEAD]   \}
.    if !r#EN_Q_AUTOLEAD  \{ .nr #EN_Q_LEAD \\n[#EN_LEAD]  \}
.    if !r#EN_BQ_AUTOLEAD \{ .nr #EN_BQ_LEAD \\n[#EN_LEAD] \}
.\" Covers and doc covers
.    if \\n[#DOC_COVERS]=1 \{\
.       if \\n[#DOC_COVER]=1 \{\
.          DO_DOC_COVER
.          rr #DOC_COVER
.          rr #DOC_COVER_TITLE
.          rr #DOC_COVER_SUBTITLE
.          rr #DOC_COVER_AUTHOR
.          rr #DOC_COVER_DOCTYPE
.          rr #DOC_COVER_COPYRIGHT
.          rr #DOC_COVER_MISC
.       \}
.    \}
.    if \\n[#COVERS]=1 \{\
.       if \\n[#COVER]=1 \{\
.          DO_COVER
.          rr #COVER
.          rr #COVER_TITLE
.          rr #COVER_SUBTITLE
.          rr #COVER_AUTHOR
.          rr #COVER_DOCTYPE
.          rr #COVER_COPYRIGHT
.          rr #COVER_MISC
.       \}
.    \}
.\" Collate related stuff
.    ie \\n[#COLLATED_DOC]=1 \{\
.\" Collect TITLE for TOC.
.       nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.       af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.       ie \\n[#USER_SET_TITLE_ITEM] \{\
.          ds $TOC_TITLE_ITEM \\*[$USER_SET_TITLE_ITEM]\\|
.          rr #USER_SET_TITLE_ITEM
.          rm $USER_SET_TITLE_ITEM
.       \}
.       el \{\
.          ie \\n[#DOC_TYPE]=2 \{\
.             ie '\\*[$CHAPTER_TITLE]'' \{\
.                ds $TOC_TITLE_ITEM \\*[$CHAPTER_STRING] \\*[$CHAPTER]\\|
.             \}
.             el \{\
.                ie '\\*[$CHAPTER]'' \{\
.                   ds $TOC_TITLE_ITEM \\*[$CHAPTER_TITLE]\\|
.                \}
.                el \{\
.                   ds $TOC_TITLE_ITEM \\*[$CHAPTER_STRING] \\*[$CHAPTER]: \\*[$CHAPTER_TITLE]\\|
.                \}
.             \}
.          \}
.          el \{\
.             ds $TOC_TITLE_ITEM \\*[$TITLE]\\|
.          \}
.       \}
.       if \\n[#TOC_AUTHORS]=1 \{\
.          ie '\\*[$TOC_AUTHORS]'' \{\
.             as $TOC_TITLE_ITEM /\\|\\*[$AUTHOR_1]\\|
.          \}
.          el \{\
.             as $TOC_TITLE_ITEM /\\|\\*[$TOC_AUTHORS]\\|
.             rm $TOC_AUTHORS
.          \}
.       \}
.\" Note the use of \!, which transparently embeds the macros used
.\" in the TOC_ENTRIES diversion.  The elements they control must be
.\" processed literally when the diversion is output.
.       ev TOC_EV
.       da TOC_ENTRIES
.       if \\n[#PRINT_STYLE]=1 \{\
\!.        fam C
\!.        ft  R
\!.        ps  12
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
\!.        FAMILY  \\*[$TOC_TITLE_FAM]
\!.        FT      \\*[$TOC_TITLE_FT]
\!.        PT_SIZE \\n[#TOC_PS]u\\*[$TOC_TITLE_SIZE_CHANGE]
.       \}
\!.     TRAP OFF
.       ie \\n[#PRINT_STYLE]=1 \{\
\!.        PAD "\\*[$TOC_TITLE_ITEM]\\*[$TOC_PN_TYPEWRITE]" 
.       \}
.       el \{\
\!.        PAD "\\h'\\n[#TOC_TITLE_INDENT]u'\\*[$TOC_TITLE_ITEM]\\*[$TOC_PN]"
.       \}
\!.    EOL
\!.    ST 100 L
\!.    ST 101 R
.      if \\n[#PRINT_STYLE]=2 \{\
\!.       FAMILY  \\*[$TOC_PN_FAM]
\!.       FT      \\*[$TOC_PN_FT]
\!.       PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.      \}
\!.    TAB 100
\!.    PRINT \\*[LEADER]
\!.    TN
\!.    TRAP
\!.    PRINT \\n[#TOC_ENTRY_PN]
\!.    TQ
.      di       
.      ev
.    \}
.    el \{\
.       nr #FIRST_DOC_TITLE_PN \\n%+\\n[#PAGE_NUM_ADJ]
.       af #FIRST_DOC_TITLE_PN \\g[#PAGENUMBER]
.       nr #FIRST_DOC_TOC_PN_PADDING \\n[#TOC_PN_PADDING]
.    \}
.\" End TITLE collection
.    if \\n[#PRINT_PAGENUM_ON_PAGE_1] \{\
.       sp |\\n[#HEADER_MARGIN]u
.       PRINT_PAGE_NUMBER
.    \}
.    rr #COLLATE
.    rr #PAGINATION_STATE
.\" End collate stuff
.    ie \\n[#DOC_HEADER]=0 \{\
.       PRINT \&
.       if \\n[#DOC_TYPE]=4 \{\
.          if !'\\n(.z'' \{ .di \}
.       \}
.       nr #STORED_PP_INDENT \\n[#PP_INDENT]
.       PARA_INDENT 0
.       PP
.       PARA_INDENT \\n[#STORED_PP_INDENT]u
.       rr #STORED_PP_INDENT
.       ie r#ADVANCE_FROM_TOP \{\
.          sp |\\n[#ADVANCE_FROM_TOP]u-1v
.          if \\n[#ADJ_DOC_LEAD]=1 \{ .SHIM \}
.       \}
.       el \{ .sp |\\n[#T_MARGIN]u-1v \}
.       if \\n[#COLUMNS] \{\
.          mk dc
.          nr #COL_NUM 0 1
.          po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n(.o
.          ll \\n[#COL_L_LENGTH]u
.       \}
.       nr #PP 0
.       rr #DOC_HEADER
.       if r#ADVANCE_FROM_TOP \{ .rr #ADVANCE_FROM_TOP \}
.    \}
.    el \{\
.       if \\n[#PRINT_STYLE]=2 \{ .LS \\n[#DOC_LEAD]u\\*[$DOCHEADER_LEAD_ADJ] \}
.       nr #DOCHEADER_LEAD \\n[#LEAD]
.\" Default
.       if \\n[#DOC_TYPE]=1 \{\
.          PRINT \&
.          sp |\\n[#DOCHEADER_ADVANCE]u-1v
.          ev DOCHEADER
.          if \\n[#DOCHEADER_COLOR]=1 \{\
.             nf
\m[\\*[$DOCHEADER_COLOR]]
.             EOL
.          \}
.          L_MARGIN \\n[#DOC_L_MARGIN]u
.          LL       \\n[#DOC_L_LENGTH]u
.          ta \\n(.lu
.          if \\n[#PRINT_STYLE]=1 \{\
.             CENTER
.             TYPEWRITER
.             ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u*2u \}
.             el \{ .vs \\n[#DOC_LEAD]u \}
.             CAPS
.             if !'\\*[$TITLE]'' \{ .UNDERSCORE "\\*[$TITLE]\}
.             CAPS OFF
.             if !'\\*[$SUBTITLE]'' \{\
.                ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u*2u \}
.                el \{ .vs \\n[#DOC_LEAD]u \}
.             PRINT \\*[$SUBTITLE]
.             \}
.             if '\\*[$SUBTITLE]'' \{\
.                ALD \\n[#DOC_LEAD]u
.             \}
.             ie !'\\*[$AUTHOR_1]'' \{\
.                ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u \}
.                el \{ .vs \\n[#DOC_LEAD]u/2u \}
.                if !d$SUBTITLE \{\
.                   ie \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.                   el \{ .ALD \\n[#DOC_LEAD]u*2u \}
.                \}
.                PRINT \\*[$ATTRIBUTE_STRING]
.                nr #AUTHORS \\n[#AUTHOR_NUM]
.                nr #NEXT_AUTHOR 0 1
.                while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.                   PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]
.\}
.                if \\n[#AUTHOR_LINES]=1 \{\
.                    ie \\n[#SINGLE_SPACE] \{ .RLD \\n[#DOC_LEAD]u \}
.                    el \{ .ALD \\n[#DOC_LEAD]u/2u \}
.                \}
.             \}
.             el \{\
.                ie !d$SUBTITLE \{\
.                   ie \\n[#SINGLE_SPACE] \{ .RLD \\n[#DOC_LEAD]u*2u \}
.                   el \{ .RLD \\n[#DOC_LEAD]u \}
.                \}
.                el \{\
.                   ie \\n[#SINGLE_SPACE] \{ .RLD \\n[#DOC_LEAD]u*2u \}
.                   el \{ .ALD \\n[#DOC_LEAD]u \}
.                \}
.             \}
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             DEFAULT_DOCHEADER
.             di DOCHEADER_DIVERSION \" This diversion is only
.             br                     \" necessary to find the depth of the
.             DEFAULT_DOCHEADER      \" docheader
.             br
.             di
.             nr #DOCHEADER_DEPTH \\n(dn-\\n[#DOCHEADER_LEAD] \"Storing the depth (height) of the diversion
.                                                             \"in #DOCHEADER_DEPTH
.             rm DOCHEADER_DIVERSION                          \" Removing the diversion macro
.          \}
.          ev
.       \}
.\" Chapter
.       if \\n[#DOC_TYPE]=2 \{\
.          PRINT \&
.          sp |\\n[#DOCHEADER_ADVANCE]u-1v
.          ev DOCHEADER
.          if \\n[#DOCHEADER_COLOR]=1 \{\
.             nf
\m[\\*[$DOCHEADER_COLOR]]
.             EOL
.          \}
.          L_MARGIN \\n[#DOC_L_MARGIN]u
.          LL       \\n[#DOC_L_LENGTH]u
.          ta \\n(.lu
.          if \\n[#PRINT_STYLE]=1 \{\
.             CENTER
.             TYPEWRITER
.             vs \\n[#DOC_LEAD]u
.             ie '\\*[$CHAPTER]'' \{\
.                CAPS
.                ie !'\\*[$CHAPTER_TITLE]'' \{\
.                   PRINT \\*[$CHAPTER_TITLE]
.                \}
.                el \{\
.                   CAPS
.                   PRINT \\*[$CHAPTER_STRING]
.                \}
.                CAPS OFF
.             \}
.             el \{\
.                CAPS
.                PRINT \\*[$CHAPTER_STRING] \\*[$CHAPTER]
.                CAPS OFF
.                if !'\\*[$CHAPTER_TITLE]'' \{\
.                   if \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.                   UNDERSCORE "\\*[$CHAPTER_TITLE]
.                \}
.             \}
.             if \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             CHAPTER_DOCHEADER
.             di DOCHEADER_DIVERSION \" This diversion is only
.             br                     \" necessary to find the depth of the
.             CHAPTER_DOCHEADER      \" docheader
.             br
.             di
.             nr #DOCHEADER_DEPTH \\n(dn-\\n[#DOCHEADER_LEAD] \" Storing the depth (height) of the diversion
.                                                             \" in #DOCHEADER_DEPTH
.             rm DOCHEADER_DIVERSION                          \" Removing the diversion macro
.          \}
.          ev
.       \}
.\" Named
.       if \\n[#DOC_TYPE]=3 \{\
.          PRINT \&
.          sp |\\n[#DOCHEADER_ADVANCE]u-1v
.          ev DOCHEADER
.          if \\n[#DOCHEADER_COLOR]=1 \{\
.             nf
\m[\\*[$DOCHEADER_COLOR]]
.             EOL
.          \}
.          L_MARGIN \\n[#DOC_L_MARGIN]u
.          LL       \\n[#DOC_L_LENGTH]u
.          ta \\n(.lu
.          if \\n[#PRINT_STYLE]=1 \{\
.             CENTER
.             TYPEWRITER
.             ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u*2u \}
.             el \{ .vs \\n[#DOC_LEAD]u \}
.             CAPS
.             if !'\\*[$TITLE]'' \{ .UNDERSCORE "\\*[$TITLE]\}
.             CAPS OFF
.             if !'\\*[$SUBTITLE]'' \{\
.                ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u*2u \}
.                el \{ .vs \\n[#DOC_LEAD]u \}
.                PRINT \\*[$SUBTITLE]
.             \}
.             if '\\*[$SUBTITLE]'' \{\
.                ALD \\n[#DOC_LEAD]u
.             \}
.             ie !'\\*[$AUTHOR_1]'' \{\
.                ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u \}
.                el \{ .vs \\n[#DOC_LEAD]u/2u \}
.                if !d$SUBTITLE \{\
.                   ie \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.                   el \{ .ALD \\n[#DOC_LEAD]u*2u \}
.                \}
.                PRINT \\*[$ATTRIBUTE_STRING]
.                nr #AUTHORS \\n[#AUTHOR_NUM]
.                nr #NEXT_AUTHOR 0 1
.                while \\n[#AUTHORS]>\\n[#NEXT_AUTHOR] \{\
.                   PRINT \\*[$AUTHOR_\\n+[#NEXT_AUTHOR]]
.\}
.                if \\n[#AUTHOR_LINES]=1 \{\
.                    ie \\n[#SINGLE_SPACE] \{ .RLD \\n[#DOC_LEAD]u \}
.                    el \{ .ALD \\n[#DOC_LEAD]u/2u \}
.                 \}
.             vs  \\n[#DOC_LEAD]u
.             \}
.             el \{\
.                ie !d$SUBTITLE \{\
.                   ie \\n[#SINGLE_SPACE] \{ .RLD \\n[#DOC_LEAD]u*2u \}
.                   el \{ .RLD \\n[#DOC_LEAD]u \}
.                \}
.                el \{\
.                   ie \\n[#SINGLE_SPACE] \{ . \}
.                   el \{ .RLD \\n[#DOC_LEAD]u \}
.                \}
.             \}
.             ie \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u*2u \}
.             el \{ .ALD \\n[#DOC_LEAD]u \}
.             UNDERSCORE2 "\\*[$DOC_TYPE]
.             if \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             NAMED_DOCHEADER
.             di DOCHEADER_DIVERSION \" This diversion is only
.             br                     \" necessary to find the depth of the
.             NAMED_DOCHEADER        \" docheader
.             br
.             di
.             nr #DOCHEADER_DEPTH \\n(dn-\\n[#DOCHEADER_LEAD] \"Storing the depth (height) of the diversion
.                                                             \"in #DOCHEADER_DEPTH
.             rm DOCHEADER_DIVERSION                          \" Removing the diversion macro
.          \}
.          ev
.       \}
.       if !\\n[#DOC_TYPE]=4 \{\
.          if \\n[#PRINT_STYLE]=1 \{ .ALD \\n[#DOC_LEAD]u \}
.          nr #DOCHEADER_SPACE_ADJ \\n[#DOCHEADER_DEPTH]%\\n[#DOC_LEAD]
.          ie !\\n[#DOCHEADER_SPACE_ADJ]=0 \{ .nr #DOCHEADER_EXTRA_SPACE \\n[#DOC_LEAD]-\\n[#DOCHEADER_SPACE_ADJ] \}
.          el \{ .nr #DOCHEADER_EXTRA_SPACE 0 \}
.          if \\n[#PRINT_STYLE]=2 \{ .ALD (\\n[#DOC_LEAD]u*2u)+\\n[#DOCHEADER_EXTRA_SPACE]u \}
.          if \\n[#COLUMNS] \{\
.             nr #COL_NUM 0 1
.             nr #L_LENGTH_FOR_EPI \\n[#L_LENGTH]
.             po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.             nr #L_MARGIN \\n(.o
.             LL \\n[#COL_L_LENGTH]u
.             ta \\n(.lu
.             mk dc
.          \}
.       \}
.    \}
.    LS \\n[#DOC_LEAD]u
.    if \\n[#ADJ_DOC_LEAD]=1 \{ .SHIM \}
.    QUAD \\*[$DOC_QUAD]
.    CLEANUP_DEFAULTS
.    nr #START_FOR_FOOTERS 1
.    if \\n[#COLLATED_DOC]=1 \{\
.       if !\\n[MNinit_DEFERRED]=1 \{\
.          MN_INIT rerun
.       \}
.    \}
.    if \\n[#MNinit_DEFERRED]=1 \{\
.       rr #MNinit_DEFERRED
.       nr #START_FOR_MNinit 1
.       MN_INIT \\*[$MN-arg1] \\*[$MN-arg2] \\*[$MN-arg3] \\*[$MN-arg4] \\*[$MN-arg5] \\*[$MN-arg6] \\*[$MN-arg7] \\*[$MN-arg8] \\*[$MN-arg9]
.    \}
.    nr #START_FOR_MNinit 2
.    if !\\n[#DOC_TYPE]=4 \{ .em TERMINATE \}
.    if \\n[#LINENUMBERS]=2 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.    if \\n[#RUN_ON]=1 \{\
.       if \\n[#FN_MARKER_STYLE]=1 \{ .RUNON_WARNING \}
.       if \\n[#FN_MARKER_STYLE]=2 \{ .RUNON_WARNING \}
.    \}
.END
\#
.MAC CLEANUP_DEFAULTS END
.    nr #START 1
.\" Family strings for docheader
.    rm $AUTHOR_FAM
.    rm $CHAPTER_TITLE_FAM
.    rm $DOCTYPE_FAM
.    rm $SUBTITLE_FAM
.    rm $TITLE_FAM
.\" Family strings for cover
.    rm $COVER_AUTHOR_FAM
.    rm $COVER_CHAPTER_TITLE_FAM
.    rm $COVER_COPYRIGHT_FAM
.    rm $COVER_DOCTYPE_FAM
.    rm $COVER_LEAD_ADJ
.    rm $COVER_SUBTITLE_FAM
.    rm $COVER_TITLE_FAM
.\" Family strings for doc cover
.    rm $DOC_COVER_AUTHOR_FAM
.    rm $DOC_COVER_CHAPTER_TITLE_FAM
.    rm $DOC_COVER_COPYRIGHT_FAM
.    rm $DOC_COVER_DOCTYPE_FAM
.    rm $DOC_COVER_LEAD_ADJ
.    rm $DOC_COVER_SUBTITLE_FAM
.    rm $DOC_COVER_TITLE_FAM
.\" Quad args to copyright and misc
.    rm $COVER_COPYRIGHT_QUAD
.    rm $COVER_MISC_QUAD
.    rm $DOC_COVER_COPYRIGHT_QUAD
.    rm $DOC_COVER_MISC_QUAD
.\" Miscellaneous strings
.    rm $TOC_TITLE_ITEM
.    rm $DOCHEADER_LEAD_ADJ
.\" Various registers
.    rr #ADJ_DOC_LEAD
.    rr #ADVANCE_FROM_TOP
.    rr #AUTHOR_NUM
.    rr #AUTHORS
.    rr #COVER_LEAD
.    rr #DEPTH_1
.    rr #DEPTH_2
.    rr #DOC_COVER_LEAD
.    rr #DOCHEADER_ADVANCE
.    rr #DOCHEADER_EXTRA_SPACE
.    rr #DOCHEADER_LEAD
.    rr #DOCHEADER_SPACE_ADJ
.    rr #MISC_NUM
.    rr #MISCS
.    rr #NEXT_AUTHOR
.    rr #NEXT_MISC
.    rr #NUM_AUTHORS
.END
\#
\# ====================================================================
\#
\# +++MACROS TO CHANGE SOME DEFAULTS+++
\#
\# DOCUMENT HEADER
\# ---------------
\# *Argument:
\#   <none> | <anything> [distance to advance from top of page]
\# *Function:
\#   Turns printing of document header on or off.  If a second argument
\#   in units of measure is given, advances that distance from the
\#   top of the page without printing the document header.
\# *Notes:
\#   Default is on.  If the 1st argument is <anything> (which turns
\#   document headers off), the optional 2nd argument may be given
\#   (with a unit of measure).
\#
.MAC DOCHEADER END
.    ie '\\$1'' \{ .nr #DOC_HEADER 1 \}
.    el \{\
.       if !'\\$2'' \{ .nr #ADVANCE_FROM_TOP (\\$2) \}
.       nr #DOC_HEADER 0
.    \}
.END
\#
\#
\# DOCUMENT HEADER LEADING
\# -----------------------
\# *Arguments:
\#   <+|- amount by which to in/decrease leading of doc header>
\# *Function:
\#   Stores user supplied lead in/decrease in string $DOCHEADER_LEAD_ADJ.
\# *Notes:
\#   A unit of measure must be supplied.  Decimal fractions OK.
\#   Default is +0, i.e. same as DOC_LEAD.
\#
.MAC DOCHEADER_LEAD END
.    ds $DOCHEADER_LEAD_ADJ \\$1
.END
\#
\#
\# DOCHEADER ADVANCE
\# -----------------
\# *Arguments:
\#   <docheader start position>
\# *Function:
\#   Creates register #DOCHEADER_ADVANCE, used in START.
\# *Notes:
\#   Unit of measure required.
\#   Default is same as T_MARGIN.
\#
.MAC DOCHEADER_ADVANCE END
.    nr #DOCHEADER_ADVANCE (\\$1)
.END
\#
\#
\# DOCUMENT LEFT MARGIN
\# --------------------
\# *Argument:
\#   <left margin of document>
\# *Function:
\#   Creates or modifies register #DOC_L_MARGIN.
\# *Notes:
\#   Affects EVERYTHING on the page.
\#
.MAC DOC_LEFT_MARGIN END
.    br
.    nr #DOC_L_MARGIN (\\$1)
.    L_MARGIN \\n[#DOC_L_MARGIN]u
.END
\#
\#
\# DOCUMENT RIGHT MARGIN
\# ---------------------
\# *Argument:
\#   <right margin of document>
\# *Function:
\#   Creates or modifies register #DOC_R_MARGIN.
\# *Notes:
\#   Affects EVERYTHING on the page.
\#
.MAC DOC_RIGHT_MARGIN END
.    br
.    nr #DOC_R_MARGIN (\\$1)
.    R_MARGIN \\n[#DOC_R_MARGIN]
.    nr #DOC_L_LENGTH \\n[#L_LENGTH]
.END
\#
\#
\# DOCUMENT LINE LENGTH
\# --------------------
\# *Argument:
\#   <line length of document>
\# *Function:
\#   Creates or modifies string $DOC_L_LENGTH.
\# *Notes:
\#   Affects EVERYTHING on the page.
\#
.MAC DOC_LINE_LENGTH END
.    br
.    nr #DOC_L_LENGTH (\\$1)
.    LL \\n[#DOC_L_LENGTH]u
.    ta \\n(.lu
.END
\#
\#
\# DOCUMENT FAMILY
\# ---------------
\# *Argument:
\#   <family of running text>
\# *Function:
\#   Creates or modifies string $DOC_FAM.
\# *Notes:
\#   Affects everything EXCEPT headers and footers.
\#
.MAC DOC_FAMILY END
.    br
.    ds $DOC_FAM       \\$1
.    ds $FAMILY        \\*[$DOC_FAM]
.    TITLE_FAMILY      \\*[$DOC_FAM]
.    SUBTITLE_FAMILY   \\*[$DOC_FAM]
.    AUTHOR_FAMILY     \\*[$DOC_FAM]
.    DOCTYPE_FAMILY    \\*[$DOC_FAM]
.    HEAD_FAMILY       \\*[$DOC_FAM]
.    SUBHEAD_FAMILY    \\*[$DOC_FAM]
.    QUOTE_FAMILY      \\*[$DOC_FAM]
.    BLOCKQUOTE_FAMILY \\*[$DOC_FAM]
.    EPIGRAPH_FAMILY   \\*[$DOC_FAM]
.    HDRFTR_FAMILY     \\*[$DOC_FAM]
.    FOOTNOTE_FAMILY   \\*[$DOC_FAM]
.END
\#
\#
\# DOCUMENT POINT SIZE
\# -------------------
\# *Argument:
\#   <point size of running text>
\# *Function:
\#   Creates or modifies register #DOC_PT_SIZE.
\# *Notes:
\#   DOC_PT_SIZE is the basis for calculating all type sizes in
\#   a document.
\#
.MAC DOC_PT_SIZE END
.    if \\n[#IGNORE] \{ .return \}
.    br
.    PT_SIZE \\$1
.    nr #DOC_PT_SIZE \\n[#PT_SIZE]
.END
\#
\#
\# DOCUMENT LEAD
\# -------------
\# *Argument:
\#   <lead (".vs") of running text> [ADJUST]
\# *Function:
\#   Creates or modifies register #DOC_LEAD.  If the optional
\#   ADJUST argument is given, adjusts leading so that the last
\#   line of text falls exactly on #B_MARGIN.
\# *Notes:
\#   DOC_LEAD is the basis for calculating all leading changes in
\#   a document.  Default for TYPESET is 16; 24 for TYPEWRITE.
\#
\#   Because the visible bottom or footer margin of a page depends
\#   on the overall document lead supplied by the register #DOC_LEAD,
\#   DOC_LEAD, in the body of a document, should always be associated
\#   with the start of a new page (in other words, just before or
\#   just after a manual NEWPAGE).
\#
.MAC DOC_LEAD END
.    if \\n[#IGNORE] \{ .return \}
.    br
.    vs \\$1
.    nr #DOC_LEAD \\n[#LEAD]
.    if '\\$2'ADJUST' \{ .TRAPS \}
.END
\#
\#
\# ADJUST DOCUMENT LEAD
\# --------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Adjusts document lead so that the last line of text falls exactly
\#   on #B_MARGIN.
\#
.MAC DOC_LEAD_ADJUST END
.    ie '\\$1'' \{\
.       nr #ADJ_DOC_LEAD 1
.    \}
.    el \{\
.       nr #ADJ_DOC_LEAD 0
.       nr #DOC_LEAD_ADJUST_OFF 1
.    \}
.END
\#
\#
\# SHIM
\# ----
\# *Argument:
\#   None
\# *Function:
\#   Advances to the next "legal" baseline.
\# *Notes:
\#   If a user plays around with spacing in a doc (say, with ALD),
\#   it isn't easy to get mom back on track so she can achieve
\#   perfectly flush bottom margins.  Any time SHIM is used, it
\#   ensures that the next output line falls on a legal baseline.
\#
\# First, a little convenience macro
\#
.MAC PROCESS_SHIM END
.    while \\n+[#LEGAL_BASELINE]<\\n[#CURRENT_V_POS] \{\
.
.\}
.    nr #SHIM \\n[#LEGAL_BASELINE]-\\n[#CURRENT_V_POS]
.END
\#
\#
.MAC SHIM END
.    nr #LEGAL_BASELINE \\n[#T_MARGIN]-1v \\n[#DOC_LEAD]
.    if !r#CURRENT_V_POS \{ .nr #CURRENT_V_POS \\n(.d \}
.    ie r#ADVANCE_FROM_TOP \{\
.       ie \\n[#CURRENT_V_POS]<(\\n[#T_MARGIN]-1v) \{\
.          while \\n-[#LEGAL_BASELINE]>\\n[#CURRENT_V_POS] \{\
.
.\}
.          nr #LEGAL_BASELINE +\\n[#DOC_LEAD]
.          nr #SHIM \\n[#LEGAL_BASELINE]-\\n[#CURRENT_V_POS]
.       \}
.       el \{\
.          PROCESS_SHIM
.       \}
.    \}
.    el \{\
.       PROCESS_SHIM
.    \}
.    ALD \\n[#SHIM]u
.    rr #CURRENT_V_POS
.END
\#
\#
\#
\# ====================================================================
\#
\# +++INTERNATIONALIZATION+++
\#
\# ATTRIBUTE STRING
\# ----------------
\# *Argument:
\#   <what goes in the "by" slot before author in the document header>
\# *Function:
\#   Creates or modifies string $ATTRIBUTE_STRING.
\# *Notes:
\#   Default is "by".  A blank string ("") may be used if no
\#   attribution is desired.
\#
.MAC ATTRIBUTE_STRING END
.    ds $ATTRIBUTE_STRING \\$1
.END
\#
\#
\# CHAPTER STRING
\# --------------
\# *Argument:
\#   <what to print any time the word "chapter" is required>
\# *Function:
\#   Creates or modifies string $CHAPTER_STRING.
\# *Notes:
\#   Default is "chapter".
\#
.MAC CHAPTER_STRING END
.    ds $CHAPTER_STRING \\$1
.END
\#
\#
\# DRAFT STRING
\# ------------
\# *Argument:
\#   <what to print any time the word "draft" is required>
\# *Function:
\#   Creates or modifies string $DRAFT_STRING.
\# *Notes:
\#   Default is "draft".
\#
.MAC DRAFT_STRING END
.    ds $DRAFT_STRING \\$1
.END
\#
\#
\# REVISION STRING
\# ---------------
\# *Argument:
\#   <what to print any time the word "revision" is required>
\# *Function:
\#   Creates or modifies string $REVISION_STRING.
\# *Notes:
\#   Default is "revision".
\#
.MAC REVISION_STRING END
.    ds $REVISION_STRING \\$1
.END
\#
\#
\# FINIS STRING
\# ------------
\# *Argument:
\#   <what to print with the finis macro>
\# *Function:
\#   Creates or modifies string $FINIS_STRING.
\# *Notes:
\#   Default is "END".
\#
.MAC FINIS_STRING END
.    nr #FINIS 1
.    CAPS
.    ds $FINIS_STRING \\$1
.    CAPS OFF
.END
\#
\#
\# ====================================================================
\#
\# +++RECTO/VERSO+++
\#
\# RECTO_VERSO
\# -----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Switches HDRFTR_LEFT and HDRFTR_RIGHT on alternate pages.  Also
\#   switches page numbers left and right if either is chosen rather
\#   than the default centered page numbers.  Switches left and right
\#   margins if differing values have been entered.
\# *Notes:
\#   Default is OFF.
\#
.MAC RECTO_VERSO END
.    ie '\\$1'' \{ .nr #RECTO_VERSO 1 \}
.    el \{ .nr #RECTO_VERSO 0 \}
.END
\#
\# ====================================================================
\#
\# +++EPIGRAPHS+++
\#
\# EPIGRAPH INDENT
\# ---------------
\# *Argument:
\#   <value by which to multiply PP_INDENT for block epigraphs>
\# *Function:
\#   Creates or modifies register #EPI_OFFSET_VALUE.
\# *Notes:
\#   Default is 2 for TYPEWRITE, 3 for TYPESET.
\#
.MAC EPIGRAPH_INDENT END
.    nr #EPI_OFFSET_VALUE \\$1
.END
\#
\#
\# EPIGRAPH AUTOLEAD
\# -----------------
\# *Argument:
\#   <amount of lead to add to the epigraph ps for epigraph leading>
\# *Function:
\#   Creates or modifies register #EPI_AUTOLEAD.
\# *Notes:
\#   Default is 2 (for TYPESET; TYPEWRITE doesn't require this).
\#
.MAC EPIGRAPH_AUTOLEAD END
.    nr #EPI_AUTOLEAD \\$1
.END
\#
\#
\# EPIGRAPH
\# --------
\# *Arguments:
\#   BLOCK | <anything>
\# *Function:
\#   Places an epigraph before the document's text, after the
\#   document header, or after a HEAD.
\# *Notes:
\#   #EPIGRAPH 1 = centered; 2 = block
\#
\#   By default, epigraphs are centered, allowing the user
\#   to input them on a line per line basis.  To change this
\#   behaviour, the user can supply the argument BLOCK, which
\#   will produce indented, filled text similar to BLOCKQUOTE.
\#
\#   If a block epigraph contains more than one para, ALL paras of
\#   the epigraph must be preceded by PP.  Otherwise, PP is optional.
\#
.MAC EPIGRAPH END
.    nr #PP_STYLE 2
.    nr #Q_PP     0
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#START] \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          if \\n[#AUTHOR_LINES]=1 \{ .ALD \\n[#DOC_LEAD]u \}
.       \}
.    \}
.    ie '\\$1'' \{\
.       nr #EPIGRAPH 1
.       ev EPIGRAPH
.       nr #IN_DIVER 1
.       ll \\n[#L_LENGTH]u
.       ta \\n(.lu
.       CHECK_INDENT
.       if \\n[#COLUMNS] \{\
.          ie \\n[#START] \{\
.              ll \\n[#DOC_L_LENGTH]u
.              ta \\n(.lu
.          \}
.          el \{\
.             ll \\n[#COL_L_LENGTH]u
.             ta \\n(.lu
.          \}
.       \}
.       CENTER
.       if \\n[#PRINT_STYLE]=1 \{\
.          fam C
.          ft  R
.          if '\\*[$EPI_FT]'I' \{\
.             FT I
.          \}
.          ps  12
.          ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u \}
.          el \{ .vs  \\n[#DOC_LEAD]u/2u \}
.          nr #EPI_LEAD      \\n[#LEAD]
.          nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY   \\*[$EPI_FAM]
.          FT       \\*[$EPI_FT]
.          PT_SIZE  \\n[#DOC_PT_SIZE]u\\*[$EPI_SIZE_CHANGE]
.          if \\n[#EPI_COLOR]=1 \{\
.             nf
\m[\\*[$EPI_COLOR]]
.             EOL
.          \}
.          AUTOLEAD \\n[#EPI_AUTOLEAD]
.          nr #EPI_LEAD      \\n[#LEAD]
.          nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.       \}
.       di EPI_TEXT
.       nr #DIVERSIONS_HY_MARGIN (p;\\n[.ps]u*2.75)/1000
.       HY_SET 1 \\n[#DIVERSIONS_HY_MARGIN]u (\\n[#PT_SIZE]u/1000u/8u)p
.       hy 14
.       nr #EPI_ACTIVE 1
.    \}
.    el \{\
.       ie '\\$1'BLOCK' \{\
.          nr #EPIGRAPH 2
.          ev EPIGRAPH
.          ie \\n[#START] \{\
.             ie \\n[#COLUMNS] \{\
.                ll \\n[#L_LENGTH_FOR_EPI]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.                ta \\n(.lu
.             \}
.             el \{\
.                ll \\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.                ta \\n(.lu
.             \}
.          \}
.          el \{\
.             ll \\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.             ta \\n(.lu
.             if \\n[#COLUMNS] \{\
.                ll \\n[#COL_L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#EPI_OFFSET_VALUE]u*2u))
.                ta \\n(.lu
.             \}
.             CHECK_INDENT
.          \}
.          if \\n[#PRINT_STYLE]=1 \{\
.             fam C
.             ft  R
.             if '\\*[$EPI_FT]'I' \{\
.                FT I
.             \}
.             ps  12
.             ie \\n[#SINGLE_SPACE] \{ .vs \\n[#DOC_LEAD]u \}
.             el \{ .vs  \\n[#DOC_LEAD]u/2u \}
.             QUAD LEFT
.             HY OFF
.             nr #EPI_LEAD \\n[#LEAD]
.             nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.             di EPI_TEXT
.             nr #EPI_ACTIVE 1
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY   \\*[$EPI_FAM]
.             FT       \\*[$EPI_FT]
.             PT_SIZE  \\n[#DOC_PT_SIZE]u\\*[$EPI_SIZE_CHANGE]
.          if \\n[#EPI_COLOR]=1 \{\
.             nf
\m[\\*[$EPI_COLOR]]
.             EOL
.          \}
.             AUTOLEAD \\n[#EPI_AUTOLEAD]
.             QUAD     \\*[$EPI_QUAD]
.             nr #DIVERSIONS_HY_MARGIN (p;\\n[.ps]u*2.75)/1000
.             HY_SET 1 \\n[#DIVERSIONS_HY_MARGIN]u (\\n[#PT_SIZE]u/1000u/8u)p
.             hy 14
.             nr #EPI_LEAD \\n[#LEAD]
.             nr #EPI_LEAD_DIFF \\n[#DOC_LEAD]-\\n[#EPI_LEAD]
.             di EPI_TEXT
.             nr #EPI_ACTIVE 1
.          \}
.       \}
.       el \{\
.          DO_EPIGRAPH
.       \}
.    \}
.END
\#
\#
\# DO EPIGRAPH
\# -----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Ends diversion started in EPIGRAPH.  Makes spacing
\#   adjustments to compensate for the difference between epigraph
\#   leading and overall document leading, so that the bottom of
\#   the pages remain flush.
\# *Notes:
\#   In addition to its usual place at the beginning of a
\#   document, EPIGRAPH may also be used after HEAD.
\#
.MAC DO_EPIGRAPH END
.    br
.    di
.    rr #IN_DIVER
.    if \\n[#RESET_FN_COUNTERS]=2 \{\
.       if !\\n[#FN_COUNT]=1 \{\
.          if ((\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS])+\\n[#DIVER_DEPTH])>(\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS]) \{\
.             DIVER_FN_2_POST
.             rr #RESET_FN_COUNTERS
.          \}
.       \}
.    \}
.    nr #SAVED_FN_NUMBER \\n[#FN_NUMBER]
.    nr #DONE_ONCE 0 1
.    REMOVE_INDENT
.    ev
.    nr #EPI_DEPTH \\n[#DIVER_DEPTH]-\\n[#EPI_LEAD]
.    nr #EPI_LINES \\n[#EPI_DEPTH]/\\n[#EPI_LEAD]
.    ie \\n[#START] \{\
.       RLD \\n[#SHIM]u
.       nr #EPI_WHITESPACE (\\n[#DOC_LEAD]*\\n[#EPI_LINES])-\\n[#EPI_DEPTH]
.       while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.             nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.\}
.       if \\n[#PRINT_STYLE]=2 \{\
.          RLD \\n[#DOC_LEAD]u
.          if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \{\
.             ALD \\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)
.          \}
.          if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.             ALD \\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.          \}
.       \}
.    \}
.    el \{\
.       ie \\n[#EPI_DEPTH]<\\n[#TRAP_DISTANCE] \{\
.          nr #EPI_FITS 1
.          nr #EPI_WHITESPACE (\\n[#DOC_LEAD]*\\n[#EPI_LINES])-\\n[#EPI_DEPTH]
.          while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.\}
.          ie \\n[#PRINT_STYLE]=1 \{\
.             if \\n[#EPI_WHITESPACE]=\\n[#DOC_LEAD] \{ .ALD \\n[#EPI_WHITESPACE]u/2u \}
.          \}
.          el \{\
.             if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \{\
.                ALD \\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)
.             \}
.             if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                ALD \\n[#EPI_LEAD_DIFF]u+(\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.             \}
.          \}
.          if \\n[#DIVER_FN]=2 \{ .rr #DIVER_FN \}
.       \}
.       el \{\
.          nr #EPI_LINES_TO_TRAP 0 1
.          while \\n[#EPI_LEAD]*\\n+[#EPI_LINES_TO_TRAP]<\\n[#TRAP_DISTANCE] \{\
.                nr #LOOP 1
.\}
.          nr #EPI_LINES_TO_TRAP -1
.          nr #EPI_WHITESPACE (\\n[#EPI_LINES_TO_TRAP]*\\n[#DOC_LEAD])-(\\n[#EPI_LINES_TO_TRAP]*\\n[#EPI_LEAD])
.          while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.\}
.          if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \{ .ALD \\n[#EPI_WHITESPACE]u \}
.          if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{ .ALD \\n[#EPI_WHITESPACE]u-\\n[#DOC_LEAD]u \}
.      \}
.    \}
.    if \\n[#EPIGRAPH]=1 \{\
.       po \\n[#L_MARGIN]u
.       if \\n[#COLUMNS] \{\
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n(.o
.       \}
.    \}
.    if \\n[#EPIGRAPH]=2 \{\
.       nr #EPI_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.       if \\n[#COLUMNS] \{\
.          nr #EPI_OFFSET \\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.       \}
.       po \\n[#EPI_OFFSET]u
.    \}
.    nf
.    EPI_TEXT
.    br
.    ie \\n[#START] \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          ie \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.          el \{\
.             ie \\n[#EPI_LINES]%2=1 \{ .ALD \\n[#DOC_LEAD]u \}
.             el \{ .ALD \\n[#DOC_LEAD]u/2u \}
.          \}
.          SHIM
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \{\
.             ALD \\n[#EPI_WHITESPACE]u/2u
.          \}
.          if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.             ALD (\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.          \}
.          SHIM
.       \}
.    \}
.    el \{\
.       rr #EPI_ACTIVE
.       ie \\n[#EPI_FITS] \{\
.          ie \\n[#FN_FOR_EPI] \{\
.             nr #EPI_LINES_TO_END 1
.             nr #EPI_WHITESPACE (\\n[#EPI_LINES_TO_END]*\\n[#DOC_LEAD])-(\\n[#EPI_LINES_TO_END]*\\n[#EPI_LEAD])
.             while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                   nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.\}
.             ALD \\n[#EPI_WHITESPACE]u-(\\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u)
.          \}
.          el \{\
.             ie \\n[#PRINT_STYLE]=1 \{\
.                if \\n[#EPI_WHITESPACE]=\\n[#DOC_LEAD] \{ .ALD \\n[#EPI_WHITESPACE]u \}
.             \}
.             el \{\
.                if \\n[#EPI_WHITESPACE]<\\n[#DOC_LEAD] \{\
.                   ALD \\n[#EPI_WHITESPACE]u/2u
.                \}
.                if \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                   ALD (\\n[#EPI_WHITESPACE]u/2u)-\\n[#DOC_LEAD]u
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          nr #EPI_LINES_TO_END \\n[#EPI_LINES]-\\n[#EPI_LINES_TO_TRAP]
.          if \\n[#LOOP] \{ .nr #EPI_LINES_TO_END +1 \}
.          rr #LOOP
.          nr #EPI_WHITESPACE (\\n[#EPI_LINES_TO_END]*\\n[#DOC_LEAD])-(\\n[#EPI_LINES_TO_END]*\\n[#EPI_LEAD])
.          while \\n[#EPI_WHITESPACE]>\\n[#DOC_LEAD] \{\
.                nr #EPI_WHITESPACE -\\n[#DOC_LEAD]
.\}
.          ALD \\n[#EPI_WHITESPACE]u-(\\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u)
.          if \\n[#PRINT_STYLE]=1 \{\
.             if !\\n[#SINGLE_SPACE] \{\
.                nr #EPI_LINES_EVEN \\n[#EPI_LINES_TO_END]%2
.                ie \\n[#EPI_LINES_EVEN] \{ .ALD .5v \}
.                el \{ .RLD .5v \}
.                rr #EPI_LINES_EVEN
.             \}
.          \}
.       \}
.    \}
.    nr #PP_STYLE 1
.    rr #EPI_FITS
.    ALD \\n[#DOC_LEAD]u
.    QUAD \\*[$DOC_QUAD]
.    po \\n[#L_MARGIN]u
.    if \\n[#COLUMNS] \{\
.       po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n(.o
.    \}
.    if \\n[#START] \{\
.       if \\n[#COLUMNS] \{\
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n(.o
.          mk dc
.       \}
.    \}
.    if \\n[#LINENUMBERS]=2 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.END
\#
\# ====================================================================
\#
\# +++FINIS MACRO+++
\#
\# FINIS
\# -----
\# *Arguments:
\#   <none>
\# *Function:
\#   Deposits --END-- at the end of a document.
\#
.MAC FINIS END
.    br
.    ev FINIS
.    evc 0
.    if \\n[#TAB_ACTIVE] \{ .TQ \}
.    if \\n[#INDENT_ACTIVE] \{ .IQ CLEAR \}
.    nr #EM_ADJUST (1m/8)
.    if \\n[#COLUMNS] \{\
.       po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n(.o
.    \}
.    ALD \\n[#DOC_LEAD]u
.    CENTER
.    if \\n[#PRINT_STYLE]=1 \{ .PRINT "--\\*[$FINIS_STRING]--\}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#FINIS_COLOR] \{\
.          PRINT "\m[\\*[$FINIS_COLOR]]\v'-\\n[#EM_ADJUST]u'\(em\v'+\\n[#EM_ADJUST]u'\\*[$FINIS_STRING]\v'-\\n[#EM_ADJUST]u'\*[FU1]\(em\m[]
.       \}
.       el \{ .PRINT \v'-\\n[#EM_ADJUST]u'\(em\v'+\\n[#EM_ADJUST]u'\\*[$FINIS_STRING]\v'-\\n[#EM_ADJUST]u'\*[FU1]\(em\m[] \}
.    \}
.    ev
.END
\#
\# ====================================================================
\#
\# +++HEADERS/FOOTERS+++
\#
\# Define a string so that the current page number can be incorporated
\# into the strings for hdrftr left, right, and center.  NOTE: This is
\# not the same thing as using the shortform # in hdrftr strings.
\#
.ds PAGE# \En[#PAGENUMBER]
\#
\#
\# HDRFTR RULE GAP
\# ---------------
\# *Argument:
\#   <amount of space between header/footer and header/footer rule>
\# *Function:
\#   Creates or modifies register #HDRFTR_RULE_GAP to hold amount
\#   of space between header/footer and header/footer rule.
\# *Notes:
\#   Default is 4p.
\#
.MAC HDRFTR_RULE_GAP END
.    nr #HDRFTR_RULE_GAP (\\$1)
.END
\#
\#
\# HDRFTR LEFT
\# -----------
\# *Argument:
\#   <what to put in the left position of page header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_LEFT.
\#   Creates register #USER_DEF_HDRFTR_LEFT, which, if 1,
\#   overrides the $HDRFTR_LEFT string created by default
\#   in DEFAULTS.
\# *Notes:
\#   Especially useful if doc has more than one author, and a list
\#   of authors by last name is desired in header/footers.
\#   Default is author.
\#
\#   If the argument is the # character, simply prints the current
\#   page number.
\#
\#   If the user wants to *incorporate* the page number into the string,
\#   \*[PAGE#] must be used.  For example, if the user wants to put
\#   an elipsis before the page number in the string, s/he should use
\#   ...\*[PAGE#], not ...#
\#
.MAC HDRFTR_LEFT END
.    nr #USER_DEF_HDRFTR_LEFT 1
.    ds $HDRFTR_LEFT \\$1
.END
\#
\#
\# HDRFTR LEFT CAPS
\# ----------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalisation of $HDRFTR_LEFT (typically, the author of
\#   the document) on or off.
\# *Notes:
\#   Default is on.
\#
.MAC HDRFTR_LEFT_CAPS END
.    ie '\\$1'' \{\
.        nr #HDRFTR_LEFT_CAPS 1
.    \}
.    el \{\
.       nr #HDRFTR_LEFT_CAPS 0
.       ds $HDRFTR_LEFT_SIZE_CHANGE +0
.    \}
.END
\#
\#
\# HDRFTR CENTER
\# -------------
\# *Argument:
\#   <what to put in the centre position of page header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_CENTER.
\#   Creates register #USER_DEF_HDRFTR_CENTER, which, if 1,
\#   overrides the $HDRFTR_CENTER string created by default
\#   in COPYSTYLE.
\# *Notes:
\#   Default is document type if DOCTYPE NAMED, Chapter # if DOCTYPE
\#   CHAPTER, draft and revision number if COPYSTYLE DRAFT.
\#
\#   If the argument is the # character, simply prints the current
\#   page number.
\#
\#   If the user wants to *incorporate* the page number into the string,
\#   \*[PAGE#] must be used.  For example, if the user wants to put
\#   an elipsis before the page number in the string, s/he should use
\#   ...\*[PAGE#], not ...#
\#
.MAC HDRFTR_CENTER END
.    nr #USER_DEF_HDRFTR_CENTER 1
.    if '\\$0'FOOTER_CENTER' \{\
.       ds $HDRFTR_CENTER_OLD \\*[$HDRFTR_CENTER]
.       ds $HDRFTR_CENTER_NEW \\$1
.    \}
.    if '\\$0'FOOTER_CENTRE' \{\
.       ds $HDRFTR_CENTER_OLD \\*[$HDRFTR_CENTER]
.       ds $HDRFTR_CENTER_NEW \\$1
.    \}
.    ds $HDRFTR_CENTER \\$1
.END
\#
\#
\# HDRFTR CENTER CAPS
\# ------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalisation of $HDRFTR_CENTER (typically, doctype of
\#   the document) on or off.
\# *Notes:
\#   Default is on.
\#
.MAC HDRFTR_CENTER_CAPS END
.    ie '\\$1'' \{\
.       nr #HDRFTR_CENTER_CAPS 1
.    \}
.    el \{\
.       nr #HDRFTR_CENTER_CAPS 0
.       ds $HDRFTR_CENTER_SIZE_CHANGE +0
.    \}
.END
\#
\#
\# HDRFTR CENTER PADDING
\# ---------------------
\# *Argument:
\#   LEFT | RIGHT <amount of padding to put left or right of hdrftr
\#   center string>
\# *Function:
\#   Creates or modifies registers #HDRFTR_CTR_PAD_LEFT or
\#   #HDRFTR_CTR_PAD_RIGHT.
\# *Notes:
\#   By default, the HDRFTR_CENTER string is centered on the doc
\#   line length.  Long titles or long author names can screw up
\#   visual centering, or create overprints.  This macro allows the
\#   user to pad the center string by the specified amount of space
\#   to fix these problems.  Use only one of LEFT or RIGHT.
\#
\#   A unit of measure is required.
\#
.MAC HDRFTR_CENTER_PAD END
.    if '\\$1'LEFT' \{\
.       nr #HDRFTR_CTR_PAD_LEFT (\\$2)
.    \}
.    if '\\$1'RIGHT' \{\
.       nr #HDRFTR_CTR_PAD_RIGHT (\\$2)
.    \}
.END
\#
\#
\# SWITCH HDRFTR CENTER PADDING SIDE - support macro
\# --------------------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Switches the padding side of hdrftr center padding.
\# *Notes:
\#   Required to keep spacing around hdrftr string constant
\#   in recto/verso documents.
\#
.MAC SWITCH_HDRFTR_CENTER_PAD END
.    nr #HDRFTR_CTR_PAD_TMP  \\n[#HDRFTR_CTR_PAD_LEFT]
.    HDRFTR_CENTER_PAD LEFT  \\n[#HDRFTR_CTR_PAD_RIGHT]u
.    HDRFTR_CENTER_PAD RIGHT \\n[#HDRFTR_CTR_PAD_TMP]u
.END
\#
\#
\# HDRFTR RIGHT
\# ------------
\# *Argument:
\#   <what to put in the right position of page header/footers>
\# *Function:
\#   Creates or modifies string $HDRFTR_RIGHT.
\#   Creates register #USER_DEF_HDRFTR_RIGHT, which, if 1,
\#   overrides the $HDRFTR_RIGHT string created by default
\#   in DEFAULTS.
\# *Notes:
\#   Default is document title.
\#
\#   If the argument is the # character, simply prints the current
\#   page number.
\#
\#   If the user wants to *incorporate* the page number into the string,
\#   \*[PAGE#] must be used.  For example, if the user wants to put
\#   an elipsis before the page number in the string, s/he should use
\#   ...\*[PAGE#], not ...#
\#
.MAC HDRFTR_RIGHT END
.    nr #USER_DEF_HDRFTR_RIGHT 1
.    ds $HDRFTR_RIGHT \\$1
.END
\#
\#
\# HDRFTR RIGHT CAPS
\# -----------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalisation of $HDRFTR_RIGHT (typically, the title of
\#   the document) on or off.
\# *Notes:
\#   Default is on.
\#
.MAC HDRFTR_RIGHT_CAPS END
.    ie '\\$1'' \{\
.       nr #HDRFTR_RIGHT_CAPS 1
.    \}
.    el \{\
.       nr #HDRFTR_RIGHT_CAPS 0
.       ds $HDRFTR_RIGHT_SIZE_CHANGE +0
.    \}
.END
\#
\#
\# HDRFTR RULE
\# -----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   If invoked via the alias HDRFTR_RULE_INTERNAL in HDRFTR, prints a rule
\#   under the header/over the footer.  Otherwise, turns HDRFTR_RULE
\#    on or off.
\#
.MAC HDRFTR_RULE END   \"To print rule under header/over footer.
.    ie '\\$0'HDRFTR_RULE_INTERNAL' \{\
.       ie \\n[#USERDEF_HDRFTR] \{\
.          nr #CAP_HEIGHT_ADJUST \\n[#HDRFTR_HEIGHT]
.          ps 12
.          if \\n[#HEADERS_ON] \{\
.             rt \\nyu
.             ALD \\n[#HDRFTR_RULE_GAP]u
.          \}
.          if \\n[#FOOTERS_ON] \{\
.              rt \\nyu
.              RLD \\n[#HDRFTR_RULE_GAP]u+\\n[#CAP_HEIGHT_ADJUST]u+1p
.          \}
.          ie \\n[#HDRFTR_RULE_COLOR]=1 \{\
.             PRINT \m[\\*[$HDRFTR_RULE_COLOR]]\\l'\\n[#DOC_L_LENGTH]u'\m[]
.          \}
.          el \{\
.             PRINT \\l'\\n[#DOC_L_LENGTH]u'
.          \}
.          br
.       \}
.       el \{\
.          if \\n[#PRINT_STYLE]=1 \{\
.             nr #CAP_HEIGHT_ADJUST \\n[#CAP_HEIGHT]
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             ie \\n[#LEFT_CAP_HEIGHT]>\\n[#CENTER_CAP_HEIGHT] \{\
.                nr #CAP_HEIGHT_ADJUST \\n[#LEFT_CAP_HEIGHT]
.             \}
.             el \{ .nr #CAP_HEIGHT_ADJUST \\n[#CENTER_CAP_HEIGHT] \}
.             ie \\n[#CAP_HEIGHT_ADJUST]>\\n[#RIGHT_CAP_HEIGHT] \{\
.                nr #CAP_HEIGHT_ADJUST \\n[#CAP_HEIGHT_ADJUST]
.             \}
.             el \{ .nr #CAP_HEIGHT_ADJUST \\n[#RIGHT_CAP_HEIGHT] \}
.          \}
.          ps 12
.          if \\n[#HEADERS_ON] \{\
.             rt \\nyu
.             ALD \\n[#HDRFTR_RULE_GAP]u
.          \}
.          if \\n[#FOOTERS_ON] \{\
.             rt \\nyu
.             RLD \\n[#HDRFTR_RULE_GAP]u+\\n[#CAP_HEIGHT_ADJUST]u+1p
.          \}
.          ie \\n[#HDRFTR_RULE_COLOR]=1 \{\
.             PRINT \m[\\*[$HDRFTR_RULE_COLOR]]\\l'\\n[#DOC_L_LENGTH]u'\m[]
.          \}
.          el \{\
.             PRINT \\l'\\n[#DOC_L_LENGTH]u'
.          \}
.          br
.       \}
.    \}
.    el \{\
.       ie '\\$1'' \{ .nr #HDRFTR_RULE 1 \}
.       el \{ .nr #HDRFTR_RULE 0 \}
.    \}
.END
\#
\#
.ALIAS HDRFTR_RULE_INTERNAL HDRFTR_RULE
\#
\#
\# HDRFTR PLAIN
\# ------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Sets the family, font, and point size of all strings in
\#   header/footers to the same family and point size as running
\#   text.  Font for the header/footer becomes roman throughout.
\#
.MAC HDRFTR_PLAIN END
.    HDRFTR_FAMILY        \\*[$DOC_FAM]
.    HDRFTR_PT_SIZE       \\n[#DOC_PT_SIZE]
.    HDRFTR_LEFT_FAMILY   \\*[$DOC_FAM]
.    HDRFTR_LEFT_FONT     R
.    HDRFTR_LEFT_SIZE     +0
.    HDRFTR_LEFT_CAPS     OFF
.    HDRFTR_CENTER_FAMILY \\*[$DOC_FAM]
.    HDRFTR_CENTER_FONT   R
.    HDRFTR_CENTER_SIZE   +0
.    HDRFTR_CENTER_CAPS   OFF
.    HDRFTR_RIGHT_FAMILY  \\*[$DOC_FAM]
.    HDRFTR_RIGHT_FONT    R
.    HDRFTR_RIGHT_SIZE    +0
.    HDRFTR_RIGHT_CAPS    OFF
.END
\#
\#
\# SWITCH HDRFTR
\# -------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #SWITCH_HDRFTR, used to switch
\#   default location of HDRFTR_LEFT and HDRFTR_RIGHT.
\# *Notes:
\#
.ig
Typically, the author string appears at the left of header/footers,
and the title string appears at the right.  This switches the
location of the two.  Useful in conjuction with RECTO_VERSO to tweak
switches on alternate pages to come out as the user wishes.  The
assumption of RECTO_VERSO is that the first page of the document
(recto) is odd, and even though it has no header/footer, if it did
have one, it would print as AUTHOR...CENTER...TITLE (or whatever
strings the user has supplied for HDRFTR_LEFT/RIGHT), meaning that
the next page, which does have a header/footer, will come out as
TITLE...CENTER...AUTHOR (or whatever strings the user has supplied
for HDRFTR_LEFT/RIGHT).  SWITCH_HDRFTRS allows the user to get the
desired string in the desired place on the desired recto/verso page.

Default is OFF.
..
\#
.MAC SWITCH_HDRFTR END
.    ie '\\$1'' \{ .nr #SWITCH_HDRFTR 1 \}
.    el \{ .nr #SWITCH_HDRFTR 0 \}
.END
\#
\#
\# USER DEFINED HDRFTR RECTO
\# -------------------------
\# *Arguments:
\#   L | LEFT | C | CENTER | CENTER | R | RIGHT <hdrftr_recto_string>
\# *Function:
\#   Toggles #USERDEF_HDRFTR on, stores quad as #USERDEF_HDRFTR_RECTO_QUAD,
\#   stores string in $USERDEF_HDRFTR_RECTO.
\# *Notes:
\#   For use when users don't want 3-part headers/footers, but rather
\#   want to design their own headers/footers and need different
\#   headers/footers on recto and verso pages.  Using just
\#   HEADER_RECTO, even when recto/verso is not on, allows users to
\#   design their own headers/footers for doc pages.
\#
.MAC HDRFTR_RECTO END
.    nr #USERDEF_HDRFTR 1
.    if '\\$1'L'      \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 1 \}
.    if '\\$1'LEFT'   \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 1 \}
.    if '\\$1'C'      \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 2 \}
.    if '\\$1'CENTER' \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 2 \}
.    if '\\$1'CENTRE' \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 2 \}
.    if '\\$1'R'      \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 3 \}
.    if '\\$1'RIGHT'  \{ .nr #USERDEF_HDRFTR_RECTO_QUAD 3 \}
.    ds $USERDEF_HDRFTR_RECTO \\$2
.END
\#
\#
\# USER DEFINED HDRFTR VERSO
\# -------------------------
\# *Arguments:
\#   L | LEFT | C | CENTER | CENTER | R | RIGHT <hdrftr_verso_string>
\# *Function:
\#   Toggles #USERDEF_HDRFTR on, stores quad as #USERDEF_HDRFTR_VERSO_QUAD,
\#   stores string in $USERDEF_HDRFTR_VERSO.
\# *Notes:
\#   For use when users don't want 3-part headers/footers, but rather
\#   want to design their own headers/footers and need different
\#   headers/footers on recto and verso pages.
\#
.MAC HDRFTR_VERSO END
.    nr #USERDEF_HDRFTR 1
.    if '\\$1'L'      \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 1 \}
.    if '\\$1'LEFT'   \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 1 \}
.    if '\\$1'C'      \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 2 \}
.    if '\\$1'CENTER' \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 2 \}
.    if '\\$1'CENTRE' \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 2 \}
.    if '\\$1'R'      \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 3 \}
.    if '\\$1'RIGHT'  \{ .nr #USERDEF_HDRFTR_VERSO_QUAD 3 \}
.    ds $USERDEF_HDRFTR_VERSO \\$2
.END
\#
\#
\# PRINT FOOTER ON FIRST PAGE
\# --------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #PRINT_FOOTER_ON_PAGE_1
\# *Notes:
\#   Lets user choose whether to print footer on first
\#   page of doc.
\#
.MAC FOOTER_ON_FIRST_PAGE END
.    ie '\\$1'' \{ .nr #PRINT_FOOTER_ON_PAGE_1 1 \}
.    el \{ .rr #PRINT_FOOTER_ON_PAGE_1 \}
.END
\#
\#
\# PRINT PAGE NUMBER ON FIRST PAGE
\# -------------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #PRINT_PAGENUM_ON_PAGE_1
\# *Notes:
\#   Lets user choose whether to print page number on first
\#   page of doc and after collate when footers are on or page numbering
\#   has been user set at top of page.
\#
.MAC PAGENUM_ON_FIRST_PAGE END
.    ie '\\$1'' \{ .nr #PRINT_PAGENUM_ON_PAGE_1 1 \}
.    el \{ .rr #PRINT_PAGENUM_ON_PAGE_1 \}
.END
\#
\#
\# PRINT HEADER/FOOTER
\# -------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Based on defaults or values entered by user, prints a
\#   three-part title at either the top or the bottom of the page.
\# *Notes:
\#   Called from within either HEADER or FOOTER.
\#
.MAC PRINT_HDRFTR END
.    if \\n[#DOC_TYPE]=4 \{\
.       nr #SUITE \En[.pn]
.    \}
.    if \\n[#FOOTERS_ON] \{\
.       if \\n[#START_FOR_FOOTERS] \{\
.          rr #START_FOR_FOOTERS
.          if !\\n[#PRINT_FOOTER_ON_PAGE_1] \{ .return \}
.       \}
.    \}
.    if \\n[#USERDEF_HDRFTR] \{\
.       PRINT_USERDEF_HDRFTR
.       return
.    \}
.    if \\n[#SWITCH_HDRFTR] \{\
.       ds $HDRFTR_TMP_SWITCH             \\*[$HDRFTR_LEFT]
.       ds $HDRFTR_LEFT                   \\*[$HDRFTR_RIGHT]
.       ds $HDRFTR_RIGHT                  \\*[$HDRFTR_TMP_SWITCH]
.       ds $HDRFTR_TMP_SIZE_CHANGE_SWITCH \\*[$HDRFTR_LEFT_SIZE_CHANGE]
.       ds $HDRFTR_LEFT_SIZE_CHANGE       \\*[$HDRFTR_RIGHT_SIZE_CHANGE]
.       ds $HDRFTR_RIGHT_SIZE_CHANGE      \\*[$HDRFTR_TMP_SIZE_CHANGE_SWITCH]
.       nr #HDRFTR_TMP_CAPS_SWITCH        \\n[#HDRFTR_LEFT_CAPS]
.       nr #HDRFTR_LEFT_CAPS              \\n[#HDRFTR_RIGHT_CAPS]
.       nr #HDRFTR_RIGHT_CAPS             \\n[#HDRFTR_TMP_CAPS_SWITCH]
.       ds $HDRFTR_TMP_COLOR_SWITCH       \\*[$HDRFTR_LEFT_COLOR]
.       ds $HDRFTR_LEFT_COLOR             \\*[$HDRFTR_RIGHT_COLOR]
.       ds $HDRFTR_RIGHT_COLOR            \\*[$HDRFTR_TMP_COLOR_SWITCH]
.       rr #HDRFTR_TMP_CAPS_SWITCH
.       rm $HDRFTR_TMP_SWITCH
.       rm $HDRFTR_TMP_SIZE_CHANGE_SWITCH
.       rm $HDRFTR_TMP_COLOR_SWITCH
.       nr #SWITCH_HDRFTR 0
.    \}
.    nr #PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]
.    if \\n[#ENDNOTES] \{ .PAGENUM_STYLE \\*[$EN_PN_STYLE] \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #LEFT_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       if o                        \{ .RIGHT \}
.       if e                        \{ .LEFT  \}
.       if \\n[#RECTO_VERSO]=0      \{ .LEFT  \}
.       if \\n[#HDRFTR_LEFT_CAPS]   \{ .CAPS  \}
.       ie '\\*[$HDRFTR_LEFT]'#' \{\
.           PRINT \\n[#PAGENUMBER]
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_LEFT]'' \{ . PRINT \\*[$HDRFTR_LEFT] \}
.          el \{ .PRINT \& \}
.       \}
.       if \\n[#HDRFTR_LEFT_CAPS] \{ .CAPS OFF \}
.       CENTER
.       if \\n[#HDRFTR_CENTER_CAPS] \{ .CAPS \}
.       rt \\nyu
.       ie '\\*[$HDRFTR_CENTER]'#' \{\
.           PRINT \\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\n[#PAGENUMBER]\\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_CENTER]'' \{ .PRINT \\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\*[$HDRFTR_CENTER]\\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u' \}
.          el \{ .PRINT \& \}
.       \}
.       if \\n[#HDRFTR_CENTER_CAPS] \{ .CAPS OFF \}
.       if o                       \{ .LEFT  \}
.       if e                       \{ .RIGHT \}
.       if \\n[#RECTO_VERSO]=0     \{ .RIGHT \}
.       if \\n[#HDRFTR_RIGHT_CAPS] \{ .CAPS  \}
.       rt \\nyu
.       ie '\\*[$HDRFTR_RIGHT]'#' \{\
.           PRINT \\n[#PAGENUMBER]
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_RIGHT]'' \{ .PRINT \\*[$HDRFTR_RIGHT] \}
.          el \{ .PRINT \& \}
.       \}
.       if \\n[#HDRFTR_RIGHT_CAPS] \{ .CAPS OFF \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#HDRFTR_COLOR]=1 \{\
.          nf
\m[\\*[$HDRFTR_COLOR]]
.          EOL
.       \}
.       fam     \\*[$HDRFTR_LEFT_FAM]
.       ft      \\*[$HDRFTR_LEFT_FT]
.       ps      \\n[#HDRFTR_PT_SIZE]u\\*[$HDRFTR_LEFT_SIZE_CHANGE]
.       vs      12
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #LEFT_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       if o                      \{ .LEFT  \}
.       if e                      \{ .RIGHT \}
.       if \\n[#RECTO_VERSO]=0    \{ .LEFT  \}
.       if \\n[#HDRFTR_LEFT_CAPS] \{ .CAPS  \}
.       ie '\\*[$HDRFTR_LEFT]'#' \{\
.          ie \\n[#HDRFTR_LEFT_COLOR]=1 \{\
.             PRINT \m[\\*[$HDRFTR_LEFT_COLOR]]\\n[#PAGENUMBER]\m[]
.          \}
.          el \{\
.             PRINT \\n[#PAGENUMBER]
.          \}
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_LEFT]'' \{\
.             ie \\n[#HDRFTR_LEFT_COLOR]=1 \{\
.                 PRINT \m[\\*[$HDRFTR_LEFT_COLOR]]\\*[$HDRFTR_LEFT]\m[]
.             \}
.             el \{\
.                 PRINT \\*[$HDRFTR_LEFT]
.             \}
.          \}
.          el \{ .PRINT \& \}
.       \}
.       if \\n[#HDRFTR_LEFT_CAPS] \{ .CAPS OFF \}
.       fam     \\*[$HDRFTR_CENTER_FAM]
.       ft      \\*[$HDRFTR_CENTER_FT]
.       ps      \\n[#HDRFTR_PT_SIZE]u\\*[$HDRFTR_CENTER_SIZE_CHANGE]
.       vs      12
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #CENTER_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       CENTER
.       if \\n[#HDRFTR_CENTER_CAPS] \{ .CAPS \}
.       rt \\nyu
.       ie '\\*[$HDRFTR_CENTER]'#' \{\
.           ie \\n[#HDRFTR_CENTER_COLOR]=1 \{\
.              PRINT \\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\m[\\*[$HDRFTR_CENTER_COLOR]]\\n[#PAGENUMBER]\\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'\m[]
.           \}
.           el \{\
.              PRINT \\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\n[#PAGENUMBER]\\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.           \}
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_CENTER]'' \{\
.             ie \\n[#HDRFTR_CENTER_COLOR]=1 \{\
.                PRINT \\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\m[\\*[$HDRFTR_CENTER_COLOR]]\\*[$HDRFTR_CENTER]\\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'\m[]
.             \}
.             el \{\
.                PRINT \\h'\\n[#HDRFTR_CTR_PAD_LEFT]u'\\*[$HDRFTR_CENTER]\\h'\\n[#HDRFTR_CTR_PAD_RIGHT]u'
.             \}
.          \}
.          el \{ .PRINT \& \}
.       \}
.       if \\n[#HDRFTR_CENTER_CAPS] \{ .CAPS OFF \}
.       fam     \\*[$HDRFTR_RIGHT_FAM]
.       ft      \\*[$HDRFTR_RIGHT_FT]
.       ps      \\n[#HDRFTR_PT_SIZE]u\\*[$HDRFTR_RIGHT_SIZE_CHANGE]
.       vs      12
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #RIGHT_CAP_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.       if o                       \{ .RIGHT \}
.       if e                       \{ .LEFT  \}
.       if \\n[#RECTO_VERSO]=0     \{ .RIGHT \}
.       if \\n[#HDRFTR_RIGHT_CAPS] \{ .CAPS  \}
.       rt \\nyu
.       ie '\\*[$HDRFTR_RIGHT]'#' \{\
.          ie \\n[#HDRFTR_RIGHT_COLOR]=1 \{\
.             PRINT \m[\\*[$HDRFTR_RIGHT_COLOR]]\\n[#PAGENUMBER]\m[]
.          \}
.          el \{\
.             PRINT \\n[#PAGENUMBER]
.          \}
.       \}
.       el \{\
.          ie !'\\*[$HDRFTR_RIGHT]'' \{\
.             ie \\n[#HDRFTR_RIGHT_COLOR]=1 \{\
.                PRINT \m[\\*[$HDRFTR_RIGHT_COLOR]]\\*[$HDRFTR_RIGHT]\m[]
.             \}
.             el \{\
.                PRINT \\*[$HDRFTR_RIGHT]
.             \}
.          \}
.          el \{ .PRINT \& \}
.       \}
.       if \\n[#HDRFTR_RIGHT_CAPS] \{ .CAPS OFF \}
.    \}
.    if \\n[#HDRFTR_RULE] \{\
.       HDRFTR_RULE_INTERNAL
.    \}
.    br
.END
\#
\#
\# PRINT USER DEFINED HEADER/FOOTER
\# --------------------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Based on defaults or values entered by user, prints a single part
\#   (i.e. not 3-part) title at either the top or the bottom of the page.
\# *Notes:
\#   Called from within PRINT_HDRFTR.
\#
.MAC PRINT_USERDEF_HDRFTR END
.    nr #PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]
.    fc ^ #
.    if \\n[#PRINT_STYLE]=2 \{\
.       FAMILY  \\*[$HDRFTR_FAM]
.       FT      R
.       PT_SIZE \\n[#HDRFTR_PT_SIZE]u
.       if \\n[#HDRFTR_COLOR]=1 \{\
.          nf
.          COLOR \\*[$HDRFTR_COLOR]
.       \}
.    \}
.    ie \\n[#RECTO_VERSO] \{\
.       if o \{\
.          if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=1 \{ .LEFT   \}
.          if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=2 \{ .CENTER \}
.          if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=3 \{ .RIGHT  \}
.          PRINT \\*[$USERDEF_HDRFTR_RECTO]
.          EOL
.          if \\n[#FOOTERS_ON] \{\
.             di NULL
.             SIZESPECS
.             nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.             di
.          \}
.       \}
.       if e \{\
.          ie !'\\*[$USERDEF_HDRFTR_VERSO]'' \{\
.             if \\n[#USERDEF_HDRFTR_VERSO_QUAD]=1 \{ .LEFT   \}
.             if \\n[#USERDEF_HDRFTR_VERSO_QUAD]=2 \{ .CENTER \}
.             if \\n[#USERDEF_HDRFTR_VERSO_QUAD]=3 \{ .RIGHT  \}
.             PRINT \\*[$USERDEF_HDRFTR_VERSO]
.             EOL
.             if \\n[#FOOTERS_ON] \{\
.                di NULL
.                SIZESPECS
.                nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.                di
.             \}
.          \}
.          el \{\
.             if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=1 \{ .LEFT   \}
.             if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=2 \{ .CENTER \}
.             if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=3 \{ .RIGHT  \}
.             PRINT \\*[$USERDEF_HDRFTR_RECTO]
.             EOL
.             if \\n[#FOOTERS_ON] \{\
.                di NULL
.                SIZESPECS
.                nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.                di
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=1 \{ .LEFT   \}
.       if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=2 \{ .CENTER \}
.       if \\n[#USERDEF_HDRFTR_RECTO_QUAD]=3 \{ .RIGHT  \}
.       PRINT \\*[$USERDEF_HDRFTR_RECTO]
.       EOL
.       if \\n[#FOOTERS_ON] \{\
.          di NULL
.          SIZESPECS
.          nr #HDRFTR_HEIGHT \\n[#CAP_HEIGHT]
.          di
.       \}
.    \}
.    fc
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#HDRFTR_COLOR]=1 \m[\\*[$HDRFTR_COLOR]]
.       el \m[black]
.    \}
.    if \\n[#HDRFTR_RULE] \{\
.       HDRFTR_RULE_INTERNAL
.    \}
.END
\#
\#
\# +++HEADERS+++
\#
\# HEADERS (off or on)
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns headers at the top of the page off or on.
\# *Notes:
\#   Default is on.
\#
.MAC HEADERS END
.    ie '\\$1'' \{ .nr #HEADERS_ON 1 \}
.    el \{ .nr #HEADERS_ON 0 \}
.END
\#
\#
\# HEADER MARGIN
\# -------------
\# *Argument:
\#   <amount of space between top of page and header>
\# *Function:
\#   Creates or modifies register #HEADER_MARGIN to hold amount
\#   of space between top of page and header.
\# *Notes:
\#   Requires unit of measure.  Default is 4P+6p, measured top-of-page
\#   to baseline.
\#
.MAC HEADER_MARGIN END
.    nr #HEADER_MARGIN (\\$1)
.END
\#
\#
\# HEADER GAP
\# ----------
\# *Argument:
\#   <amount of space between header and running text>
\# *Function:
\#   Creates or modifies register #HEADER_GAP to hold amount
\#   of space between header and running text.
\# *Notes:
\#   Default is 1P+6p.
\#
.MAC HEADER_GAP END
.    nr #HEADER_GAP (\\$1)
.END
\#
\#
\# HEADER
\# ------
\# *Arguments:
\#   <none>
\# *Function:
\#   Prints header appropriate to DOC_TYPE, PRINTSTYLE, and COPYSTYLE.
\# *Notes:
\#   In order to convert the title string to caps in the header (in the
\#   event that the user enters .TITLE in caps/lc), I've used
\#   quad left, quad centre, and quad right to arrange the three bits
\#   of the header, rather than .tl.  This allows the use of the CAPS macro.
\#   The downside is that I have to add \\v'-(\\n[#LEAD]u*<n>) in order
\#   for -Tlatin1 output to align the header/footer strings on the baseline.
\#   The console output still isn't brilliant, but at least it's
\#   comprehensible.
\#
.MAC HEADER END
.    MNtop
.    rr #FROM_FOOTER
.    nr #FROM_HEADER 1
.    nr #LAST_FN_COUNT_FOR_COLS \\n[#FN_COUNT_FOR_COLS]
.    if \\n[#FN_DEPTH] \{ .PROCESS_FN_LEFTOVER \}
.    rr #RULED
.    if \\n[#RESET_FN_NUMBER] \{ .nr #FN_NUMBER 0 1 \}
.    po \\n[#DOC_L_MARGIN]u
.    if \\n[#RECTO_VERSO] \{\
.       if !\\n[#TOC_RV_SWITCH] \{\
.          nr #DOC_LR_MARGIN_TMP \\n[#DOC_L_MARGIN]
.          DOC_LEFT_MARGIN  \\n[#DOC_R_MARGIN]u
.          DOC_RIGHT_MARGIN \\n[#DOC_LR_MARGIN_TMP]u
.          SWITCH_HDRFTR_CENTER_PAD
.       \}
.       rr #TOC_RV_SWITCH
.    \}
.    ev HEADER
.    if \\n[#PAGE_NUM_V_POS]=1 \{ .vs 0 \}
.    sp |\\n[#HEADER_MARGIN]u-1v
.    mk y
.    ll \\n[#DOC_L_LENGTH]u
.    ta \\n(.lu
.    if \\n[#PRINT_STYLE]=1 \{\
.       fam C
.       ft  R
.       ps  12\\*[$HDRFTR_SIZE_CHANGE]
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.      fam \\*[$HDRFTR_FAM]
.      ft  R
.      ps  \\n[#DOC_PT_SIZE]u\\*[$HDRFTR_SIZE_CHANGE]
.      vs  12
.    \}
.    nr #HDRFTR_PT_SIZE \\n[#PT_SIZE]
.    if \\n[#CAPS_ON] \{\
.       nr #CAPS_WAS_ON 1
.       CAPS OFF
.    \}
.    if \\n[#UNDERLINE_ON] \{\
.       nr #UNDERLINE_WAS_ON 1
.       UNDERLINE OFF
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#ENDNOTES]=1 \{\
.\" Single-spaced endotes have a different lead
.          if \\n[#EN_SINGLESPACE] \{\
.             nr #RESTORE_DOC_LEAD \\n[#DOC_LEAD]
.             nr #DOC_LEAD \\n[#EN_LEAD]u
.          \}
.       \}
.    \}
.    ie \\n[#HEADERS_ON] \{\
.       PRINT_HDRFTR
.       sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.    \}
.    el \{\
.       ie \\n[#PAGE_NUM_V_POS]=1 \{\
.          ie \\n[#PAGINATE] \{\
.             PRINT_PAGE_NUMBER
.             sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.          \}
.          el \{ .sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u \}
.       \}
.       el \{ .sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u \}
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#ENDNOTES]=1 \{\
.          if \\n[#EN_SINGLESPACE] \{\
.             nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]u
.             rr #RESTORE_DOC_LEAD
.          \}
.       \}
.    \}
.    nr #PAGE_TOP \\n(nl
.    ev
.    po \\n[#L_MARGIN]u
.    if \\n[#RECTO_VERSO] \{\
.       nr #L_MARGIN +\\n[#L_MARGIN_DIFF]
.    \}
.    if \\n[#CAPS_WAS_ON] \{\
.       CAPS
.       rr #CAPS_WAS_ON
.    \}
.    if \\n[#UNDERLINE_WAS_ON] \{\
.       UNDERLINE
.       rr #UNDERLINE_WAS_ON
.    \}
.    if \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.    if \\n[#QUOTE] \{\
.       ie \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.       el \{\
.          nr #Q_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.          po \\n[#Q_OFFSET]u
.       \}
.       ALD \\n[#Q_LEAD_DIFF]u
.    \}
.    if \\n[#EPIGRAPH] \{\
.       ie \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.       el \{\
.          nr #EPI_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.          po \\n[#EPI_OFFSET]u
.       \}
.    \}
.    ie \\n[#EPIGRAPH] \{\
.       ie !\\n[#EPI_ACTIVE] \{\
.          ns
.          rr #EPI_ACTIVE
.       \}
.       el \{\
.          ie \\n[#EPI_FITS] \{ .ns \}
.          el \{ .ALD \\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u \}
.       \}
.    \}
.    el \{ .ns \}
.    ns
.    if \\n[#COLUMNS] \{\
.       nr #FN_COUNT_FOR_COLS 0 1
.       nr #L_MARGIN \\n[#DOC_L_MARGIN]
.       if \\n[#RECTO_VERSO] \{ .COLUMNS \\n[#NUM_COLS] \\n[#GUTTER]u \}
.       nr #COL_NUM 0 1
.       mk dc
.       po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n(.o
.       if \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.       ll \\n[#COL_L_LENGTH]u
.       ta \\n(.lu
.       if \\n[#QUOTE] \{\
.          po +(\\n[#PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u)
.       \}
.       if \\n[#EPIGRAPH] \{\
.          if \\n[#EPI_ACTIVE] \{\
.             ie \\n[#EPI_FITS] \{ . \}
.             el \{ .nr dc -\\n[#EPI_LEAD_DIFF] \}
.          \}
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u+(\\n[#PP_INDENT]u*\\n[#EPI_OFFSET_VALUE]u)
.       \}
.    \}
.    if \\n[#RESET_FN_COUNTERS]=1 \{\
.       rr #RESET_FN_COUNTERS
.       PROCESS_FN_IN_DIVER
.       nr #FN_COUNT \\n[#SAVED_FN_COUNT] 1
.       if \\n[#COLUMNS]=1 \{ .nr #FN_COUNT_FOR_COLS \\n[#SAVED_FN_COUNT_FOR_COLS] 1 \}
.       ie \\n[#RESET_FN_NUMBER]=1 \{ .nr #FN_NUMBER \\n[#SAVED_FN_NUMBER] 1 \}
.       el \{ .nr #FN_NUMBER \\n[#FN_NUMBER] 1 \}
.       rm FN_IN_DIVER
.       if dRUNON_FN_IN_DIVER \{ .rm RUNON_FN_IN_DIVER \}
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#SLANT_ON] \{\
.          if \\n[#UNDERLINE_SLANT] \{ .UNDERLINE \}
.       \}
.    \}
.    rr #FROM_HEADER
.    rr #DEFER_SPACE_ADDED
.    if !\\n[#FN_DEPTH] \{\
.       if r#DIVERTED \{ .rr #DIVERTED \}
.    \}
.    if \\n[#MN_OVERFLOW_LEFT]=1 \{\
.       MN LEFT
.       nf
.       MN_OVERFLOW_LEFT
.       MN
.    \}
.    if \\n[#MN_OVERFLOW_RIGHT]=1 \{\
.       MN RIGHT
.       nf
.       MN_OVERFLOW_RIGHT
.       MN
.    \}
.    rm MN_OVERFLOW_LEFT
.    rr #MN_OVERFLOW_LEFT
.    rr #no-repeat-MN-left
.    rm MN_OVERFLOW_RIGHT
.    rr #MN_OVERFLOW_RIGHT
.    rr #no-repeat-MN-right
.END
\#
\# ====================================================================
\#
\# +++FOOTERS+++
\#
\# FOOTERS (off or on)
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns footers at the bottom of the page off or on.
\# *Notes:
\#   Default is off.  If on, page numbers automatically go at
\#   the top, centered, unless pagination has been turned off,
\#   or the pagenumber position has been changed to left or right.
\#
.MAC FOOTERS END
.    ie '\\$1''   \{\
.       nr #FOOTERS_ON 1
.       PAGE_NUM_POS TOP CENTER
.    \}
.    el \{ .nr #FOOTERS_ON 0 \}
.END
\#
\#
\# FOOTER MARGIN
\# -------------
\# *Argument:
\#   <footer margin>
\# *Function:
\#   Creates or modifies register #FOOTER_MARGIN which holds the
\#   amount of space to leave between the page number and the bottom
\#   of the page.
\# *Notes:
\#   Unit of measure required.  Default is 3P.
\#
.MAC FOOTER_MARGIN END
.    ie \\n%>0 \{ .nr #FOOTER_MARGIN (\\$1) \}
.    el \{ . \}
.END
\#
\#
\# FOOTER GAP
\# ----------
\# *Argument:
\#   <distance from end of running text to page # or footer>
\# *Function:
\#   Creates or modifies register #FOOTER_GAP which holds the
\#   amount of space to leave between running text and the page number.
\# *Notes:
\#   Requires unit of measure.  Default is 3P.  Measured baseline to
\#   baseline.
\#
.MAC FOOTER_GAP END
.    ie \\n%>0 \{ .nr #FOOTER_GAP (\\$1) \}
.    el \{ . \}
.END
\#
\#
\# FOOTER
\# ------
\# *Arguments:
\#   <none>
\# *Function:
\#   Places footer at bottom of page if #FOOTERS=1, otherwise
\#   places page number at bottom of page (if #PAGINATE=1).
\#   Page numbers are in arabic or roman according to COPYSTYLE.
\#   DRAFT starts the document at page 1 regardless of PAGENUMBER.
\#   FINAL respects PAGENUMBER.
\#
.MAC FOOTER END
.    ev PAGE_TRANSITION
.    if \\n[MN-left]>0 \{\
.       if !\\n[#no-repeat-MN-left]=1 \{\
.          MNbottom-left
.          nr #no-repeat-MN-left 1
.       \}
.       if '\\n(.z'MN_OVERFLOW_LEFT' \{\
.          di
.          nr #MN_OVERFLOW_LEFT 1
.          rr #OVERFLOW_LEFT
.       \}
.    \}
.    if \\n[MN-right]>0 \{\
.       if (\\n[MN-right] > 0) \{\
.          if !\\n[#no-repeat-MN-right]=1 \{\
.             MNbottom-right
.          \}
.       \}
.       if '\\n(.z'MN_OVERFLOW_RIGHT' \{\
.          di
.          nr #MN_OVERFLOW_RIGHT 1
.          rr #OVERFLOW_RIGHT
.       \}
.    \}
.    ch MN_OVERFLOW_TRAP
.    nr #SAVED_LEAD \\n(.v
.    nr #L_MARGIN_DIFF \\n[#L_MARGIN]-\\n[#DOC_L_MARGIN]
.    if !\\n[#FN_DEFER] \{\
.       nr #DIVER_DEPTH 0
.       if \\n[#FN_DEPTH] \{\
.          if \\n[#DIVERTED]=3 \{ .nr #FN_DEPTH +\\n[#VFP_DIFF] \}
.          vpt 0
.          sp |\\n[#PAGE_LENGTH]u-(\\n[#B_MARGIN]u+\\n[#FN_DEPTH]u-\\n[#DOC_LEAD]u)
.          vpt 1
.          po \\n[#DOC_L_MARGIN]u
.          if \\n[#COLUMNS] \{\
.             po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.             nr #L_MARGIN \\n(.o
.             nr #FROM_FOOTER 1
.          \}
.          nf
.          FOOTNOTES
.          rm FOOTNOTES
.          if dRUNON_FOOTNOTES \{ .rm RUNON_FOOTNOTES \}
.          if \\n[#PRINT_STYLE]=1 \{ .vs \\n[#SAVED_LEAD]u \}
.          if \\n[#PRINT_STYLE]=2 \{ .LS \\n[#SAVED_LEAD]u \}
.          if '\\n(.z'FN_OVERFLOW' \{\
.              di
.              nr #FN_OVERFLOW_DEPTH \\n[#DIVER_DEPTH]
.          \}
.          nr #FN_COUNT_AT_FOOTER \\n[#FN_COUNT]
.          nr #FN_COUNT 0
.          if \\n[#COL_NEXT] \{\
.             ie !\\n[#COL_NUM]=\\n[#NUM_COLS] \{ .nr #COL_NUM \\n-[#COL_NUM] \}
.             el \{ .nr #COL_NUM \\n[#NUM_COLS] 1 \}
.          \}
.       \}
.       rr #DIVERTED
.    \}
.    ie \\n[#COLUMNS]=1 \{\
.       ie \\n[#COL_NUM]=\\n[#NUM_COLS] \{ .DO_FOOTER \}
.       el \{\
.          ie \\n[#ENDNOTES] \{ .sp |\\n(ecu-\\n[#EN_LEAD]u \}
.          el \{ .sp |\\n(dcu \}
.          po \\n[#COL_\\n+[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n(.o
.          if \\n[#FN_DEPTH] \{ .PROCESS_FN_LEFTOVER \}
.          LS \\n[#SAVED_LEAD]u
.          if \\n[#PREV_FN_DEFERRED] \{\
.             nr #PREV_FN_DEFERRED 2
.          \}
.          rr #RULED
.          if !\\n[#EPIGRAPH] \{ .rr #COL_NEXT \}
.          if !\\n[#QUOTE]    \{ .rr #COL_NEXT \}
.          if \\n[#RESET_FN_COUNTERS]=1 \{\
.             rr #RESET_FN_COUNTERS
.             PROCESS_FN_IN_DIVER
.             LS \\n[#SAVED_LEAD]u
.             nr #FN_COUNT \\n[#FN_COUNT] 1
.             nr #FN_COUNT_FOR_COLS \\n[#FN_COUNT_FOR_COLS] 1
.             rm FN_IN_DIVER
.             if dRUNON_FN_IN_DIVER \{ .rm RUNON_FN_IN_DIVER \}
.          \}
.          rr #DEFER_SPACE_ADDED
.          if \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.          if \\n[#QUOTE] \{\
.             ie \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.             el \{\
.                nr #Q_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.                if \\n[#COLUMNS] \{ .nr #Q_OFFSET \\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE]) \}
.                po \\n[#Q_OFFSET]u
.             \}
.          \}
.          if \\n[#EPIGRAPH] \{\
.             ie \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.             el \{\
.                nr #EPI_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE])
.                if \\n[#COLUMNS] \{ .nr #EPI_OFFSET \\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#EPI_OFFSET_VALUE]) \}
.                po \\n[#EPI_OFFSET]u
.             \}
.          \}
.          ie \\n[#EPIGRAPH] \{\
.             ie !\\n[#EPI_ACTIVE] \{\
.                ns
.                rr #EPI_ACTIVE
.             \}
.             el \{\
.                sp |\\n(dcu+(\\n[#DOC_LEAD]u-\\n[#EPI_LEAD]u)
.                rr #EPI_ACTIVE
.             \}
.          \}
.          el \{ .ns \}
.          ev
.       \}
.       ns
.       rr #DIVERTED
.    \}
.    el \{ .DO_FOOTER \}
.END
\#
\#
\# PROCESS FOOTER
\# --------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Prints footer (page number, or 3-part footer).
\#   Resets CAPS and UNDERLINE if they were on.
\#
.MAC DO_FOOTER END
.\" Have to change position of FN_OVERFLOW_TRAP or it screws up the
.\" placement of page numbers (or footers).  It's reset to its original
.\" position at the end of the macro.
.    if r#SAVED_FOOTER_POS \{ .ch FOOTER \\n[#SAVED_FOOTER_POS]u \}
.    rr #SAVED_FOOTER_POS
.    ie (\\n[#FOOTER_MARGIN]+\\n(.v)>\\n[#B_MARGIN] \{\
.       nr #SKIP_FOOTER 1
.    \}
.    el \{\
.       vpt 0
.       sp |\\n[#PAGE_LENGTH]u-\\n[#FOOTER_MARGIN]u-1v
.       mk y
.       vpt 1
.    \}
.    ev FOOTER
.    po \\n[#DOC_L_MARGIN]u
.    ll \\n[#DOC_L_LENGTH]u
.    ta \\n(.lu
.    FAMILY  \\*[$HDRFTR_FAM]
.    FT      R
.    PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$HDRFTR_SIZE_CHANGE]
.    if \\n[#PRINT_STYLE]=1 \{\
.       TYPEWRITER
.    \}
.    LS \\n[#SAVED_LEAD]u
.    nr #HDRFTR_PT_SIZE \\n[#PT_SIZE]
.    if \\n[#CAPS_ON] \{\
.       nr #CAPS_WAS_ON 1
.       CAPS OFF
.    \}
.    if \\n[#UNDERLINE_ON] \{\
.       nr #UNDERLINE_WAS_ON 1
.       UNDERLINE OFF
.    \}
.    ie \\n[#FOOTERS_ON] \{\
.       if !\\n[#SKIP_FOOTER]=1 \{ .PRINT_HDRFTR \}
.    \}
.    el \{\
.       if \\n[#PAGINATE] \{\
.          if \\n[#PAGE_NUM_V_POS]=2 \{\
.             if !\\n[#SKIP_FOOTER]=1 \{ .PRINT_PAGE_NUMBER \}
.          \}
.       \}
.    \}
.    rr #SKIP_FOOTER
.    if \\n[#CAPS_WAS_ON] \{\
.       CAPS
.       rr #CAPS_WAS_ON
.    \}
.    if \\n[#UNDERLINE_WAS_ON] \{\
.       UNDERLINE
.       rr #UNDERLINE_WAS_ON
.    \}
.    ev
.    rr #SAVED_LEAD
.    bp
.\" This ev pops the PAGE_TRANSITION environment still active at the
.\" end of HEADER
.    ev
.END
\#
\# ====================================================================
\#
\# +++HEADS+++
\#
\# ---Head numbers---
\#
\# NUMBER HEADS
\# ------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #NUMBER_HEAD; sets incrementing register #HEAD_NUM.
\# *Notes:
\#   Default is OFF.
\#
.MAC NUMBER_HEADS END
.    ie '\\$1'' \{\
.       nr #NUMBER_HEAD 1
.       if !\\n[#HEAD_NUM] \{ .nr #HEAD_NUM 0 1 \}
.    \}
.    el \{ .rr #NUMBER_HEAD \}
.END
\#
\#
\# RESET HEAD NUMBER
\# -----------------
\# *Arguments:
\#   <none> | <desired head number>
\# *Function:
\#   Resets incrementing register #HEAD_NUM to 1 or, if there's
\#   an argument, to user supplied number.
\# *Notes:
\#   Also resets subhead and parahead numbers.  If this is not
\#   desired, subhead and parahead numbers may be reset individually.
\#
.MAC RESET_HEAD_NUMBER END
.    ie '\\$1'' \{\
.       nr #HEAD_NUM 0 1
.       nr #SH_NUM   0 1
.       nr #PH_NUM   0 1
.    \}
.    el \{\
.       nr #HEAD_NUM \\$1-1 1
.       nr #SH_NUM   0 1
.       nr #PH_NUM   0 1
.    \}
.END
\#
\#
\# NUMBER SUBHEADS
\# ---------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #NUMBER_SH; sets incrementing register #SH_NUM.
\# *Notes:
\#   Default is OFF.
\#
.MAC NUMBER_SUBHEADS END
.    ie '\\$1'' \{\
.       nr #NUMBER_SH 1
.       if !\\n[#SH_NUM] \{ .nr #SH_NUM 0 1 \}
.    \}
.    el \{ .rr #NUMBER_SH \}
.END
\#
\#
\# RESET SUBHEAD NUMBER
\# --------------------
\# *Arguments:
\#   <none> | <desired subhead number>
\# *Function:
\#   Resets incrementing register #SH_NUM to 1 or, if there's
\#   an argument, to user supplied number.
\# *Notes:
\#   When the subhead number is reset, it resets the parahead number as
\#   well.  If this behaviour is not what's wanted, RESET_SUBHEAD_NUMBER
\#   allows the user to set the parahead number to whatever s/he desires.
\#
.MAC RESET_SUBHEAD_NUMBER END
.    ie '\\$1'' \{ .nr #SH_NUM 0 1 \}
.    el \{\
.       nr #SH_NUM \\$1-1 1
.       nr #PH_NUM 0 1
.       \}
.END
\#
\#
\# NUMBER PARAHEADS
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #NUMBER_PH; sets incrementing register #PH_NUM.
\# *Notes:
\#   Default is OFF.
\#
.MAC NUMBER_PARAHEADS END
.    ie '\\$1'' \{\
.       nr #NUMBER_PH 1
.       if !\\n[#PH_NUM] \{ .nr #PH_NUM 0 1 \}
.    \}
.    el \{ .rr #NUMBER_PH \}
.END
\#
\#
\# RESET PARAHEAD NUMBER
\# ---------------------
\# *Arguments:
\#   <none> | <desired parahead number>
\# *Function:
\#   Resets incrementing register #PH_NUM to 1 or, if there's
\#   an argument, to user supplied number.
\# *Notes:
\#   Resetting the parahead number resets the parahead number
\#   only.
\#
.MAC RESET_PARAHEAD_NUMBER END
.    ie '\\$1'' \{ .nr #PH_NUM 0 1 \}
.    el \{ nr #SH_NUM \\$1-1 1 \}
.END
\#
\#
\# ---Main heads---
\#
\# HEAD CAPS
\# ---------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #HEAD_CAPS.
\# *Notes:
\#   Default is on.
\#
.MAC HEAD_CAPS END
.    ie '\\$1'' \{ .nr #HEAD_CAPS 1 \}
.    el \{ .nr #HEAD_CAPS 0 \}
.END
\#
\#
\# HEAD SPACE
\# ----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates register #HEAD_SPACE, which toggles whether the space
\#   before heads is 1 extra line space ("off") or 2 ("on").  Used only
\#   in PRINTSTYLE TYPESET.
\# *Notes:
\#   Default is on.
\#
.MAC HEAD_SPACE END
.    ie '\\$1'' \{ .nr #HEAD_SPACE 1 \}
.    el \{ .nr #HEAD_SPACE 0 \}
.END
\#
\#
\# HEAD UNDERLINE
\# --------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #HEAD_UNDERLINE.
\# *Notes:
\#   Default is on.
\#
.MAC HEAD_UNDERLINE END
.    ie '\\$1'' \{ .nr #HEAD_UNDERLINE 1 \}
.    el \{ .nr #HEAD_UNDERLINE 0 \}
.END
\#
\#
\# MAIN HEAD
\# ---------
\# *Arguments:
\#   "text of main head" ["text of main head"] ...
\# *Function:
\#   In TYPEWRITE, prints main heads centered, all caps, underlined.
\#   In TYPESET, prints bold main heads 1 point larger than running
\#   text, all caps, underlined.
\# *Notes:
\#   The HEAD macro requires that double-quotes (") surround
\#   each line of text.
\#
.MAC HEAD END
.    br
.\" Collect head for TOC.
.    nr #ARG_NUM 0 1
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.    while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.       ie \\n[#ARG_NUM]=\\n[#NUM_ARGS] \{\
.          as $TOC_HEAD_ITEM \\$[\\n+[#ARG_NUM]]\\|
.       \}
.       el \{\
.\" Note that in the .as lines, below, \ at the end has a literal
.\" space after it.
.          ie \\n[#NUMBER_HEAD] \{\
.             ie \\n[#ARG_NUM]=0 \{\
.                as $TOC_HEAD_ITEM \\n+[#HEAD_NUM].\0\\$[\\n+[#ARG_NUM]]\ 
.                nr #HEAD_NUM \\n-[#HEAD_NUM]
.             \}
.             el \{\
.                as $TOC_HEAD_ITEM \\$[\\n+[#ARG_NUM]]\ 
.             \}
.          \}
.          el \{\
.             as $TOC_HEAD_ITEM \\$[\\n+[#ARG_NUM]]\ 
.          \}
.       \}
.\}
.\" Note the use of \!, which transparently embeds the macros used
.\" in the TOC_ENTRIES diversion.  The elements they control must be
.\" processed literally when the diversion is output.
.    ev TOC_EV
.    da TOC_ENTRIES
.    if \\n[#PRINT_STYLE]=1 \{\
\!.     fam C
\!.     ft  R
\!.     ps  12
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_HEAD_FAM]
\!.     FT      \\*[$TOC_HEAD_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_HEAD_SIZE_CHANGE]
.    \}
\!.  TRAP OFF
.    ie \\n[#PRINT_STYLE]=1 \{\
\!.     PAD "\\h'2m'\\*[$TOC_HEAD_ITEM]\\*[$TOC_PN_TYPEWRITE]"
.    \}
.    el \{\
\!.     PAD "\\h'\\n[#TOC_HEAD_INDENT]u'\\*[$TOC_HEAD_ITEM]\\*[$TOC_PN]"
.    \}
\!.  EOL
\!.  ST 100 L
\!.  ST 101 R
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_PN_FAM]
\!.     FT      \\*[$TOC_PN_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.    \}
\!.  TAB 100
\!.  PRINT \\*[LEADER]
\!.  TN
\!.  TRAP
\!.  PRINT \\n[#TOC_ENTRY_PN]
\!.  TQ
.    di       
.    ev
.\" End collection of head for TOC
.\" Process head
.    nr #HEAD 1
.    ev HEAD
.    ll \\n[#L_LENGTH]u
.    ta \\n(.lu
.    if \\n[#COLUMNS] \{\
.       ll \\n[#COL_L_LENGTH]u
.       ta \\n(.lu
.    \}
.    CHECK_INDENT
.    QUAD \\*[$HEAD_QUAD]
.    if \\n[#PRINT_STYLE]=1 \{\
.       TYPEWRITER
.       vs  \\n[#DOC_LEAD]u
.       UNDERLINE OFF
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       FAMILY  \\*[$HEAD_FAM]
.       FT      \\*[$HEAD_FT]
.       PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$HEAD_SIZE_CHANGE]
.       LS      \\n[#DOC_LEAD]u
.    \}
.    if r#QUOTE             \{ .rr #QUOTE \}
.    if r#EPIGRAPH          \{ .rr #EPIGRAPH \}
.    if \\n[#PRINT_STYLE]=1 \{ .ne \\n[#NUM_ARGS]+2 \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#HEAD_SPACE] \{ .ne \\n[#NUM_ARGS]+3 \}
.       el \{ .ne \\n[#NUM_ARGS]+2 \}
.    \}
.    ie \\n[#START] \{\
.       if \\n[#DOC_HEADER]=0 \{ .RLD 1v \}
.    \}
.    el \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          if !\\n[#LINEBREAK] \{\
.             ALD \\n[#DOC_LEAD]u
.             if \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.          \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          ie \\n[#PP_SPACE] \{\
.             ie \\n[#END_QUOTE] \{ . \}
.             el \{\
.                if !\\n[#LINEBREAK] \{\
.                   if \\n[#HEAD_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.                \}
.             \}
.          \}
.          el \{\
.             ie \\n[#HEAD_SPACE] \{ .ALD \\n[#DOC_LEAD]u*2u \}
.             el \{ .ALD \\n[#DOC_LEAD]u \}
.          \}
.          if \\n[#END_QUOTE] \{\
.             if !\\n[#Q_FITS] \{\
.                RLD \\n[#DOC_LEAD]u
.                if \\n[#PP_ACTIVE] \{ .ALD \\n[#DOC_LEAD]u \}
.             \}
.             if \\n[#Q_AT_TOP] \{\
.                RLD \\n[#DOC_LEAD]u
.                if \\n[#Q_AT_TOP] \{ .ALD \\n[#DOC_LEAD]u \}
.             \}
.          \}
.          if \\n[#LINEBREAK] \{\
.             if \\n[#HEAD_SPACE] \{ .RLD \\n[#DOC_LEAD]u \}
.          \}
.       \}
.    \}
.\" Print head
.    nr #ARG_NUM 0 1
.    if \\n[#HEAD_CAPS] \{ .CAPS \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#HEAD_COLOR]=1 \{\
.          TRAP OFF
.          COLOR \\*[$HEAD_COLOR]
.          EOL
.          TRAP
.       \}
.    \}
.    while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.       ie \\n[#NUMBER_HEAD] \{\
.          ie \\n[#ARG_NUM]=0 \{\
.             br
.             ie \\n[#HEAD_UNDERLINE]=0 \{ .PRINT "\\n+[#HEAD_NUM].\0\\$[\\n+[#ARG_NUM]]\}
.             el \{ .UNDERSCORE "\\n+[#HEAD_NUM].\0\\$[\\n+[#ARG_NUM]]\}
.             br
.          \}
.          el \{\
.             br
.             ie \\n[#HEAD_UNDERLINE]=0 \{ .PRINT "\\$[\\n+[#ARG_NUM]]\}
.             el \{ .UNDERSCORE "\\$[\\n+[#ARG_NUM]]\}
.             br
.          \}
.       \}
.       el \{\
.          br
.          ie \\n[#HEAD_UNDERLINE]=0 \{ .PRINT "\\$[\\n+[#ARG_NUM]]\}
.          el \{ .UNDERSCORE "\\$[\\n+[#ARG_NUM]]\}
.          br
.       \}
.\}
.    REMOVE_INDENT
.    CAPS OFF
.    ev
.    ALD \\n[#DOC_LEAD]u
.    RESET_SUBHEAD_NUMBER
.    RESET_PARAHEAD_NUMBER
.    if r#START      \{ .rr #START     \}
.    if r#EPIGRAPH   \{ .rr #EPIGRAPH  \}
.    if r#QUOTE      \{ .rr #QUOTE     \}
.    if r#Q_FITS     \{ .rr #Q_FITS    \}
.    if r#END_QUOTE  \{ .rr #END_QUOTE \}
.    if r#LINEBREAK  \{ .rr #LINEBREAK \}
.    if r#Q_AT_TOP   \{ .rr #Q_AT_TOP  \}
.    if r#PP_ACTIVE  \{ .rr #PP_ACTIVE \}
.    rr #ARG_NUM
.    rm $TOC_HEAD_ITEM
.    nr #PP 0
.END
\#
\#
\# ---Subheads---
\#
\# SUBHEAD
\# -------
\# *Arguments:
\#   "text of subhead" ["text of subhead"] ...
\# *Function:
\#   In TYPEWRITE, prints subheads underlined.
\#   In TYPESET, prints subheads bold, .5 points larger than running
\#   text.
\#   In both styles, a line space precedes the subhead, and a small
\#   amount of lead comes after.
\# *Notes:
\#   As with the HEAD macro, double-quotes (") must surround
\#   each line of text.
\#
.MAC SUBHEAD END
.    br
.\" Collect subhead for TOC.
.    nr #ARG_NUM 0 1
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.       ie \\n[#ARG_NUM]=\\n[#NUM_ARGS] \{\
.          as $TOC_SH_ITEM \\$[\\n+[#ARG_NUM]]\\|
.       \}
.       el \{\
.\" Note that in the .as lines, below, \ at the end has a literal
.\" space after it.
.          ie \\n[#NUMBER_SH] \{\
.             ie \\n[#ARG_NUM]=0 \{\
.                as $TOC_SH_ITEM \\n+[#SH_NUM].\0\\$[\\n+[#ARG_NUM]]\ 
.                nr #SH_NUM \\n-[#SH_NUM]
.             \}
.             el \{\
.                as $TOC_SH_ITEM \\$[\\n+[#ARG_NUM]]\ 
.             \}
.          \}
.          el \{\
.             as $TOC_SH_ITEM \\$[\\n+[#ARG_NUM]]\ 
.          \}
.       \}
.\}
.\" Note the use of \!, which transparently embeds the macros used
.\" in the TOC_ENTRIES diversion.  The elements they control must be
.\" processed literally when the diversion is output.
.    ev TOC_EV
.    da TOC_ENTRIES
.    if \\n[#PRINT_STYLE]=1 \{\
\!.     fam C
\!.     ft  R
\!.     ps  12
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_SH_FAM]
\!.     FT      \\*[$TOC_SH_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_SH_SIZE_CHANGE]
.    \}
\!.  TRAP OFF
.    ie \\n[#PRINT_STYLE]=1 \{\
\!.     PAD "\\h'4m'\\*[$TOC_SH_ITEM]\\*[$TOC_PN_TYPEWRITE]"
.    \}
.    el \{\
\!.     PAD "\\h'\\n[#TOC_SH_INDENT]u'\\*[$TOC_SH_ITEM]\\*[$TOC_PN]"
.    \}
\!.  EOL
\!.  ST 100 L
\!.  ST 101 R
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_PN_FAM]
\!.     FT      \\*[$TOC_PN_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.    \}
\!.  TAB 100
\!.  PRINT \\*[LEADER]
\!.  TN
\!.  TRAP
\!.  PRINT \\n[#TOC_ENTRY_PN]
\!.  TQ
.    di       
.    ev
.\" End collection of head for TOC
.\" Process subhead
.    nr #ARG_NUM 0 1
.    if r#QUOTE    \{ .rr #QUOTE    \}
.    if r#Q_AT_TOP \{ .rr #Q_AT_TOP \}
.    ev SUBHEAD
.    ll \\n[#L_LENGTH]u
.    ta \\n(.lu
.    if \\n[#COLUMNS] \{\
.       ll \\n[#COL_L_LENGTH]u
.       ta \\n(.lu
.    \}
.    CHECK_INDENT
.    if \\n[#PRINT_STYLE]=1 \{\
.       TYPEWRITER
.       vs  \\n[#DOC_LEAD]u
.       QUAD   \\*[$SH_QUAD]
.       UNDERLINE OFF
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       FAMILY  \\*[$SH_FAM]
.       FT      \\*[$SH_FT]
.       PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$SH_SIZE_CHANGE]
.       LS      \\n[#DOC_LEAD]u
.       QUAD    \\*[$SH_QUAD]
.    \}
.    if \\n[#PRINT_STYLE]=1 \{ .nr #SH_LEAD_ADJUST \\n[#LEAD]/5 \}
.    if \\n[#PRINT_STYLE]=2 \{ .nr #SH_LEAD_ADJUST \\n[#LEAD]/8 \}
.    ie \\n[#START] \{ .RLD 1v \}
.    el \{\
.       ie ( \\n[#TRAP_DISTANCE] < (\\n[#DOC_LEAD]*(\\n[#NUM_ARGS]+1)) ) \{\
.          ie \\n[#COLUMNS] \{ .COL_NEXT \}
.          el \{ .bp \}
.       \}
.       el \{\
.          ie \\n[#HEAD]=1 \{ . \}
.          el \{\
.             if \\n[#PRINT_STYLE]=1 \{\
.                if !\\n[#LINEBREAK] \{ .ALD \\n[#DOC_LEAD]u \}
.             \}
.             if \\n[#PRINT_STYLE]=2 \{\
.                ie \\n[#PP_SPACE]=1 \{\
.                   ie !\\n[#LINEBREAK] \{ .ALD \\n[#DOC_LEAD]u \}
.                   el \{ .RLD \\n[#DOC_LEAD]u \}
.                \}
.                el \{\
.                   if !\\n[#LINEBREAK] \{ .ALD \\n[#DOC_LEAD]u \}
.                \}
.             \}
.          \}
.       \}
.    \}
.\" Print subhead
.    if \\n[#PRINT_STYLE]=1 \{\
.       while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.          ie \\n[#NUMBER_SH] \{\
.             ie \\n[#ARG_NUM]=0 \{\
.                ie \\n[#NUMBER_HEAD] \{\
.                   br
.                   UNDERSCORE "\v'-\\n[#SH_LEAD_ADJUST]u'\\n[#HEAD_NUM].\\n+[#SH_NUM]\0\\$[\\n+[#ARG_NUM]]
.                   br
.                \}
.                el \{\
.                   br
.                   UNDERSCORE "\v'-\\n[#SH_LEAD_ADJUST]u'\\n+[#SH_NUM].\0\\$[\\n+[#ARG_NUM]]
.                   br
.                \}
.             \}
.             el \{\
.                br
.                ie \\n[#HEAD_UNDERLINE]=0 \{ .PRINT "\v'-\\n[#SH_LEAD_ADJUST]u'\\$[\\n+[#ARG_NUM]]\}
.                el \{ .UNDERSCORE "\v'-\\n[#SH_LEAD_ADJUST]u'\\$[\\n+[#ARG_NUM]]\}
.                br
.             \}
.          \}
.          el \{\
.             br
.             UNDERSCORE "\v'-\\n[#SH_LEAD_ADJUST]u'\\$[\\n+[#ARG_NUM]]
.             br
.          \}
.\}
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#SINGLE_SPACE] \{ .ALD \\n[#DOC_LEAD]u \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#SH_COLOR]=1 \{ .COLOR \\*[$SH_COLOR] \}
.       ie \\n[#PP_SPACE]=0 \{\
.          while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.             ie \\n[#NUMBER_SH] \{\
.                ie \\n[#ARG_NUM]=0 \{\
.                   ie \\n[#NUMBER_HEAD] \{\
.                      br
.                      PRINT "\v'-\\n[#SH_LEAD_ADJUST]u'\\n[#HEAD_NUM].\\n+[#SH_NUM]\0\\$[\\n+[#ARG_NUM]]
.                      br
.                   \}
.                   el \{\
.                      br
.                      PRINT "\v'-\\n[#SH_LEAD_ADJUST]u'\\n+[#SH_NUM].\0\\$[\\n+[#ARG_NUM]]
.                      br
.                   \}
.                \}
.                el \{\
.                   br
.                   PRINT "\\v'-\\n[#SH_LEAD_ADJUST]u'\\$[\\n+[#ARG_NUM]]
.                   br
.                \}
.             \}
.             el \{\
.                br
.                PRINT "\\v'-\\n[#SH_LEAD_ADJUST]u'\\$[\\n+[#ARG_NUM]]
.                br
.             \}
.\}
.       \}
.       el \{\
.          ALD \\n[#DOC_LEAD]u
.          if \\n[#HEAD]=1      \{ .RLD \\n[#DOC_LEAD]u \}
.          if \\n[#END_QUOTE]   \{ .RLD \\n[#DOC_LEAD]u \}
.          if \\n[#EPIGRAPH]    \{ .RLD \\n[#DOC_LEAD]u \}
.          while \\n[#ARG_NUM]<\\n[#NUM_ARGS] \{\
.             PRINT "\\$[\\n+[#ARG_NUM]]
.\}
.          ALD \\n[#DOC_LEAD]u
.       \}
.    \}
.    REMOVE_INDENT
.    ev
.    RESET_PARAHEAD_NUMBER
.    if r#START     \{ .rr #START     \}
.    if r#EPIGRAPH  \{ .rr #EPIGRAPH  \}
.    if r#Q_FITS    \{ .rr #Q_FITS    \}
.    if r#END_QUOTE \{ .rr #END_QUOTE \}
.    if r#LINEBREAK \{ .rr #LINEBREAK \}
.    rm $TOC_SH_ITEM
.    nr #PP 0
.    nr #HEAD 2
.END
\#
\# ---Paragraph heads---
\#
\# PARAHEAD INDENT
\# ---------------
\# *Argument:
\#   <size of indent>
\# *Function:
\#   Creates or modifies register #PH_INDENT.
\# *Notes:
\#   Default is 1/2 #PP_INDENT for TYPESET and TYPEWRITE.
\#
.MAC PARAHEAD_INDENT END
.    nr #PH_INDENT (\\$1)
.END
\#
\#
\# PARAHEAD
\# --------
\# *Arguments:
\#   "<para head>"
\# *Function:
\#   Deposits a paragraph head at the start and into the body of a
\#   paragraph.
\# *Notes:
\#   PARAHEAD *must* come after PP.
\#
.MAC PARAHEAD END
.\" Collect parahead for TOC.
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    ie \\n[#NUMBER_PH] \{\
.       ds $TOC_PH_ITEM \\n+[#PH_NUM].\0\\$1\\|
.       nr #PH_NUM \\n-[#PH_NUM]
.    \}
.    el \{\
.       ds $TOC_PH_ITEM \\$1\\|
.    \}
.    ev TOC_EV
.    da TOC_ENTRIES
.    if \\n[#PRINT_STYLE]=1 \{\
\!.       fam C
\!.       ft  R
\!.       ps  12
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_PH_FAM]
\!.     FT      \\*[$TOC_PH_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PH_SIZE_CHANGE]
.    \}
\!.  TRAP OFF
.    ie \\n[#PRINT_STYLE]=1 \{\
\!.     PAD "\\h'6m'\\*[$TOC_PH_ITEM]\\*[$TOC_PN_TYPEWRITE]" 
.    \}
.    el \{\
\!.     PAD "\\h'\\n[#TOC_PH_INDENT]u'\\*[$TOC_PH_ITEM]\\*[$TOC_PN]"
.    \}
\!.  EOL
\!.  ST 100 L
\!.  ST 101 R
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_PN_FAM]
\!.     FT      \\*[$TOC_PN_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.    \}
\!.  TAB 100
\!.  PRINT \\*[LEADER]
\!.  TN
\!.  TRAP
\!.  PRINT \\n[#TOC_ENTRY_PN]
\!.  TQ
.    di       
.    ev
.\" End collection of parahead for TOC
.\" Process parahead
.    if \\n[#SLANT_ON] \{\
.       nr #SLANT_WAS_ON 1
\E*[SLANTX]
.    \}
.    ie \\n[#PP]=1 \{\
.       if \\n[#INDENT_FIRST_PARAS] \{\
.          ti \\n[#PH_INDENT]u
.       \}
.    \}
.    el \{ .ti \\n[#PH_INDENT]u \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       TYPEWRITER
.       UNDERLINE OFF
.       ie \\n[#NUMBER_PH] \{\
.          if \\n[#NUMBER_HEAD] \{\
.             ie \\n[#NUMBER_SH] \{\
.                UNDERSCORE "\R'#NUMBERED 1'\\n[#HEAD_NUM].\\n[#SH_NUM].\\n+[#PH_NUM].\\ \\$1"
\0
.             \}
.             el \{\
.                UNDERSCORE "\R'#NUMBERED 1'\\n[#HEAD_NUM].\\n+[#PH_NUM].\\ \\$1
\0
.             \}
.          \}
.          ie \\n[#NUMBER_SH] \{\
.             if !\\n[#NUMBERED] \{\
.                UNDERSCORE "\\n[#SH_NUM].\\n+[#PH_NUM].\\ \\$1
\0
.             \}
.          \}
.          el \{\
.             if !\\n[#NUMBERED] \{\
.                UNDERSCORE "\\n+[#PH_NUM].\\ \\$1
\0
.             \}
.          \}
.       \}
.       el \{\
.          UNDERSCORE "\\$1
\0
.       \}
.       if \\n[#SLANT_WAS_ON] \{\
.          if \\n[#UNDERLINE_SLANT] \{ .UNDERLINE \}
.          if \\n[#SLANT_MEANS_SLANT] \{\
\E*[SLANT]\c
.          \}
.          rr #SLANT_WAS_ON
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       FAM     \\*[$PH_FAM]
.       FT      \\*[$PH_FT]
.       PT_SIZE \\*[$PH_SIZE_CHANGE]
.       if \\n[#PH_COLOR]=1 \{ .COLOR \\*[$PH_COLOR] \}
.          ie \\n[#NUMBER_PH] \{\
.             if \\n[#NUMBER_HEAD] \{\
.                ie \\n[#NUMBER_SH] \{\
.                   PRINT "\R'#NUMBERED 1'\\n[#HEAD_NUM].\\n[#SH_NUM].\\n+[#PH_NUM].\0\\$1\h'.6m'\c"
.                \}
.                el \{\
.                   PRINT "\R'#NUMBERED 1'\\n[#HEAD_NUM].\\n+[#PH_NUM].\0\\$1\h'.6m'\c"
.                \}
.             \}
.             ie \\n[#NUMBER_SH] \{\
.                if !\\n[#NUMBERED] \{\
.                   PRINT "\\n[#SH_NUM].\\n+[#PH_NUM].\0\\$1\h'.6m'\c"
.                \}
.             \}
.             el \{\
.                if !\\n[#NUMBERED] \{\
.                   PRINT "\\n+[#PH_NUM].\0\\$1\h'.6m'\c"
.                \}
.             \}
.          \}
.          el \{\
.             PRINT "\\$1\h'.6m'\c"
.          \}
.       \}
.    FAMILY  \\*[$DOC_FAM]
.    FT      \\*[$PP_FT]
.    PT_SIZE \\n[#DOC_PT_SIZE]u
.    if \\n[#PH_COLOR]=1 \m[]\c
.    if \\n[#SLANT_WAS_ON] \{\
.       rr #SLANT_WAS_ON
\E*[SLANT]\c
.    \}
.    rr #NUMBERED
.    rm $TOC_PH_ITEM
.END
\#
\#
\# ====================================================================
\#
\# +++LINE BREAKS+++
\#
\# LINEBREAK CHARACTER
\# -------------------
\# *Arguments:
\#   [character] [iterations] [vertical adjustment]
\# *Function:
\#   Allows user to specify a line break character and the number
\#   of times to repeat it horiontally.
\# *Notes:
\#   Without an argument, LINEBREAK_CHAR will deposit a blank line.
\#
\#   Vertical adjustment requires a unit of measure (most likely
\#   "p"), and has to be preceded by +|-
\#
.MAC LINEBREAK_CHAR END
.    nr #REPEAT 1
.    ds $LINEBREAK_CHAR \\$1
.    ds $LINEBREAK_CHAR_V_ADJ \\$3
.    if '\\*[$LINEBREAK_CHAR_V_ADJ]'' \{\
.       ds $LINEBREAK_CHAR_V_ADJ +0
.    \}
.    while \\$2>\\n[#REPEAT] \{\
.       as $LINEBREAK_CHAR "\\ \\$1
.       nr #REPEAT \\n[#REPEAT]+1
.\}
.   rr #REPEAT
.END
\#
\#
\# LINE BREAK
\# ----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Deposits line break character.
\# *Notes:
\#   If $LINEBREAK_CHAR is blank, simply advances 2 line spaces.
\#
.MAC LINEBREAK END
.    if r#Q_AT_TOP \{ .rr #Q_AT_TOP \}
.    po \\n[#DOC_L_MARGIN]u
.    ie  '\\*[$LINEBREAK_CHAR]'' \{ .ALD \\n[#DOC_LEAD]u*2 \}
.    el \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          ie \\n[#END_QUOTE] \{ . \}
.          el \{ .ALD \\n[#DOC_LEAD]u \}
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          ie \\n[#END_QUOTE] \{ . \}
.          el \{ .ALD \\n[#DOC_LEAD]u \}
.       \}
.       ev LINEBREAK
.       evc 0
.       CENTER
.       PRINT \m[\\*[$LINEBREAK_COLOR]]\\v'\\*[$LINEBREAK_CHAR_V_ADJ]'\\*[$LINEBREAK_CHAR]\\v'\\*[$LINEBREAK_CHAR_V_ADJ]'\m[]
.       if \\n[#PRINT_STYLE]=1 \{ .ALD \\n[#DOC_LEAD]u \}
.       if \\n[#PRINT_STYLE]=2 \{ .ALD \\n[#DOC_LEAD]u \}
.       ev
.       QUAD \\*[$DOC_QUAD]
.    \}
.    nr #LINEBREAK 1
.    if r#QUOTE     \{ .rr #QUOTE     \}
.    if r#END_QUOTE \{ .rr #END_QUOTE \}
.    nr #PP 0
.END
\#
\# ====================================================================
\#
\# +++PARAGRAPHS+++
\#
\# PARAGRAPH FONT
\# --------------
\# *Argument:
\#   <font of running text>
\# *Function:
\#   Creates or modifies string $PP_FT.
\# *Notes:
\#   Affects all paragraphs.
\#
.MAC PP_FONT END
.    if \\n[#IGNORE] \{ .return \}
.    br
.    ds $PP_FT \\$1
.    FT \\*[$PP_FT]
.END
\#
\#
\# PARAGRAPH INDENT
\# ----------------
\# *Argument:
\#   <amount to indent paragraphs in running text (ipPcm)>
\# *Function:
\#   Allows user to change the default para indent.  The change will
\#   affect the indent of QUOTEs and BLOCKQUOTEs as well.
\# *Notes:
\#   Default for printstyle TYPEWRITE is 1/2-inch.  Default for
\#   printstyle TYPESET is 2 ems.  The defaults are set in
\#   PRINTSTYLE, not DEFAULTS.
\#
.MAC PARA_INDENT END
.    nr #PP_INDENT (\\$1)
.END
\#
\#
\# INDENT FIRST PARAGRAPHS
\# -----------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   By default, the first para of a document, as well as the first
\#   paras of blockquotes and block-style epigraphs are not indented.
\#   When invoked, this macro will indent all paras.
\# *Notes:
\#   Default is OFF.
\#
.MAC INDENT_FIRST_PARAS END
.    ie '\\$1'' \{ .nr #INDENT_FIRST_PARAS 1 \}
.    el \{ .rr #INDENT_FIRST_PARAS   \}
.END
\#
\#
\# INTER-PARAGRAPH SPACING
\# -----------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Adds a line space between paragraphs in body text.  Block quotes
\#   are unaffected.
\# *Notes:
\#   Default is OFF.  PARA_SPACE ON is not recommended for use
\#   with PRINTSTYLE TYPEWRITE.
\#
.MAC PARA_SPACE END
.    ie '\\$1'' \{ .nr #PP_SPACE 1 \}
.    el \{ .rr #PP_SPACE   \}
.END
\#
\#
\# PARAGRAPH
\# ---------
\# *Arguments:
\#   <none>
\# *Function:
\#   Figures out what to do with paragraphs under differing conditions.
\# *Notes:
\#   For the time being, there's no automatic widow/orphan control.
\#   Controlling them isn't just a matter of establishing an arbitrary
\#   number of lines needed for a para, since groff doesn't then
\#   handle single line paragraphs gracefully.  Usually, the whole
\#   page needs to be tweaked.
\#
\#   Note the use of transparent line break (\!.br) to get
\#   PP to work within blockquotes and epigraphs.
\#
\#   PP_STYLE 1 = regular paras; 2 = blockquotes, epigraphs
\#
.MAC PP END
.    br
.    if \\n[#DOC_TYPE]=4 \{\
.       if !'\\n(.z'' \{ .di \}
.       nr #TOTAL_FIELDS \\n[#FIELD]
.       nr #FIELD        0 1
.       nr #NUM_FIELDS   0 1
.       if \\n[#TOTAL_FIELDS]>0 \{\
.          while \\n+[#NUM_FIELDS]<=\\n[#TOTAL_FIELDS] \{\
.             nf
.             LETTERHEAD\\n+[#FIELD]
.             QUAD \\*[$DOC_QUAD]
.             ALD \\n[#DOC_LEAD]u
.             if \\n[#DATE_FIRST]=1 \{ .ALD \\n[#DOC_LEAD]u \}
.             rr #DATE_FIRST
.             rm LETTERHEAD\\n[#FIELD]
.\}
.          rr #FIELD
.          rr #NUM_FIELDS
.          rr #TOTAL_FIELDS
.       \}
.    \}
.    rr #PP_ACTIVE
.    if r#Q_AT_TOP \{ .rr #Q_AT_TOP \}
.    if \\n[#PP_STYLE]=1 \{\
.       if \\n[#ENDNOTE] \{\
.          nr #RESET_PARA_SPACE \\n[#PP_SPACE]
.          ie \\n[#EN_PP_SPACE] \{ .PARA_SPACE \}
.          el \{ .PARA_SPACE OFF \}
.       \}
.       br
.       if !\\n[#ENDNOTE] \{ .po \\n[#L_MARGIN]u \}
.       if \\n[#COLUMNS] \{\
.          if !\\n[#ENDNOTE] \{\
.             po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.             nr #L_MARGIN \\n(.o
.          \}
.       \}
.       if \\n[#TAB_ACTIVE] \{ .TAB \\n[#CURRENT_TAB] \}
.       ie \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          ie \\n[#ENDNOTE] \{ .vs \\n[#EN_LEAD]u \}
.          el \{ .vs \\n[#DOC_LEAD]u \}
.          QUAD \\*[$DOC_QUAD]
.          UNDERLINE OFF
.          if \\n[#SLANT_ON] \{\
.             if \\n[#UNDERLINE_SLANT] \{ .UNDERLINE \}
.          \}
.       \}
.       el \{\
.          ie \\n[#ENDNOTE] \{\
.             FAMILY  \\*[$EN_FAM]
.             FT      \\*[$EN_FT]
.             PT_SIZE \\n[#EN_PS]u
.             vs      \\n[#EN_LEAD]u
.             QUAD    \\*[$EN_QUAD]
.          \}
.          el \{\
.             FAMILY  \\*[$DOC_FAM]
.             FT      \\*[$PP_FT]
.             PT_SIZE \\n[#DOC_PT_SIZE]u
.             LS      \\n[#DOC_LEAD]u
.             QUAD    \\*[$DOC_QUAD]
.          \}
.       \}
.       ie \\n[#PP]=0 \{\
.          if \\n[#INDENT_FIRST_PARAS] \{\
.             ie \\n[#INDENT_ACTIVE] \{ .ti \\n[#INDENT]u+\\n[#PP_INDENT]u \}
.             el \{ .ti \\n[#PP_INDENT]u \}
.             if '\\n(.z'END_NOTES' \{\
.                ti \\n[#EN_PP_INDENT]u+\\n[#EN_TEXT_INDENT]u
.             \}
.          \}
.          if r#END_QUOTE \{\
.             if \\n[#END_QUOTE] \{\
.                if !\\n[#LINEBREAK] \{\
.                   ie \\n[#INDENT_ACTIVE] \{ .ti \\n[#INDENT]u+\\n[#PP_INDENT]u \}
.                   el \{ .ti \\n[#PP_INDENT]u \}
.                   if '\\n(.z'END_NOTES' \{\
.                      ti \\n[#EN_PP_INDENT]u+\\n[#EN_TEXT_INDENT]u
.                   \}
.                \}
.             \}
.          \}
.       \}
.       el \{\
.          br
.          if \\n[#PP_SPACE] \{\
.             if \\n[#PRINT_STYLE]=2 \{\
.                ie \\n[#END_QUOTE] \{\
.                   ALD \\n[#DOC_LEAD]u
.                   rr #END_QUOTE
.                   nr #NO_SPACE 1
.                   nr #BASELINE_MARK \\n(nl
.                \}
.                el \{\
.                   if \\n[#NO_SPACE]=1 \{\
.                      rr #NO_SPACE
.                   \}
.                   if !\\n(nl=\\n[#BASELINE_MARK] \{\
.                      ALD \\n[#DOC_LEAD]u
.                      rr #BASELINE_MARK
.                   \}
.                \}
.             \}
.          \}
.          ie \\n[#INDENT_ACTIVE] \{ .ti \\n[#INDENT]u+\\n[#PP_INDENT]u \}
.          el \{ .ti \\n[#PP_INDENT]u \}
.          if '\\n(.z'END_NOTES' \{\
.             ti \\n[#EN_PP_INDENT]u+\\n[#EN_TEXT_INDENT]u
.          \}
.       \}
.       if r#START     \{ .rr #START     \}
.       if r#QUOTE     \{ .rr #QUOTE     \}
.       if r#END_QUOTE \{ .rr #END_QUOTE \}
.       if r#HEAD      \{ .rr #HEAD      \}
.       if r#EPIGRAPH  \{ .rr #EPIGRAPH  \}
.       if r#Q_FITS    \{ .rr #Q_FITS    \}
.       if r#LINEBREAK \{ .rr #LINEBREAK \}
.       if \\n[#ENDNOTE] \{\
.          ie \\n[#RESET_PARA_SPACE] \{ .PARA_SPACE \}
.          el \{ .PARA_SPACE OFF \}
.       \}
.       if \\n[#CONDENSE] \{\
\E*[COND]\c
.       \}
.       if \\n[#EXTEND]=1 \{\
\E*[EXT]\c
.       \}
.       nr #PP +1
.    \}
.    if \\n[#PP_STYLE]=2 \{\
\!.     br
.       if \\n[#BROKEN_QUOTE] \{\
.          ie \\n(nl=\\n[#PAGE_TOP] \{ .nr #Q_PP 1 \}
.          el \{ .nr #Q_PP 0 \}
.          rr #BROKEN_QUOTE
.       \}
.       ie \\n[#Q_PP]=0 \{\
.          if \\n[#INDENT_FIRST_PARAS] \{\
.             ti \\n[#PP_INDENT]u/2u
.          \}
.          if \\n[#ENDNOTE] \{\
.             ie \\n[#INDENT_FIRSTS] \{ .ti \\n[#PP_INDENT]u/2u \}
.             el \{ .ti 0 \}
.          \}
.       \}
.       el \{\
.          ti \\n[#PP_INDENT]u/2u
.       \}
.       if \\n[#CONDENSE] \{\
\E*[COND]\c
.       \}
.       if \\n[#EXTEND]=1 \{\
\E*[EXT]\c
.       \}
.    nr #Q_PP +1
.    \}
.    nr #PP_ACTIVE 1
.END
\#
\# ====================================================================
\#
\# +++QUOTES+++
\#
\# ---Line for line quotes, i.e. poetry or code snippets---
\#
\# UNDERLINE QUOTES
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #UNDERLINE_QUOTES (toggle).
\#   If on, line for line quotes are underlined when printstyle
\#   is TYPEWRITE.
\# *Notes:
\#   Default is ON for printstyle TYPEWRITE.
\#
.MAC UNDERLINE_QUOTES END
.    ie '\\$1'' \{ .nr #UNDERLINE_QUOTES 1 \}
.    el \{ .rr #UNDERLINE_QUOTES   \}
.END
\#
\#
\# QUOTE INDENT
\# ------------
\# *Argument:
\#   <value by which to multiply PP_INDENT for indented quoted text>
\# *Function:
\#   Creates or modifies register #Q_OFFSET_VALUE.
\# *Notes:
\#   Default is 3 for typeset; 2 for typewrite
\#
.MAC QUOTE_INDENT END
.    nr #Q_OFFSET_VALUE \\$1
.END
\#
\#
\# QUOTE_AUTOLEAD
\# --------------
\# *Arguments:
\#   <autolead value>
\# *Function:
\#   Sets autolead for quotes and/or blockquotes.
\#
.MAC QUOTE_AUTOLEAD END
.    if '\\$0'QUOTE_AUTOLEAD'      \{ .nr #Q_AUTOLEAD \\$1 \}
.    if '\\$0'BLOCKQUOTE_AUTOLEAD' \{ .nr #BQ_AUTOLEAD \\$1 \}
.    if '\\$0'ENDNOTE_QUOTE_AUTOLEAD'      \{ .nr #EN_Q_AUTOLEAD \\$1 \}
.    if '\\$0'ENDNOTE_BLOCKQUOTE_AUTOLEAD' \{ .nr #EN_BQ_AUTOLEAD \\$1 \}
.END
\#
.ALIAS BLOCKQUOTE_AUTOLEAD         QUOTE_AUTOLEAD
.ALIAS ENDNOTE_QUOTE_AUTOLEAD      QUOTE_AUTOLEAD
.ALIAS ENDNOTE_BLOCKQUOTE_AUTOLEAD QUOTE_AUTOLEAD
\#
\# ALWAYS FULLSPACE QUOTES
\# -----------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles register #FULLSPACE_QUOTES.
\# *Notes:
\#   If user doesn't like the default 1/2 line space above and below
\#   quotes, s/he can turn it off here.  Has no effect in TYPEWRITE.
\#
.MAC ALWAYS_FULLSPACE_QUOTES END
.    if '\\$1'' \{ .nr #FULLSPACE_QUOTES 1 \}
.    el \{ .rr #FULLSPACE_QUOTES \}
.END
\#
\#
\# QUOTE
\# -----
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Indents quoted text on a line for line basis, or turns QUOTE off.
\# *Notes:
\#   Owing to the need to bottom align TYPESET pages, quoted text gets
\#   diverted so its depth can be measured (in DO_QUOTE) for determining
\#   how much space to put before and after.
\#
.MAC QUOTE END
.    br
.    if \\n[#LINENUMBERS]=1 \{\
.       nr #LINENUMBERS 2
.       nr #NEXT_LN \\n(ln
.       nm
.    \}
.    ie '\\$1'' \{\
.       ev QUOTE
.       if \\n[#LINENUMBERS]=2 \{\
.          if \\n[#SILENT_QUOTE_LN]=1 \{ .nm \\n[#NEXT_LN] 1000 -4 \}
.       \}
.       nr #IN_DIVER 1
.       nr #QUOTE 1
.       di P_QUOTE
.       ll \\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u)
.       if \\n[#LINENUMBERS]=2 \{\
.          if \\n[#QUOTE_LN]=1 \{\
.             nm \\n(ln "" \\*[$Q_LN_GUTTER] -3-\\*[$Q_LN_GUTTER]
.          \}
.       \}
.       ta \\n(.lu
.       if \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u-(\\n[#PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u)
.          ta \\n(.lu
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          vs \\n[#DOC_LEAD]u
.          LEFT
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$QUOTE_FAM]
.          FT      \\*[$QUOTE_FT]
.          PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$QUOTE_SIZE_CHANGE]
.          ie !r#Q_AUTOLEAD  \{ .LS \\n[#Q_LEAD]u \}
.          el \{\
.             AUTOLEAD \\n[#Q_AUTOLEAD]
.             nr #Q_LEAD \\n(.v
.          \}
.          if \\n[#ENDNOTE] \{\
.             PT_SIZE \\n[#EN_PS]u\\*[$QUOTE_SIZE_CHANGE]
.             ie !r#EN_Q_AUTOLEAD  \{ .LS \\n[#EN_Q_LEAD]u \}
.             el \{\
.                AUTOLEAD \\n[#EN_Q_AUTOLEAD]
.                nr #EN_Q_LEAD \\n(.v
.             \}
.          \}
.          nr #Q_LEAD_REAL \\n(.v
.          LEFT
.          if \\n[#QUOTE_COLOR]=1 \{\
.             nf
\m[\\*[$QUOTE_COLOR]]
.             EOL
.          \}
.       \}
.       if \\n[#LINENUMBERS]=2 \{\
.          ie \\n[#QUOTE_LN]=1 \{\
.             if '\\*[$Q_LN_GUTTER]'' .ds $Q_LN_GUTTER \\*[$LN_GUTTER]
.             nm \\n(ln "" \\*[$Q_LN_GUTTER] -3-\\*[$Q_LN_GUTTER]
.          \}
.          el \{\
.             if !\\n[#SILENT_QUOTE_LN] \{ .NUMBER_LINES OFF \}
.          \}
.       \}
.       nr #Q_TOP \\n(nl
.       if \\n[#PRINT_STYLE]=1 \{\
.          if \\n[#UNDERLINE_QUOTES] \{\
.               FT I
.          \}
.       \}
.    \}
.    el \{ .DO_QUOTE \}
.END
\#
\# ---Blockquotes---
\#
\# BLOCKQUOTE
\# ----------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Indents quoted text in fill mode and shortens line length
\#   equivalently, or turns BLOCKQUOTE off.
\# *Notes:
\#   Owing to the need to bottom align TYPESET pages, quoted text gets
\#   diverted so its depth can be measured (in DO_QUOTE) for determining
\#   how much space to put before and after.
\#
\#   .PP after blockquote is optional if there's only one para,
\#   but REQUIRED if there's more than one.
\#
.MAC BLOCKQUOTE END
.    br
.    if \\n[#LINENUMBERS]=1 \{\
.       nr #LINENUMBERS 2
.       nr #NEXT_LN \\n(ln
.       nm
.    \}
.    ie '\\$1'' \{\
.       ev BLOCKQUOTE
.       if \\n[#LINENUMBERS]=2 \{\
.          if \\n[#SILENT_BQUOTE_LN]=1 \{ .nm \\n[#NEXT_LN] 1000 -4 \}
.       \}
.       nr #IN_DIVER 1
.       nr #QUOTE    2
.       nr #PP_STYLE 2
.       nr #Q_PP     0
.       di B_QUOTE
.       ll \\n[#L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.       if \\n[#ENDNOTE] \{\
.          if \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.             ll \\n[#RESET_L_LENGTH]u-\\n[#EN_TEXT_INDENT]u-(\\n[#EN_PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.          \}
.          if \\n[#EN_NUMBERS_ALIGN_LEFT] \{\
.             ll \\n[#L_LENGTH]u-(\\n[#EN_PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.          \}
.       \}
.       ta \\n(.lu
.       CHECK_INDENT
.       if \\n[#COLUMNS] \{\
.          ll \\n[#COL_L_LENGTH]u-(\\n[#PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.          if \\n[#ENDNOTE] \{\
.             if \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.                ll \\n[#RESET_L_LENGTH]u-\\n[#EN_TEXT_INDENT]u-(\\n[#EN_PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.             \}
.             if \\n[#EN_NUMBERS_ALIGN_LEFT] \{\
.                ll \\n[#COL_L_LENGTH]u-(\\n[#EN_PP_INDENT]u*(\\n[#Q_OFFSET_VALUE]u*2u))
.             \}
.          \}
.          ta \\n(.lu
.       \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          vs \\n[#DOC_LEAD]u
.          QUAD LEFT
.          HY OFF
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$BQUOTE_FAM]
.          FT      \\*[$BQUOTE_FT]
.          PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$BQUOTE_SIZE_CHANGE]
.          ie !\\n[#BQ_AUTOLEAD] \{ .LS \\n[#BQ_LEAD]u \}
.          el \{\
.             AUTOLEAD \\n[#BQ_AUTOLEAD]
.             nr #BQ_LEAD \\n(.v
.          \}
.          if \\n[#ENDNOTE] \{\
.             PT_SIZE \\n[#EN_PS]u\\*[$BQUOTE_SIZE_CHANGE]
.             ie !r#EN_BQ_AUTOLEAD  \{ .LS \\n[#EN_BQ_LEAD]u \}
.             el \{\
.                AUTOLEAD \\n[#EN_BQ_AUTOLEAD]
.                nr #EN_BQ_LEAD \\n(.v
.             \}
.          \}
.          nr #Q_LEAD_REAL \\n(.v
.          if \\n[#BQUOTE_COLOR]=1 \{\
.             nf
\m[\\*[$BQUOTE_COLOR]]
.             EOL
.          \}
.          QUAD \\*[$BQUOTE_QUAD]
.          nr #DIVERSIONS_HY_MARGIN (p;\\n[.ps]u*2.75)/1000
.          HY_SET 1 \\n[#DIVERSIONS_HY_MARGIN]u (\\n[#PT_SIZE]u/1000u/8u)p
.          hy 14
.       \}
.       if \\n[#LINENUMBERS]=2 \{\
.          ie \\n[#BQUOTE_LN]=1 \{\
.             if '\\*[$BQ_LN_GUTTER]'' .ds $BQ_LN_GUTTER \\*[$LN_GUTTER]
.             nm \\n(ln "" \\*[$BQ_LN_GUTTER] -3-\\*[$BQ_LN_GUTTER]
.          \}
.          el \{\
.             if !\\n[#SILENT_BQUOTE_LN] \{ .NUMBER_LINES OFF \}
.          \}
.       \}
.       nr #Q_TOP \\n(nl
.       if \\n[#INDENT_FIRST_PARAS] \{\
.          ie !\\n[#ENDNOTE] \{\
.             if \\n[#PRINT_STYLE]=1 \{ .ti \\n[#PP_INDENT]u/2u \}
.             if \\n[#PRINT_STYLE]=2 \{ .ti \\n[#PP_INDENT]u/2u \}
.          \}
.          el \{\
.             if \\n[#INDENT_FIRSTS]=1 \{\
.                if \\n[#PRINT_STYLE]=1 \{ .ti \\n[#EN_PP_INDENT]u/2u \}
.                if \\n[#PRINT_STYLE]=2 \{ .ti \\n[#EN_PP_INDENT]u/2u \}
.             \}
.          \}
.       \}
.    \}
.    el \{ .DO_QUOTE \}
.END
\#
\#
\# DO QUOTE
\# --------
\# *Arguments:
\#   <none>
\# *Function:
\#   Ends the diversion P_QUOTE or B_QUOTE.  Spaces them according to
\#   PRINTSTYLE, whether there's inter-paragraph spacing, and page
\#   position.  TYPEWRITE treats spacing the same way in all circumstance
\#   (viz. an extra line space).  TYPESET puts in only half
\#   line spaces if the entire quote plus 1 line of body under the quote
\#   fits on the the page; otherwise it puts in a full extra blank
\#   line.  (This is to ensure the page remains bottom aligned).
\#
.MAC DO_QUOTE END
.    br
.    if \\n[#DIVER_LN_OFF] \{\
\!.     NUMBER_LINES OFF
.       rr #DIVER_LN_OFF
.    \}
.    di
.    rr #IN_DIVER
.    if \\n[#RESET_FN_COUNTERS]=2 \{\
.       if !\\n[#FN_COUNT]=1 \{\
.          if ((\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS])+\\n[#DIVER_DEPTH])>(\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS]) \{\
.             DIVER_FN_2_POST
.             rr #RESET_FN_COUNTERS
.          \}
.       \}
.    \}
.    nr #SAVED_FN_NUMBER \\n[#FN_NUMBER]
.    nr #DONE_ONCE 0 1
.    REMOVE_INDENT
.    ev
.    nr #Q_DEPTH (\\n[#DIVER_DEPTH]-\\n[#Q_LEAD_REAL])+\\n[#LEAD]
.    nr #Q_LEAD_DIFF \\n[#LEAD]-\\n[#Q_LEAD_REAL]
.    SILENT
.    br
.    nf
.    nr #CURRENT_V_POS \\n(nl+\\n[#Q_LEAD_DIFF]+(\\n[#DIVER_DEPTH]-\\n[#Q_DEPTH_REAL])
.    SHIM
.    SILENT OFF
.    nr #Q_SPACE_ADJ \\n[#SHIM]/2
.    nr #TRAP \\n(.t-1
.    if \\n[#ENDNOTE] \{\
.       nr #RESET_QUOTE_SPACING \\n[#FULLSPACE_QUOTES]
.       ALWAYS_FULLSPACE_QUOTES
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#START]=1 \{ . \}
.       if \\n[#START]=0 \{\
.          if !\\n[#LINEBREAK] \{ .ALD \\n[#DOC_LEAD]u \}
.       \}
.       if \\n[#HEAD] \{\
.          if \\n[#HEAD]=1 \{ .RLD \\n[#DOC_LEAD]u \}
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#PP_SPACE] \{\
.          ie \\n[#HEAD]>0 \{ . \}
.          el \{\
.             ie \\n[#START] \{ . \}
.             el \{ .ALD \\n[#DOC_LEAD]u \}
.          \}
.       \}
.       el \{\
.          ie \\n[#Q_DEPTH]<(\\n[#TRAP_DISTANCE]-1) \{\
.             ie (\\n[#TRAP_DISTANCE]-1)-\\n[#Q_DEPTH]<\\n[#DOC_LEAD] \{\
.                Q_NOFIT
.             \}
.             el \{\
.                Q_FITS
.             \}
.          \}
.          el \{\
.             Q_NOFIT
.          \}
.       \}
.    \}
.    nr #Q_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.    if \\n[#COLUMNS] \{\
.       nr #Q_OFFSET \\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.    \}
.    if !\\n[#ENDNOTE] \{ .po \\n[#Q_OFFSET]u \}
.    if \\n[#ENDNOTE] \{\
.       in +\\n[#EN_PP_INDENT]u*\\n[#Q_OFFSET_VALUE]u
.    \}
.    ie \\n[#START]=1 \{\
.       ie !\\n[#Q_LEAD_DIFF]<0 \{ .ALD \\n[#Q_SPACE_ADJ]u \}
.       el \{ .RLD 0-\\n[#Q_LEAD_DIFF]u \}
.    \}
.    el \{\
.       ALD \\n[#Q_SPACE_ADJ]u
.    \}
.    if \\n[#QUOTE]=1 \{\
.       nf
.       P_QUOTE
.       if !\\n[#START] \{ .rr #QUOTE \}
.    \}
.    if \\n[#QUOTE]=2 \{\
.       nf
.       B_QUOTE
.    \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       ALD \\n[#DOC_LEAD]u
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#START] \{\
.          ie \\n[#PP_SPACE] \{\
.
.          \}
.          el \{\
.             ALD \\n[#DOC_LEAD]u
.             SHIM
.          \}
.       \}
.       el \{\
.          ie \\n[#PP_SPACE] \{ . \}
.          el \{\
.             ie \\n[#HEAD]=1 \{\
.                ALD \\n[#DOC_LEAD]u
.                SHIM
.             \}
.             el \{\
.                ie \\n[#FULLSPACE_QUOTES] \{\
.                   ie \\n[#ENDNOTE] \{ .ALD \\n[#EN_LEAD]u \}
.                   el \{ .ALD \\n[#DOC_LEAD]u \}
.                \}
.                el \{ .ALD (\\n[#DOC_LEAD]u/2u) \}
.                ie \\n[#Q_FITS] \{\
.                   ie \\n[#Q_TOP]=\\n[#PAGE_TOP] \{\
.                      nr #Q_AT_TOP 1
.                      nr #DELAY_SHIM 1
.                   \}
.                   el \{ .SHIM \}
.                \}
.                el \{\
.                   SHIM
.\" Make sure that Q_LEAD_DIFF is not added to the first line of
.\" normal text at the top of any page following output of a quote
.\" whose last line falls on B_MARGIN of the previous page.
.                   if \\n(nl=(\\n[#T_MARGIN]-\\n[#DOC_LEAD]+\\n[#Q_LEAD_DIFF]) \{\
.                      PRINT \&
.                      br
.                      sp -1v-\\n[#Q_LEAD_DIFF]u
.                   \}
.                \}
.             \}
.          \}
.       \}
.    \}
.    if \\n[#LINENUMBERS]=2 \{\
.       nr #LINENUMBERS 1
.       ie \\n[#RESTORE_LN_NUM]=1 \{ .nm \\n[#NEXT_LN] \}
.       el \{ .nm +0 \}
.    \}
.    if \\n[#ENDNOTE] \{ .nr #FULLSPACE_QUOTES \\n[#RESET_QUOTE_SPACING] \}
.    if r#HEAD        \{ .rr #HEAD     \}
.    if r#EPIGRAPH    \{ .rr #EPIGRAPH \}
.    rr #Q_PP
.    rr #LINEBREAK
.    nr #PP_STYLE  1
.    nr #END_QUOTE 1
.    if !\\n[#ENDNOTE] \{ .po \\n[#L_MARGIN]u \}
.    if \\n[#ENDNOTE] \{\
.       in \\n[#EN_TEXT_INDENT]u
.    \}
.    if \\n[#COLUMNS] \{\
.       if !\\n[#ENDNOTE] \{\
.          po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.          nr #L_MARGIN \\n(.o
.       \}
.       if \\n[#ENDNOTE] \{\
.          in \\n[#EN_TEXT_INDENT]u
.       \}
.    \}
.    ie !\\n[#ENDNOTE] \{\
.       nr #RESET_PP_INDENT \\n[#PP_INDENT]
.       PARA_INDENT 0
.       PP
.       PARA_INDENT \\n[#RESET_PP_INDENT]u
.       QUAD \\*[$DOC_QUAD]
.    \}
.    el \{\
.       nr #RESET_EN_PP_INDENT \\n[#EN_PP_INDENT]
.       ENDNOTE_PARA_INDENT 0
.       PP
.       ENDNOTE_PARA_INDENT \\n[#RESET_EN_PP_INDENT]u
.       QUAD \\*[EN_QUAD]
.    \}
.    if r#DELAY_SHIM \{\
.       SHIM
.       rr #DELAY_SHIM
.    \}
.END
\#
\#
\# Utility macros for DO_QUOTE
\# ---------------------------
\#
.MAC Q_FITS END
.    nr #Q_FITS 1
.    ie \\n[#HEAD]=1 \{\
.       ALD \\n[#Q_LEAD_DIFF]u
.    \}
.    el \{\
.       ie \\n[#START] \{ . \}
.       el \{\
.          ie \\n[#FULLSPACE_QUOTES] \{\
.             ie \\n[#ENDNOTE] \{ .ALD \\n[#EN_LEAD]u+\\n[#Q_LEAD_DIFF]u \}
.             el \{ .ALD \\n[#DOC_LEAD]u+\\n[#Q_LEAD_DIFF]u \}
.          \}
.          el \{\
.\" This seems to be the only way to get the baseline of quotes that start
.\" at the top of the page to fall on the first line of the "grid" (i.e on
.\" the first legal baseline of the page).
.             ie \\n[#Q_TOP]=\\n[#PAGE_TOP] \{\
.                if \\n[#QUOTE]=1 \{\
.                   rn P_QUOTE Q_TEMP
.                   di P_QUOTE
.                   vs \\n[#Q_LEAD]u
.                   PRINT \&
.                   sp -1v+\\n[#Q_LEAD_DIFF]u
.                   Q_TEMP
.                   di
.                \}
.                if \\n[#QUOTE]=2 \{\
.                   rn B_QUOTE Q_TEMP
.                   di B_QUOTE
.                   vs \\n[#BQ_LEAD]u
.                   PRINT \&
.                   sp -1v+\\n[#Q_LEAD_DIFF]u
.                   Q_TEMP
.                   di
.                \}
.                rm Q_TEMP
.             \}
.             el \{\
.                ALD (\\n[#DOC_LEAD]u/2u)+\\n[#Q_LEAD_DIFF]u
.             \}
.          \}
.       \}
.       if \\n[#DIVER_FN]=2 \{ .rr #DIVER_FN \}
.    \}
.END
\#
.MAC Q_NOFIT END
.    rr #Q_FITS
.    ie r#HEAD \{\
.       if \\n[#HEAD]=1 \{ . \}
.    \}
.    el \{\
.       ie \\n[#FULLSPACE_QUOTES] \{\
.          ie \\n[#ENDNOTE] \{ .ALD \\n[#EN_LEAD]u+\\n[#Q_LEAD_DIFF]u \}
.          el \{ .ALD \\n[#DOC_LEAD]u+\\n[#Q_LEAD_DIFF]u \}
.       \}
.       el \{ .ALD (\\n[#DOC_LEAD]u/2u)+\\n[#Q_LEAD_DIFF]u \}
.       nr #Q_PARTIAL_DEPTH 0 \\n[#Q_LEAD_REAL]
.       while \\n+[#Q_PARTIAL_DEPTH]<(\\n[#TRAP_DISTANCE]-1) \{\
.
.\}
.       nr #Q_PARTIAL_DEPTH -\\n[#Q_LEAD_REAL]
.       nr #Q_SPACE_ADJ (\\n[#TRAP_DISTANCE]-1)-\\n[#Q_PARTIAL_DEPTH]+\\n[#Q_LEAD_DIFF]u
.\" Hack to deal with the fact that even though the above routine
.\" makes the bottom line of the quote fall exactly on the bottom
.\" margin when traps are disabled, it refuses to do so when traps
.\" are on.  The difference by which it's off is #Q_LEAD_DIFF
.\" (the +\\n[#Q_LEAD_DIFF] at the end of the line, above).  Hack
.\" solution: temporarily lower the FOOTER trap position.
.       nr #SAVED_FOOTER_POS \\n[#VARIABLE_FOOTER_POS]
.       ch FOOTER \\n[#VARIABLE_FOOTER_POS]u+.25v
.    \}
.END
\#
\# ====================================================================
\#
\# BREAK QUOTE
\# -----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Ends the diversion P_QUOTE or B_QUOTE, breaks to a new
\#   page, and reinvokes BLOCKQUOTE.
\# *Notes:
\#   Because quotes go into a diversion before they're output,
\#   footnotes in quotes that cross pages behave erratically.  The footnote
\#   isn't processed until the diversion ends, hence the footnote
\#   marker in the quote isn't always correct for the new page (it's
\#   picked up from the old one).  BREAK_QUOTE is a workaround for
\#   this problem.
\#
.MAC BREAK_QUOTE END
.    br
.    di
.    nr #BROKEN_QUOTE 1
.    REMOVE_INDENT
.    ev
.    nr #Q_DEPTH \\n[#DIVER_DEPTH]+\\n[#LEAD]
.    if \\n[#PRINT_STYLE]=1 \{\
.       if !\\n[#LINEBREAK] \{ .ALD \\n[#DOC_LEAD]u \}
.       if \\n[#HEAD] \{\
.          if \\n[#HEAD]=1 \{ .RLD \\n[#DOC_LEAD]u \}
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#PP_SPACE] \{\
.          ie \\n[#HEAD]=1 \{ . \}
.          el \{\
.             if !\\n[#LINEBREAK] \{ .ALD \\n[#DOC_LEAD]u \}
.          \}
.       \}
.       el \{\
.          rr #Q_FITS
.          ie r#HEAD \{\
.             if \\n[#HEAD]=1 \{ . \}
.          \}
.          el \{ .ALD \\n[#DOC_LEAD]u \}
.       \}
.    \}
.    nr #Q_OFFSET \\n[#L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE])
.    if \\n[#COLUMNS] \{ .nr #Q_OFFSET \\n[#COL_\\n[#COL_NUM]_L_MARGIN]+(\\n[#PP_INDENT]*\\n[#Q_OFFSET_VALUE]) \}
.    po \\n[#Q_OFFSET]u
.    if \\n[#QUOTE]=1 \{\
.       nf
.       P_QUOTE
.    \}
.    if \\n[#QUOTE]=2 \{\
.       nf
.       B_QUOTE
.    \}
.    if r#HEAD     \{ .rr #HEAD     \}
.    if r#EPIGRAPH \{ .rr #EPIGRAPH \}
.    rr #Q_PP
.    rr #LINEBREAK
.    nr #PP_STYLE  1
.    nr #END_QUOTE 1
.    if \\n[#PRINT_STYLE]=1 \{\
.       if \\n[#UNDERLINE_QUOTES] \{\
.          UNDERLINE OFF
.       \}
.    \}
.    po \\n[#L_MARGIN]u
.    if \\n[#COLUMNS] \{\
.       po \\n[#COL_\\n[#COL_NUM]_L_MARGIN]u
.       nr #L_MARGIN \\n(.o
.    \}
.    QUAD \\*[$DOC_QUAD]
.    sp |\\n[#PAGE_LENGTH]u  \" To trip footer/header
.    BLOCKQUOTE
.END
\#
\# ====================================================================
\#
\# +++PAGINATION+++
\#
\# PAGINATE
\# --------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns page numbering off or on during document processing.
\# *Notes:
\#   Default is on.
\#
.MAC PAGINATE END
.    ie '\\$1'' \{ .nr #PAGINATE 1 \}
.    el \{ .nr #PAGINATE 0 \}
.END
\#
\#
\# SUSPEND PAGINATION (before ENDNOTES)
\# ------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Creates register #SUSPEND_PAGINATION
\# *Notes:
\#   Useful only to suspend pagination before outputting endnotes.
\#
.MAC SUSPEND_PAGINATION END
.    nr #SUSPEND_PAGINATION 1
.END
\#
\# RESTORE PAGINATION (after ENDNOTES)
\# ------------------
\# *Argument:
\#   <none>
\# *Function:
\#   Removes register #SUSPEND_PAGINATION.  Creates register
\#   #DEFER_PAGINATION
\# *Notes:
\#   Useful only to restore pagination after outputting endnotes.
\#
.MAC RESTORE_PAGINATION END
.    rr #SUSPEND_PAGINATION
.    if \\n[#PAGE_NUM_V_POS]=1 \{ .PAGINATE \}
.    if \\n[#PAGE_NUM_V_POS]=2 \{ .nr #DEFER_PAGINATION 1 \}
.END
\#
\#
\# PAGE NUMBER FORMAT
\# ------------------
\# *Arguments:
\#   DIGIT | ROMAN | roman | ALPHA | alpha
\# *Function:
\#   Assigns user entered format to #PAGENUMBER.
\#
.MAC PAGENUM_STYLE END
.    nr #PAGENUM_STYLE_SET 1
.    if '\\$1'DIGIT'  \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER 1
.    \}
.    if '\\$1'ROMAN'  \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER I
.    \}
.    if '\\$1'roman'  \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER i
.    \}
.    if '\\$1'ALPHA'  \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER A
.    \}
.    if '\\$1'alpha'  \{\
.       ds $PAGENUM_STYLE \\$1
.       af #PAGENUMBER a
.    \}
.END
\#
\#
\# HYPHENS AROUND PAGE NUMBERS
\# ---------------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Creates or modifies register #PAGE_NUM_HYPHENS.
\#   Used to dis/enable hyphens on either side of page numbers.
\# *Notes:
\#   Default is on.
\#
.MAC PAGENUM_HYPHENS END
.    nr #PAGE_NUM_HYPHENS_SET 1
.    ie '\\$1'' \{ .nr #PAGE_NUM_HYPHENS 1 \}
.    el \{ .rr #PAGE_NUM_HYPHENS   \}
.END
\#
\#
\# PAGENUMBER POSITION
\# -------------------
\# *Arguments:
\#   TOP | BOTTOM  LEFT | CENTER | RIGHT
\# *Function:
\#   Creates or modifies various PAGE_NUM_H | V_POS registers.
\#   Used to position page numbers.
\# *Notes:
\#   Default is center/bottom.
\#
.MAC PAGENUM_POS END
.    nr #PAGE_NUM_POS_SET 1
.    if '\\$1'TOP'    \{ .nr #PAGE_NUM_V_POS 1 \}
.    if '\\$1'BOTTOM' \{ .nr #PAGE_NUM_V_POS 2 \}
.    if '\\$2'LEFT'   \{ .nr #PAGE_NUM_H_POS 1 \}
.    if '\\$2'CENTER' \{ .nr #PAGE_NUM_H_POS 2 \}
.    if '\\$2'CENTRE' \{ .nr #PAGE_NUM_H_POS 2 \}
.    if '\\$2'RIGHT'  \{ .nr #PAGE_NUM_H_POS 3 \}
.END
\#
\#
.MAC PN_WITH_HYPHENS END
.    nr #HYPHEN_ADJ \\n[#CAP_HEIGHT]/12
.    ds $HYPHEN \v'-\En[#HYPHEN_ADJ]u'-\v'\En[#HYPHEN_ADJ]u'
.    PRINT \m[\\*[$PAGENUM_COLOR]]\\*[$HYPHEN]\|\\n[#PAGENUMBER]\|\\*[$HYPHEN]
.br
.END
\#
\#
\# PRINT PAGE NUMBER
\# -----------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Prints page number if PAGINATE=1.
\#
.MAC PRINT_PAGE_NUMBER END
.    ev PAGENUMBER
.    nf
.    na
.    po \\n[#DOC_L_MARGIN]u
.    ll \\n[#DOC_L_LENGTH]u
.    ta \\n(.lu
.    FAMILY  \\*[$PAGE_NUM_FAM]
.    FT      \\*[$PAGE_NUM_FT]
.    PT_SIZE \\n[#DOC_PT_SIZE]u\\*[$PAGE_NUM_SIZE_CHANGE]
.    if \\n[#PRINT_STYLE]=1 \{\
.       TYPEWRITER
.    \}
.    if \\n[#PAGE_NUM_V_POS]=1 \{ .vs 0 \}
.    if o \{\
.       ie \\n[#PAGE_NUM_H_POS]=1 \{ .LEFT  \}
.       el                        \{ .RIGHT \}
.    \}
.    if e \{\
.       ie \\n[#PAGE_NUM_H_POS]=1 \{ .RIGHT  \}
.       el                        \{ .LEFT   \}
.    \}
.    if \\n[#PAGE_NUM_H_POS]=2    \{ .CENTER \}
.    if \\n[#RECTO_VERSO]=0 \{\
.       if \\n[#PAGE_NUM_H_POS]=1 \{ .LEFT   \}
.       if \\n[#PAGE_NUM_H_POS]=2 \{ .CENTER \}
.       if \\n[#PAGE_NUM_H_POS]=3 \{ .RIGHT  \}
.    \}
.    nr #PAGENUMBER \\n%+\\n[#PAGE_NUM_ADJ]
.    if \\n[#EN_FIRST_PAGE] \{\
.       if \\n[#EN_FIRST_PN] \{ .PAGENUMBER \\n[#EN_FIRST_PN] \}
.       rr #EN_FIRST_PAGE
.    \}
.    if \\n[#BIB_FIRST_PAGE] \{\
.       if \\n[#BIB_FIRST_PN] \{ .PAGENUMBER \\n[#BIB_FIRST_PN] \}
.       rr #BIB_FIRST_PAGE
.    \}
.    if \\n[#TOC_FIRST_PAGE] \{\
.       PAGENUMBER 1
.       rr #TOC_FIRST_PAGE
.    \}
.    ie \\n[#DRAFT_WITH_PAGENUM] \{\
.       ie '\\*[$REVISION]'' \{\
.          PRINT "\\*[$DRAFT_STRING]\\*[$DRAFT] / \\n[#PAGENUMBER]"
.       \}
.       el \{\
.          ie '\\*[$DRAFT]'' \{\
.             PRINT "\\*[$REVISION_STRING] \\*[$REVISION] / \\n[#PAGENUMBER]"
.          \}
.          el \{\
.             PRINT "\\*[$DRAFT_STRING]\\*[$DRAFT], \\*[$REVISION_STRING] \\*[$REVISION] / \\n[#PAGENUMBER]"
.          \}
.       \}
.    \}
.    el \{\
.       ie \\n[#PAGE_NUM_HYPHENS] \{\
.          if '\\*[$PAGENUM_STYLE]'DIGIT' \{\
.             di NULL
1\\R'#CAP_HEIGHT \\n[.cht]'
.             di
.             PN_WITH_HYPHENS
.          \}
.          if '\\*[$PAGENUM_STYLE]'ROMAN' \{\
.             di NULL
I\\R'#CAP_HEIGHT \\n[.cht]'
.             di
.             PN_WITH_HYPHENS
.          \}
.          if '\\*[$PAGENUM_STYLE]'ALPHA' \{\
.             di NULL
E\\R'#CAP_HEIGHT \\n[.cht]'
.             di
.             PN_WITH_HYPHENS
.          \}
.          if '\\*[$PAGENUM_STYLE]'roman' \{\
.             PRINT \m[\\*[$PAGENUM_COLOR]]-\|\\n[#PAGENUMBER]\|-
.          \}
.          if '\\*[$PAGENUM_STYLE]'alpha' \{\
.             PRINT "\m[\\*[$PAGENUM_COLOR]]-\|\\n[#PAGENUMBER]\|-"
.          \}
.       \}
.       el \{ .PRINT "\m[\\*[$PAGENUM_COLOR]]\\n[#PAGENUMBER]" \}
.    \}
.    ev
.END
\#
\# ====================================================================
\#
\# +++FOOTNOTES+++
\#
.ig
Mom's footnote handling is baroque, to say the least.  There are
redundancies in a number of the macros involved, as well as some
registers that probably don't get used anymore.  The baggage is left
in in case some new footnote oddity/challenge gets thrown my way.

The macros are heavily commented.
..
\#
\# FOOTNOTE AUTOLEAD
\# -----------------
\# *Arguments:
\#   <autolead value for footnotes>
\# *Function:
\#   Creates or modifies register #FN_AUTOLEAD.
\# *Notes:
\#   Default is #DOC_LEAD/2 for TYPEWRITE; 2 for TYPESET
\#
.MAC FOOTNOTE_AUTOLEAD END
.    nr #FN_AUTOLEAD \\$1
.END
\#
\#
\# FOOTNOTE MARKERS
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns generation of footnote markers on or off.
\# *Notes:
\#   Default is on.
\#
.MAC FOOTNOTE_MARKERS END
.    ie '\\$1'' \{ .nr #FN_MARKERS 1 \}
.    el \{ .nr #FN_MARKERS 0 \}
.END
\#
\#
\# FOOTNOTE MARKER STYLE
\# ---------------------
\# *Arguments:
\#   STAR | NUMBER | LINE
\# *Function:
\#   Sets register #FN_MARKER_STYLE, used in FOOTNOTE to determine
\#   the style of footnote markers.
\# *Notes:
\#   1=STAR; 2=NUMBER; 3=LINE.  LINE means "use output line numbers".
\#   Default is STAR.
\#
.MAC FOOTNOTE_MARKER_STYLE END
.    if '\\$1'STAR' \{\
.       if \\n[#FN_MARKER_STYLE]=3 \{\
.          if !\\n[#NEWPAGE]=1 \{\
.             tm1 "[mom]: Your current FOOTNOTE_MARKER STYLE is LINE.  
.             tm1 "       You cannot change footnote marker style without
.             tm1 "       first breaking to a new page with NEWPAGE.
.             tm1 "       Ignoring request FOOTNOTE_MARKER_STYLE STAR at line \\n(.c.
.             return
.          \}
.       \}
.       if \\n[#RUN_ON]=1 \{\
.          tm1 "[mom]: FOOTNOTE_MARKER_STYLE STAR at line \\n(.c is incompatible
.          tm1 "       with RUN_ON footnotes.  Ignoring request.
.          return
.       \}
.       nr #FN_MARKER_STYLE 1
.       if \\n[#NEWPAGE]=1 \{ .rr #NEWPAGE \}
.       FOOTNOTE_MARKERS
.    \}
.    if '\\$1'NUMBER' \{\
.       if \\n[#FN_MARKER_STYLE]=3 \{\
.          if !\\n[#NEWPAGE]=1 \{\
.             tm1 "[mom]: Your current FOOTNOTE_MARKER STYLE is NUMBER.  
.             tm1 "       You cannot change footnote marker style without
.             tm1 "       first breaking to a new page with NEWPAGE.
.             tm1 "       Ignoring request FOOTNOTE_MARKER_STYLE NUMBER at line \\n(.c.
.             return
.          \}
.       \}
.       if \\n[#RUN_ON]=1 \{\
.          tm1 "[mom]: FOOTNOTE_MARKER_STYLE NUMBER at line \\n(.c is incompatible
.          tm1 "       with RUN_ON footnotes.  Ignoring request.
.          return
.       \}
.       nr #FN_MARKER_STYLE 2
.       if \\n[#NEWPAGE]=1 \{ .rr #NEWPAGE \}
.       FOOTNOTE_MARKERS
.    \}
.    if '\\$1'LINE' \{\
.       nr #FN_MARKER_STYLE 3
.       FOOTNOTE_MARKERS OFF
.       if !\\n[#FN_LN_SEP] \{\
.          if !\\n[#FN_LN_BRACKETS] \{ .FOOTNOTE_LINENUMBER_BRACKETS SQUARE \}
.       \}
.    \}
.END
\#
\#
\# FOOTNOTE LINENUMBER MARK
\# ------------------------
\# *Function:
\#   This string, when called inline, stores the current output line
\#   number in register #FN_MARK for use with FOOTNOTE.
\#
.ds FN-MARK \R'#FN_MARK \En(ln'
\#
\#
\# FOOTNOTE LINENUMBER SEPARATOR
\# -----------------------------
\# *Argument:
\#   <user-defined separator>
\# *Function:
\#   Stores user-defined separator (for use then
\#   FOOTNOTE_MARKER_STYLE is LINE) in string $FN_LN_SEP.  The
\#   separator is intended to be used when the user wishes a
\#   separator, rather than the choice of brackets offered by
\#   FOOTNOTE_LINENUMBER_BRACKETS.
\#
.MAC FOOTNOTE_LINENUMBER_SEPARATOR END
.    rr #FN_LN_BRACKETS
.    nr #FN_LN_SEP 1
.    ds $FN_LN_SEP "\\$1
.END
\#
\#
\# FOOTNOTE LINENUMBER BRACKETS
\# ----------------------------
\# *Argument:
\#   PARENS | SQUARE | BRACES or ( | [ | {
\# *Function:
\#   Sets register #FN_LN_BRACKETS to 1, and creates strings
\#   $FN_OPEN_BRACKET and $FN_CLOSE_BRACKET according to the given
\#   argument.
\#
.MAC FOOTNOTE_LINENUMBER_BRACKETS END
.    rr #FN_LN_SEP
.    nr #FN_LN_BRACKETS 1
.    if '\\$1'PARENS' \{\
.       ds $FN_OPEN_BRACKET (
.       ds $FN_CLOSE_BRACKET )
.    \}
.    if '\\$1'(' \{\
.       ds $FN_OPEN_BRACKET (
.       ds $FN_CLOSE_BRACKET )
.    \}
.    if '\\$1'SQUARE' \{\
.       ds $FN_OPEN_BRACKET [
.       ds $FN_CLOSE_BRACKET ]
.    \}
.    if '\\$1'[' \{\
.       ds $FN_OPEN_BRACKET [
.       ds $FN_CLOSE_BRACKET ]
.    \}
.    if '\\$1'BRACES' \{\
.       ds $FN_OPEN_BRACKET {
.       ds $FN_CLOSE_BRACKET }
.    \}
.    if '\\$1'{' \{\
.       ds $FN_OPEN_BRACKET {
.       ds $FN_CLOSE_BRACKET }
.    \}
.END
\#
\#   
\# RESET FOOTNOTE NUMBER
\# ---------------------
\# *Arguments:
\#   <none> | PAGE
\# *Function:
\#   Resets register #FN_NUMBER to 1.  If argument is PAGE, creates
\#   toggle #RESET_FN_NUMBER which is checked in HEADER.  If 1,
\#   numbered footnotes on every page start at 1.
\#
.MAC RESET_FOOTNOTE_NUMBER END
.    ie '\\$1'' \{ .nr #FN_NUMBER 0 1 \}
.    el \{ .nr #RESET_FN_NUMBER 1 \}
.END
\#
\#
\# FOOTNOTE RULE LENGTH
\# --------------------
\# *Arguments:
\#   <length of rule used to separate footnotes from running text>
\# *Function:
\#   Creates or modifies registers #FN_RULE_LENGTH.
\# *Notes:
\#   Requires unit of measure (iPpcm).
\#   Default is 4P for both PRINTSTYLEs.
\#
.MAC FOOTNOTE_RULE_LENGTH END
.    nr #FN_RULE_LENGTH (\\$1)
.END
\#
\#
\# FOOTNOTE_RULE_ADJ
\# -----------------
\# *Arguments:
\#   <number of points to raise footnote rule from it's baseline position>
\# *Function:
\#   Creates or modifies register #FN_RULE_ADJ.
\# *Notes:
\#   Default is 3p for both TYPESTYLES.
\#
\#   Requires unit of measure.
\#
.MAC FOOTNOTE_RULE_ADJ END
.    nr #FN_RULE_ADJ (\\$1)
.END
\#
\#
\# FOOTNOTE RULE
\# -------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns printing of footnote separator rule on or off.  If invoked as
\#   PRINT_FOOTNOTE_RULE, prints footnote separator rule.
\# *Notes:
\#   Default is on.
\#
\#   Invoked in FOOTNOTE (as PRINT_FOOTNOTE_RULE) as 1st line of a footnote
\#   if the footnote number (#FN_COUNT) is 1.
\#
.MAC FOOTNOTE_RULE END
.    ie '\\$0'PRINT_FOOTNOTE_RULE' \{\
.       if \\n[#FN_RULE]=0 \{ .RLD 1v \}
\!.     PT_SIZE 12
.       RLD 1v
.       LEFT
.       PRINT \v'-\\n[#FN_RULE_ADJ]u'\l'\\n[#FN_RULE_LENGTH]u'\v'+\\n[#FN_RULE_ADJ]u'
\!.     PT_SIZE \\n[#DOC_PT_SIZE]u\\*$[FN_SIZE_CHANGE]
.       QUAD \\*[$FN_QUAD]
.    \}
.    el \{\
.       ie '\\$1'' \{ .nr #FN_RULE 1 \}
.       el \{ .nr #FN_RULE 0 \}
.    \}
.END
\#
\#
\# FOOTNOTE SPACING
\# ----------------
\# *Arguments:
\#   <per item post footnote spacing> | <anything>
\# *Function:
\#   Enables printing of post footnote spacing.
\# *Notes:
\#   Default is no space.
\#
.MAC FOOTNOTE_SPACING END
.    ie \B'\\$1' \{ .nr #FN_SPACE (\\$1) \}
.    el \{ .nr #FN_SPACE 0 \}
.END
\#
\#
\# RUN ON FOOTNOTES
\# ----------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Toggles run-on footnotes on or off.
\#
.MAC FOOTNOTES_RUN_ON END
.    ie '\\$1'' \{\
.       if \\n[#FN_COUNT]>0 \{\
.          tm1 "[mom]: Switching to run-on footnotes at line \\n(.c will cause
.          tm1 "       you to loose footnotes already formatted for this page.
.          tm1 "       Ignoring request FOOTNOTES_RUN_ON.
.          rr #RUN_ON
.          return
.       \}
.       nr #RUN_ON 1
.       if \\n[#FN_MARKER_STYLE]=1 \{ .RUNON_WARNING \}
.       if \\n[#FN_MARKER_STYLE]=2 \{ .RUNON_WARNING \}
.    \}
.    el \{\
.       if \\n[#FN_COUNT]>0 \{\
.          if \\n[#RUN_ON]=1 \{\
.             tm1 "[mom]: Switching off run-on footnotes at line \\n(.c will cause
.             tm1 "       you to loose footnotes already formatted for this page.
.             tm1 "       Ignoring request FOOTNOTES_RUN_ON \\$1.
.             return
.          \}
.       \}
.       rr #RUN_ON
.    \}
.END
\#
\#
.MAC RUNON_WARNING END
.    if \\n[#FN_MARKER_STYLE]=1 \{\
.       tm1 "[mom]: The footnote marker style active at line \\n(.c is STAR,
.       tm1 "       which is incompatible with run-on footnotes.  Please change
.       tm1 "       the footnote marker style to LINE.  Continuing to process,
.       tm1 "       but ignoring request FOOTNOTES_RUN_ON.
.       rr #RUN_ON
.    \}
.    if \\n[#FN_MARKER_STYLE]=2 \{\
.       tm1 "[mom]: The footnote marker style active at line \\n(.c is NUMBER,
.       tm1 "       which is incompatible with run-on footnotes.  Please change
.       tm1 "       the footnote marker style to LINE.  Continuing to process,
.       tm1 "       but ignoring request FOOTNOTES_RUN_ON.
.       rr #RUN_ON
.    \}
.END
\#
\# FOOTNOTE
\# --------
\# *Arguments:
\#   <none> | INDENT  L|LEFT|R|RIGHT|B|BOTH  <indent value> | <anything>
\# *Function:
\#   Begins collecting and diverting footnote text if no argument
\#   given.  Otherwise, ends diversion FOOTNOTES, measures footnote
\#   depth, and sets footnote trap.
\# *Notes:
\#   The input line preceding a footnote call MUST terminate with \c
\#   or the footnote marker will be spaced away from the word it
\#   should be joined to.
\#
\#   If FOOTNOTE is invoked with INDENT, the footnote will
\#   be indented.  An indent style and an indent value must be given.
\#   Subsequent footnotes will NOT be indented; INDENT must be given
\#   for each footnote the user wants indented.
\#
.MAC FOOTNOTE END
.    if !\\n(.u \{ .nr #ADD_BREAK 1 \}
.    ie '\\$1'' \{\
.       if \\n[#FN_MARKER_STYLE]=3 \{\
.          if !\\n[#LINENUMBERS] \{\
.             tm1 "[mom]: Line numbering must be enabled with NUMBER_LINES when
.             tm1 "       FOOTNOTE_MARKER_STYLE is LINE.
.             ab Aborting on FOOTNOTE at line \\n(.c.
.          \}
.          if \\n[#FN_MARK]=0 \{ .nr #FN_MARK \\n(ln \}
.          nr #FN_MARK_2 \\n(ln
.          if '\\n(.z'P_QUOTE' \{\
.             nr #FN_MARK -1
.             nr #FN_MARK_2 -1
.          \}
.          if \\n[#IN_DIVER]=1 \{\
.             if '\\n(.z'P_QUOTE' \{\
.                if !\\n[#QUOTE_LN]=1 \{\
.                   if !\\n[#SILENT_QUOTE_LN]=1 \{\
.                      tm1 "[mom]: You have requested a line-numbered footnote inside a
.                      tm1 "       QUOTE at line \\n(.c, but line-numbering has not been enabled
.                      tm1 "       for QUOTES.  Printing footnote with label "0".
.                      rr #FN_MARK
.                      rr #FN_MARK_2
.                   \}
.                \}
.             \}
.             if '\\n(.z'B_QUOTE' \{\
.                if !\\n[#BQUOTE_LN]=1 \{\
.                   if !\\n[#SILENT_BQUOTE_LN]=1 \{\
.                      tm1 "[mom]: You have requested a line-numbered footnote inside a
.                      tm1 "       BLOCKQUOTE at line \\n(.c, but line-numbering has not been enabled
.                      tm1 "       for BLOCKQUOTES.  Printing footnote with label "0".
.                      rr #FN_MARK
.                      rr #FN_MARK_2
.                   \}
.                \}
.             \}
.          \}
.       \}
.\" Begin processing footnotes that occur inside QUOTE, BLOCKQUOTE
.\" or EPIGRAPH.
.       if \\n[#IN_DIVER]=1 \{\
.          nr #PAGE_POS \\n(nl+\\n(.d+\\n[#DOC_LEAD]
.          nr #FOOTER_POS \\n[#PAGE_LENGTH]+(\\n[#VARIABLE_FOOTER_POS]-1)
.          nr #SPACE_TO_FOOTER \\n[#FOOTER_POS]-\\n[#PAGE_POS]
.\" Are we on a "defer" line?  If so, defer the text of the footnote.
.          ie \\n[#SPACE_TO_FOOTER]=\\n[#DOC_LEAD]:\\n[#SPACE_TO_FOOTER]=0 \{\
.             nr #DIVER_FN 2 \" treat like a normal deferred footnote
.          \}
.          el \{\
.             nr #DIVER_FN 2 \" treat like a normal footnote
.          \}
.          if \\n[#PAGE_POS]>\\n[#FOOTER_POS] \{\
.             nr #DIVER_FN 1 \" move this footnote
.          \}
.\" Test for situation where, because a final line of QUOTE, BLOCKQUOTE
.\" or EPIGRAPH isn't yet adjusted at this point, the last word on the
.\" line may *seem* to belong to the final line of the page, but will,
.\" in fact, become the first word of the subsequent page.  In such
.\" circumstances, we want the the footnote to be treated as a "moved"
.\" diversion footnote.
.          if \\n(.k>\\n(.l \{ .nr #DIVER_FN 1 \}
.          if r#DIVER_FN \{\
.             if !\\n[#DIVER_FN]=2 \{ .\\n+[#DONE_ONCE] \}
.\" A footnote inside a diversion will become the 1st footnote on the
.\" following page/column.
.             if \\n[#DIVER_FN]=1 \{ .DIVER_FN_1_PRE \}
.\" A footnote inside a diversion that should be treated like a
.\" normal footnote (including defers.)
.             if \\n[#DIVER_FN]=2 \{ .DIVER_FN_2_PRE \}
.          \}
.          nr #SAVED_FN_COUNT \\n[#FN_COUNT]+1
.          nr #SAVED_FN_COUNT_FOR_COLS \\n[#FN_COUNT_FOR_COLS]+1
.       \}
.\" End processing footnotes that occur inside QUOTE, BLOCKQUOTE or
.\" EPIGRAPH.
.\"
.\" Test for situation where, because a final line of running text
.\" isn't yet adjusted at this point, the last word on the line may
.\" *seem* to belong to the final line of the page, but will, in
.\" fact, become the first word of the subsequent page.  In such
.\" circumstances, we want the the footnote marker in running text to
.\" be the correct one for the 1st footnote on the page.
.       if \\n(.k>\\n(.l \{\
.          if (\\n(nl+\\n[#DOC_LEAD])>(\\n[#PAGE_LENGTH]+\\n[#VARIABLE_FOOTER_POS]) \{\
.             ie \\n[#COLUMNS]=1 \{\
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                   if \\n[#FN_MARKER_STYLE]=1 \{\
.                      nr #FN_COUNT_FOR_COLS 0 1
.                   \}
.                   if \\n[#FN_MARKER_STYLE]=2 \{\
.                      if \\n[#RESET_FN_NUMBER] \{\
.                         nr #FN_NUMBER 0 1
.                         nr #NOT_YET_ADJUSTED 1
.                      \}
.                   \}
.                \}
.             \}
.             el \{\
.                if \\n[#FN_MARKER_STYLE]=1 \{\
.                   nr #FN_COUNT 0 1
.                \}
.                if \\n[#FN_MARKER_STYLE]=2 \{\
.                   if \\n[#RESET_FN_NUMBER] \{\
.                      nr #FN_NUMBER 0 1
.                      nr #NOT_YET_ADJUSTED 1
.                   \}
.                \}
.             \}
.          \}
.       \}
.       if \\n[#FN_MARKERS] \{\
.\" Housekeeping
.          if \\n[#CONDENSE] \{ \*[CONDX]\c \}
.          if \\n[#EXTEND]   \{ \*[EXTX]\c  \}
.          if \\n[#PRINT_STYLE]=1 \{\
.             if \\n[#UNDERLINE_ON] \{\
.                nr #UNDERLINE_WAS_ON 1
.                UNDERLINE OFF
.             \}
.          \}
.\" Add footnote markers to running text...
.          if !\\n[#NO_FN_MARKER] \{\
.\" ...but not if TERMINATE has not been called
.             if !r#TERMINATE \{\
.\" Marker style star/dagger/double-dagger
.                if \\n[#FN_MARKER_STYLE]=1 \{\
.\" Columnar docs either move col to col, or last col to next page.
.\" They require their own special FN_COUNT because regular FN_COUNT
.\" is used to figure out things like whether or not to put a rule
.\" above footnotes (in addition to keeping track of the footnote
.\" count in non-columnar docs).
.                   ie \\n[#COLUMNS]=1 \{\
.                      if \\n[#FN_COUNT_FOR_COLS]=0 \{ .PRINT \*[BU2]*\c            \}
.                      if \\n[#FN_COUNT_FOR_COLS]=1 \{ .PRINT \*[BU1]\(dg\c         \}
.                      if \\n[#FN_COUNT_FOR_COLS]=2 \{ .PRINT \(dd\c                \}
.                      if \\n[#FN_COUNT_FOR_COLS]=3 \{ .PRINT \*[BU2]**\c           \}
.                      if \\n[#FN_COUNT_FOR_COLS]=4 \{ .PRINT \*[BU1]\(dg\(dg\c     \}
.                      if \\n[#FN_COUNT_FOR_COLS]=5 \{ .PRINT \(dd\(dd\c            \}
.                      if \\n[#FN_COUNT_FOR_COLS]=6 \{ .PRINT \*[BU2]***\c          \}
.                      if \\n[#FN_COUNT_FOR_COLS]=7 \{ .PRINT \*[BU1]\(dg\(dg\(dg\c \}
.                      if \\n[#FN_COUNT_FOR_COLS]=8 \{ .PRINT \(dd\(dd\(dd\c        \}
.                      if \\n[#FN_COUNT_FOR_COLS]=9 \{ .PRINT \*[BU2]****\c         \}
.                   \}
.                   el \{\
.                      if \\n[#FN_COUNT]=0 \{ .PRINT \*[BU2]*\c            \}
.                      if \\n[#FN_COUNT]=1 \{ .PRINT \*[BU1]\(dg\c         \}
.                      if \\n[#FN_COUNT]=2 \{ .PRINT \(dd\c                \}
.                      if \\n[#FN_COUNT]=3 \{ .PRINT \*[BU2]**\c           \}
.                      if \\n[#FN_COUNT]=4 \{ .PRINT \*[BU1]\(dg\(dg\c     \}
.                      if \\n[#FN_COUNT]=5 \{ .PRINT \(dd\(dd\c            \}
.                      if \\n[#FN_COUNT]=6 \{ .PRINT \*[BU2]***\c          \}
.                      if \\n[#FN_COUNT]=7 \{ .PRINT \*[BU1]\(dg\(dg\(dg\c \}
.                      if \\n[#FN_COUNT]=8 \{ .PRINT \(dd\(dd\(dd\c        \}
.                      if \\n[#FN_COUNT]=9 \{ .PRINT \*[BU2]****\c         \}
.                   \}
.                \}
.\" Marker style superscript numbers
.                if \\n[#FN_MARKER_STYLE]=2 \{\
.                   if \\n[#PRINT_STYLE]=1 \{ .PRINT "\s-2\v'-\\n[#DOC_LEAD]u/5u'\\n+[#FN_NUMBER]\v'+\\n[#DOC_LEAD]u/5u'\s+2\c" \}
.                   if \\n[#PRINT_STYLE]=2 \{ .PRINT "\*[SUP]\\n+[#FN_NUMBER]\*[SUPX]\c" \}
.                \}
.             \}
.          \}
.       \}
.\" More housekeeping
.\"
.\" #SPACE_REMAINING is the space left between where we are
.\" on the page and the bottom margin.  It's used to determine whether
.\" or not the footnote will overflow, and how many lines of
.\" footnotes will fit on the page if some have to overflow.
.       ie \\n[#DIVER_FN]=2 \{\
.          nr #SPACE_REMAINING (\\n[#PAGE_LENGTH]-\\n[#B_MARGIN])-(\\n[#PAGE_POS])
.       \}
.       el \{\
.          nr #SPACE_REMAINING (\\n[#PAGE_LENGTH]-\\n[#B_MARGIN])-\\n(nl
.       \}
.       if \\n[#FROM_DIVERT_FN]=1 \{\
.          nr #SPACE_REMAINING \\n[#PAGE_LENGTH]-\\n[#B_MARGIN]
.          rr #FROM_DIVERT_FN
.       \}
.       nr #PP_STYLE_PREV \\n[#PP_STYLE]
.       nr #PP_STYLE 2
.       if \\n[#INDENT_FIRST_PARAS] \{ .nr #INDENT_FIRSTS 1 \}
.       INDENT_FIRST_PARAS
.\" Prepare FOOTNOTE to receive footnote text.
.       ev FOOTNOTES
.       ll \\n[#DOC_L_LENGTH]u
.       ta \\n(.lu
.       if \\n[#COLUMNS]=1 \{\
.          ll \\n[#COL_L_LENGTH]u
.          ta \\n(.lu
.       \}
.       if \\n[#FN_R_INDENT]  \{\
.          ll -\\n[#FN_R_INDENT]u
.          ta \\n(.lu
.       \}
.       if \\n[#FN_BR_INDENT] \{\
.          ll -\\n[#FN_BR_INDENT]u
.          ta \\n(.lu
.       \}
.       FAMILY   \\*[$FN_FAM]
.       FT       \\*[$FN_FT]
.       PT_SIZE  \\n[#DOC_PT_SIZE]u\\*[$FN_SIZE_CHANGE]
.       AUTOLEAD \\n[#FN_AUTOLEAD]
.       QUAD     \\*[$FN_QUAD]
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          ie \\n[#SINGLE_SPACE] \{ .vs \\n[#ORIGINAL_DOC_LEAD]u \}
.          el \{ .vs \\n[#ORIGINAL_DOC_LEAD]u/2u \}
.          QUAD LEFT
.          HY OFF
.       \}
.       nr #FN_LEAD \\n[#LEAD]
.\" Begin diversion FOOTNOTES or FN_IN_DIVER
.       ie r#COUNTERS_RESET \{\
.          ie \\n[#DONE_ONCE]=1 \{\
.             ie \\n[#RUN_ON] \{\
.                di RUNON_FN_IN_DIVER
.                nr #RUNON_FN_IN_DIVER 1
.             \}
.             el \{ .di FN_IN_DIVER \}
.          \}
.          el \{\
.             ie \\n[#RUN_ON] \{\
.                da RUNON_FN_IN_DIVER
.                nr #RUNON_FN_IN_DIVER 1
.             \}
.             el \{ .da FN_IN_DIVER \}
.          \}
.       \\n+[#DONE_ONCE]
.       \}
.       el \{\
.          ie \\n[#RUN_ON] \{\
.             da RUNON_FOOTNOTES
.             nr #RUNON_FOOTNOTES 1
.          \}
.          el \{ .da FOOTNOTES \}
.       \}
.       if \\n[#FOOTNOTE_COLOR]=1 \{\
.          TRAP OFF
.          nf
\m[\\*[$FOOTNOTE_COLOR]]
.          EOL
.          fi
.          TRAP
.       \}
.       if \\n[#EPIGRAPH] \{ .nr #FN_FOR_EPI 1 \}
.\" When a deferred footnote is also the 1st footnote on the page,
.\" and when the page it's output on also has footnotes, some
.\" whitespace is needed between the deferred footnote and the
.\" first footnote belonging to the output page so that there's
.\" no confusion when two stars (or two number 1s) appear in
.\" footnotes...
.       if \\n[#FN_DEFER_SPACE] \{\
.\" ...but only add the extra space if TERMINATE has not been called
.          if !r#TERMINATE \{\
.\" ...and not if defer space has already been added
.             if !\\n[#DEFER_SPACE_ADDED] \{\
.\" ...and not if the footnote count the last time we checked for
.\" a defer situation inside a diversion is greater than 1.
.                if !\\n[#SAVED_DIVER_FN_COUNT]>1 \{\
.                   if \\n[#FN_MARKER_STYLE]=1 \{ .ALD 1v \}
.                   if \\n[#RESET_FN_NUMBER] \{ .ALD 1v \}
.                   nr #DEFER_SPACE_ADDED 1
.                \}
.             \}
.          \}
.          rr #FN_DEFER_SPACE
.          rr #SAVED_DIVER_FN_COUNT
.       \}
.       if \\n[#DIVERTED]=3 \{\
.          if \\n[#FN_COUNT]>0 \{\
\!.           RLD 1v
.          \}
.       \}
.\" Add footnote rule (or, if no rule, some whitespace).
.\" N.B.- this line increments #FN_COUNT each and every time FOOTNOTE
.\" is run.
.       if \\n+[#FN_COUNT]=1 \{\
.\" If a footnote is called in a diversion, and the footnote has to
.\" be moved, don't put in the rule now (it's taken care of when
.\" FN_IN_DIVER is output into FOOTNOTE in PROCESS_FN_IN_DIVER).
.          if !\\n[#DONT_RULE_ME]=1 \{\
.             if !\\n[#FN_DEPTH] \{\
.                if \\n[#PRINT_STYLE]=1 \{\
.                   if !\\n[#RUN_ON] \{ .ALD \\n[#DOC_LEAD]u \}
.                \}
.                ie \\n[#FN_RULE]=1 \{\
.                   if !\\n[#RUN_ON] \{ .PRINT_FOOTNOTE_RULE \}
.                \}
.                el \{ .ALD 1v \}
.                nr #RULED 1
.             \}
.          \}
.       \}
.       rr #DONT_RULE_ME
.\" Add footnote markers to footnote text...
.       ie \\n[#FN_MARKERS] \{\
.          if \\n[#FN_SPACE]>0 \{\
.             if \\n[#FN_COUNT]>0 \{\
.                ALD \\n[#FN_SPACE]u
.             \}
.          \}
.          if !\\n[#NO_FN_MARKER] \{\
.\" ...but not if TERMINATE has been called.
.             if !r#TERMINATE \{\
.                if \\n[#REF]=1 \{\
\!.                 in +\\*[$REF_FN_INDENT]
\!.                 ti -\\*[$REF_FN_INDENT]
.                \}
.                if \\n[#FN_MARKER_STYLE]=1 \{\
.                   ie \\n[#COLUMNS]=1 \{\
.                      \\n+[#FN_COUNT_FOR_COLS]
.                      if \\n[#FN_COUNT_FOR_COLS]=1  \{ .PRINT *\c            \}
.                      if \\n[#FN_COUNT_FOR_COLS]=2  \{ .PRINT \(dg\c         \}
.                      if \\n[#FN_COUNT_FOR_COLS]=3  \{ .PRINT \(dd\c         \}
.                      if \\n[#FN_COUNT_FOR_COLS]=4  \{ .PRINT **\c           \}
.                      if \\n[#FN_COUNT_FOR_COLS]=5  \{ .PRINT \(dg\(dg\c     \}
.                      if \\n[#FN_COUNT_FOR_COLS]=6  \{ .PRINT \(dd\(dd\c     \}
.                      if \\n[#FN_COUNT_FOR_COLS]=7  \{ .PRINT ***\c          \}
.                      if \\n[#FN_COUNT_FOR_COLS]=8  \{ .PRINT \(dg\(dg\(dg\c \}
.                      if \\n[#FN_COUNT_FOR_COLS]=9  \{ .PRINT \(dd\(dd\(dd\c \}
.                      if \\n[#FN_COUNT_FOR_COLS]=10 \{ .PRINT ****\c         \}
.                   \}
.                   el \{\
.                      if \\n[#FN_COUNT]=1  \{ .PRINT *\c            \}
.                      if \\n[#FN_COUNT]=2  \{ .PRINT \(dg\c         \}
.                      if \\n[#FN_COUNT]=3  \{ .PRINT \(dd\c         \}
.                      if \\n[#FN_COUNT]=4  \{ .PRINT **\c           \}
.                      if \\n[#FN_COUNT]=5  \{ .PRINT \(dg\(dg\c     \}
.                      if \\n[#FN_COUNT]=6  \{ .PRINT \(dd\(dd\c     \}
.                      if \\n[#FN_COUNT]=7  \{ .PRINT ***\c          \}
.                      if \\n[#FN_COUNT]=8  \{ .PRINT \(dg\(dg\(dg\c \}
.                      if \\n[#FN_COUNT]=9  \{ .PRINT \(dd\(dd\(dd\c \}
.                      if \\n[#FN_COUNT]=10 \{ .PRINT ****\c         \}
.                   \}
.                \}
.                if \\n[#FN_MARKER_STYLE]=2 \{\
.                   if \\n[#COLUMNS]=1 \{\
.                      \\n+[#FN_COUNT_FOR_COLS]
.                   \}
.                   if \\n[#NOT_YET_ADJUSTED]=1 \{\
.                      nr #FN_NUMBER 1 1
.                      rr #NOT_YET_ADJUSTED
.                   \}
.                   if \\n[#PRINT_STYLE]=1 \{ .PRINT "(\\n[#FN_NUMBER])\c" \}
.                   if \\n[#PRINT_STYLE]=2 \{ .PRINT "\*[SUP]\\n[#FN_NUMBER]\*[SUPX]\*[FU 2]\c" \}
.                \}
.             \}
.          \}
.       \}
.       el \{\
.\" Line-numbered footnotes handling
.          if \\n[#FN_MARKER_STYLE]=3 \{\
.             if \\n[#FN_SPACE]>0 \{\
.                if !\\n[#RUN_ON]=1 \{\
.                   if \\n[#FN_COUNT]>0 \{\
.                      ALD \\n[#FN_SPACE]u
.                   \}
.                \}
.             \}
.             if \\n[#REF]=1 \{\
.                if !\\n[#RUN_ON]=1 \{\
\!.                 in +\\*[$REF_FN_INDENT]
\!.                 ti -\\*[$REF_FN_INDENT]
.                \}
.             \}
.             ie \\n[#FN_LN_BRACKETS]=1 \{\
.                ds $FN_LINENUMBER \v'-.085m'\\*[$FN_OPEN_BRACKET]\v'.085m'
.                ie \\n[#FN_MARK_2]=\\n[#FN_MARK] \{\
.                   as $FN_LINENUMBER \\n[#FN_MARK]\v'-.085m'\\*[$FN_CLOSE_BRACKET]\v'.085m' \"
.                \}
.                el \{\
.                   as $FN_LINENUMBER \\n[#FN_MARK]\v'-.1m'-\v'.1m'\\n[#FN_MARK_2]\v'-.085m'\\*[$FN_CLOSE_BRACKET]\v'.085m' \"
.                \}
.             \}
.             el \{\
.                ie \\n[#FN_MARK_2]=\\n[#FN_MARK] \{\
.                   ds $FN_LINENUMBER \\n[#FN_MARK]\\*[$FN_LN_SEP]
.                \}
.                el \{\
.                   ds $FN_LINENUMBER \\n[#FN_MARK]\v'-.1m'-\v'.1m'\\n[#FN_MARK_2]\\*[$FN_LN_SEP]
.                \}
.             \}
.             if !\\n[#NO_FN_MARKER] \{\
.                PRINT \\*[$FN_LINENUMBER]\c
.             \}
.             rm $FN_LINENUMBER
.             nr #FN_MARK 0
.          \}
.       \}
.    \}
.\" If INDENT arg is passed to FOOTNOTE, calculate the indent...
.    el \{\
.       ie '\\$1'INDENT' \{\
.          ev FOOTNOTES
.          if '\\$2'L'     \{ .in (\\$3)  \}
.          if '\\$2'LEFT'  \{ .in (\\$3)  \}
.          if '\\$2'R'     \{ .nr #FN_R_INDENT (\\$3) \}
.          if '\\$2'RIGHT' \{ .nr #FN_R_INDENT (\\$3) \}
.          if '\\$2'B' \{\
.             nr #FN_BL_INDENT (\\$3)
.             ie '\\$4'' \{ .nr #FN_BR_INDENT \\n[#FN_BL_INDENT] \}
.             el \{ .nr #FN_BR_INDENT (\\$4) \}
.             in \\n[#FN_BL_INDENT]u
.          \}
.          if '\\$2'BOTH' \{\
.             nr #FN_BL_INDENT (\\$3)
.             ie '\\$4'' \{ .nr #FN_BR_INDENT \\n[#FN_BL_INDENT] \}
.             el \{ .nr #FN_BR_INDENT (\\$4) \}
.             in \\n[#FN_BL_INDENT]u
.          \}
.          ev
.\" ...then re-run FOOTNOTE without an argument.
.          FOOTNOTE
.       \}
.       el \{\
.          br
.\" Add "defer space" if the previously diverted footnote was the
.\" 1st footnote proper to its page (i.e. it looks like a deferred
.\" footnote but it's really an overflow).
.          if \\n[#DIVERTED] \{\
.             if \\n[#PREV_FN_DEFERRED]=1 \{\
.                if \\n[#FN_MARKER_STYLE]=1 \{ .ALD \\n[#FN_LEAD]u \}
.                if \\n[#RESET_FN_NUMBER] \{ .ALD \\n[#FN_LEAD]u \}
.                nr #PREV_FN_DEFERRED 2
.             \}
.          \}
.          if \\n[#REF]=1 \{\
\!.           in 
.          \}
.\" Terminate FOOTNOTES or FN_IN_DIVER diversion
.          di
.          HY_SET 1 \\n[#DIVERSIONS_HY_MARGIN]u (\\n[#PT_SIZE]u/1000u/8u)p
.          hy 14
.\" More housekeeping
.\" Turn off indent possibly set by FOOTNOTE INDENT
.          in 0
.\" Restore sentence spacing
.       if \\n[#PRINT_STYLE]=2 \{\
.          if d$RESTORE_SS_VAR \{ .SS \\*[$RESTORE_SS_VAR] \}
.          rm $RESTORE_SS_VAR
.       \}
.          if \\n[#PRINT_STYLE]=1 \{\
.             if \\n[#UNDERLINE_WAS_ON] \{\
.                UNDERLINE
.                rr #UNDERLINE_WAS_ON
.             \}
.          \}
.          ev
.          rr #FN_R_INDENT
.          rr #FN_BR_INDENT
.          nr #PP_STYLE \\n[#PP_STYLE_PREV]
.          if !\\n[#INDENT_FIRSTS] \{ .INDENT_FIRST_PARAS OFF \}
.          rr #INDENT_FIRSTS
.\" Calculate footnote depth, but not if #COUNTERS_RESET (created in
.\" DIVER_FN_1_PRE) to instruct FOOTNOTES to skip this step for now
.\" (it's taken care of when FN_IN_DIVER is output into FOOTNOTES in
.\" PROCESS_FN_IN_DIVER).
.          ie r#COUNTERS_RESET \{\
.             rr #COUNTERS_RESET
.          \}
.          el \{\
.             nr #GET_DEPTH 1
.\" If the footnote is the 1st on the page and it falls too close
.\" to the bottom margin, defer the footnote text to the next page...
.             if (\\n[#SPACE_REMAINING]-1)<=(\\n[#DOC_LEAD]) \{\
.\" ...but not if PROCESS_FN_LEFTOVER has set #PREV_FN_DEFERRED to 1
.                if !\\n[#PREV_FN_DEFERRED]=1 \{\
.                   nr #FN_DEFER 1
.                   nr #FN_DEPTH +\\n[#DIVER_DEPTH]
.                   rr #GET_DEPTH
.\" This is required so that the defer space clause can distinguish
.\" a real #FN_COUNT=1 from one generated if FOOTNOTE is run inside
.\" QUOTE, BLOCKQUOTE or EPIGRAPH
.                   if \\n[#DIVER_FN]=2 \{\
.                      nr #SAVED_DIVER_FN_COUNT \\n[#FN_COUNT]
.                      rr #DIVER_FN
.                   \}
.                \}
.             \}
.\" Calculate the footnote depth.
.             if \\n[#GET_DEPTH]=1 \{\
.\" Save the previous footnote depth (for use when there will be
.\" some overflowed footnote text).
.                nr #SAVED_FN_DEPTH_1 \\n[#FN_DEPTH]
.\" Add the depth of the current footnote to any already existent
.\" footnotes.
.                nr #FN_DEPTH +\\n[#DIVER_DEPTH]
.\" Special handling for run-on footnotes
.                if \\n[#RUN_ON]=1 \{\
.                   if \\n[#RUNON_FOOTNOTES] \{\
.                      unformat RUNON_FOOTNOTES
.                   \}
.                   if \\n[#RUNON_FN_IN_DIVER] \{\
.                      unformat RUNON_FN_IN_DIVER
.                   \}
.                   ev FOOTNOTES
.\" Recreate FOOTNOTES with rule followed by text of unformatted
.\" run-on footnotes.
.                   di FOOTNOTES
.                   ie \\n[#FN_RULE]=0 \{ .RLD 1v \}
.                   el \{\
.                      PRINT \v'-\\n[#FN_RULE_ADJ]u'\l'\\n[#FN_RULE_LENGTH]u'\v'+\\n[#FN_RULE_ADJ]u'
.                   \}
.                   br
.                   if \\n[#RUNON_FOOTNOTES] \{\
.                      RUNON_FOOTNOTES
.                      rr #RUNON_FOOTNOTES
.                   \}
.                   if \\n[#RUNON_FN_IN_DIVER] \{\
.                      RUNON_FN_IN_DIVER
.                      rr #RUNON_FN_IN_DIVER
.                   \}
.                   br
.                   di
.                   ev
.                   nr #FN_DEPTH \\n[#DIVER_DEPTH]
.                   nr #SAVED_VFP 0+\\n[#VARIABLE_FOOTER_POS]
.                   nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]u
.                \}
.\" Save the new depth
.                nr #SAVED_FN_DEPTH_2 \\n[#FN_DEPTH]
.\" Signal that defer space should be added when PROCESS_FN_LEFTOVER
.\" processes deferred footnotes.
.                if \\n[#FN_DEFER] \{\
.                   if \\n[#FN_COUNT]=2 \{\
.                      ie \\n[#COLUMNS] \{\
.                         if !\\n[#FROM_FOOTER] \{\
.                            if \\n[#FN_DEFER]=1 \{ .nr #FN_DEFER_SPACE 1 \}
.                            if \\n[#FN_COUNT_FOR_COLS]>=1 \{ .rr #FN_DEFER_SPACE \}
.                            if \\n[#FROM_HEADER] \{ .nr #FN_DEFER_SPACE 1 \}
.                         \}
.                      \}
.                      el \{\
.                         nr #FN_DEFER_SPACE 1
.                      \}
.                   \}
.                   rr #FN_DEFER
.                \}
.\" If the depth of the whole footnote won't fit in the space
.\" between where we are on the page and the bottom margin, calculate
.\" how much of it will fit.
.                if \\n[#FN_DEPTH]>\\n[#SPACE_REMAINING] \{\
.                   nr #FN_LINES 0 1
.                   while (\\n+[#FN_LINES]*\\n[#FN_LEAD])<\\n[#SPACE_REMAINING] \{\
.                      nr #FN_DEPTH (\\n[#FN_LINES]*\\n[#FN_LEAD])
.\}
.                   nr #VFP_DIFF \\n[#FN_DEPTH]-\\n[#SAVED_FN_DEPTH_1]
.                   nr #OVERFLOW 1
.\" Very occasionally, #VFP_DIFF, on a 1st footnote that isn't to
.\" be deferred, comes up with a depth equal to exactly 1 line
.\" of footnotes, i.e. enough room to print the rule and nothing
.\" else.  The following tests for such a condition, and rather than
.\" attempting to treat the footnote as an overflow, it tells mom to
.\" treat it as a special kind of deferred footnote (#FN_DEFER 2).
.                   if \\n[#SAVED_FN_DEPTH_1]=0 \{\
.                      if \\n[#FN_DEPTH]=\\n[#FN_LEAD] \{\
.                         nr #FN_DEFER 2
.                         nr #FN_DEPTH \\n[#SAVED_FN_DEPTH_2]
.                         rr #OVERFLOW
.                      \}
.                   \}
.                \}
.\" Calculate VFP based on whether the footnote overflows, or is to
.\" be treated normally.
.                ie \\n[#OVERFLOW]=1 \{\
.                   if \\n[#RUN_ON] \{\
.                      rr #VARIABLE_FOOTER_POS
.                      nr #VARIABLE_FOOTER_POS \\n[#SAVED_VFP]
.                   \}
.                   ie \\n[#FN_COUNT]=1 \{\
.                      ie \\n[#RULED]=1 \{\
.                         ie \\n[#COLUMNS]=1 \{\
.                            ie \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                               ie \\n[#FROM_FOOTER] \{\
.                                  ie \\n[#FN_COUNT_FOR_COLS]>1 \{\
.                                     nr #FN_DEPTH -\\n[#FN_DEPTH]
.                                     if \\n[#DIVERTED]=1 \{ .nr #DIVERTED 3 \}
.                                     if !\\n[#PREV_FN_DEFERRED]=1 \{\
.                                        nr #FN_DEPTH -\\n[#VFP_DIFF]
.                                     \}
.                                  \}
.                                  el \{\
.                                     nr #VARIABLE_FOOTER_POS -\\n[#FN_DEPTH]
.                                     if \\n[#DIVERTED]=1 \{ .nr #DIVERTED 3 \}
.                                  \}
.                               \}
.                               el \{\
.                                  nr #VARIABLE_FOOTER_POS -(\\n[#FN_DEPTH])
.                               \}
.                            \}
.                            el \{\
.                               nr #VARIABLE_FOOTER_POS -(\\n[#FN_DEPTH])
.                            \}
.                         \}
.                         el \{ .nr #VARIABLE_FOOTER_POS -(\\n[#FN_DEPTH]) \}
.                      \}
.                      el \{\
.                         nr #VARIABLE_FOOTER_POS -\\n[#VFP_DIFF]
.                         if \\n[#DIVERTED]=1 \{ .nr #DIVERTED 3 \}
.                         if !\\n[#PREV_FN_DEFERRED]=1 \{\
.                            ie \\n[#COLUMNS]=1 \{\
.                               if !\\n[#FROM_FOOTER] \{\
.
.                               \}
.                            \}
.                            el \{\
.                               nr #FN_DEPTH -\\n[#VFP_DIFF]
.                            \}
.                         \}
.                         if \\n[#DIVERTED]=3 \{\
.                            if !\\n[#PREV_FN_DEFERRED] \{\
.                               if !\\n[#FROM_FOOTER] \{\
.                                  if \\n[#FN_COUNT]=1 \{\
.                                     if !\\n[#VFP_DIFF] \{\
.                                        if \\n[#FN_MARKER_STYLE]=1 \{\
.                                           da FOOTNOTES
\!.                                            ALD \\n[#FN_LEAD]u
.                                           di
.                                        \}
.                                        if \\n[#RESET_FN_NUMBER] \{\
.                                           da FOOTNOTES
\!.                                            ALD \\n[#FN_LEAD]u
.                                           di
.                                        \}
.                                     \}
.                                  \}
.                               \}
.                            \}
.                         \}
.                      \}
.                      nr #VARIABLE_FOOTER_POS -\\n[#VFP_DIFF]
.                      nr #FN_DEPTH \\n[#SAVED_FN_DEPTH_1]+\\n[#VFP_DIFF]
.                   \}
.                   el \{\
.                      nr #VARIABLE_FOOTER_POS -\\n[#VFP_DIFF]
.                      nr #FN_DEPTH \\n[#SAVED_FN_DEPTH_1]+\\n[#VFP_DIFF]
.                   \}
.                   rr #OVERFLOW
.                   rr #RULED
.                \}
.                el \{\
.                   nr #VARIABLE_FOOTER_POS -\\n[#DIVER_DEPTH]
.                   if \\n[#PREV_FN_DEFERRED]=1 \{\
.                      if \\n[#DIVERTED] \{\
.                         if !\\n[#FN_DEPTH]=\\n[#SAVED_FN_DEPTH_1] \{\
.                            nr #FN_DEPTH +\\n[#FN_LEAD]
.                            nr #VARIABLE_FOOTER_POS -\\n[#FN_LEAD] 
.                            rr #PREV_FN_DEFERRED
.                         \}
.                      \}
.                   \}
.                   if \\n[#FN_COUNT]>1 \{\
.                      nr #NO_BACK_UP 1
.                      rr #DIVERTED
.                      rr #RULED
.                   \}
.                \}
.             \}
.          \}
.          ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.\" See VFP_CHECK for an explanation of the next lines.
.\" The trap has to be removed, prior to setting it, each time
.\" FOOTNOTE is run.
.          if \\n[#PRINT_STYLE]=2 \{\
.             ch VFP_CHECK
.             wh \\n[#VARIABLE_FOOTER_POS]u-\\n[#DOC_LEAD]u VFP_CHECK
.          \}
.\" If we have a footnote whose text has to be deferred to the next
.\" page, reset the FOOTER trap to its original location.
.          if \\n[#FN_DEFER] \{\
.             nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]u
.             ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.          \}
.       \}
.       nr #NO_FN_MARKER 0
.    \}
.    if \\n[#ADD_BREAK] \{\
.       br
.       rr #ADD_BREAK
.    \}
.END
\#
\# Utility macros to manage footnotes that occur inside diversions
\# ---------------------------------------------------------------
\#
.ig
There are some redundancies here; they're left in in case unforeseen
footnote situations crop up in the future that might require
manipulation of them.
..
\#
\# 1. Pre-footnote processing for footnotes in diversions
\#
\# a) A footnote inside a diversion will be moved entirely (marker
\# in running text and text of footnote) to the next page/column.
\# 
.MAC DIVER_FN_1_PRE END
.    nr #RESET_FN_COUNTERS 1
.    nr #COUNTERS_RESET 1
.    if \\n[#DONE_ONCE]=1 \{\
.       if \\n[#FN_DEFER] \{\
.          if \\n[#SAVED_DIVER_FN_COUNT]=1 \{\
.             ie \\n[#COLUMNS]=1 \{\
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] \{ .nr #FN_DEFER_SPACE 1 \}
.             \}
.             el \{\
.                nr #FN_DEFER_SPACE 1
.             \}
.          \}
.       \}
.       if \\n[#FN_MARKER_STYLE]=1 \{\
.          if \\n[#FN_COUNT]>0 \{ .nr #FN_COUNT 0 1 \}
.          if \\n[#COLUMNS]=1 \{\
.             if \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                nr #FN_COUNT_FOR_COLS 0 1
.             \}
.          \}
.       \}
.       if \\n[#FN_MARKER_STYLE]=2 \{\
.          if \\n[#RESET_FN_NUMBER]=1 \{\
.             ie \\n[#COLUMNS]=1 \{\
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] \{ .nr #FN_NUMBER 0 1 \}
.             \}
.             el \{\
.                nr #FN_NUMBER 0 1
.             \}
.          \}
.       \}
.    \}
.END
\#
\# b) Treat as a normal footnote, including defers.
\#
.MAC DIVER_FN_2_PRE END
.    nr #RESET_FN_COUNTERS 2
.END
\#
\# 2. Post-footnote processing for footnotes in diversions
\#
\# Even when a footnote inside a diversion is treated as
\# "normal," some manipulation of registers is required.  The
\# macro is called in DO_QUOTE (i.e. at the termination of
\# quotes and blockquotes) and in DO_EPIGRAPH.
\#
.MAC DIVER_FN_2_POST END
.    if \\n[#DONE_ONCE]=1 \{\
.       if \\n[#FN_MARKER_STYLE]=1 \{\
.          if \\n[#FN_COUNT]=0 \{\
.             nr #DONT_RULE_ME 1
.          \}
.          if \\n[#FN_COUNT]>0 \{\
.             nr #FN_COUNT 0 1
.          \}
.          if \\n[#COLUMNS]=1 \{\
.             if \\n[#COL_NUM]=\\n[#NUM_COLS] \{ .nr #FN_COUNT_FOR_COLS 0 1 \}
.             if !\\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.             \}
.          \}
.       \}
.       if \\n[#FN_MARKER_STYLE]=2 \{\
.          if \\n[#FN_COUNT]=0 \{\
.             nr #DONT_RULE_ME 1
.          \}
.          if \\n[#FN_COUNT]>0 \{\
.             nr #FN_COUNT 0 1
.          \}
.          if \\n[#RESET_FN_NUMBER]=1 \{\
.             ie \\n[#COLUMNS]=1 \{\
.                if \\n[#COL_NUM]=\\n[#NUM_COLS] \{ .nr #FN_NUMBER 0 1 \}
.             \}
.             el \{\
.                nr #FN_NUMBER 0 1
.             \}
.          \}
.       \}
.    \}
.END
\#
\# The main macros that handle footnote processing.
\# -----------------------------------------------
\#
.ig
Sometimes, #VARIABLE_FOOTER_POS sets FOOTER at a location that gives
the impression another line of running text could fit on the page.
VFP_CHECK is always set to the line just above the one where FOOTER
will be sprung, and checks for this condition.  If it exists, FOOTER
is set one line lower on the page, thus squeezing in an extra line
of running text.  This is a judgment call on my part, but seems to
work well.  If there are problems (e.g. footnotes really do look
jammed), the user should probably adjust FOOTNOTE_AUTOLEAD and/or
FOOTNOTE_RULE_ADJ.

The macro has to be run in its own environment, otherwise the first
word of the last line before the footnotes gets chopped.
..
\#
.MAC VFP_CHECK END
.    ev VFP_CHECK
.\" The trap also has to be removed each time VFP_CHECK is run
.    if \\n[#PRINT_STYLE]=2 \{\
.       ch VFP_CHECK
.       SIZESPECS
.       ie !\\n[#IN_DIVER] \{ .nr #PAGE_POS \\n(nl \}
.       el \{ .nr #PAGE_POS \\n(nl+\\n(.d+(\\n[#DOC_LEAD]) \}
.       nr #FOOTER_POS \\n[#PAGE_LENGTH]+(\\n[#VARIABLE_FOOTER_POS])
.       nr #SPACE_TO_FOOTER \\n[#FOOTER_POS]-\\n[#PAGE_POS]
.       nr #FN_GAP \\n[#SPACE_TO_FOOTER]%\\n[#DOC_LEAD]
.       if !\\n[#FN_GAP]<0 \{\
.          if \\n[#FN_GAP]<\\n[#DOC_LEAD] \{\
.             ie (\\n[#PAGE_POS]+(\\n[#FN_DEPTH]+\\n[#FN_GAP]))>(\\n[#VISUAL_B_MARGIN]) \{\
.                nr #VARIABLE_FOOTER_POS 0+\\n[#VARIABLE_FOOTER_POS]
.             \}
.             el \{\
.                ie \\n[#DOC_LEAD]-\\n[#FN_GAP]<\\n[#DESCENDER] \{\
.                   nr #VARIABLE_FOOTER_POS +\\n[#DOC_LEAD]
.                   ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.                \}
.                el \{\
.                   nr #VARIABLE_FOOTER_POS 0+\\n[#VARIABLE_FOOTER_POS]
.                \}
.             \}
.          \}
.       \}
.    \}
.    ev
.END
\#
.ig
FN_OVERFLOW_TRAP starts off "underneath" FOOTER, but is revealed
as #VARIABLE_FOOTER_POSITION changes the position of FOOTER.
FN_OVERFLOW_TRAP simply starts diversion FN_OVERFLOW to "catch"
the overflow.  The diversion is ended in FOOTER, immediately after
FOOTER outputs the diversion, FOOTNOTES, before PROCESS_FN_LEFTOVER
is run (either in HEADER, or in FOOTER if moving col to col).
..
\#
.MAC FN_OVERFLOW_TRAP END 
.    if \\n[#FN_COUNT] \{\
.       di FN_OVERFLOW
.       ie !\\n[#NO_BACK_UP]=1 \{\
.          if \\n[#PREV_FN_DEFERRED] \{\
.             ie \\n[#COLUMNS]=1 \{\
.                if \\n[#FROM_FOOTER] \{\
.                   if \\n[#PREV_FN_DEFERRED] \{\
.                      if !\\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                      rr #PREV_FN_DEFERRED
.                      \}
.                   \}
.                \}
.                if !\\n[#FROM_FOOTER] \{\
.                   if !\\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.                      if !\\n[#LAST_FN_COUNT_FOR_COLS]>1 \{\
\!.                       RLD \\n[#FN_LEAD]u
.                      \}
.                   \}
.                \}
.             \}
.             el \{\
\!.              RLD \\n[#FN_LEAD]u
.             \}
.          \}
.       \}
.       el \{\
.          rr #NO_BACK_UP
.          rr #PREV_FN_DEFERRED
.       \}
.    \}
.\" When #FROM_DIVERT_FN is 1, it signals to FOOTNOTE, when run from
.\" within DIVERT_FN_LEFTOVER, to set #SPACE_REMAINING to the total
.\" area allowable for running text.
.    nr #FROM_DIVERT_FN 1
.END
\#
.ig
PROCESS_FN_LEFTOVER is called at the top of HEADER, and in
FOOTER if we're moving from one column to the next (i.e. after
outputting FOOTNOTES).  It checks for whether we have a "deferred
footnote" situation, and resets counters and number registers
accordingly.  Lastly, if we have some footnote overflow, it calls
DIVERT_FN_OVERFLOW.
..
\#
.MAC PROCESS_FN_LEFTOVER END
.    if \\n[#PREV_FN_DEFERRED]=2 \{\
.       if \\n[#FN_COUNT_AT_FOOTER]>1 \{ .rr #PREV_FN_DEFERRED \}
.    \}
.    if !\\n[#FN_DEFER] \{\
.       nr #FN_COUNT 0 1
.       nr #FN_DEPTH 0
.       nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]
.    \}
.    if r#FN_DEFER \{\
.       if \\n[#FN_DEFER]=1 \{\
.          nr #VARIABLE_FOOTER_POS -\\n[#FN_DEPTH]
.       \}
.       if \\n[#FN_DEFER]=2 \{\
.          nr #FN_DEPTH 0
.          nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]
.       \}
.    \}
.    nr #SPACE_REMAINING 0
.    ch FOOTER -\\n[#B_MARGIN]u
.    if \\n[#FN_DEFER] \{\
.       nr #NO_FN_MARKER 1
.       FOOTNOTE
.       nf
.       FOOTNOTE OFF
.       ie \\n[#COLUMNS]=1 \{\
.          if \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.             if !\\n[#FROM_FOOTER] \{\
.                if \\n[#FN_COUNT_FOR_COLS]=1 \{ .nr #PREV_FN_DEFERRED 1 \}
.             \}
.          \}
.       \}
.       el \{ .nr #PREV_FN_DEFERRED 1 \}
.    \}
.    if !\\n[#FN_DEFER] \{\
.       if \\n[#FN_OVERFLOW_DEPTH] \{\
.          DIVERT_FN_LEFTOVER
.       \}
.    \}
.    ie \\n[#COLUMNS]=1 \{\
.       if \\n[#COL_NUM]>1 \{\
.          if \\n[#COL_NUM]=\\n[#NUM_COLS] \{ .nr #FN_COUNT 0 1 \}
.       \}
.    \}
.    el \{ .nr #FN_COUNT 0 1 \}
.    if \\n[#DIVER_FN]=2 \{ .rr #DIVER_FN \}
.    rr #FROM_DIVERT_FN
.END
\#
.ig
DIVERT_FN_LEFTOVER is called in PROCESS_FN_LEFTOVER (at
the top of HEADER, and in FOOTER if we're moving from one column
to the next).
..
\#
.MAC DIVERT_FN_LEFTOVER END
.    nr #NO_FN_MARKER 1
.    nr #DIVERTED 1
.    FOOTNOTE
.    nf
.    FN_OVERFLOW
.    FOOTNOTE OFF
.    if \\n[#PREV_FN_DEFERRED] \{\
.       nr #FN_DEPTH -\\n[#FN_LEAD]
.       nr #VARIABLE_FOOTER_POS +\\n[#FN_LEAD]  
.       ch FOOTER \\n[#VARIABLE_FOOTER_POS]u
.       if \\n[#PREV_FN_DEFERRED]=2 \{\
.          nr #PREV_FN_DEFERRED 1
.          rr #DIVERTED
.       \}
.    \}
.    rr #FN_OVERFLOW_DEPTH
.END
\#
.ig
This is a special macro to deal with footnotes that are set inside
diversions (QUOTE, BLOCKQUOTE and EPIGRAPH).  It's called in HEADER
(and in FOOTER, if we're moving from column to column), and comes
after PROCESS_FOOTNOTE_LEFTOVER in those two macros.
..
\#
.MAC PROCESS_FN_IN_DIVER END
.    nr #SPACE_REMAINING 0
.    ch FOOTER -\\n[#B_MARGIN]u
.    nr #NO_FN_MARKER 1
.    if !\\n[#RESET_FN_COUNTERS]=2 \{\
.       rr #RESET_FN_COUNTERS
.    \}
.    FOOTNOTE
.    if \\n[#FN_OVERFLOW_DEPTH] \{ .nf \}
.    ie dRUNON_FN_IN_DIVER \{\
.       RUNON_FN_IN_DIVER
.       rm RUNON_FN_IN_DIVER
.    \}
.    el \{\
.       nf
.       FN_IN_DIVER
.    \}
.    FOOTNOTE OFF
.    rr #DIVER_FN
.END
\#
\# ====================================================================
\#
\# +++ENDNOTES+++
\#
.ig
When endnotes are output, the spacing between the notes is always
1 extra linespace.  This can have bottom margin consequences.  If
this doesn't bother you, don't worry about it.  If it does bother
you, and you want to adjust the spacing between any two endnotes (as
they're output), make the spacing adjustments (.ALD/.RLD) at the
*end* of endnotes (i.e. just before .ENDNOTE OFF), not at the top.

Endnotes must be output manually with .ENDNOTES. This allows user
the flexibility to output endnotes at the end of each collated
document, or to output them at the end of the entire document.
..
\#
\# Control macros
\#
\# ENDNOTE POINT SIZE
\# ------------------
\# *Argument:
\#   <base point size for endnotes>
\# *Function:
\#   Creates or modifies register #EN_PS.
\# *Notes:
\#   Default is same as running text in body of document.
\#
\#   This size control macro differs from other size control macros
\#   in that it sets an absolute point size, not a relative one.  This
\#   is because a) endnotes always appear separate from the body of
\#   a document and therefore don't need to be relative to the body
\#   of the document, and b) there are quite a few elements of the
\#   endnotes page(s) that need to be relative to the base point size
\#   of that page.  If the base endnote point size were relative to
\#   the body of the document (i.e. a _SIZE macro taking a +|- value)
\#   getting the rest of the endnote elements sized properly could
\#   become very confusing.
\#
.MAC ENDNOTE_PT_SIZE END
.    nr #EN_PS (p;\\$1)
.END
\#
\#
\# ENDNOTE LEAD
\# ------------
\# *Argument:
\#   <base leading to use in endnotes> [ ADJUST ]
\# *Function:
\#   Creates or modifies register #EN_LEAD.  Creates or removes
\#   register #ADJ_EN_LEAD.  Stores arguments in strings if ENDNOTE_LEAD
\#   set before START.
\# *Notes:
\#   Default is 14 points for TYPESET, adjusted; 24 for TYPEWRITE.
\#
.MAC ENDNOTE_LEAD END
.    if !\\n[#OK_PROCESS_LEAD] \{\
.       ds $EN_LEAD \\$1
.       if !'\\$2'' \{\
.           ds $ADJUST_EN_LEAD \\$2
.       \}
.       return
.    \}
.    rr #ADJ_EN_LEAD
.    nr #EN_LEAD (p;\\$1)
.    if '\\$2'ADJUST' \{\
.       nr #ORIG_DOC_LEAD \\n[#DOC_LEAD]
.       nr #RESTORE_ADJ_DOC_LEAD \\n[#ADJ_DOC_LEAD]
.       nr #ADJ_DOC_LEAD 1
.       nr #ADJ_EN_LEAD 1
.       nr #NO_TRAP_RESET 1
.       DOC_LEAD \\n[#EN_LEAD]u ADJUST
.       nr #EN_LEAD \\n[#DOC_LEAD]
.       DOC_LEAD \\n[#ORIG_DOC_LEAD]u
.       rr #NO_TRAP_RESET
.       nr #ADJ_DOC_LEAD \\n[#RESTORE_ADJ_DOC_LEAD]
.       rr #ORIG_DOC_LEAD
.    \}
.END
\#
\#
\# ENDNOTES_HDRFTR_CENTER
\# ----------------------
\# *Argument:
\#   toggle
\# *Function:
\#   Creates or removes toggle register #EN_HDRFTR_CENTER, used to
\#   determine whether mom should print a/the hdrftr center string
\#   on the endnotes page.  Primarily to enable/disable printing of the
\#   chapter name in hdrftrs when DOCTYPE CHAPTER.
\# *Notes:
\#   Default is OFF
\#
.MAC ENDNOTES_HDRFTR_CENTER END
.    ie '\\$1'' \{ .nr #EN_HDRFTR_CENTER 1 \}
.    el         \{ .rr #EN_HDRFTR_CENTER   \}
.END
\#
\#
\# ENDNOTE STRING 
\# --------------
\# *Argument:
\#   <title for endnotes page>
\# *Function:
\#   Creates or modifies string $EN_STRING.
\# *Notes:
\#   Default is "Endnotes"
\#
.MAC ENDNOTE_STRING END
.    ds $EN_STRING \\$1
.END
\#
\#
\# ENDNOTE STRING UNDERSCORE
\# -------------------------
\# *Arguments:
\#   toggle | 2
\# *Function:
\#   Turns underscoring of endnote main title on or off.  If the argument
\#   is the digit "2", turns on double-underscoring.
\# *Notes:
\#   Default is double-underscored.
\#
.MAC ENDNOTE_STRING_UNDERSCORE END
.    ie '\\$1'' \{ .nr #EN_STRING_UNDERSCORE 1 \}
.    el \{\
.       ie '\\$1'2' \{ .nr #EN_STRING_UNDERSCORE 2 \}
.       el \{ .nr #EN_STRING_UNDERSCORE 0 \}
.    \}
.END
\#
\#
\# ENDNOTE STRING CAPS
\# -------------------
\# *Arguments:
\#   <none> | <anything>
\# *Function:
\#   Turns capitalization of the endnotes pages title string
\#   "Endnotes" on or off.
\# *Notes:
\#   Users may want the endnotes pages title string to be in caps,
\#   but the toc entry for endnotes in lower case.  If the argument
\#   to ENDNOTE_STRING is in lower case and ENDNOTE_STRING_CAPS is
\#   turned on, this is exactly what will happen.
\#
\#   Default is on.
\#
.MAC ENDNOTE_STRING_CAPS END
.   ie '\\$1'' \{ .nr #EN_STRING_CAPS 1 \}
.   el \{ .rr #EN_STRING_CAPS \}
.END
\#
\#
\# ENDNOTE TITLE
\# -------------
\# *Argument:
\#   <string that appears before the first endnote pertaining to any document>
\# *Function:
\#   Creates string $EN_TITLE_STRING.
\# *Notes:
\#   Default is the document title, or, if doc is a chapter, "Chapter #"
\#
.MAC ENDNOTE_TITLE END
.    ds $EN_TITLE \\$1
.END
\#
\#
.MAC ENDNOTE_TITLE_SPACE END
.    nr #EN_TITLE_SPACE (\\$1)
.END
\#
\#
\# ENDNOTE TITLE UNDERSCORE
\# ------------------------
\# *Argument:
\#   toggle
\# *Function:
\#   Creates or removes register #EN_TITLE_UNDERSCORE.
\# *Notes:
\#   Default is to underscore the endnote titles.
\#
.MAC ENDNOTE_TITLE_UNDERSCORE END
.    ie '\\$1'' \{ .nr #EN_TITLE_UNDERSCORE 1 \}
.    el \{ .rr #EN_TITLE_UNDERSCORE \}
.END
\#
\#
\# ENDNOTE MARKER STYLE
\# --------------------
\# *Arguments:
\#   NUMBER | LINE
\# *Function:
\#   Sets register #EN_MARKER_STYLE, used in ENDNOTE to determine
\#   the style of endnote markers (labels).
\# *Notes:
\#   1=NUMBER; 2=LINE.  LINE means "use output line numbers".
\#   Default is NUMBER.
\#
.MAC ENDNOTE_MARKER_STYLE END
.    if '\\$1'NUMBER' \{\
.       nr #EN_MARKER_STYLE 1
.    \}
.    if '\\$1'LINE' \{\
.       nr #EN_MARKER_STYLE 2
.       if !\\n[#EN_LN_SEP] \{\
.          if !\\n[#EN_LN_BRACKETS] \{ .ENDNOTE_LINENUMBER_BRACKETS SQUARE \}
.       \}
.    \}
.END
\#
\#
\# ENDNOTE LINENUMBER MARK
\# -----------------------
\# *Function:
\#   This string, when called inline, stores the current output line
\#   number in register #EN_MARK for use with ENDNOTE.
\#
.ds EN-MARK \R'#EN_MARK \En(ln'
\#
\#
\# ENDNOTE LINENUMBER SEPARATOR
\# ----------------------------
\# *Argument:
\#   <user-defined separator>
\# *Function:
\#   Stores user-defined separator (for use then
\#   ENDNOTE_MARKER_STYLE is LINE) in string $EN_LN_SEP.  The
\#   separator is intended to be used when the user wishes a
\#   separator, rather than the choice of brackets offered by
\#   ENDNOTE_LINENUMBER_BRACKETS.
\#
.MAC ENDNOTE_LINENUMBER_SEPARATOR END
.    rr #EN_LN_BRACKETS
.    nr #EN_LN_SEP 1
.    ds $EN_LN_SEP "\\$1
.END
\#
\#
\# ENDNOTE LINENUMBER BRACKETS
\# ---------------------------
\# *Argument:
\#   PARENS | SQUARE | BRACES or ( | [ | {
\# *Function:
\#   Sets register #EN_LN_BRACKETS to 1, and creates strings
\#   $EN_OPEN_BRACKET and $EN_CLOSE_BRACKET according to the given argument.
\#
.MAC ENDNOTE_LINENUMBER_BRACKETS END
.    rr #EN_LN_SEP
.    nr #EN_LN_BRACKETS 1
.    if '\\$1'PARENS' \{\
.       ds $EN_OPEN_BRACKET (
.       ds $EN_CLOSE_BRACKET )
.    \}
.    if '\\$1'(' \{\
.       ds $EN_OPEN_BRACKET (
.       ds $EN_CLOSE_BRACKET )
.    \}
.    if '\\$1'SQUARE' \{\
.       ds $EN_OPEN_BRACKET [
.       ds $EN_CLOSE_BRACKET ]
.    \}
.    if '\\$1'[' \{\
.       ds $EN_OPEN_BRACKET [
.       ds $EN_CLOSE_BRACKET ]
.    \}
.    if '\\$1'BRACES' \{\
.       ds $EN_OPEN_BRACKET {
.       ds $EN_CLOSE_BRACKET }
.    \}
.    if '\\$1'{' \{\
.       ds $EN_OPEN_BRACKET {
.       ds $EN_CLOSE_BRACKET }
.    \}
.END
\#
\#
\# ENDNOTE LINENUMBER GAP
\# ----------------------
\# *Argument:
\#   <space between line-number labels and endnotes text>
\# *Function:
\#   Defines string $EN_LN_GAP, used during printing of line-number
\#   labels in ENDNOTE.
\#
.MAC ENDNOTE_LINENUMBER_GAP END
.    ds $EN_LN_GAP \\$1
.END
\#
\#   
\# ENDNOTE NUMBERS ALIGN RIGHT
\# ---------------------------
\# *Argument:
\#   <max. number of digit placeholders that will appear in endnotes>
\# *Function:
\#   Toggles register #EN_NUMBERS_ALIGN_RIGHT on; creates register
\#   #EN_NUMBER_PLACEHOLDERS.
\# *Notes:
\#   Default is for footnote numbers to be right aligned to 2 placeholders.
\#
.MAC ENDNOTE_NUMBERS_ALIGN_RIGHT END
.    rr #EN_NUMBERS_ALIGN_LEFT
.    nr #EN_NUMBERS_ALIGN_RIGHT 1
.    nr #EN_NUMBER_PLACEHOLDERS \\$1
.END
\#
\#
\# ENDNOTE NUMBERS ALIGN LEFT
\# --------------------------
\# *Argument:
\#   none
\# *Function:
\#   Toggles register #EN_NUMBERS_ALIGN_LEFT on.
\# *Notes:
\#   Default is for footnote numbers to be right aligned to 2 placeholders
\#   (i.e. not left aligned).
\#
.MAC ENDNOTE_NUMBERS_ALIGN_LEFT END
.    rr #EN_NUMBERS_ALIGN_RIGHT
.    nr #EN_NUMBERS_ALIGN_LEFT 1
.END
\#
\#
\# ENDNOTE PARAGRAPH INDENT
\# ------------------------
\# *Argument:
\#   <first line indent of paras subsequent to 1st in endnotes>
\# *Function:
\#   Creates register #EN_PP_INDENT for use in .PP.
\# *Notes:
\#   Requires a unit of measure.
\#
\#   Default is 1.5m for TYPESET; same indent as PARA_INDENT for TYPEWRITE.
\#
.MAC ENDNOTE_PARA_INDENT END
.    nr #EN_PP_INDENT (\\$1)
.END
\#
\#
\# TURN OFF COLUMN MODE FOR ENDNOTES
\# ---------------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #EN_NO_COLS
\# *Notes:
\#   Allows user to tell mom not to set endnotes in columnar
\#   documents in columns.  Default is to set endnotes in columns.
\#
.MAC ENDNOTES_NO_COLUMNS END
.    ie '\\$1'' \{ .nr #EN_NO_COLS 1 \}
.    el \{ .rr #EN_NO_COLS \}
.END
\#
\#
\# NO FIRST PAGE NUMBER ON ENDNOTES FIRST PAGE
\# -------------------------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #EN_NO_FIRST_PN
\# *Notes:
\#   For use if FOOTERS are on.  Tells ENDNOTES not to put a page
\#   number on the first endnotes page.  Some users may want this.
\#   Default is to print a page number at the top of the first
\#   endnotes page when footers are on.
\#
.MAC ENDNOTES_NO_FIRST_PAGENUM END
.    ie '\\$1'' \{ .nr #EN_NO_FIRST_PN 1 \}
.    el \{ .rr #EN_NO_FIRST_PN \}
.END
\#
\#
\# PAGE HEADERS ON ENDNOTES PAGES
\# ------------------------------
\# *Argument:
\#   <none> | ALL
\# *Function:
\#   Creates or removes register #EN_ALLOWS_HEADERS or
\#   #EN_ALLOWS_HEADERS_ALL
\# *Notes:
\#   Whether ENDNOTES puts a page header at the top of endnotes
\#   pages if page headers are used throughout the document.
\#   Default is to insert the page headers, but not on the first
\#   page.  If the optional argument ALL is given, ENDNOTES puts a
\#   page header on the first page as well.
\#
.MAC ENDNOTES_ALLOWS_HEADERS END
.    ie '\\$1'' \{ .nr #EN_ALLOWS_HEADERS 1 \}
.    el \{\
.       ie '\\$1'ALL' \{\
.          nr #EN_ALLOWS_HEADERS 1
.          nr #EN_ALLOWS_HEADERS_ALL 1
.       \}
.       el \{\
.          rr #EN_ALLOWS_HEADERS
.          rr #EN_ALLOWS_HEADERS_ALL
.       \}
.    \}
.END
\#
\#
\# ENDNOTES PAGES PAGE NUMBERING STYLE
\# -----------------------------------
\# *Argument:
\#   DIGIT | ROMAN | roman | ALPHA | alpha
\# *Function:
\#   Creates or modifies $EN_PN_STYLE.
\# *Notes:
\#   Allows user to define what style should be used for endnotes
\#   pages page numbering.  Arguments are the same as for
\#   PAGENUM_STYLE.
\#
\#   Default is DIGIT.
\#
.MAC ENDNOTES_PAGENUM_STYLE END
.    ds $EN_PN_STYLE \\$1
.END
\#
\#
\# FIRST PAGE NUMBER FOR ENDNOTES
\# ------------------------------
\# *Argument:
\#   <page number that appears on page 1 of endnotes pages>
\# *Function:
\#   Creates or modifies string $EN_FIRST_PN
\# *Notes:
\#   To be used with caution, only if all endnotes
\#   are to be output at once, i.e. not at the end of the separate
\#   docs of a collated doc
\#
.MAC ENDNOTES_FIRST_PAGENUMBER END
.    nr #EN_FIRST_PN \\$1
.END
\#
\# SINGLESPACE ENDNOTES
\# --------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Sets lead of endnotes pages in TYPEWRITE to 12 points,
\#   adjusted.
\# *Notes:
\#   Default is to double-space endnotes pages.
\#
.MAC SINGLESPACE_ENDNOTES END
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE] \{\
.          nr #EN_SINGLESPACE 1
.          rr #IGNORE
.          if \\n[#OK_PROCESS_LEAD] \{\
.             ENDNOTE_LEAD 12 ADJUST
.             nr #IGNORE 1
.          \}
.       \}
.       el \{\
.          ie '\\$1'' \{\
.             nr #EN_SINGLESPACE 1
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                ENDNOTE_LEAD 12 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.          el \{\
.             rr #EN_SINGLESPACE
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                ENDNOTE_LEAD 24 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.       \}
.    \}
.END
\#
\#
\# ENDNOTE PARAGRAPH SPACE
\# -----------------------
\# *Argument:
\#   toggle
\# *Function:
\#   Creates toggle register #EN_PP_SPACE for use in .PP.
\# *Notes:
\#   Like PARA_SPACE.  Default is not to space endnote paras.
\#
.MAC ENDNOTE_PARA_SPACE END
.    ie '\\$1'' \{ .nr #EN_PP_SPACE 1 \}
.    el \{ .rr #EN_PP_SPACE \}
.END
\#
\#
\# ENDNOTE
\# -------
\# *Argument:
\#   toggle
\# *Function:
\#   Places superscript endnote number in text, then collects and
\#   processes endnote in diversion END_NOTES.
\# *Notes:
\#   \c must be appended to the word immediately preceding .ENDNOTE
\#   when ENDNOTE_MARKER_STYLE is NUMBER.
\#
.MAC ENDNOTE END
.    if !\\n(.u \{ .nr #ADD_BREAK 1 \}
.    ie '\\$1'' \{\
.       nr #ENDNOTE 1
.       if \\n[#EN_MARKER_STYLE]=1 \{\
.          if \\n[#CONDENSE] \{ \*[CONDX]\c \}
.          if \\n[#EXTEND]   \{ \*[EXTX]\c  \}
.          if \\n[#PRINT_STYLE]=1 \{\
.             if \\n[#UNDERLINE_ON] \{\
.                nr #UNDERLINE_WAS_ON 1
.                UNDERLINE OFF
.             \}
.             if \\n[#SLANT_ON] \{\
.                 nr #SLANT_WAS_ON 1
\*[SLANTX]\c
.             \}
.             PRINT "\s-2\v'-\\n[#DOC_LEAD]u/5u'\\n+[#EN_NUMBER]\v'+\\n[#DOC_LEAD]u/5u'\s+2\c"
.          \}
.          if \\n[#PRINT_STYLE]=2 \{ .PRINT "\*[SUP]\\n+[#EN_NUMBER]\*[SUPX]\c" \}
.       \}
.       if \\n[#EN_MARKER_STYLE]=2 \{\
.          if !\\n[#LINENUMBERS] \{\
.             tm1 "[mom]: Line numbering must be enabled with NUMBER_LINES when
.             tm1 "       ENDNOTE_MARKER_STYLE is LINE.
.             ab Aborting on ENDNOTE at line \\n(.c.
.          \}
.          if \\n[#EN_MARK]=0 \{ .nr #EN_MARK \\n(ln \}
.          nr #EN_MARK_2 \\n(ln
.          if '\\n(.z'P_QUOTE' \{\
.             nr #EN_MARK -1
.             nr #EN_MARK_2 -1
.          \}
.       \}
.       nr #PP_STYLE_PREV \\n[#PP_STYLE]
.       nr #PP_STYLE 1
.       if \\n[#INDENT_FIRST_PARAS] \{ .nr #INDENT_FIRSTS 1 \}
.       INDENT_FIRST_PARAS
.       ev EN
.       da END_NOTES
.       LL \\n[#DOC_L_LENGTH]u
.       ta \\n(.lu
.       if \\n[#COLUMNS] \{\
.          ie \\n[#EN_NO_COLS] \{ .LL \\n[#DOC_L_LENGTH]u \}
.          el \{ .LL \\n[#COL_L_LENGTH]u \}
.          ta \\n(.lu
.       \}
.       vs \\n[#EN_LEAD]u
.       if \\n[#EN_NUMBER]=1 \{\
\!.        ne 3
.          if \\n[#PRINT_STYLE]=1 \{\
.             TYPEWRITER
.          \}
.          if \\n[#PRINT_STYLE]=2 \{\
.             FAMILY  \\*[$EN_TITLE_FAM]
.             FT      \\*[$EN_TITLE_FT]
.             PT_SIZE \\n[#EN_PS]u\\*[$EN_TITLE_SIZE_CHANGE]
.          \}
.          sp
.          if !'\\*[$EN_TITLE]'' \{\
.             if '\\*[$EN_TITLE_QUAD]'L'      \{ .LEFT   \}
.             if '\\*[$EN_TITLE_QUAD]'LEFT'   \{ .LEFT   \}
.             if '\\*[$EN_TITLE_QUAD]'C'      \{ .CENTER \}
.             if '\\*[$EN_TITLE_QUAD]'CENTER' \{ .CENTER \}
.             if '\\*[$EN_TITLE_QUAD]'CENTRE' \{ .CENTER \}
.             if '\\*[$EN_TITLE_QUAD]'R'      \{ .RIGHT  \}
.             if '\\*[$EN_TITLE_QUAD]'RIGHT'  \{ .RIGHT  \}
.             ie \\n[#EN_TITLE_UNDERSCORE] \{\
.                UNDERSCORE "\\*[$EN_TITLE]
.             \}
.             el \{\
.                PRINT "\\*[$EN_TITLE]
.             \}
.          \}
.       \}
.       ie \\n[#EN_NUMBER]=1 \{\
.          if !'\\*[$EN_TITLE]'' \{ .sp \}
.       \}
.       el \{ .sp \}
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          if \\n[#EN_MARKER_STYLE]=1 \{\
.             FAMILY  \\*[$EN_NUMBER_FAM]
.             FT      \\*[$EN_NUMBER_FT]
.             PT_SIZE \\n[#EN_PS]u\\*[$EN_NUMBER_SIZE_CHANGE]
.          \}
.          if \\n[#EN_MARKER_STYLE]=2 \{\
.             FAMILY  \\*[$EN_LN_FAM]
.             FT      \\*[$EN_LN_FT]
.             PT_SIZE \\n[#EN_PS]u\\*[$EN_LN_SIZE_CHANGE]
.          \}
.       \}
.       if \\n[#EN_MARKER_STYLE]=2 \{\
.          ENDNOTE_NUMBERS_ALIGN_LEFT
.          ie \\n[#EN_LN_BRACKETS]=1 \{\
.             ds $EN_LINENUMBER \v'-.085m'\\*[$EN_OPEN_BRACKET]\v'.085m'
.             ie \\n[#EN_MARK_2]=\\n[#EN_MARK] \{\
.                as $EN_LINENUMBER \\n[#EN_MARK]\v'-.085m'\\*[$EN_CLOSE_BRACKET]\v'.085m' \"
.             \}
.             el \{\
.                as $EN_LINENUMBER \\n[#EN_MARK]\v'-.1m'-\v'.1m'\\n[#EN_MARK_2]\v'-.085m'\\*[$EN_CLOSE_BRACKET]\v'.085m' \"
.             \}
.          \}
.          el \{\
.             ie \\n[#EN_MARK_2]=\\n[#EN_MARK] \{\
.                ds $EN_LINENUMBER \\n[#EN_MARK]\\*[$EN_LN_SEP]
.             \}
.             el \{\
.                ds $EN_LINENUMBER \\n[#EN_MARK]\v'-.1m'-\v'.1m'\\n[#EN_MARK_2]\\*[$EN_LN_SEP]
.             \}
.          \}
.          nr #EN_MARK 0
.       \}
\!.     TRAP OFF
.       nr #RESET_L_LENGTH \\n(.l
.       ie \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.          nr #EN_NUMBER_L_LENGTH \w'\0'*\\n[#EN_NUMBER_PLACEHOLDERS]+\w'.'
.          RIGHT
.       \}
.       el \{\
.          nr #EN_NUMBER_L_LENGTH \w'\En[#EN_NUMBER].\0'
.          LEFT
.       \}
.       if \\n[#EN_MARKER_STYLE]=2 \{\
.          if !\\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.             nr #EN_NUMBER_L_LENGTH \w'\\*[$EN_LINENUMBER]'+\\*[$EN_LN_GAP]
.             LEFT
.          \}
.       \}
.       ll \\n[#EN_NUMBER_L_LENGTH]u
.       if \\n[#EN_MARKER_STYLE]=1 \{\
\En[#EN_NUMBER].
.       \}
.       if \\n[#EN_MARKER_STYLE]=2 \{\
\\*[$EN_LINENUMBER]
.          rm $EN_LINENUMBER
.       \}
.       EOL
.       ll \\n[#RESET_L_LENGTH]u
.       nr #EN_FIGURE_SPACE \w'\0.'
.       ie \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.          in \\n[#EN_NUMBER_L_LENGTH]u+\\n[#EN_FIGURE_SPACE]u
.       \}
.       el \{\
.          ti \\n[#EN_NUMBER_L_LENGTH]u
.       \}
.       nr #EN_TEXT_INDENT \\n(.i
.       QUAD \\*[$EN_QUAD]
\!.     TRAP
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$EN_FAM]
.          FT      \\*[$EN_FT]
.          PT_SIZE \\n[#EN_PS]u
.       \}
.       if \\n[#REF]=1 \{\
.          ie !\\n[#EN_MARKER_STYLE]=2 \{\
.             if \\n[#EN_NUMBERS_ALIGN_LEFT] \{\
.                in \\*[$REF_EN_INDENT]
.                ti -(\\*[$REF_EN_INDENT]-\\n[#EN_NUMBER_L_LENGTH]u)
.             \}
.             if \\n[#EN_NUMBERS_ALIGN_RIGHT] \{\
.                in \\*[$REF_EN_INDENT]
.                ti -(\\*[$REF_EN_INDENT]-\\n[#EN_NUMBER_L_LENGTH]u-\\n[#EN_FIGURE_SPACE]u)
.             \}
.          \}
.          el \{\
.             if \\n[#EN_NUMBERS_ALIGN_LEFT] \{\
.                in \\*[$REF_EN_INDENT]
.                ti -(\\*[$REF_EN_INDENT]-\\n[#EN_NUMBER_L_LENGTH]u)
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       br
.          in 0
.       if \\n[#EN_MARKER_STYLE]=2 \{\
\!.        in 0
.       \}
.       di
.\" Restore sentence spacing
.       if \\n[#PRINT_STYLE]=2 \{\
.          if d$RESTORE_SS_VAR \{ .SS \\*[$RESTORE_SS_VAR] \}
.          rm $RESTORE_SS_VAR
.       \}
.       ev
.       nr #PP_STYLE \\n[#PP_STYLE_PREV]
.       if !\\n[#INDENT_FIRSTS] \{ .INDENT_FIRST_PARAS OFF \}
.       rr #INDENT_FIRSTS
.       rr #ENDNOTE
.       if \\n[#PRINT_STYLE]=1 \{\
.          if \\n[#UNDERLINE_WAS_ON] \{\
.             rr #UNDERLINE_WAS_ON
.             UNDERLINE
.          \}
.       \}
.       if \\n[#SLANT_WAS_ON] \{\
.          rr #SLANT_WAS_ON
\*[SLANT]\c
.       \}
.    \}
.    if \\n[#ADD_BREAK] \{\
.       br
.       rr #ADD_BREAK
.    \}
.END
\#
\#
\# ENDNOTES
\# --------
\# *Arguments:
\#   none
\# *Function:
\#   Sets new document leading from #EN_LEAD, breaks to a new page,
\#   sets up an endnotes page based on registers and strings associated
\#   with endnotes, then outputs diversion END_NOTES.
\#
.MAC ENDNOTES END
.    nr #ENDNOTES 1
.    nr #EN_FIRST_PAGE 1
.    nr #HEADER_STATE \\n[#HEADERS_ON]
.    ds $RESTORE_PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#HEADERS_ON]=1 \{\
.       if !\\n[#EN_ALLOWS_HEADERS_ALL] \{ .HEADERS OFF \}
.    \}
.    if \\n[#HEADER_STATE]=1 \{\
.       ie \\n[#EN_HDRFTR_CENTER]=1 \{ . \}
.       el \{ .rm $HDRFTR_CENTER  \}
.    \}
.    ie !\\n[#SUSPEND_PAGINATION] \{\
.       if \\n[#PAGINATE]=1 \{\
.          if \\n[#PAGE_NUM_V_POS]=1 \{\
.             PAGENUM_STYLE \\*[$EN_PN_STYLE]
.             if \\n[#EN_FIRST_PN] \{ .PAGENUMBER \\n[#EN_FIRST_PN]-1 \}
.             if r#EN_NO_FIRST_PN \{ .nr #PAGINATE 0 \}
.          \}
.       \}
.    \}
.    el \{\
.       ie \\n[#PAGE_NUM_V_POS]=2 \{ .nr #PAGINATE 1 \}
.       el \{ .nr #PAGINATE 0 \}
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       if !'\\*[$HDRFTR_CENTER_OLD]'' .ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_OLD]
.    \}
.    NEWPAGE
.    if \\n[#FOOTERS_ON]=1 \{\
.       ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_NEW]
.       rm $HDRFTR_CENTER_OLD
.       rm $HDRFTR_CENTER_NEW
.    \}
.    ie !\\n[#SUSPEND_PAGINATION] \{\
.       if \\n[#PAGE_NUM_V_POS]=1 \{\
.          if r#EN_NO_FIRST_PN \{\
.             if \\n[#PAGINATION_STATE]=1 \{\
.                nr #PAGINATE 1
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       if \\n[#PAGE_NUM_V_POS]=2 \{ .nr #PAGINATE 0 \}
.    \}
.    rr #PAGINATION_STATE
.    PAGENUM_STYLE \\*[$EN_PN_STYLE]
.    if \\n[#EN_FIRST_PN] \{ .PAGENUMBER \\n[#EN_FIRST_PN] \}
.    if \\n[#HEADER_STATE]=1 \{\
.       if \\n[#EN_ALLOWS_HEADERS] \{ .HEADERS \}
.    \}
.\" Collect endnotes title string for TOC
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.    ds $TOC_TITLE_ITEM \\*[$EN_STRING]\\|
.    ev TOC_EV
.    da TOC_ENTRIES
.    if \\n[#PRINT_STYLE]=1 \{\
.       TYPEWRITER
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_TITLE_FAM]
\!.     FT      \\*[$TOC_TITLE_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_TITLE_SIZE_CHANGE]
.    \}
\!.  TRAP OFF
.    ie \\n[#PRINT_STYLE]=1 \{\
\!.     PAD "\\*[$TOC_TITLE_ITEM]\\*[$TOC_PN_TYPEWRITE]" 
.    \}
.    el \{\
\!.     PAD "\\h'\\n[#TOC_TITLE_INDENT]u'\\*[$TOC_TITLE_ITEM]\\*[$TOC_PN]"
.    \}
\!.  EOL
\!.  ST 100 L
\!.  ST 101 R
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_PN_FAM]
\!.     FT      \\*[$TOC_PN_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.    \}
\!.  TAB 100
\!.  PRINT \\*[LEADER]
\!.  TN
\!.  TRAP
\!.  PRINT \\n[#TOC_ENTRY_PN]
\!.  TQ
.    di       
.    ev
.\" End collection of endnotes title string for TOC
.\" Process endnotes
.    if \\n[#PRINT_STYLE]=1 \{ .vs \\n[#EN_LEAD]u \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#EN_NO_COLS] \{\
.          if \\n[#COLUMNS] \{ .nr #COLUMNS_WERE_ON 1 \}
.          nr #COLUMNS 0
.       \}
.       nr #RESTORE_DOC_LEAD \\n[#DOC_LEAD]
.       ie \\n[#ADJ_EN_LEAD] \{\
.          nr #DOC_LEAD \\n[#EN_LEAD]
.       \}
.       el \{ .DOC_LEAD \\n[#EN_LEAD]u \}
.    \}
.    PRINT \&
.    ie r#EN_TITLE_SPACE \{ .sp |\\n[#EN_TITLE_SPACE]u \}
.    el \{ .sp |\\n[#T_MARGIN]u \}
.    mk ec
.    if \\n[#SLANT_ON] \{\
\*[SLANTX]\c
.    \}
.    ev ENDNOTES
.    if !'\\*[$EN_STRING]'' \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          vs \\n[#EN_LEAD]u
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          LL \\n[#DOC_L_LENGTH]u
.          ta \\n(.lu
.          if \\n[#COLUMNS] \{\
.             ie \\n[#EN_NO_COLS] \{ .LL \\n[#DOC_L_LENGTH]u \}
.             el \{ .LL \\n[#COL_L_LENGTH]u \}
.             ta \\n(.lu
.          \}
.          FAMILY  \\*[$EN_STRING_FAM]
.          FT      \\*[$EN_STRING_FT]
.          PT_SIZE \\n[#EN_PS]u\\*[$EN_STRING_SIZE_CHANGE]
.          vs      \\n[#EN_LEAD]u
.       \}
.       if '\\*[$EN_STRING_QUAD]'L'      \{ .LEFT   \}
.       if '\\*[$EN_STRING_QUAD]'LEFT'   \{ .LEFT   \}
.       if '\\*[$EN_STRING_QUAD]'C'      \{ .CENTER \}
.       if '\\*[$EN_STRING_QUAD]'CENTER' \{ .CENTER \}
.       if '\\*[$EN_STRING_QUAD]'CENTRE' \{ .CENTER \}
.       if '\\*[$EN_STRING_QUAD]'R'      \{ .RIGHT  \}
.       if '\\*[$EN_STRING_QUAD]'RIGHT'  \{ .RIGHT  \}
.       EOL
.       if \\n[#EN_STRING_CAPS] \{ .CAPS \}
.       ie \\n[#EN_STRING_UNDERSCORE] \{\
.          ie \\n[#EN_STRING_UNDERSCORE]=2 \{\
.             UNDERSCORE2 "\\*[$EN_STRING]
.          \}
.          el \{\
.             UNDERSCORE "\\*[$EN_STRING]
.          \}
.       \}
.       el \{\
.          PRINT "\\*[$EN_STRING]
.       \}
.    \}
.    CAPS OFF
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE]=1 \{\
.          ALD \\n[#EN_LEAD]u*2u
.       \}
.       el \{\
.          ie \\n[#EN_SINGLESPACE]=1 \{\
.              ALD \\n[#EN_LEAD]u*2
.          \}
.          el \{\
.
.          \}
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{ .ALD \\n[#EN_LEAD]u \}
.    QUAD \\*[$EN_QUAD]
.    nf
.    END_NOTES
.    br
.    ev
.    rm END_NOTES
.    if \\n[#PRINT_STYLE]=1 \{ .vs \\n[#DOC_LEAD]u \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#ADJ_EN_LEAD] \{\
.          nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]
.       \}
.       el \{ .DOC_LEAD \\n[#RESTORE_DOC_LEAD]u \}
.       rr #RESTORE_DOC_LEAD
.    \}
.    if \\n[#COLUMNS_WERE_ON] \{ .nr #COLUMNS 1 \}
.    if \\n[#HEADER_STATE]=1 \{ .HEADERS \}
.    if \\n[#LINENUMBERS]=2 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.    rr #ENDNOTES
.END
\#
\# ====================================================================
\#
\# +++BIBLIOGRAPHY+++
\#
.ig
Mom treats bibliographies and endnotes very similarly.  The chief
difference is that endnotes are collected and formatted inside a
diversion, while bibliographies are built "by hand."  ENDNOTES sets
up the endnotes page and outputs the formatted diversion.
BIBLIOGRAPHY sets up the bibliography page, then awaits refer
commands.

All of the bibliography control macros have their exact
counterparts in the endnotes control macros.  It was tempting to do
fancy stuff with aliases to avoid the repetition, but for reasons
of my own sanity, and for the benefit of anyone wanting to play
around with the bibliography control macros, I decided to keep them
separate.

Because the bibliography control macros all have endnotes
equivalents, refer to the appropriate, similar endnote macro for
Arguments, Function and Notes.
..
\# Bibliography control macros
\#
.MAC BIBLIOGRAPHY_PT_SIZE END
.    nr #BIB_PS (p;\\$1)
.END
\#
.MAC BIBLIOGRAPHY_LEAD END
.    if !\\n[#OK_PROCESS_LEAD] \{\
.       ds $BIB_LEAD \\$1
.       if !'\\$2'' \{\
.           ds $ADJUST_BIB_LEAD \\$2
.       \}
.       return
.    \}
.    rr #ADJ_BIB_LEAD
.    nr #BIB_LEAD (p;\\$1)
.    if '\\$2'ADJUST' \{\
.       nr #ORIG_DOC_LEAD \\n[#DOC_LEAD]
.       nr #RESTORE_ADJ_DOC_LEAD \\n[#ADJ_DOC_LEAD]
.       nr #ADJ_DOC_LEAD 1
.       nr #ADJ_BIB_LEAD 1
.       nr #NO_TRAP_RESET 1
.       DOC_LEAD \\n[#BIB_LEAD]u ADJUST
.       nr #BIB_LEAD \\n[#DOC_LEAD]
.       DOC_LEAD \\n[#ORIG_DOC_LEAD]u
.       rr #NO_TRAP_RESET
.       nr #ADJ_DOC_LEAD \\n[#RESTORE_ADJ_DOC_LEAD]
.       rr #ORIG_DOC_LEAD
.    \}
.END
\#
.MAC BIBLIOGRAPHY_HDRFTR_CENTER END
.    ie '\\$1'' \{ .nr #BIB_HDRFTR_CENTER 1 \}
.    el         \{ .rr #BIB_HDRFTR_CENTER   \}
.END
\#
.MAC BIBLIOGRAPHY_STRING END
.    ds $BIB_STRING \\$1
.END
\#
.MAC BIBLIOGRAPHY_STRING_UNDERSCORE END
.    ie '\\$1'' \{ .nr #BIB_STRING_UNDERSCORE 1 \}
.    el \{\
.       ie '\\$1'2' \{ .nr #BIB_STRING_UNDERSCORE 2 \}
.       el \{ .nr #BIB_STRING_UNDERSCORE 0 \}
.    \}
.END
\#
.MAC BIBLIOGRAPHY_STRING_CAPS END
.   ie '\\$1'' \{ .nr #BIB_STRING_CAPS 1 \}
.   el \{ .rr #BIB_STRING_CAPS \}
.END
\#
.MAC BIBLIOGRAPHY_NO_COLUMNS END
.    ie '\\$1'' \{ .nr #BIB_NO_COLS 1 \}
.    el \{ .rr #BIB_NO_COLS \}
.END
\#
.MAC BIBLIOGRAPHY_NO_FIRST_PAGENUM END
.    ie '\\$1'' \{ .nr #BIB_NO_FIRST_PN 1 \}
.    el \{ .rr #BIB_NO_FIRST_PN \}
.END
\#
.MAC BIBLIOGRAPHY_ALLOWS_HEADERS END
.    ie '\\$1'' \{ .nr #BIB_ALLOWS_HEADERS 1 \}
.    el \{\
.       ie '\\$1'ALL' \{\
.          nr #BIB_ALLOWS_HEADERS 1
.          nr #BIB_ALLOWS_HEADERS_ALL 1
.       \}
.       el \{\
.          rr #BIB_ALLOWS_HEADERS
.          rr #BIB_ALLOWS_HEADERS_ALL
.       \}
.    \}
.END
\#
.MAC BIBLIOGRAPHY_PAGENUM_STYLE END
.    ds $BIB_PN_STYLE \\$1
.END
\#
.MAC BIBLIOGRAPHY_FIRST_PAGENUMBER END
.    nr #BIB_FIRST_PN \\$1
.END
\#
.MAC SINGLESPACE_BIBLIOGRAPHY END
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE] \{\
.          nr #BIB_SINGLESPACE 1
.          rr #IGNORE
.          if \\n[#OK_PROCESS_LEAD] \{\
.             BIBLIOGRAPHY_LEAD 12 ADJUST
.             nr #IGNORE 1
.          \}
.       \}
.       el \{\
.          ie '\\$1'' \{\
.             nr #BIB_SINGLESPACE 1
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                BIBLIOGRAPHY_LEAD 12 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.          el \{\
.             rr #BIB_SINGLESPACE
.             rr #IGNORE
.             if \\n[#OK_PROCESS_LEAD] \{\
.                BIBLIOGRAPHY_LEAD 24 ADJUST
.                nr #IGNORE 1
.             \}
.          \}
.       \}
.    \}
.END
\#
\#
\# Style for outputting collected bibliographic references
\# -------------------------------------------------------
\# *Argument:
\#   LIST | PLAIN [ <list separator> ] [ <list prefix> ]
\# *Function:
\#   Sets #BIB_LIST to 1 for numbered list style, 0 for plain output
\# *Notes:
\#   Technically, user is supposed to enter PLAIN if s/he wants an
\#   unumbered bibliography, but the el clause says "any arg but
\#   LIST means unumbered."  Effectively, any arg but LIST produces
\#   a "plain" bibliographic list.
\#
\#   The 2nd and 3rd args have the same options as the 2nd arg to LIST.
\#
.MAC BIBLIOGRAPHY_TYPE END
.    ie '\\$1'LIST' \{\
.       nr #BIB_LIST 1
.       ie '\\$2'' \{\
.          if '\\*[$BIB_LIST_SEPARATOR]'' .ds $BIB_LIST_SEPARATOR .
.       \}
.       el .ds $BIB_LIST_SEPARATOR \\$2
.       ie '\\$3'' .ds $BIB_LIST_PREFIX
.       el .ds $BIB_LIST_PREFIX \\$3
.    \}
.    el \{ .nr #BIB_LIST 0 \}
.END
\#
\# Spacing between items in bibliographies
\# ---------------------------------------
\# *Argument:
\#   <amount of space>
\# *Function:
\#   Gets value for #BIB_SPACE in units.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC BIBLIOGRAPHY_SPACING END
.    ds $BIB_SPACE \\$1
.    if \\n[#BIB_LEAD]=0 \{\
.       nr #DEFER_BIB_SPACING 1
.       return
.    \}
.    ds $EVAL_BIB_SPACE \\*[$BIB_SPACE]
.    substring $EVAL_BIB_SPACE -1
.    ie '\\*[$EVAL_BIB_SPACE]'v' \{\
.       substring $BIB_SPACE 0 0
.       nr #BIB_SPACE \\n[#BIB_LEAD]*\\*[$BIB_SPACE]
.    \}
.    el \{\
.       nr #BIB_SPACE (\\$1)
.    \}
.END
\#
\# Set up bibliography page
\# ------------------------
\# *Function:
\#   Sets up a new page, with title, ready to accept the output
\#   of refer's $LIST$ or .R1 bibliography .R2
\# *Notes:
\#   Bibliography pages are set up almost identically to endnotes pages.
\#
.MAC BIBLIOGRAPHY END
.    nr #BIBLIOGRAPHY 1
.    nr #BIB_FIRST_PAGE 1
.    nr #HEADER_STATE \\n[#HEADERS_ON]
.    ds $RESTORE_PAGENUM_STYLE \\*[$PAGENUM_STYLE]
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#HEADERS_ON]=1 \{\
.       if !\\n[#BIB_ALLOWS_HEADERS_ALL] \{ .HEADERS OFF \}
.    \}
.    if \\n[#HEADER_STATE]=1 \{\
.       ie \\n[#BIB_HDRFTR_CENTER]=1 \{ . \}
.       el \{ .rm $HDRFTR_CENTER  \}
.    \}
.    ie !\\n[#SUSPEND_PAGINATION] \{\
.       if \\n[#PAGINATE]=1 \{\
.          if \\n[#PAGE_NUM_V_POS]=1 \{\
.             PAGENUM_STYLE \\*[$BIB_PN_STYLE]
.             if \\n[#BIB_FIRST_PN] \{ .PAGENUMBER \\n[#BIB_FIRST_PN]-1 \}
.             if r#BIB_NO_FIRST_PN \{ .nr #PAGINATE 0 \}
.          \}
.       \}
.    \}
.    el \{\
.       ie \\n[#PAGE_NUM_V_POS]=2 \{ .nr #PAGINATE 1 \}
.       el \{ .nr #PAGINATE 0 \}
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       if !'\\*[$HDRFTR_CENTER_OLD]'' .ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_OLD]
.    \}
.    NEWPAGE
.    if \\n[#FOOTERS_ON]=1 \{\
.       ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_NEW]
.       rm $HDRFTR_CENTER_OLD
.       rm $HDRFTR_CENTER_NEW
.    \}
.    ie !\\n[#SUSPEND_PAGINATION] \{\
.       if \\n[#PAGE_NUM_V_POS]=1 \{\
.          if r#BIB_NO_FIRST_PN \{\
.             if \\n[#PAGINATION_STATE]=1 \{\
.                nr #PAGINATE 1
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       if \\n[#PAGE_NUM_V_POS]=2 \{ .nr #PAGINATE 0 \}
.    \}
.    rr #PAGINATION_STATE
.    PAGENUM_STYLE \\*[$BIB_PN_STYLE]
.    if \\n[#BIB_FIRST_PN] \{ .PAGENUMBER \\n[#BIB_FIRST_PN] \}
.    if \\n[#HEADER_STATE]=1 \{\
.       if \\n[#BIB_ALLOWS_HEADERS] \{ .HEADERS \}
.    \}
.\" Collect bibliography title string for TOC
.    nr #TOC_ENTRY_PN \\n%+\\n[#PAGE_NUM_ADJ]
.    af #TOC_ENTRY_PN \\g[#PAGENUMBER]
.    ds $TOC_TITLE_ITEM \\*[$BIB_STRING]\\|
.    ev TOC_EV
.    da TOC_ENTRIES
.    if \\n[#PRINT_STYLE]=1 \{\
.       TYPEWRITER
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_TITLE_FAM]
\!.     FT      \\*[$TOC_TITLE_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_TITLE_SIZE_CHANGE]
.    \}
\!.  TRAP OFF
.    ie \\n[#PRINT_STYLE]=1 \{\
\!.     PAD "\\*[$TOC_TITLE_ITEM]\\*[$TOC_PN_TYPEWRITE]" 
.    \}
.    el \{\
\!.     PAD "\\h'\\n[#TOC_TITLE_INDENT]u'\\*[$TOC_TITLE_ITEM]\\*[$TOC_PN]"
.    \}
\!.  EOL
\!.  ST 100 L
\!.  ST 101 R
.    if \\n[#PRINT_STYLE]=2 \{\
\!.     FAMILY  \\*[$TOC_PN_FAM]
\!.     FT      \\*[$TOC_PN_FT]
\!.     PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.    \}
\!.  TAB 100
\!.  PRINT \\*[LEADER]
\!.  TN
\!.  TRAP
\!.  PRINT \\n[#TOC_ENTRY_PN]
\!.  TQ
.    di       
.    ev
.\" End collection of bibliography title string for TOC
.\" Process bibliography
.    if \\n[#PRINT_STYLE]=1 \{ .vs \\n[#BIB_LEAD]u \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       if \\n[#BIB_NO_COLS] \{\
.          if \\n[#COLUMNS] \{ .nr #COLUMNS_WERE_ON 1 \}
.          nr #COLUMNS 0
.       \}
.       nr #RESTORE_DOC_LEAD \\n[#DOC_LEAD]
.       ie \\n[#ADJ_BIB_LEAD] \{\
.          nr #DOC_LEAD \\n[#BIB_LEAD]
.       \}
.       el \{ .DOC_LEAD \\n[#BIB_LEAD]u \}
.    \}
.    PRINT \&
.    ie r#BIB_TITLE_SPACE \{ .sp |\\n[#BIB_TITLE_SPACE]u \}
.    el \{ .sp |\\n[#T_MARGIN]u \}
.    mk ec
.    if \\n[#SLANT_ON] \{\
\*[SLANTX]\c
.    \}
.    if !'\\*[$BIB_STRING]'' \{\
.       if \\n[#PRINT_STYLE]=1 \{\
.          TYPEWRITER
.          vs \\n[#BIB_LEAD]u
.       \}
.       if \\n[#PRINT_STYLE]=2 \{\
.          LL \\n[#DOC_L_LENGTH]u
.          ta \\n(.lu
.          if \\n[#COLUMNS] \{\
.             ie \\n[#BIB_NO_COLS] \{ .LL \\n[#DOC_L_LENGTH]u \}
.             el \{ .LL \\n[#COL_L_LENGTH]u \}
.             ta \\n(.lu
.          \}
.          FAMILY  \\*[$BIB_STRING_FAM]
.          FT      \\*[$BIB_STRING_FT]
.          PT_SIZE \\n[#BIB_PS]u\\*[$BIB_STRING_SIZE_CHANGE]
.          vs      \\n[#BIB_LEAD]u
.       \}
.       if '\\*[$BIB_STRING_QUAD]'L'      \{ .LEFT   \}
.       if '\\*[$BIB_STRING_QUAD]'LEFT'   \{ .LEFT   \}
.       if '\\*[$EN_STRING_QUAD]'C'       \{ .CENTER \}
.       if '\\*[$BIB_STRING_QUAD]'CENTER' \{ .CENTER \}
.       if '\\*[$BIB_STRING_QUAD]'CENTRE' \{ .CENTER \}
.       if '\\*[$BIB_STRING_QUAD]'R'      \{ .RIGHT  \}
.       if '\\*[$BIB_STRING_QUAD]'RIGHT'  \{ .RIGHT  \}
.       EOL
.       if \\n[#BIB_STRING_CAPS] \{ .CAPS \}
.       ie \\n[#BIB_STRING_UNDERSCORE] \{\
.          ie \\n[#BIB_STRING_UNDERSCORE]=2 \{\
.             UNDERSCORE2 "\\*[$BIB_STRING]
.          \}
.          el \{\
.             UNDERSCORE "\\*[$BIB_STRING]
.          \}
.       \}
.       el \{\
.          PRINT "\\*[$BIB_STRING]
.       \}
.    \}
.    CAPS OFF
.    FAMILY \\*[$BIB_FAMILY]
.    FT \\*[$BIB_FT]
.    PT_SIZE -\\*[$BIB_STRING_SIZE_CHANGE]
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE]=1 \{\
.          ALD \\n[#BIB_LEAD]*3u
.       \}
.       el \{\
.          ie \\n[#BIB_SINGLESPACE]=1 \{\
.             ALD \\n[#BIB_LEAD]u*3u
.          \}
.          el \{\
.             ALD \\n[#BIB_LEAD]u
.          \}
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{ .ALD \\n[#BIB_LEAD]u*2u \}
.    QUAD \\*[$BIB_QUAD]
.    if \\n[#PRINT_STYLE]=1 \{\
.       ie \\n[#SINGLE_SPACE]=1 \{\
.          vs \\n[#BIB_LEAD]u
.       \}
.       el \{\
.          ie \\n[#BIB_SINGLESPACE]=1 \{\
.             vs \\n[#BIB_LEAD]u
.          \}
.          el \{\
.             vs \\n[#BIB_LEAD]u
.          \}
.       \}
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie \\n[#ADJ_BIB_LEAD] \{\
.          nr #DOC_LEAD \\n[#RESTORE_DOC_LEAD]
.       \}
.       el \{ .DOC_LEAD \\n[#RESTORE_DOC_LEAD]u \}
.       rr #RESTORE_DOC_LEAD
.    \}
.    if \\n[#COLUMNS_WERE_ON] \{ .nr #COLUMNS 1 \}
.    if \\n[#HEADER_STATE]=1 \{ .HEADERS \}
.    rr #BIBLIOGRAPHY
.    if \\n[#LINENUMBERS]=2 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.END
\#
\# ====================================================================
\#
\# +++TABLE OF CONTENTS+++
\#
\# Strings to allocate space for leaders and entry page numbers
\#
.ds $TOC_PN \\*[ST100]\\F[\\*[$TOC_PN_FAM]]\\f[\\*[$TOC_PN_FT]]\\s[\\n[#TOC_PS]u]#\\*[ST100X]\\*[ST101]\\s[\\*[$TOC_PN_SIZE_CHANGE]]\\|\\h'\\w'0'u*\\n[#TOC_PN_PADDING]u'\*[ST101X]
.ds $TOC_PN_TYPEWRITE \\*[ST100]#\\*[ST100X]\\*[ST101]\\|\\h'\\w'0'u*\\n[#TOC_PN_PADDING]u'\\*[ST101X]
\#
\# TOC ENTRIES PAGE NUMBERS PADDING
\# --------------------------------
\# *Argument:
\#   <number of placeholders for toc entries page numbers>
\# *Function:
\#   Creates or modifies register #TOC_PN_PADDING.
\# *Notes:
\#   "Placeholders" is the maximum number of digits in a page
\#   number numeral.
\#
\#   Default is 3.
\#
.MAC TOC_PADDING END
.    nr #TOC_PN_PADDING \\$1
.END
\#
\#
\# PAGINATE TOC
\# ------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #PAGINATE_TOC.
\# *Notes:
\#   Default is to paginate toc.
\#
.MAC PAGINATE_TOC END
.    ie '\\$1'' \{ .nr #PAGINATE_TOC 1 \}
.    el \{ .nr #PAGINATE_TOC 0 \}
.END
\#
\#
\# TOC POINT SIZE
\# --------------
\# *Argument:
\#   <base point size for toc pages>
\# *Function:
\#   Creates or modifies register #TOC_PS.
\# *Notes:
\#   This size control macro differs from other size control macros
\#   in that it sets an absolute point size, not a relative one.
\#   See notes for ENDNOTE_PT_SIZE for explanation.  No unit of
\#   measure required.
\#
\#   No unit of measure required (points assumed).  Default is 11.5
\#   for TYPESET.
\#
.MAC TOC_PT_SIZE END
.    nr #TOC_PS (p;\\$1)
.END
\#
\#
\# TOC LEADING
\# -----------
\# *Argument:
\#   <leading for toc pages> [ADJUST]
\# *Function:
\#   Creates or modifies register #TOC_LEAD. If optional ADJUST
\#   given, adjusts lead to fill page.  If #OK_PROCESS_LEAD doesn't
\#   exist, stores arguments for when it's okay to run the macro.
\# *Notes:
\#   No unit of measure required (points assumed).
\#
\#   Default is same as DOC_LEAD.
\#
.MAC TOC_LEAD END
.    if !\\n[#OK_PROCESS_LEAD] \{\
.       ds $TOC_LEAD \\$1
.       if !'\\$2'' \{\
.           ds $ADJUST_TOC_LEAD \\$2
.       \}
.       return
.    \}
.    rr #ADJ_TOC_LEAD
.    nr #TOC_LEAD (p;\\$1)
.    if '\\$2'ADJUST' \{\
.       nr #ORIG_DOC_LEAD \\n[#DOC_LEAD]
.       nr #RESTORE_ADJ_DOC_LEAD \\n[#ADJ_DOC_LEAD]
.       nr #ADJ_DOC_LEAD 1
.       nr #ADJ_TOC_LEAD 1
.       nr #NO_TRAP_RESET 1
.       DOC_LEAD \\n[#TOC_LEAD]u ADJUST
.       nr #TOC_LEAD \\n[#DOC_LEAD]
.       DOC_LEAD \\n[#ORIG_DOC_LEAD]u
.       rr #NO_TRAP_RESET
.       nr #ADJ_DOC_LEAD \\n[#RESTORE_ADJ_DOC_LEAD]
.       rr #ORIG_DOC_LEAD
.    \}
.END
\#
\#
\# TOC PAGES PAGE-NUMBERING STYLE
\# ------------------------------
\# *Argument:
\#   DIGIT | ROMAN | roman | ALPHA | alpha
\# *Function:
\#   Creates or modifies string $TOC_PN_STYLE
\# *Notes:
\#   Page numbering style for page numbers that appear in the
\#   headers/footers of toc pages.  See notes for PAGENUM_STYLE.  
\#
\#   Default is roman.
\#
.MAC TOC_PAGENUM_STYLE END
.    ds $TOC_PN_STYLE \\$1
.END
\#
\#
\# TOC RECTO_VERSO SWITCH
\# ----------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Creates or removes register #TOC_RV_SWITCH
\# *Notes:
\#   Allows switching of L/R margins if a doc is recto/verso and
\#   the first toc page happens to fall the wrong way
\#
.MAC TOC_RV_SWITCH END
.    ie '\\$1'' \{ .nr #TOC_RV_SWITCH 1 \}
.    el \{ .rr #TOC_RV_SWITCH \}
.END
\#
\# - for TOC "doc header" (i.e. "Contents")
\#
\# TOC HEADER STRING
\# -----------------
\# *Argument:
\#   <string for "doc header" of first toc page>
\# *Function:
\#   Creates or modifies string $TOC_HEADER_STRING
\# *Notes:
\#   Default is "Contents".
\#
.MAC TOC_HEADER_STRING END
.    ds $TOC_HEADER_STRING \\$1
.END
\#
\# - for TOC entries page number numerals
\#
\# Control macros for toc doc titles, heads, subheads and paraheads 
\# ----------------------------------------------------------------
\#
\# All these control macros behave the same way, setting the family,
\# font, point size and indent from the left margin of the different
\# kinds of entries that can appear in the toc.  The way they
\# operate is identical to all other _FAMILY, _FONT and _SIZE
\# control macros.  _INDENT takes an absolute value.
\# TOC_APPENDS_AUTHORS is unique in this section.
\# 
\# - for title entries
\#
.MAC TOC_TITLE_INDENT END
.    nr #TOC_TITLE_INDENT (\\$1)
.END
\#
\#
.MAC TOC_TITLE_ENTRY END
.    nr #USER_SET_TITLE_ITEM 1
.    ds $USER_SET_TITLE_ITEM \\$1
.END
\#
\#
\# APPEND AUTHOR(S) TO TOC DOC TITLE ENTRIES
\# -----------------------------------------
\# *Argument:
\#   <none> | <name(s) of author(s) as they should appear in toc doc title entries>
\# *Function:
\#   Creates register #TOC_AUTHORS (to tell TOC to append authors
\#   to toc doc title entries).  Optionally creates string
\#   $TOC_AUTHORS.
\# *Notes:
\#   Normally, TOC does not append the author(s) to a toc doc title
\#   entry.  This special macro instructs TOC to do so.
\#
\#   If user has multiple authors for each doc when collating,
\#   TOC_APPENDS_AUTHOR "<string>" must be inserted somewhere between
\#   COLLATE and START in each doc.  Otherwise, mom prints only the
\#   first author given to AUTHOR.
\#
.MAC TOC_APPENDS_AUTHOR END
.    nr #TOC_AUTHORS 1
.    if !'\\$1'' \{\
.       ds $TOC_AUTHORS \\$1
.    \}
.END
\#
\# - for head entries
\#
.MAC TOC_HEAD_INDENT END
.    nr #TOC_HEAD_INDENT (\\$1)
.END
\#
\# - for subhead entries
\#
.MAC TOC_SUBHEAD_INDENT END
.    nr #TOC_SH_INDENT (\\$1)
.END
\#
\# - for parahead entries
\#
.MAC TOC_PARAHEAD_INDENT END
.    nr #TOC_PH_INDENT (\\$1)
.END
\#
\#
.MAC TOC END
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if !r#PAGINATE_TOC \{ .PAGINATE_TOC \}
.    nr #TOC_FIRST_PAGE 1
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] \{\
.          FOOTERS \" Have to turn FOOTERS on for next bit to work, so we can't skip this step
.       \}
.    \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       if !'\\*[$HDRFTR_CENTER_OLD]'' .ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_OLD]
.       ie \\n[#PAGINATE_TOC]=1 \{ .PAGINATE \}
.       el \{ .PAGINATION OFF \}
.    \}
.    if \\n[#FOOTERS_WERE_ON] \{ .FOOTERS OFF \} \" But have to turn FOOTERS off again so they don't print when FINIS was called
.    COLLATE
.    if \\n[#FINIS] \{\
.       if \\n[#FOOTERS_WERE_ON] \{ .FOOTERS \} \" Finally, turn footers on if they were on
.       rr #FOOTERS_WERE_ON
.       if \\n[#PAGINATION_WAS_ON] \{\
.          nr #PAGINATE 1
.          rr #PAGINATION_WAS_ON
.       \}
.       rr #FINIS
.    \}
.    ie \\n[#PAGINATE_TOC]=1 \{ .PAGINATE \}
.    el \{ .PAGINATION OFF \}
.    if \\n[#FOOTERS_ON]=1 \{\
.       ds $HDRFTR_CENTER \\*[$HDRFTR_CENTER_NEW]
.       rm $HDRFTR_CENTER_OLD
.       rm $HDRFTR_CENTER_NEW
.    \}
.    rr #COLLATED_DOC
.    DOCHEADER OFF
.    PAGENUMBER 1
.    if \\n[#PRINT_STYLE]=1 \{\
.       rr #IGNORE
.       DOC_LEAD 24 ADJUST
.       nr #IGNORE 1
.    \}
.    if \\n[#LINENUMBERS]=2 \{ .nr #LINENUMBERS 3 \}
.    START
.    PP
.    nr #COLUMNS 0
.    if \\n[#PRINT_STYLE]=2 \{\
.       ie r#ADJ_TOC_LEAD \{\
.          nr #NO_TRAP_RESET 1
.          DOC_LEAD \\n[#TOC_LEAD]u ADJUST
.          rr #NO_TRAP_RESET
.       \}
.       el \{ .DOC_LEAD \\n[#TOC_LEAD]u \}
.    \}
.    sp |\\n[#T_MARGIN]u-\\n[#DOC_LEAD]u
.    if \\n[#SLANT_ON] \{\
\*[SLANTX]\c
.    \}
.    DOC_LINE_LENGTH \\n[#DOC_L_LENGTH]u
.    QUAD \\*[$TOC_HEADER_QUAD]
.    PAGENUM_STYLE \\*[$TOC_PN_STYLE]
.    if \\n[#PRINT_STYLE]=1 \{\
.       TYPEWRITER
.    \}
.    if \\n[#PRINT_STYLE]=2 \{\
.       FAMILY  \\*[$TOC_HEADER_FAM]
.       FT      \\*[$TOC_HEADER_FT]
.       PT_SIZE \\n[#TOC_PS]u\\*[$TOC_HEADER_SIZE_CHANGE]
.    \}
.    ie \\n[#PRINT_STYLE]=1 \{\
.       CAPS
.       UNDERLINE
.       PRINT "\\*[$TOC_HEADER_STRING]"
.       UNDERLINE OFF
.       CAPS      OFF
.    \}
.    el \{\
.       PRINT "\\*[$TOC_HEADER_STRING]"
.    \}
.    LEFT
.    SP
.\" In collated docs, this bit inserts the first doc's title
.\" underneath the TOC header, before the TOC_ENTRIES diversion
.\" gets output.
.    nf
.    if d$FIRST_DOC_TITLE \{\
.    nr #RESTORE_TOC_PN_PADDING \\n[#TOC_PN_PADDING]
.    TOC_PADDING \\n[#FIRST_DOC_TOC_PN_PADDING]
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$TOC_TITLE_FAM]
.          FT      \\*[$TOC_TITLE_FT]
.          PT_SIZE \\n[#TOC_PS]u\\*[$TOC_TITLE_SIZE_CHANGE]
.       \}
.       ie \\n[#PRINT_STYLE]=1 \{\
.          PAD "\\*[$FIRST_DOC_TITLE]\\*[$TOC_PN_TYPEWRITE]" 
.       \}
.       el \{\
.          PAD "\\h'\\n[#TOC_TITLE_INDENT]u'\\*[$FIRST_DOC_TITLE]\\*[$TOC_PN]"
.       \}
.       EOL
.       ST 100 L
.       ST 101 R
.       if \\n[#PRINT_STYLE]=2 \{\
.          FAMILY  \\*[$TOC_PN_FAM]
.          FT      \\*[$TOC_PN_FT]
.          PT_SIZE \\n[#TOC_PS]u\\*[$TOC_PN_SIZE_CHANGE]
.       \}
.       TAB 100
.       PRINT \\*[LEADER]
.       TN
.       PRINT \\n[#FIRST_DOC_TITLE_PN]
.       TQ
.    \}
.    TOC_PADDING \\n[#RESTORE_TOC_PN_PADDING]
.    nf
.    TOC_ENTRIES
.    br
.    rr #TOC
.    if \\n[#LINENUMBERS]=3 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.       nn 1
.    \}
.END
\#
\# ====================================================================
\#
\# +++COLUMNS+++
\#
\# COLUMNS
\# -------
\# *Arguments:
\#   <number of columns>  <width of gutters>
\# *Function:
\#   Creates registers associated with setting docs in columns.
\#   Calculates column line lengths and offsets
\# *Notes:
\#   COLUMNS, if used, s/b the last macro invoked before START.
\#
.MAC COLUMNS END
.    if \\n[#IGNORE_COLUMNS]=1 \{ .return \}
.    nr #COLUMNS 1
.    nr #NUM_COLS \\$1
.    nr #GUTTER (\\$2)
.    nr #COL_L_LENGTH \\n[#L_LENGTH]-(\\n[#GUTTER]*(\\n[#NUM_COLS]-1))/\\n[#NUM_COLS]
.    nr #COL_TOTAL 0 \\n[#COL_L_LENGTH]+\\n[#GUTTER]
.    nr #COL_NUM 0 1
.    while !\\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.       nr #COL_\\n+[#COL_NUM]_L_MARGIN \\n[#L_MARGIN]+\\n[#COL_TOTAL]
.       nr #COL_TOTAL \\n+[#COL_TOTAL]
.\}
.    if \\n[#NUM_COLS]=1 \{\
.       if !\\n[#COLLATE]=1 \{ .MN_INIT \}
.    \}
.    rr #COL_TOTAL
.    rr #COL_NUM
.END
\#
\#
\# NEXT COLUMN
\# -----------
\# *Arguments:
\#   <none>
\# *Function:
\#   Breaks current column and moves to next column.
\#   If current column is the last on the page, breaks
\#   to a new page.
\#
.MAC COL_NEXT END
.    if \\n[#COLUMNS] \{\
.       nr #COL_NEXT 1
.       ie '\\$0'COL_NEXT' \{ .br  \}
.       el \{\
.          brp
.          RLD 1v
.       \}
.       ie \\n[#COL_NUM]=\\n[#NUM_COLS] \{\
.          bp
.       \}
.       el \{ .FOOTER \}
.    \}
.END
\#
\# ====================================================================
\#
\# +++LISTS+++
\#
\# LIST
\# ----
\# *Arguments:
\#   [ BULLET | DASH | DIGIT | alpha | ALPHA | roman | ROMAN | USER ] [ <separator> | NONE ] [ <prefix> ] [ <anything> ]
\# *Function:
\#   Stores indent information in effect prior to invocation and
\#   initializes a list with the supplied enumerator (and separator).
\# *Notes:
\#   Default enumerator is a bullet.
\#
\#   Enumerator *must* be supplied for every list that's to the
\#   right of another list, every time, unless the default bullet is
\#   desired.
\#
\#   <anything> moves back one list level intuitively, or exits lists
\#   completely if the level in which it's invoked is the first.
\#
.MAC LIST END
.    ds $1ST_LETTER \\$1
.    substring $1ST_LETTER 0 0
.    if '\\*[$1ST_LETTER]'r' .ds $1ST_LETTER R
.    ie '\\*[$1ST_LETTER]'R' \{\
.       ds $LAST_CHAR \\$1
.       substring $LAST_CHAR -1
.       if !\B'\\*[$LAST_CHAR]' \{\
.          tm1 "[mom]: You must append a number to the \\$1 argument to LIST at line \\n(.c.
.          tm1 "       The number should be the total number of items in this list.
.          tm1 "       See the documentation.
.          ab Aborting LIST
.       \}
.       ds $ROMAN_WIDTH \\$1
.          substring $ROMAN_WIDTH 1
.       while !\B'\\*[$ROMAN_WIDTH]' \{\
.          substring $ROMAN_WIDTH 1
.\}
.       length #ROMAN_LENGTH \\*[$ROMAN_WIDTH]
.       ds $LIST_ARG_1 \\$1
.       substring $LIST_ARG_1 0 -(\\n[#ROMAN_LENGTH]+1)
.    \}
.    el \{\
.       ds $LIST_ARG_1 \\$1
.    \}
.    if !r#DEPTH \{\
.       nr #STORED_HL_INDENT \\n[#HL_INDENT]
.       nr #STORED_T_INDENT  \\n[#T_INDENT]
.       nr #CURRENT_L_LENGTH \\n(.l
.       nr #DEPTH 0 1
.       if \\n[#INDENT_ACTIVE]=1 \{\
.          if \\n[#INDENT_LEFT_ACTIVE]=1 \{\
.             nr #STORED_L_INDENT \\n[#L_INDENT]
.             nr #RESTORE_PREV_INDENT 1
.          \}
.          if \\n[#INDENT_BOTH_ACTIVE]=1 \{\
.             nr #STORED_BL_INDENT \\n[#BL_INDENT]
.             nr #STORED_BR_INDENT \\n[#BR_INDENT]
.             IBX
.             nr #ORIG_L_LENGTH \\n(.l
.             IB
.             nr #RESTORE_PREV_INDENT 2
.          \}
.          if \\n[#INDENT_RIGHT_ACTIVE]=1 \{\
.             nr #STORED_R_INDENT \\n[#R_INDENT]
.             IRX
.             nr #ORIG_L_LENGTH \\n(.l
.             IR
.             nr #RESTORE_PREV_INDENT 3
.             if \\n[#INDENT_LEFT_ACTIVE]=1 \{ .nr #RESTORE_PREV_INDENT 4 \}
.          \}
.       \}
.    \}
.    if \\n[#NUM_ARGS]=0 \{\
.       nr #ARGS_TO_LIST 1 \" So default behaves as if LIST BULLET
.       ds $ENUMERATOR\\n+[#DEPTH] \(bu
.       ds $ENUMERATOR_TYPE\\n[#DEPTH] other
.       ds $SEPARATOR
.    \}
.    if \\n[#NUM_ARGS]>0 \{\
.       rr #ARGS_TO_LIST \" Clear this before processing arg 1.
.       if '\\*[$LIST_ARG_1]'DASH'   \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH] \(en
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] other
.          ds $SEPARATOR\\n[#DEPTH]
.       \}
.       if '\\*[$LIST_ARG_1]'BULLET' \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH] \(bu
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] other
.          ds $SEPARATOR\\n[#DEPTH]
.       \}
.       if '\\*[$LIST_ARG_1]'DIGIT'  \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] register
.          ds $SEPARATOR\\n[#DEPTH] .
.          ds $PREFIX\\n[#DEPTH]
.          if \\n[#NUM_ARGS]>=2 \{\
.             ie '\\$2'NONE' .ds $SEPARATOR\\n[#DEPTH]
.             el             .ds $SEPARATOR\\n[#DEPTH] \\$2
.             if \\n[#NUM_ARGS]=3 \{\
.                ds $PREFIX\\n[#DEPTH] \\$3
.             \}
.          \}
.       \}
.       if '\\*[$LIST_ARG_1]'alpha'  \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          af #ENUMERATOR\\n[#DEPTH] a
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] register
.          ds $SEPARATOR\\n[#DEPTH] )
.          ds $PREFIX\\n[#DEPTH]
.          if \\n[#NUM_ARGS]>=2 \{\
.             ie '\\$2'NONE' .ds $SEPARATOR\\n[#DEPTH]
.             el             .ds $SEPARATOR\\n[#DEPTH] \\$2
.             if \\n[#NUM_ARGS]=3 \{\
.                ds $PREFIX\\n[#DEPTH] \\$3
.             \}
.          \}
.       \}
.       if '\\*[$LIST_ARG_1]'ALPHA'  \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          af #ENUMERATOR\\n[#DEPTH] A
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] register
.          ds $SEPARATOR\\n[#DEPTH] )
.          ds $PREFIX\\n[#DEPTH]
.          if \\n[#NUM_ARGS]>=2 \{\
.             ie '\\$2'NONE' .ds $SEPARATOR\\n[#DEPTH]
.             el             .ds $SEPARATOR\\n[#DEPTH] \\$2
.             if \\n[#NUM_ARGS]=3 \{\
.                ds $PREFIX\\n[#DEPTH] \\$3
.             \}
.          \}
.       \}
.       if '\\*[$1ST_LETTER]'R'  \{\
.          nr #ARGS_TO_LIST 1
.          nr #ENUMERATOR\\n+[#DEPTH] 0 1
.          if '\\*[$LIST_ARG_1]'roman' \{\
.             af #ENUMERATOR\\n[#DEPTH] i
.          \}
.          if '\\*[$LIST_ARG_1]'ROMAN' \{\
.             af #ENUMERATOR\\n[#DEPTH] I
.          \}
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] roman
.          ds $SEPARATOR\\n[#DEPTH] )
.          ds $PREFIX\\n[#DEPTH]
.          if \\n[#NUM_ARGS]>=2 \{\
.             ie '\\$2'NONE' .ds $SEPARATOR\\n[#DEPTH]
.             el             .ds $SEPARATOR\\n[#DEPTH] \\$2
.             if \\n[#NUM_ARGS]=3 \{\
.                ds $PREFIX\\n[#DEPTH] \\$3
.             \}
.          \}
.       \}
.       if '\\*[$LIST_ARG_1]'USER'   \{\
.          nr #ARGS_TO_LIST 1
.          ds $ENUMERATOR\\n+[#DEPTH] \\$2
.          ds $ENUMERATOR_TYPE\\n[#DEPTH] other
.          ds $SEPARATOR\\n[#DEPTH]
.          ds $PREFIX\\n[#DEPTH]
.       \}
.       if \\n[#NUM_ARGS]=1 \{\
.          if !r#ARGS_TO_LIST \{\
.             ie \\n[#DEPTH]=1 \{\
.                ie \\n[#NEXT_DEPTH_BACK]=0 \{\
.                   SET_LIST_INDENT
.                   if \\n[#QUIT]=1 \{\
.                      QUIT_LISTS
.                      return
.                   \}
.                   return
.                \}
.                el \{\
.                   QUIT_LISTS
.                   return
.                \} 
.             \}
.             el \{\
.                SET_LIST_INDENT
.                return
.             \}
.          \}
.       \}
.    \}
.    nr #TOTAL_LISTS \\n[#DEPTH]
.    if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'register' \{\
.       nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]m\\*[$SEPARATOR\\n[#DEPTH]]\ '
.       if '\\*[$LIST_ARG_1]'ALPHA'\{\
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]M\\*[$SEPARATOR\\n[#DEPTH]]\ '
.       \}
.    \}
.    if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'roman' \{\
.       GET_ROMAN_INDENT
.    \}
.    if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'other' \{\
.       nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$ENUMERATOR\\n[#DEPTH]]\0'
.    \}
.    LL \\n[#CURRENT_L_LENGTH]u
.    ie \\n[#DEPTH]=1 \{\
.       ie \\n[#INDENT_ACTIVE]=1 \{\
.          if \\n[#INDENT_LEFT_ACTIVE]=1 \{\
.             nr #L_INDENT \\n[#L_INDENT]+\\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #LIST_INDENT\\n[#DEPTH] \\n[#L_INDENT]
.          \}
.          if \\n[#INDENT_BOTH_ACTIVE]=1 \{\
.             nr #L_INDENT \\n[#BL_INDENT]+\\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.             nr #LIST_INDENT\\n[#DEPTH] \\n[#L_INDENT]
.          \}
.          if \\n[#INDENT_RIGHT_ACTIVE]=1 \{\
.             ie \\n[#INDENT_LEFT_ACTIVE]=1 \{\
.             \" Don't do anything; we already have a left indent
.             \}
.             el \{\
.                nr #L_INDENT +\\n[#LIST_INDENT\\n[#DEPTH]]
.                nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.             \}
.          \}
.       \}
.       el \{\
.          nr #L_INDENT +\\n[#LIST_INDENT\\n[#DEPTH]]
.          nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.       \}
.    \}
.    el \{\
.       nr #L_INDENT +\\n[#LIST_INDENT\\n[#DEPTH]]
.       nr #HL_INDENT\\n[#DEPTH] \\n[#LIST_INDENT\\n[#DEPTH]]
.    \}
.END
\#
\#
\# ITEM
\# ----
\# *Arguments:
\#   none
\# *Function:
\#   Prints enumerator for a given list depth and prepares mom to
\#   receive the text of an item.
\#
.MAC ITEM END
.    if \\n[#LINENUMBERS]=1 \{\
.       NUMBER_LINES OFF
.       nr #LINENUMBERS 2
.    \}
.    if \\n[#KERN]=1 \{\
.       nr #KERN_WAS_ON 1
.       KERN OFF
.    \}
.    IL 
.    ll \\n[#CURRENT_L_LENGTH]u \" Set ll again because IL turns IB off.
.    TRAP OFF
.    HI \\n[#HL_INDENT\\n[#DEPTH]]u
.    if '\\*[$SEPARATOR\\n[#DEPTH]]')' \{ .nr #SEP_TYPE 1 \}
.    if '\\*[$SEPARATOR\\n[#DEPTH]]']' \{ .nr #SEP_TYPE 1 \}
.    if '\\*[$SEPARATOR\\n[#DEPTH]]'}' \{ .nr #SEP_TYPE 1 \}
.    ie \\n[#IN_BIB_LIST]=1 \{\
.       ie \\n[#ENUMERATOR\\n[#DEPTH]]<9 \{\
.          ie \\n[#SEP_TYPE]=1 \{\
.             PRINT \v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.          \}
.          el \{\
.             PRINT \\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.          \}
.       \}
.       el \{\
.          ie \\n[#SEP_TYPE]=1 \{\
.             PRINT \h'-\w'\0'u'\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.          \}
.          el \{\
.             PRINT \h'-\w'\0'u'\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.          \}
.       \}
.    \}
.    el \{\
.       ie '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'register' \{\
.\" DIGIT
.          ie '\\g[#ENUMERATOR\\n[#DEPTH]]'0' \{\
.             ie \\n[#PAD_LIST_DIGITS\\n[#DEPTH]]=1 \{\
.                ie \\n[#ENUMERATOR\\n[#DEPTH]]<9 \{\
.                   ie \\n[#SEP_TYPE]=1 \{\
.                      PRINT \0\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                   \}
.                   el \{\
.                      PRINT \0\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.                   \}
.                \}
.                el \{\
.                   ie \\n[#SEP_TYPE]=1 \{\
.                      PRINT \v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                   \}
.                   el \{\
.                      PRINT \\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.                   \}
.                \}
.             \}
.             el \{\
.                ie \\n[#SEP_TYPE]=1 \{\
.                   PRINT \v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                \}
.                el \{\
.                   PRINT \\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.                \}
.             \}
.          \}
.          el \{\
.\" ALPHA
.             ie '\\g[#ENUMERATOR\\n[#DEPTH]]'A' \{\
.                ie \\n[#SEP_TYPE]=1 \{\
.                   PRINT \v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                \}
.                el \{\
.                   PRINT \\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.                \}
.             \}
.\" alpha
.             el \{\
.                PRINT \\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.          \}
.       \}
.    \}
.    el \{\
.       if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'roman' \{\
.          ie \\n[#PAD_LIST_DIGITS\\n[#DEPTH]]=1 \{\
.\" ROMAN I, padded
.             ie '\\g[#ENUMERATOR\\n[#DEPTH]]'I' \{\
.                ie \\n[#SEP_TYPE]=1 \{\
.                   PRINT "\h'\\n[#LIST_INDENT\\n[#DEPTH]]u'\h'-\w'\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\n[#SEPARATOR\\n[#DEPTH]]\ 'u'\v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n[#ENUMERATOR\\n[#DEPTH]]\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                \}
.                el \{\
.                   PRINT "\h'\\n[#LIST_INDENT\\n[#DEPTH]]u'\h'-\w'\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\n[#SEPARATOR\\n[#DEPTH]]\ 'u'\\*[$PREFIX\\n[#DEPTH]]\\n[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.                \}
.             \}
.\" roman i, padded
.             el \{\
.                PRINT "\h'\\n[#LIST_INDENT\\n[#DEPTH]]u'\h'-\w'\\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\n[#SEPARATOR\\n[#DEPTH]]\ 'u'\\*[$PREFIX\\n[#DEPTH]]\\n[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.          \}
.\" No pad
.          el \{\
.\" ROMAN I, no pad
.             ie '\\g[#ENUMERATOR\\n[#DEPTH]]'I' \{\
.                ie \\n[#SEP_TYPE]=1 \{\
.                   PRINT \v'-.085m'\\*[$PREFIX\\n[#DEPTH]]\v'.085m'\\n+[#ENUMERATOR\\n[#DEPTH]]\v'-.085m'\\*[$SEPARATOR\\n[#DEPTH]]\v'.085m'
.                \}
.                el \{\
.                   PRINT \\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.                \}
.             \}
.\" roman i, no pad
.             el \{\
.                PRINT \\*[$PREFIX\\n[#DEPTH]]\\n+[#ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.             \}
.          \}
.       \}
.       if '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'other' \{\
.          PRINT \\*[$ENUMERATOR\\n[#DEPTH]]\\*[$SEPARATOR\\n[#DEPTH]]
.       \}
.    \}
.    rr #SEP_TYPE
.    EOL
.    if \\n[#REF]=1 \{\
.       IL +\\*[$REF_BIB_INDENT]
.       ti \\n[#L_INDENT]u-\\*[$REF_BIB_INDENT]
.    \}
.    TRAP
.    if \\n[#KERN_WAS_ON]=1 \{\
.       KERN
.       rr #KERN_WAS_ON
.    \}
.    if \\n[#LINENUMBERS]=2 \{\
.       NUMBER_LINES RESUME
.       nr #LINENUMBERS 1
.    \}
.END
\#
\# A utility macro that determines the space to reserve for
\# roman numeral enumerated lists.  Limit is 20 roman numerals
\# per list.  If this isn't enough, the user can add to the
\# macro.
\#
.MAC GET_ROMAN_INDENT END
.    if '\\*[$LIST_ARG_1]'roman' \{\
.       if '\\*[$ROMAN_WIDTH]'1'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 1
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]i\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'2'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 2
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]ii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'3'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 3
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]iii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'4'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 4
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]iii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'5'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 5
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]iii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'6'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 6
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]iii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'7'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 7
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]vii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'8'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 8
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'9'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 9
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'10'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 10
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'11'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 11
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'12'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 12
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]viii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'13'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 13
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]xiii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'14'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 14
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]xiii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'15'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 15
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]xiii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'16'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 16
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]xiii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'17'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 17
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]xvii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'18'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 18
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]xviii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'19'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 19
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]xviii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'20'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 20
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]xviii\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.    \}
.    if '\\*[$LIST_ARG_1]'ROMAN' \{\
.       if '\\*[$ROMAN_WIDTH]'1'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 1
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]I\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'2'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 2
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]II\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'3'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 3
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]III\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'4'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 4
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]IV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'5'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 5
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]IV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'6'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 6
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]IV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'7'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 7
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]VII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'8'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 8
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'9'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 9
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'10'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 10
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'11'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 11
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'12'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 12
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]VIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'13'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 13
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]XIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'14'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 14
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]XIV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'15'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 15
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]XIV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'16'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 16
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]XIV\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'17'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 17
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]XVII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'18'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 18
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]XVIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'19'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 19
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]XVIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.       if '\\*[$ROMAN_WIDTH]'20'  \{\
.          ds $ROMAN_WIDTH\\n[#DEPTH] 20
.          nr #LIST_INDENT\\n[#DEPTH] \w'\\*[$PREFIX\\n[#DEPTH]]XVIII\\*[$SEPARATOR\\n[#DEPTH]]\0'
.       \}
.    \}
.END
\#
\# SHIFT LIST
\# ----------
\# *Arguments:
\#   <amount by which to indent a list to the right>
\# *Function:
\#   Adds the value of the arg to the current list's indent.
\# *Notes:
\#   Requires a unit of measure.
\#
.MAC SHIFT_LIST END
.    ie '\\*[$ENUMERATOR_TYPE\\n[#DEPTH]]'roman' \{\
.       nr #SHIFT_LIST\\n[#DEPTH] (\\$1)
.       nr #LIST_INDENT\\n[#DEPTH] \\n(.i+\\n[#L_INDENT]+\\n[#SHIFT_LIST\\n[#DEPTH]]
.       nr #L_INDENT \\n[#LIST_INDENT\\n[#DEPTH]]
.    \}
.    el \{\
.       nr #LIST_INDENT\\n[#DEPTH] \\n[#L_INDENT]+(\\$1)
.       nr #L_INDENT \\n[#LIST_INDENT\\n[#DEPTH]]
.    \}
.END
\#
\#
\# PAD LIST DIGITS
\# ---------------
\# *Arguments:
\#   [ LEFT ]
\# *Function:
\#   Adds a figure space to a list's hanging and left indent.  If
\#   LEFT is given, sets reg. #PAD_LIST_DIGITS to 1 for use in ITEM.
\#
.MAC PAD_LIST_DIGITS END
.    if '\\g[#ENUMERATOR\\n[#DEPTH]]'0' \{\
.       nr #LIST_INDENT\\n[#DEPTH] +\\w'\\0'
.       nr #L_INDENT \\n[#LIST_INDENT\\n[#DEPTH]]+\\n[#LIST_INDENT\\n-[#DEPTH]]
.       nr #HL_INDENT\\n+[#DEPTH] +\\w'\\n[#ENUMERATOR\\n[#DEPTH]]'
.       if '\\$1'LEFT' \{ .nr #PAD_LIST_DIGITS\\n[#DEPTH] 1 \}
.    \}
.    if '\\g[#ENUMERATOR\\n[#DEPTH]]'i' \{\
.       if '\\$1'LEFT' \{ .nr #PAD_LIST_DIGITS\\n[#DEPTH] 1 \}
.    \}
.    if '\\g[#ENUMERATOR\\n[#DEPTH]]'I' \{\
.       if '\\$1'LEFT' \{ .nr #PAD_LIST_DIGITS\\n[#DEPTH] 1 \}
.    \}
.END
\#
\#
\# RESET LIST
\# ----------
\# *Arguments:
\#   none
\# *Function:
\#   Resets register enumerators to 1 or a.
\#
.MAC RESET_LIST END
.    ie '\\$1'' \{ .nr #ENUMERATOR\\n[#DEPTH] 0 1 \}
.    el \{ .nr #ENUMERATOR\\n[#DEPTH] \\$1-1 1 \}
.END
\#
\#
\# QUIT LISTS
\# ----------
\# *Arguments:
\#   none
\# *Function:
\#   Exits lists cleanly and restores any indents that were in
\#   effect prior to LIST.
\#
.MAC QUIT_LISTS END
.   IQ CLEAR
.   nr #HL_INDENT \\n[#STORED_HL_INDENT]
.   nr #T_INDENT  \\n[#STORED_T_INDENT]
.   rr #STORED_HL_INDENT
.   if \\n[#RESTORE_PREV_INDENT]=1 \{\
.      nr #L_INDENT  \\n[#STORED_L_INDENT]
.      IL
.      rr #STORED_L_INDENT
.   \}
.   if \\n[#RESTORE_PREV_INDENT]=2 \{\
.      nr #BL_INDENT \\n[#STORED_BL_INDENT]
.      nr #BR_INDENT \\n[#STORED_BR_INDENT]
.      LL \\n[#ORIG_L_LENGTH]u
.      IB
.      rr #STORED_BL_INDENT
.      rr #STORED_BR_INDENT
.   \}
.   if \\n[#RESTORE_PREV_INDENT]=3 \{\
.      nr #R_INDENT \\n[#STORED_R_INDENT]
.      LL \\n[#ORIG_L_LENGTH]u
.      IR
.      rr #STORED_R_INDENT
.   \}
.   if \\n[#RESTORE_PREV_INDENT]=4 \{\
.      nr #R_INDENT \\n[#STORED_R_INDENT]
.      nr #L_INDENT \\n[#STORED_L_INDENT]
.      LL \\n[#ORIG_L_LENGTH]u
.      IR
.      IL
.      rr #STORED_R_INDENT
.      rr #STORED_L_INDENT
.   \}
.\" Clean up after exiting last depth of list
.   nr #REMOVE 0 1
.   while \\n+[#REMOVE]<=\\n[#TOTAL_LISTS] \{\
.      rr #LIST_INDENT\\n[#REMOVE]
.      rr #ENUMERATOR\\n[#REMOVE]
.      rm $ENUMERATOR\\n[#REMOVE]
.      rr #SEPARATOR\\n[#REMOVE]
.      rm $ENUMERATOR_TYPE\\n[#REMOVE]
.      rr #PAD_LIST_DIGITS\\n[#REMOVE]
.\}
.   rr #REMOVE
.   rr #TOTAL_LISTS
.   rr #QUIT
.   rr #DEPTH
.   rr #NEXT_DEPTH_BACK
.   rr #RESTORE_PREV_INDENT
.   rr #ORIG_L_LENGTH
.   rr #CURRENT_L_LENGTH
.END
\#
\#
\# SET LIST INDENT
\# ---------------
\# *Arguments:
\#   none
\# *Function:
\#   Restores indent of prev. list in nested lists.  Also sets the
\#   #QUIT register if an invocation of LIST OFF applies to the first
\#   level of list.
\#
.MAC SET_LIST_INDENT END
.    nr #NEXT_DEPTH_BACK \\n[#DEPTH]-1
.    if \\n[#NEXT_DEPTH_BACK]=0 \{\
.       nr #QUIT 1
.       return
.    \}
.    nr #L_INDENT -\\n[#LIST_INDENT\\n[#DEPTH]]
.    nr #HL_INDENT \\n[#HL_INDENT\\n-[#DEPTH]]
.END
\#
\# ====================================================================
\#
\# +++DOCUMENT PROCESSING MISC AND SUPPORT MACROS+++
\#
\# COLLATE
\# -------
\# *Arguments:
\#   <none>
\# *Function:
\#   Turns headers off (if on) and saves header state, sets register
\#   #COLLATE to 1 (toggle), and breaks to a new page.
\# *Notes:
\#   COLLATE exists primarily to allow putting multiple chapters in
\#   a single file, although it can be used for any document type.  After
\#   COLLATE, any of the macros that normally precede START may be
\#   used, and should behave as expected.
\#
\#   N.B.--the START macro *must* be used after COLLATE (and any other
\#   macros that alter mom's behaviour).
\#
.MAC COLLATE END
.    nr #COLLATE 1
.    nr #HEADER_STATE \\n[#HEADERS_ON]
.    HEADERS OFF
.    if \\n[#PAGE_NUM_V_POS]=1 \{\
.       nr #PAGINATION_STATE \\n[#PAGINATE]
.       PAGINATION OFF
.    \}
.    IQ CLEAR
.    TQ
.\" Collect first doc's title for TOC
.    if \\n[#COLLATED_DOC]=0 \{\
.       ie \\n[#USER_SET_TITLE_ITEM] \{\
.          ds $FIRST_DOC_TITLE \\*[$USER_SET_TITLE_ITEM]\\|
.          rr #USER_SET_TITLE_ITEM
.          rm $USER_SET_TITLE_ITEM
.       \}
.       el \{\
.          ie \\n[#DOC_TYPE]=2 \{\
.             ie '\\*[$CHAPTER_TITLE]'' \{\
.                ds $FIRST_DOC_TITLE \\*[$CHAPTER_STRING] \\*[$CHAPTER]\\|
.             \}
.             el \{\
.                ie '\\*[$CHAPTER]'' \{\
.                   ds $FIRST_DOC_TITLE \\*[$CHAPTER_TITLE]\\|
.                \}
.                el \{\
.                   ds $FIRST_DOC_TITLE \\*[$CHAPTER_STRING] \\*[$CHAPTER]: \\*[$CHAPTER_TITLE]\\|
.                \}
.             \}
.          \}
.          el \{\
.             ds $FIRST_DOC_TITLE \\*[$TITLE]\\|
.          \}
.       \}
.       if \\n[#TOC_AUTHORS]=1 \{\
.          ie '\\*[$TOC_AUTHORS]'' \{\
.             as $FIRST_DOC_TITLE /\\|\\*[$AUTHOR_1]\\|
.          \}
.          el \{\
.             as $FIRST_DOC_TITLE /\\|\\*[$TOC_AUTHORS]\\|
.             rm $TOC_AUTHORS
.          \}
.       \}
.       nr #COLLATED_DOC 1
.    \}
.\" End title collection for TOC
.    LL \\n[#DOC_L_LENGTH]u
.    QUAD $DOC_QUAD
.    nr #SAVED_DOC_LEAD \\n[#DOC_LEAD]
.    LS \\n[#DOC_LEAD]u
\*[SLANTX]
\*[CONDX]
\*[EXTX]
'    NEWPAGE
.    if \\n[#DEFER_PAGINATION] \{ .PAGINATE \}
.    if !'\\*[$RESTORE_PAGENUM_STYLE]'' \{\
.       PAGENUM_STYLE \\*[$RESTORE_PAGENUM_STYLE]
.       rm $RESTORE_PAGENUM_STYLE
.    \}
.    rm $EN_TITLE
.    rr #PAGENUM_STYLE_SET
.END
\#
\#
\# NUMBER_LINES
\# ------------
\# *Arguments:
\#   <starting line number> [ <increment> [ <gutter> ] ]
\#   or
\#   <anything> | RESUME
\# *Function:
\#   Begin, suspend/turn off, or resume numbering of output lines.
\#
.MAC NUMBER_LINES END
.    br
.    if '\\n(.z'EPI_TEXT' \{ .return \}
.    if '\\$1'' \{\
.       tm1 "[mom]: NUMBER_LINES at line \\n(.c has no argument.
.       tm1 "       Most likely, you have forgotten to give it a starting line number.
.       ab Aborting on NUMBER_LINES.
.    \}
.    if !\\n[#LINENUMBERS]=2 \{ .nr #LINENUMBERS 1 \}
.\" Test whether the first arg is a digit.
.    if \B'\\$1' \{\
.       nr #LN \\$1
.       ds $LN_NUM \\$1
.       if !'\\n(.z'' \{ .nr #RESTORE_LN_NUM 1 \}
.       ie '\\$2'' \{\
.          if '\\*[$LN_INC]'' .ds $LN_INC 1
.       \}
.       el .ds $LN_INC \\$2
.       ie '\\$3'' \{\
.          if '\\*[$LN_GUTTER]'' .ds $LN_GUTTER 2
.       \}
.       el .ds $LN_GUTTER \\$3
.    \}
.    ie !\\n[#LN] \{\
.\" In other words, the first arg was not a digit.
.       rr #LN
.       ie '\\$1'RESUME' \{\
.          nm +0
.       \}
.       el \{\
.          nm
.          if !\\n[#LINENUMBERS]=2 \{ .rr #LINENUMBERS \}
.       \}
.    \}
.    el \{\
.       nm \\*[$LN_NUM] \\*[$LN_INC] \\*[$LN_GUTTER] -3-\\*[$LN_GUTTER]
.       if !'\\n(.z'' \{ .nr #DIVER_LN_OFF 1 \}
.    \}
.    rr #LN
.END
\#
\#
\# NUMBER QUOTE AND BLOCKQUOTE LINES AS PART OF RUNNING TEXT
\# ---------------------------------------------------------
\# *Argument:
\#   <gutter> | <anything>
\# *Function:
\#   Sets #(B)QUOTE_LN to 1 if no argument, or a single numeric
\#   argument, is given; otherwise, turns (BLOCK)QUOTE linenumbering
\#   off.
\# *Notes:
\#   #(B)QUOTE is checked for in QUOTE and BLOCKQUOTE.
\#   The single numeric argument allows establishing a different gutter from
\#   the one used for line numbers in running text.
\#
.MAC NUMBER_QUOTE_LINES END
.    ie \\n[#NUM_ARGS]=0 \{ .nr #QUOTE_LN 1 \}
.    el \{\
.       ie \B'\\$1' \{\
.          nr #QUOTE_LN 1
.          ds $Q_LN_GUTTER \\$1
.       \}
.       el \{\
.          ie '\\$1'SILENT' \{ .nr #SILENT_QUOTE_LN 1 \}
.          el \{\
.             rr #QUOTE_LN
.             rr #SILENT_QUOTE_LN
.          \}
.       \}
.    \}
.END
\#
\#
.MAC NUMBER_BLOCKQUOTE_LINES END
.    ie \\n[#NUM_ARGS]=0 \{ .nr #BQUOTE_LN 1 \}
.    el \{\
.       ie \B'\\$1' \{\
.          nr #BQUOTE_LN 1
.          ds $BQ_LN_GUTTER \\$1
.       \}
.       el \{\
.          ie '\\$1'SILENT' \{ .nr #SILENT_BQUOTE_LN 1 \}
.          el \{\
.             rr #BQUOTE_LN
.             rr #SILENT_BQUOTE_LN
.          \}
.       \}
.    \}
.END
\#
\# OUTPUT BLANK PAGES
\# ------------------
\# *Argument:
\#   <number of blank pages to output>
\# *Function:
\#   Outputs blank pages.
\# *Notes:
\#   If recto/verso, each page is recto/verso, even if there's
\#   nothing on it.
\#
\#   The argument to BLANKPAGE is non-optional.
\#
.MAC BLANKPAGE END
.    nr #HOW_MANY \\$1
.    nr #PAGES 0 1
.    while \\n+[#PAGES]<=\\n[#HOW_MANY] \{\
.       if \\n[#HEADERS_ON]=1 \{\
.          nr #HEADERS_WERE_ON 1
.          HEADERS OFF
.       \}
.       if \\n[#PAGE_NUM_V_POS]=1 \{\
.          if \\n[#PAGINATE]=1 \{ .nr #PAGINATE_WAS_ON 1 \}
.          PAGINATION OFF
.       \}
.       NEWPAGE
.       PRINT \&
.       if \\n[#FOOTERS_ON]=1 \{\
.          nr #FOOTERS_WERE_ON 1
.          FOOTERS OFF
.       \}
.       if \\n[#PAGE_NUM_V_POS]=2 \{\
.          if \\n[#PAGINATE]=1 \{ .nr #PAGINATE_WAS_ON 1 \}
.          PAGINATION OFF
.       \}
.       if \\n[#HEADERS_WERE_ON] \{ .HEADERS \}
.       if \\n[#PAGE_NUM_V_POS]=1 \{\
.          if \\n[#PAGINATE_WAS_ON] \{ .PAGINATE \}
.       \}
.\}
.    NEWPAGE
.    if \\n[#FOOTERS_WERE_ON] \{ .FOOTERS \}
.    if \\n[#PAGE_NUM_V_POS]=2 \{\
.       if \\n[#PAGINATE_WAS_ON] \{ .PAGINATE \}
.    \}
.    rr #HEADERS_WERE_ON
.    rr #FOOTERS_WERE_ON
.    rr #PAGINATE_WAS_ON
.END
\#
\#
\# SET TRAPS FOR HEADERS/FOOTERS/FOOTNOTES
\# ---------------------------------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Sets header/footer/footnotes/etc... traps.
\#
\#   Calculates the number of lines that actually fit on a
\#   page based on #B_MARGIN and resets page bottom trap to coincide
\#   with the depth of that number of lines, or, if #ADJ_DOC_LEAD=1,
\#   adjusts #DOC_LEAD so that the last line of text on a page falls
\#   exactly on #B_MARGIN.
\#
.MAC TRAPS END
.\" Remove all header/footer traps
.    if !\\n[#NO_TRAP_RESET] \{\
.       ch DO_T_MARGIN
.       ch DO_B_MARGIN
.       ch HEADER
.       ch FOOTER
.       ch FN_OVERFLOW_TRAP
.\" Plant header trap
.       wh 0 HEADER
.    \}
.\" Adjust lead so last line of text falls on B_MARGIN,...
.    ie \\n[#ADJ_DOC_LEAD]=1 \{\
.       nr #LINES_PER_PAGE 0 1
.       nr #DOC_LEAD_ADJ 0 1
.       nr #DEPTH_TO_B_MARGIN \\n[#PAGE_LENGTH]-\\n[#ORIGINAL_B_MARGIN]-1v
.\" Get the number of unadjusted lines that fit on the page; always a
.\" bit short of the bottom margin
.       while \\n[#T_MARGIN]+(\\n[#DOC_LEAD]*\\n+[#LINES_PER_PAGE])<\\n[#DEPTH_TO_B_MARGIN] \{\
.
.\}
.       nr #LINES_PER_PAGE -1
.\" Add machine units, 1 at a time, increasing the leading until the 
.\" new leading fills the page properly
.       while \\n[#T_MARGIN]+(\\n[#DOC_LEAD]+\\n+[#DOC_LEAD_ADJ]*\\n[#LINES_PER_PAGE])<\\n[#DEPTH_TO_B_MARGIN] \{\
.
.\}
.       DOC_LEAD \\n[#DOC_LEAD]u+\\n[#DOC_LEAD_ADJ]u
.\" The "visual" bottom margin is what \n(nl would report on the
.\" last line before the FOOTER trap is sprung
.       nr #VISUAL_B_MARGIN \\n[#T_MARGIN]+(\\n[#LINES_PER_PAGE]*\\n[#DOC_LEAD])
.\" Get the difference between #B_MARGIN and #VISUAL_B_MARGIN
.       nr #FOOTER_DIFF (\\n[#PAGE_LENGTH]-\\n[#B_MARGIN])-\\n[#VISUAL_B_MARGIN]
.\" Set #B_MARGIN to 1 machine unit lower on the page than #VISUAL_B_MARGIN
.       nr #B_MARGIN \\n[#B_MARGIN]+(\\n[#FOOTER_DIFF]-1)
.\" Set the FN_OVERFLOW_TRAP position
.       nr #FN_OVERFLOW_TRAP_POS \\n[#B_MARGIN]u-\\n[#FN_LEAD]
.       if \\n[#PRINT_STYLE]=1 .nr #FN_OVERFLOW_TRAP_POS \\n[#ORIGINAL_B_MARGIN]u
.    \}
.\" ...or calculate new B_MARGIN based on # of lines (at #DOC_LEAD) that fit
.\" on the page.
.    el \{\
.       nr #LINES_PER_PAGE 0 1
.       nr #DEPTH_TO_B_MARGIN \\n[#PAGE_LENGTH]-\\n[#B_MARGIN]-1v
.       while \\n[#T_MARGIN]+(\\n[#DOC_LEAD]*\\n+[#LINES_PER_PAGE])<\\n[#DEPTH_TO_B_MARGIN] \{\
.
.\}
.       nr #VISUAL_B_MARGIN \\n[#T_MARGIN]+(\\n[#LINES_PER_PAGE]*\\n[#DOC_LEAD]-1v)
.       nr #FOOTER_DIFF (\\n[#PAGE_LENGTH]-\\n[#B_MARGIN])-\\n[#VISUAL_B_MARGIN]
.       nr #B_MARGIN \\n[#B_MARGIN]+(\\n[#FOOTER_DIFF]-1)
.       nr #FN_OVERFLOW_TRAP_POS \\n[#B_MARGIN]u-\\n[#FN_LEAD]
.    \}
.\" Set footer and footnote overflow traps
.    if !\\n[#NO_TRAP_RESET] \{\
.       nr #FN_COUNT 0 1
.       nr #SPACE_REMAINING 0
.       nr #FN_DEPTH 0
.       nr #VARIABLE_FOOTER_POS 0-\\n[#B_MARGIN]u
.       wh 20i FOOTER
.       wh -(\\n[#FN_OVERFLOW_TRAP_POS]u) FN_OVERFLOW_TRAP
.       ch FOOTER -\\n[#B_MARGIN]u
.    \}
.END
\#
\#
\# CHECK INDENT
\# ------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Adds left, right, or both indent values to document elements
\#   like heads and subheads that are processed in environments.
\#
.MAC CHECK_INDENT END
.    if \\n[#INDENT_LEFT_ACTIVE] \{\
.       in \\n[#L_INDENT]u
.       if \\n[#QUOTE] \{\
.          in -\\n[#L_INDENT]u \"Because you added an indent in 2nd line of macro
.          ll -\\n[#L_INDENT]u
.          ta \\n(.lu
.       \}
.       if \\n[#EPIGRAPH] \{\
.          in -\\n[#L_INDENT]u
.          ll -\\n[#L_INDENT]u
.          ta \\n(.lu
.       \}
.    \}
.    if \\n[#INDENT_RIGHT_ACTIVE] \{\
.       ll -\\n[#R_INDENT]u
.       ta \\n(.lu
.    \}
.    if \\n[#INDENT_BOTH_ACTIVE] \{\
.       in \\n[#BL_INDENT]u
.       ll -\\n[#BR_INDENT]u
.       ta \\n(.lu
.       if \\n[#QUOTE] \{\
.          in -\\n[#BL_INDENT]u
.          ie \\n[#BR_INDENT]=\\n[#BL_INDENT] \{\
.             ll -\\n[#BR_INDENT]u
.             ta \\n(.lu
.          \}
.          el \{\
.             ll -(\\n[#BR_INDENT]u/2u)
.             ta \\n(.lu
.          \}
.       \}
.       if \\n[#EPIGRAPH] \{\
.          in -\\n[#BL_INDENT]u
.          ie \\n[#BR_INDENT]=\\n[#BL_INDENT] \{\
.             ll -\\n[#BR_INDENT]u
.             ta \\n(.lu
.          \}
.          el \{\
.             ll -(\\n[#BR_INDENT]u/2u)
.             ta \\n(.lu
.          \}
.       \}
.    \}
.END
\#
\#
\# REMOVE INDENT
\# -------------
\# *Arguments:
\#   <none>
\# *Function:
\#   Removes left, right, or both indent values from document elements
\#   like heads and subheads that are processed in environments.
\#
.MAC REMOVE_INDENT END
.    in 0
.    ll \\n[#L_LENGTH]u
.    ta \\n(.lu
.END
\#
\#
\# This .em (for all DOC_TYPEs except 4 [LETTER]) ensures that
\# deferred footnotes that happen on the 2nd to last page get
\# output.
\#
.MAC TERMINATE END
.    ie \\n[#FN_DEPTH] \{\
.       ie \\n[#FN_DEFER] \{\
.          br
.          nr #TERMINATE 1
.          FOOTNOTE
.          nf
.          FOOTNOTE OFF
.       \}
.       el \{\
.          br
.          ch FN_OVERFLOW_TRAP
.          DO_B_MARGIN
.       \}
.    \}
.    el \{\
.       br
.       ch FN_OVERFLOW_TRAP
.       DO_B_MARGIN
.    \}
.END
\#
\# END MACRO FOR LETTERS
\# ---------------------
\# *Arguments:
\#   none
\# *Function:
\#   The .em macro executed at the end of letters.  Turns footers
\#   and pagination off, terminates and outputs diversion CLOSING
\#   (indented with the author's name underneath).
\#
.MAC ALL_DONE END
.    br
.    FOOTERS OFF
.    PAGINATION OFF
.    if \\n[#DOC_TYPE]=4 \{\
.       br
.       if !'\\n(.z'' \{ .di \}
.       IQ CLEAR
.       TQ
.       TAB_SET 1 \\n[#DOC_L_LENGTH]u/2u \\n[#DOC_L_LENGTH]u/2u LEFT
.       ALD \\n[#DOC_LEAD]u*2u
.       TAB 1
.       if \\n[#CLOSING] \{\
.          nf
.          CLOSING
.       \}
.       ALD \\n[#DOC_LEAD]u*3u
.       PRINT \\*[$AUTHOR_1]
.    \}
.    DO_FOOTER
.END
\#
\# Set up a default papersize of US letter
\#
.PAPER LETTER
\#
\# ====================================================================
\#
\# +++DOCUMENT PROCESSING ALIASES+++
\#
\# Aliases to make life easier for users: synonyms, short forms
\# and alternate spellings.
\#
.ALIAS   BREAK_BLOCKQUOTE    BREAK_QUOTE
.ALIAS   BREAK_CITATION      BREAK_QUOTE
.ALIAS   BREAK_CITE          BREAK_QUOTE
.ALIAS   BLOCKQUOTE_INDENT   QUOTE_INDENT
.ALIAS   CITATION            BLOCKQUOTE
.ALIAS   CITATION_FAMILY     BLOCKQUOTE_FAMILY
.ALIAS   CITATION_FONT       BLOCKQUOTE_FONT
.ALIAS   CITATION_SIZE       BLOCKQUOTE_SIZE
.ALIAS   CITATION_COLOR      BLOCKQUOTE_COLOR
.ALIAS   CITATION_QUAD       BLOCKQUOTE_QUAD
.ALIAS   CITE                BLOCKQUOTE
.ALIAS   CITE_FAMILY         BLOCKQUOTE_FAMILY
.ALIAS   CITE_FONT           BLOCKQUOTE_FONT
.ALIAS   CITE_SIZE           BLOCKQUOTE_SIZE
.ALIAS   CITE_COLOR          BLOCKQUOTE_COLOR
.ALIAS   CITE_QUAD           BLOCKQUOTE_QUAD
.ALIAS   DOC_R_MARGIN        DOC_RIGHT_MARGIN
.ALIAS   DOC_L_MARGIN        DOC_LEFT_MARGIN
.ALIAS   DOC_L_LENGTH        DOC_LINE_LENGTH
.ALIAS   DOC_RMARGIN         DOC_RIGHT_MARGIN
.ALIAS   DOC_LMARGIN         DOC_LEFT_MARGIN
.ALIAS   DOC_LLENGTH         DOC_LINE_LENGTH
.ALIAS   DOC_FAM             DOC_FAMILY
.ALIAS   DOC_LS              DOC_LEAD
.ALIAS   DOC_PS              DOC_PT_SIZE
.ALIAS   FILL                QUAD
.ALIAS   PAGENUM             PAGENUMBER
.ALIAS   PAGINATION          PAGINATE
.ALIAS   PP_FT               PP_FONT
.ALIAS   REF_INDENT          INDENT_REFS
.ALIAS   TOC_PS              TOC_PT_SIZE
\#
\# HEADER and FOOTER macros
\# ------------------------
\# Because the type-style of headers and footers are managed
\# identically, and the type-style macros (_<type parameter>) all
\# require the correct name of the calling macro, it's necessary
\# to create HEADER_ and FOOTER_ macros here.  They're basically
\# "aliases" of HDRFTR_, but required because you can't alias an
\# alias.
\#
.MAC FOOTER_CENTER_COLOR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC FOOTER_CENTER_COLOUR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC FOOTER_CENTER_FAM END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC FOOTER_CENTER_FAMILY END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC FOOTER_CENTER_FONT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC FOOTER_CENTER_FT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC FOOTER_CENTER_PS END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC FOOTER_CENTER_SIZE END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC FOOTER_CENTRE_CAPS END
.    HDRFTR_CENTER_CAPS \\$1
.END
\#
.MAC FOOTER_CENTRE_COLOR END
.    HDRFTR_CENTRE_COLOR \\$1
.END
\#
.MAC FOOTER_CENTRE_COLOUR END
.    HDRFTR_CENTRE_COLOR \\$1
.END
\#
.MAC FOOTER_CENTRE_FAM END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC FOOTER_CENTRE_FAMILY END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC FOOTER_CENTRE_FONT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC FOOTER_CENTRE_FT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC FOOTER_CENTRE_PS END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC FOOTER_CENTRE_SIZE END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC FOOTER_COLOR END
.    HDRFTR_COLOR \\$1
.END
\#
.MAC FOOTER_COLOUR END
.    HDRFTR_COLOR \\$1
.END
\#
.MAC FOOTER_FAM END
.    HDRFTR_FAMILY \\$1
.END
\#
.MAC FOOTER_FAMILY END
.    HDRFTR_FAMILY \\$1
.END
\#
.MAC FOOTER_LEFT_COLOR END
.    HDRFTR_LEFT_COLOR \\$1
.END
\#
.MAC FOOTER_LEFT_COLOUR END
.    HDRFTR_LEFT_COLOR \\$1
.END
\#
.MAC FOOTER_LEFT_FAM END
.    HDRFTR_LEFT_FAMILY \\$1
.END
\#
.MAC FOOTER_LEFT_FAMILY END
.    HDRFTR_LEFT_FAMILY \\$1
.END
\#
.MAC FOOTER_LEFT_FONT END
.    HDRFTR_LEFT_FONT \\$1
.END
\#
.MAC FOOTER_LEFT_FT END
.    HDRFTR_LEFT_FONT \\$1
.END
\#
.MAC FOOTER_LEFT_PS END
.    HDRFTR_LEFT_SIZE \\$1
.END
\#
.MAC FOOTER_LEFT_SIZE END
.    HDRFTR_LEFT_SIZE \\$1
.END
\#
.MAC FOOTER_RIGHT_COLOR END
.    HDRFTR_RIGHT_COLOR \\$1
.END
\#
.MAC FOOTER_RIGHT_COLOUR END
.    HDRFTR_RIGHT_COLOR \\$1
.END
\#
.MAC FOOTER_RIGHT_FAM END
.    HDRFTR_RIGHT_FAMILY \\$1
.END
\#
.MAC FOOTER_RIGHT_FAMILY END
.    HDRFTR_RIGHT_FAMILY \\$1
.END
\#
.MAC FOOTER_RIGHT_FONT END
.    HDRFTR_RIGHT_FONT \\$1
.END
\#
.MAC FOOTER_RIGHT_FT END
.    HDRFTR_RIGHT_FONT \\$1
.END
\#
.MAC FOOTER_RIGHT_PS END
.    HDRFTR_RIGHT_SIZE \\$1
.END
\#
.MAC FOOTER_RIGHT_SIZE END
.    HDRFTR_RIGHT_SIZE \\$1
.END
\#
.MAC FOOTER_RULE_COLOR END
.    HDRFTR_RULE_COLOR \\$1
.END
\#
.MAC FOOTER_SIZE END
.    HDRFTR_SIZE \\$1
.END
\#
.MAC HEADER_CENTER_COLOR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC HEADER_CENTER_COLOUR END
.    HDRFTR_CENTER_COLOR \\$1
.END
\#
.MAC HEADER_CENTER_FAM END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC HEADER_CENTER_FAMILY END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC HEADER_CENTER_FONT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC HEADER_CENTER_FT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC HEADER_CENTER_PS END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC HEADER_CENTER_SIZE END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC HEADER_CENTRE_COLOR END
.    HDRFTR_CENTRE_COLOR \\$1
.END
\#
.MAC HEADER_CENTRE_COLOUR END
.    HDRFTR_CENTRE_COLOR \\$1
.END
\#
.MAC HEADER_CENTRE_FAM END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC HEADER_CENTRE_FAMILY END
.    HDRFTR_CENTER_FAMILY \\$1
.END
\#
.MAC HEADER_CENTRE_FONT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC HEADER_CENTRE_FT END
.    HDRFTR_CENTER_FONT \\$1
.END
\#
.MAC HEADER_CENTRE_PS END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC HEADER_CENTRE_SIZE END
.    HDRFTR_CENTER_SIZE \\$1
.END
\#
.MAC HEADER_COLOR END
.    HDRFTR_COLOR \\$1
.END
\#
.MAC HEADER_COLOUR END
.    HDRFTR_COLOR \\$1
.END
\#
.MAC HEADER_FAM END
.    HDRFTR_FAMILY \\$1
.END
\#
.MAC HEADER_FAMILY END
.    HDRFTR_FAMILY \\$1
.END
\#
.MAC HEADER_LEFT_COLOR END
.    HDRFTR_LEFT_COLOR \\$1
.END
\#
.MAC HEADER_LEFT_COLOUR END
.    HDRFTR_LEFT_COLOR \\$1
.END
\#
.MAC HEADER_LEFT_FAM END
.    HDRFTR_LEFT_FAMILY \\$1
.END
\#
.MAC HEADER_LEFT_FAMILY END
.    HDRFTR_LEFT_FAMILY \\$1
.END
\#
.MAC HEADER_LEFT_FONT END
.    HDRFTR_LEFT_FONT \\$1
.END
\#
.MAC HEADER_LEFT_FT END
.    HDRFTR_LEFT_FONT \\$1
.END
\#
.MAC HEADER_LEFT_PS END
.    HDRFTR_LEFT_SIZE \\$1
.END
\#
.MAC HEADER_LEFT_SIZE END
.    HDRFTR_LEFT_SIZE \\$1
.END
\#
.MAC HEADER_RIGHT_COLOR END
.    HDRFTR_RIGHT_COLOR \\$1
.END
\#
.MAC HEADER_RIGHT_COLOUR END
.    HDRFTR_RIGHT_COLOR \\$1
.END
\#
.MAC HEADER_RIGHT_FAM END
.    HDRFTR_RIGHT_FAMILY \\$1
.END
\#
.MAC HEADER_RIGHT_FAMILY END
.    HDRFTR_RIGHT_FAMILY \\$1
.END
\#
.MAC HEADER_RIGHT_FONT END
.    HDRFTR_RIGHT_FONT \\$1
.END
\#
.MAC HEADER_RIGHT_FT END
.    HDRFTR_RIGHT_FONT \\$1
.END
\#
.MAC HEADER_RIGHT_PS END
.    HDRFTR_RIGHT_SIZE \\$1
.END
\#
.MAC HEADER_RIGHT_SIZE END
.    HDRFTR_RIGHT_SIZE \\$1
.END
\#
.MAC HEADER_RULE_COLOR END
.    HDRFTR_RULE_COLOR \\$1
.END
\#
.MAC HEADER_SIZE END
.    HDRFTR_SIZE \\$1
.END
\#
\# HEADER and FOOTER aliases for HDRFTR macros.
\#
.ALIAS   BIBLIOGRAPHY_FOOTER_CENTER    BIBLIOGRAPHY_HDRFTR_CENTER
.ALIAS   BIBLIOGRAPHY_FOOTER_CENTRE    BIBLIOGRAPHY_HDRFTR_CENTRE
.ALIAS   BIBLIOGRAPHY_HEADER_CENTER    BIBLIOGRAPHY_HDRFTR_CENTER
.ALIAS   BIBLIOGRAPHY_HEADER_CENTRE    BIBLIOGRAPHY_HDRFTR_CENTRE
.ALIAS   ENDNOTES_FOOTER_CENTER    ENDNOTES_HDRFTR_CENTER
.ALIAS   ENDNOTES_FOOTER_CENTRE    ENDNOTES_HDRFTR_CENTRE
.ALIAS   ENDNOTES_HEADER_CENTER    ENDNOTES_HDRFTR_CENTER
.ALIAS   ENDNOTES_HEADER_CENTRE    ENDNOTES_HDRFTR_CENTRE
.ALIAS   FOOTER_CENTER_CAPS        HDRFTR_CENTER_CAPS
.ALIAS   FOOTER_CENTER             HDRFTR_CENTER
.ALIAS   FOOTER_CENTER_PAD         HDRFTR_CENTER_PAD
.ALIAS   FOOTER_CENTRE             HDRFTR_CENTER
.ALIAS   FOOTER_CENTRE_PAD         HDRFTR_CENTER_PAD
.ALIAS   FOOTER_LEFT_CAPS          HDRFTR_LEFT_CAPS
.ALIAS   FOOTER_LEFT               HDRFTR_LEFT
.ALIAS   FOOTER_PLAIN              HDRFTR_PLAIN
.ALIAS   FOOTER_RECTO              HDRFTR_RECTO
.ALIAS   FOOTER_RIGHT_CAPS         HDRFTR_RIGHT_CAPS
.ALIAS   FOOTER_RIGHT              HDRFTR_RIGHT
.ALIAS   FOOTER_RULE_GAP           HDRFTR_RULE_GAP
.ALIAS   FOOTER_RULE               HDRFTR_RULE
.ALIAS   FOOTER_VERSO              HDRFTR_VERSO
.ALIAS   HEADER_CENTER_CAPS        HDRFTR_CENTER_CAPS
.ALIAS   HEADER_CENTER             HDRFTR_CENTER
.ALIAS   HEADER_CENTER_PAD         HDRFTR_CENTER_PAD
.ALIAS   HEADER_CENTRE_CAPS        HDRFTR_CENTER_CAPS
.ALIAS   HEADER_CENTRE             HDRFTR_CENTER
.ALIAS   HEADER_CENTRE_PAD         HDRFTR_CENTER_PAD
.ALIAS   HEADER_LEFT_CAPS          HDRFTR_LEFT_CAPS
.ALIAS   HEADER_LEFT               HDRFTR_LEFT
.ALIAS   HEADER_PLAIN              HDRFTR_PLAIN
.ALIAS   HEADER_RECTO              HDRFTR_RECTO
.ALIAS   HEADER_RIGHT_CAPS         HDRFTR_RIGHT_CAPS
.ALIAS   HEADER_RIGHT              HDRFTR_RIGHT
.ALIAS   HEADER_RULE_GAP           HDRFTR_RULE_GAP
.ALIAS   HEADER_RULE               HDRFTR_RULE
.ALIAS   HEADER_VERSO              HDRFTR_VERSO
.ALIAS   SWITCH_FOOTERS            SWITCH_HDRFTR
.ALIAS   SWITCH_HEADERS            SWITCH_HDRFTR
\#
\# Type-style aliases
\#
.ALIAS   AUTHOR_FAMILY                    _FAMILY
.ALIAS   BIBLIOGRAPHY_FAMILY              _FAMILY
.ALIAS   BIBLIOGRAPHY_STRING_FAMILY       _FAMILY
.ALIAS   BLOCKQUOTE_FAMILY                _FAMILY
.ALIAS   CHAPTER_TITLE_FAMILY             _FAMILY
.ALIAS   COVER_AUTHOR_FAMILY              _FAMILY
.ALIAS   COVER_CHAPTER_TITLE_FAMILY       _FAMILY
.ALIAS   COVER_COPYRIGHT_FAMILY           _FAMILY
.ALIAS   COVER_DOCTYPE_FAMILY             _FAMILY
.ALIAS   COVER_FAMILY                     _FAMILY
.ALIAS   COVER_SUBTITLE_FAMILY            _FAMILY
.ALIAS   COVER_TITLE_FAMILY               _FAMILY
.ALIAS   DOC_COVER_AUTHOR_FAMILY          _FAMILY
.ALIAS   DOC_COVER_CHAPTER_TITLE_FAMILY   _FAMILY
.ALIAS   DOC_COVER_COPYRIGHT_FAMILY       _FAMILY
.ALIAS   DOC_COVER_DOCTYPE_FAMILY         _FAMILY
.ALIAS   DOC_COVER_FAMILY                 _FAMILY
.ALIAS   DOC_COVER_SUBTITLE_FAMILY        _FAMILY
.ALIAS   DOC_COVER_TITLE_FAMILY           _FAMILY
.ALIAS   DOCHEADER_FAMILY                 _FAMILY
.ALIAS   DOCTYPE_FAMILY                   _FAMILY
.ALIAS   ENDNOTE_FAMILY                   _FAMILY
.ALIAS   ENDNOTE_NUMBER_FAMILY            _FAMILY
.ALIAS   ENDNOTE_LINENUMBER_FAMILY        _FAMILY
.ALIAS   ENDNOTE_STRING_FAMILY            _FAMILY
.ALIAS   ENDNOTE_TITLE_FAMILY             _FAMILY
.ALIAS   EPIGRAPH_FAMILY                  _FAMILY
.ALIAS   FOOTNOTE_FAMILY                  _FAMILY
.ALIAS   HDRFTR_CENTER_FAMILY             _FAMILY
.ALIAS   HDRFTR_FAMILY                    _FAMILY
.ALIAS   HDRFTR_LEFT_FAMILY               _FAMILY
.ALIAS   HDRFTR_RIGHT_FAMILY              _FAMILY
.ALIAS   HEAD_FAMILY                      _FAMILY
.ALIAS   PAGENUM_FAMILY                   _FAMILY
.ALIAS   PARAHEAD_FAMILY                  _FAMILY
.ALIAS   QUOTE_FAMILY                     _FAMILY
.ALIAS   SUBHEAD_FAMILY                   _FAMILY
.ALIAS   SUBTITLE_FAMILY                  _FAMILY
.ALIAS   TITLE_FAMILY                     _FAMILY
.ALIAS   TOC_FAM                          _FAMILY
.ALIAS   TOC_FAMILY                       _FAMILY
.ALIAS   TOC_HEADER_FAMILY                _FAMILY
.ALIAS   TOC_HEAD_FAMILY                  _FAMILY
.ALIAS   TOC_PARAHEAD_FAMILY              _FAMILY
.ALIAS   TOC_PN_FAMILY                    _FAMILY
.ALIAS   TOC_SUBHEAD_FAMILY               _FAMILY
.ALIAS   TOC_TITLE_FAMILY                 _FAMILY
\#
.ALIAS   AUTHOR_FONT                    _FONT
.ALIAS   BIBLIOGRAPHY_STRING_FONT       _FONT
.ALIAS   BIBLIOGRAPHY_FONT              _FONT
.ALIAS   BLOCKQUOTE_FONT                _FONT
.ALIAS   CHAPTER_TITLE_FONT             _FONT
.ALIAS   COVER_AUTHOR_FONT              _FONT
.ALIAS   COVER_CHAPTER_TITLE_FONT       _FONT
.ALIAS   COVER_COPYRIGHT_FONT           _FONT
.ALIAS   COVER_DOCTYPE_FONT             _FONT
.ALIAS   COVER_SUBTITLE_FONT            _FONT
.ALIAS   COVER_TITLE_FONT               _FONT
.ALIAS   DOC_COVER_AUTHOR_FONT          _FONT
.ALIAS   DOC_COVER_CHAPTER_TITLE_FONT   _FONT
.ALIAS   DOC_COVER_COPYRIGHT_FONT       _FONT
.ALIAS   DOC_COVER_DOCTYPE_FONT         _FONT
.ALIAS   DOC_COVER_SUBTITLE_FONT        _FONT
.ALIAS   DOC_COVER_TITLE_FONT           _FONT
.ALIAS   DOCTYPE_FONT                   _FONT
.ALIAS   ENDNOTE_FONT                   _FONT
.ALIAS   ENDNOTE_NUMBER_FONT            _FONT
.ALIAS   ENDNOTE_LINENUMBER_FONT        _FONT
.ALIAS   ENDNOTE_STRING_FONT            _FONT
.ALIAS   ENDNOTE_TITLE_FONT             _FONT
.ALIAS   EPIGRAPH_FONT                  _FONT
.ALIAS   FOOTNOTE_FONT                  _FONT
.ALIAS   HDRFTR_CENTER_FONT             _FONT
.ALIAS   HDRFTR_LEFT_FONT               _FONT
.ALIAS   HDRFTR_RIGHT_FONT              _FONT
.ALIAS   HEAD_FONT                      _FONT
.ALIAS   PAGENUM_FONT                   _FONT
.ALIAS   PARAHEAD_FONT                  _FONT
.ALIAS   QUOTE_FONT                     _FONT
.ALIAS   SUBHEAD_FONT                   _FONT
.ALIAS   SUBTITLE_FONT                  _FONT
.ALIAS   TITLE_FONT                     _FONT
.ALIAS   TOC_HEADER_FONT                _FONT
.ALIAS   TOC_HEAD_FONT                  _FONT
.ALIAS   TOC_PARAHEAD_FONT              _FONT
.ALIAS   TOC_PN_FONT                    _FONT
.ALIAS   TOC_SUBHEAD_FONT               _FONT
.ALIAS   TOC_TITLE_FONT                 _FONT
\#
.ALIAS   AUTHOR_SIZE                    _SIZE
.ALIAS   BIBLIOGRAPHY_STRING_SIZE       _SIZE
.ALIAS   BLOCKQUOTE_SIZE                _SIZE
.ALIAS   CHAPTER_TITLE_SIZE             _SIZE
.ALIAS   COVER_AUTHOR_SIZE              _SIZE
.ALIAS   COVER_CHAPTER_TITLE_SIZE       _SIZE
.ALIAS   COVER_COPYRIGHT_SIZE           _SIZE
.ALIAS   COVER_DOCTYPE_SIZE             _SIZE
.ALIAS   COVER_SUBTITLE_SIZE            _SIZE
.ALIAS   COVER_TITLE_SIZE               _SIZE
.ALIAS   DOC_COVER_AUTHOR_SIZE          _SIZE
.ALIAS   DOC_COVER_CHAPTER_TITLE_SIZE   _SIZE
.ALIAS   DOC_COVER_COPYRIGHT_SIZE       _SIZE
.ALIAS   DOC_COVER_DOCTYPE_SIZE         _SIZE
.ALIAS   DOC_COVER_SUBTITLE_SIZE        _SIZE
.ALIAS   DOC_COVER_TITLE_SIZE           _SIZE
.ALIAS   DOCTYPE_SIZE                   _SIZE
.ALIAS   ENDNOTE_NUMBER_SIZE            _SIZE
.ALIAS   ENDNOTE_LINENUMBER_SIZE        _SIZE
.ALIAS   ENDNOTE_STRING_SIZE            _SIZE
.ALIAS   ENDNOTE_TITLE_SIZE             _SIZE
.ALIAS   EPIGRAPH_SIZE                  _SIZE
.ALIAS   FOOTNOTE_SIZE                  _SIZE
.ALIAS   HDRFTR_CENTER_SIZE             _SIZE
.ALIAS   HDRFTR_LEFT_SIZE               _SIZE
.ALIAS   HDRFTR_RIGHT_SIZE              _SIZE
.ALIAS   HDRFTR_SIZE                    _SIZE
.ALIAS   HEAD_SIZE                      _SIZE
.ALIAS   PAGENUM_SIZE                   _SIZE
.ALIAS   PARAHEAD_SIZE                  _SIZE
.ALIAS   QUOTE_SIZE                     _SIZE
.ALIAS   SUBHEAD_SIZE                   _SIZE
.ALIAS   SUBTITLE_SIZE                  _SIZE
.ALIAS   TITLE_SIZE                     _SIZE
.ALIAS   TOC_HEADER_SIZE                _SIZE
.ALIAS   TOC_HEAD_SIZE                  _SIZE
.ALIAS   TOC_PARAHEAD_SIZE              _SIZE
.ALIAS   TOC_PN_SIZE                    _SIZE
.ALIAS   TOC_SUBHEAD_SIZE               _SIZE
.ALIAS   TOC_TITLE_SIZE                 _SIZE
\#
.ALIAS   ATTRIBUTE_COLOR                 _COLOR
.ALIAS   AUTHOR_COLOR                    _COLOR
.ALIAS   BLOCKQUOTE_COLOR                _COLOR
.ALIAS   CHAPTER_TITLE_COLOR             _COLOR
.ALIAS   COVER_ATTRIBUTE_COLOR           _COLOR
.ALIAS   COVER_AUTHOR_COLOR              _COLOR
.ALIAS   COVER_CHAPTER_TITLE_COLOR       _COLOR
.ALIAS   COVER_COLOR                     _COLOR
.ALIAS   COVER_COPYRIGHT_COLOR           _COLOR
.ALIAS   COVER_DOCTYPE_COLOR             _COLOR
.ALIAS   COVER_MISC_COLOR                _COLOR
.ALIAS   COVER_SUBTITLE_COLOR            _COLOR
.ALIAS   COVER_TITLE_COLOR               _COLOR
.ALIAS   DOC_COVER_ATTRIBUTE_COLOR       _COLOR
.ALIAS   DOC_COVER_AUTHOR_COLOR          _COLOR
.ALIAS   DOC_COVER_CHAPTER_TITLE_COLOR   _COLOR
.ALIAS   DOC_COVER_COLOR                 _COLOR
.ALIAS   DOC_COVER_COPYRIGHT_COLOR       _COLOR
.ALIAS   DOC_COVER_DOCTYPE_COLOR         _COLOR
.ALIAS   DOC_COVER_MISC_COLOR            _COLOR
.ALIAS   DOC_COVER_SUBTITLE_COLOR        _COLOR
.ALIAS   DOC_COVER_TITLE_COLOR           _COLOR
.ALIAS   DOCHEADER_COLOR                 _COLOR
.ALIAS   DOCTYPE_COLOR                   _COLOR
.ALIAS   EPIGRAPH_COLOR                  _COLOR
.ALIAS   FINIS_COLOR                     _COLOR
.ALIAS   FOOTNOTE_COLOR                  _COLOR
.ALIAS   HDRFTR_CENTER_COLOR             _COLOR
.ALIAS   HDRFTR_COLOR                    _COLOR
.ALIAS   HDRFTR_LEFT_COLOR               _COLOR
.ALIAS   HDRFTR_RIGHT_COLOR              _COLOR
.ALIAS   HDRFTR_RULE_COLOR               _COLOR
.ALIAS   HEAD_COLOR                      _COLOR
.ALIAS   LINEBREAK_COLOR                 _COLOR
.ALIAS   PAGENUM_COLOR                   _COLOR
.ALIAS   PARAHEAD_COLOR                  _COLOR
.ALIAS   QUOTE_COLOR                     _COLOR
.ALIAS   SUBHEAD_COLOR                   _COLOR
.ALIAS   SUBTITLE_COLOR                  _COLOR
.ALIAS   TITLE_COLOR                     _COLOR
\#
.ALIAS   BIBLIOGRAPHY_QUAD          _QUAD
.ALIAS   BIBLIOGRAPHY_STRING_QUAD   _QUAD
.ALIAS   BLOCKQUOTE_QUAD            _QUAD
.ALIAS   COVER_COPYRIGHT_QUAD       _QUAD
.ALIAS   COVER_MISC_QUAD            _QUAD
.ALIAS   DOC_COVER_COPYRIGHT_QUAD   _QUAD
.ALIAS   DOC_COVER_MISC_QUAD        _QUAD
.ALIAS   DOC_QUAD                   _QUAD
.ALIAS   ENDNOTE_QUAD               _QUAD
.ALIAS   ENDNOTE_STRING_QUAD        _QUAD
.ALIAS   ENDNOTE_TITLE_QUAD         _QUAD
.ALIAS   EPIGRAPH_QUAD              _QUAD
.ALIAS   FOOTNOTE_QUAD              _QUAD
.ALIAS   HEAD_QUAD                  _QUAD
.ALIAS   SUBHEAD_QUAD               _QUAD
.ALIAS   TOC_HEADER_QUAD            _QUAD
\#
\# Support aliases
\#
.ALIAS   COL_BREAK             COL_NEXT
.ALIAS   DOC_COVER_ADVANCE     COVER_ADVANCE 
.ALIAS   DOC_COVER             COVER
.ALIAS   DOC_COVERS            COVERS
.ALIAS   DOC_COVER_LEAD        COVER_LEAD
.ALIAS   DOC_COVERTITLE        COVERTITLE
.ALIAS   DO_DOC_COVER          DO_COVER
.ALIAS   PRINT_FOOTNOTE_RULE   FOOTNOTE_RULE
\#
\# Miscellaneous aliases
.ALIAS  SECTION       LINEBREAK
.ALIAS  SECTION_CHAR  LINEBREAK_CHAR
\#
\# Miscellaneous macros to take care of backward compatibility
\# -----------------------------------------------------------
\#
\# As of 1.1.9, EL and TN got changed to make TRAP...TRAP OFF
\# unnecessary for users.  However, I used both macros extensively
\# throughout this file (in conjunction with TRAP...TRAP OFF).
\# EOL is the "old" EL, for the personal use of om.tmac
\#
.MAC EOL END
.    br
.    sp -1v
.END
\#
\# REFER SUPPORT
\# -------------
\#
\# Footnote references
\# -------------------
\# *Function:
\#   Instruct REF to put references in footnotes.
\#
.MAC FOOTNOTE_REFS END
.    if r#EN_REF \{ .rr #EN_REF \}
.    nr #FN_REF 1
.END
\#
\# Endnote references
\# ------------------
\# *Function:
\#   Instruct REF to collect references for endnotes output.
\#
.MAC ENDNOTE_REFS END
.    if r#FN_REF \{ .rr #FN_REF \}
.    nr #EN_REF 1
.END
\#
\# Prepare mom for a reference
\# ---------------------------
\# *Argument:
\#   <none> | INDENT  L|LEFT|R|RIGHT|B|BOTH  <indent value>
\# *Function:
\#   Calls FOOTNOTE or ENDNOTE, depending on whether #REF_FN or
\#   #REF_EN is set to 1.
\# *Notes:
\#   For convenience, REF is a toggle.
\#
\#   REF optionally takes the same arguments as FOOTNOTE, allowing
\#   users to indent references that go in footnotes when footnote
\#   indenting is required.  FOOTNOTE_REFS must be on for this.
\#
.MAC REF END
.    ie \\n[#FN_REF]+\\n[#EN_REF]=0 \{\
.       if !\\n[#REF_WARNING]=1 \{\
.          tm1 "[mom]: Before REF at line \\n(.c, neither FOOTNOTE_REFS nor ENDNOTE_REFS
.          tm1 "       has been selected.  If "sort" and "accumulate" are in your refer
.          tm1 "       commands, references will be collected for later output with $LIST$.
.          tm1 "       Otherwise, they will disappear.
.          nr #REF_WARNING 1
.       \}
.    \}
.    el \{\
.    ie \\n[#REF]=1 \{\
.       if \\n[#FN_REF]=1 \{ .FOOTNOTE OFF \}
.       if \\n[#EN_REF]=1 \{ .ENDNOTE OFF  \}
.       rr #REF
.    \}
.    el \{\
.       rr #REF_WARNING
.       nr #REF 1
.       if \\n[#FN_REF]=1 \{ .FOOTNOTE \\$1 \\$2 \\$3 \}
.       if \\n[#EN_REF]=1 \{ .ENDNOTE  \}
.    \}
.    \}
.END
\#
\# Embedded references in text (with brackets)
\# -------------------------------------------
\#
.MAC REF_BRACKETS_START END
.    ds $CURRENT_EV \\n[.ev]
.    ev REFERENCE
.    evc  \\*[$CURRENT_EV]
.    di REFERENCE
.END
\#
.MAC REF_BRACKETS_END END
.    br
.    di
.    ev
.    chop REFERENCE
.    unformat REFERENCE
.    if '\\$0'REF)' \{ .nop (\\*[REFERENCE]) \}
.    if '\\$0'REF]' \{ .nop [\\*[REFERENCE]] \}
.    if '\\$0'REF}' \{ .nop {\\*[REFERENCE]} \}
.END
\#
\# These three pairs of aliases allow users to embed references in
\# text and have them surrounded by (), [] or {}.
\#
.ALIAS REF( REF_BRACKETS_START
.ALIAS REF) REF_BRACKETS_END
\#
.ALIAS REF[ REF_BRACKETS_START
.ALIAS REF{ REF_BRACKETS_START
\#
.ALIAS REF} REF_BRACKETS_END
.ALIAS REF] REF_BRACKETS_END
\#
\# Second-line indent for refs
\# ---------------------------
\# *Argument:
\#   FOOTNOTE | ENDNOTE | BIBLIO <indent for 2nd and subsequent lines of discrete reference entries>
\# *Function:
\#   Sets strings $REF_FN_INDENT, $REF_EN_INDENT or $REF_BIB_INDENT.
\# *Notes:
\#   Indent value requires a unit of measure.
\#
.MAC INDENT_REFS END
.    if '\\$1'FOOTNOTE' .ds $REF_FN_INDENT \\$2
.    if '\\$1'ENDNOTE'  .ds $REF_EN_INDENT \\$2
.    if '\\$1'BIBLIO'   .ds $REF_BIB_INDENT \\$2
.END
\#
\# Hyphenation of references
\# -------------------------
\# *Argument:
\#   <none> | <anything>
\# *Function:
\#   Sets register #REF_HYPHENATE
\#
.MAC HYPHENATE_REFS END
.    ie '\\$1'' \{ .nr #REF_HYPHENATE 1 \}
.    el \{\
.       if r#REF_HY \{ .rr #REF_HY \}
.    \}
.END
\#
.ig
The remainder of the definitions in this section are modified
versions of the definitions found in the refer module of s.tmac.
..
\#
\# This one is directly from s.tmac.
.de @error
.tm \\n(.F:\\n(.c: macro error: \\$*
..
\#
.ig
The following strings define the order of entries for different
types of references.  Each letter in the string refers to a database
field (A for author, T1/T2 for article and book titles, etc).
Mom is set up for MLA-style bibliographies.  Other styles can be
implemented here by re-ordering the fields.
..
\# Book - type 2
.ds ref*spec!2 Q A T1 d t l r E S e V a C I D P O
\# Article within book - type 3
.ds ref*spec!3 Q A T2 B d t l r E S e V a C I D P O
\# Journal article - type 1
.ds ref*spec!1 Q A T2 J S N D P O
\# Tech report - type 4
.ds ref*spec!4 Q A T1 R G C I D P O
\# Internet site - type 0
.ds ref*spec!0 Q A T2 s E c d o a u O
\#
\# Refer's "1st" macro.  Since it is possible to define database
\# fields using any single letter, we remove all possible string
\# definitions of the form [X and [x
\#
.de ]-
.rm [A [B [C [D [E [F [G [H [I [J [K [L [M \
    [N [O [P [Q [R [S [T [U [V [W [X [Y [Z \
.   [a [b [c [d [e [f [g [h [i [j [k [l [m \
    [n [o [p [q [r [s [t [u [v [w [x [y [z
.rm ref*string
.rr ref*type
..
\#
\# Refer's "2nd" macro; builds up a reference with ref*build, and
\# prints it with ref*print.
\#
.de ][
.nr ref*type \\$1
.if \\n[ref*type]=3 \{\
.   if !'\\*([R'' \{\
.      nr ref*type 4
.      ds ref*spec!4 Q A T2 B R C I D P O
.   \}
.   if !'\\*([G'' \{\
.      nr ref*type 4
.      ds ref*spec!4 Q A T2 B G C I D P O
.   \}
.\}
.if r [T \{\
.   als [T1 [T
.   als [T2 [T
.\}
.ie d ref*spec!\\n[ref*type] .ref*build \\*[ref*spec!\\n[ref*type]]
.el \{\
.   @error unknown reference type `\\n[ref*type]'
.   ref*build \\*[ref*spec!0]
.\}
.if !\\n[.hy]=0 \{\
.nr #RESTORE_HY \\n[.hy]
.if !r#REF_HY .nh
.\}
.ref*print
.if !\\n[#RESTORE_HY]=0 .hy \\n[#RESTORE_HY]
.rr #RESTORE_HY
.rm ref*string
.rm [F [T1 [T2
..
\#
\# Refer's "3rd" macros, which set up and terminate the output
\# of collected references
\#
.de ]<
.als ref*print ref*end-print
.nr #REF 1
.if \\n[#BIB_LIST]=1 \{\
.   nr #IN_BIB_LIST 1
.   LIST DIGIT \\*[$BIB_LIST_SEPARATOR] \\*[$BIB_LIST_PREFIX]
.\}
..
\#
.de ]>
.LIST OFF
.rr #REF
.rr #IN_BIB_LIST
.als ref*print ref*normal-print
..
\#
\# Output
\# ------
\#
\# Output normal, non-collected refs
\#
.de ref*normal-print
.nr #CURRENT_HY \\n[.hy]
\\*[ref*string]
..
\#
\# Output collected refs
\#
.de ref*end-print
.\" 10 is abritrary
.nn 10
.ie \\n[#BIB_LIST]=0 \{\
.in +\\*[$REF_BIB_INDENT]
.ti -\\*[$REF_BIB_INDENT]
.\}
.el .ITEM
\\*[ref*string]
.sp \\n[#BIB_SPACE]u
.ie \\n[#BIB_LIST]=0 .in
.el .IL -\\*[$REF_BIB_INDENT]u
.nn 0
..
\#
.als ref*print ref*normal-print
\#
\# Build up the ref*string
\#
.ig
Correct MLA "typewritten" style (printstyle TYPEWRITE) demands
two spaces after each period.  The spaces are hardwired into the
string definitions (ref*add-<x>), so we have to make sure that there
aren't two spaces when the printstyle is TYPESET.  Since I find that
references look a bit crowded with 0 sentence space, I've bumped it
up to +4.  User's sentence spacing is reset in FOOTNOTES and ENDNOTES.
..
\#
.de ref*build
.if \\n[#PRINT_STYLE]=2 \{\
.   ds $RESTORE_SS_VAR \\*[$SS_VAR]
.   SS +4
.\}
.rm ref*string ref*post-punct
.nr ref*suppress-period 1
.while \\n[.$] \{\
.   if d [\\$1 \{\
.      ie d ref*add-\\$1 .ref*add-\\$1
.      el .ref*add-dflt \\$1
.   \}
.   shift
.\}
.\" now add a final period
.ie d ref*string \{\
.   if !\\n[ref*suppress-period] .as ref*string .
.   if d ref*post-punct \{\
.      as ref*string "\\*[ref*post-punct]
.      rm ref*post-punct
.   \}
.\}
.el .ds ref*string
..
\#
\# The following macros determine how entries are formatted WRT
\# punctuation, type style, additional strings, etc.
\#
.ig
o First argument is the database field letter.
o Second argument is the punctuation character to use to separate this
  field from the previous field.
o Third argument is a string with which to prefix this field.
o Fourth argument is a string with which to postfix this field.
o Fifth argument is a string to add after the punctuation character
  supplied by the next field.
..
\#
\# %A Author(s)
.de ref*add-A
.ref*field A ,
.if r [A .nr ref*suppress-period \\n([A
..
\# %T Title (generic)
.de ref*add-T1
.ref*field T . " \E*[IT]" "" \E*[PREV]
.if \\n([T .nr ref*suppress-period \\n([T
..
\# %T Title of a chapter or article
.de ref*add-T2
.ref*field T . " \(lq" "" "\(rq"
.if \\n([T .nr ref*suppress-period \\n([T
..
\# %B Book title (when citing an article from a book)
.de ref*add-B
.ie \\n([T .ref*field B "" ".\E*[IT]" "" \E*[PREV]
.el .ref*field B . " \E*[IT]" "" \E*[PREV]
\# refer doesn't set reg [T to 1 for these book titles, so we do it here
.ds eval*[B \\*([B
.substring eval*[B -1
.rr [T
.if '\\*[eval*[B]'!' .nr [T 1
.if '\\*[eval*[B]'?' .nr [T 1
.rm eval*[B
..
\# %R Report number for technical reports
.de ref*add-R
.ref*field R . " "
..
\# %J Journal name
.de ref*add-J
.ie \\n([T .ref*field J "" " \E*[IT]" "" \E*[PREV]
.el .ref*field J . " \E*[IT]" "" \E*[PREV]
..
\# %E Editor(s)
.de ref*add-E
.ie !\\n[ref*type]=0 \{\
.   ie \\n([E>0 \{\
.      ie \\n([T .ref*field E "" " Eds. "
.      el .ref*field E . " Eds. "
.   \}
.   el \{\
.      ie \\n([T .ref*field E "" " Ed. "
.      el .ref*field E . " Ed. "
.   \}
.\}
.el \{\
.   ie \\n([T .ref*field E "" " "
.   el .ref*field E . " "
.\}
.rr [T
..
\# %e Edition
.de ref*add-e
.ie \\n([T .ref*field e "" " " " edition"
.el .ref*field e . " " " edition"
.rr [T
..
\# %V Volume (of a journal, or series of books)
.de ref*add-V
.if \\n[ref*type]=1 \{\
.   ref*field V 
.\}
.if \\n[ref*type]=2 \{\
.   ie \\n([T .ref*field V "" " "
.   el .ref*field V . " "
.\}
.if \\n[ref*type]=3 \{\
.   ie \\n([T .ref*field V "" " "
.   el .ref*field V . " "
.\}
.rr [T
..
\# %N Journal number
.de ref*add-N
.ref*field N 
..
\# %S Series (books or journals)
.de ref*add-S
.if \\n[ref*type]=1 \{\
.   ref*field S
.\}
.if \\n[ref*type]=2 \{\
.   ie \\n([T .ref*field S "" " "
.   el .ref*field S . " "
.\}
.if \\n[ref*type]=3 \{\
.   ie \\n([T .ref*field S "" " "
.   el .ref*field S . " "
.\}
.rr [T
\# refer doesn't set reg [T to 1 for series titles, so we do it here
.ds eval*[S \\*([S
.substring eval*[S -1
.if '\\*[eval*[S]'!' .nr [T 1
.if '\\*[eval*[S]'?' .nr [T 1
.rm eval*[S
..
\# %C City
.de ref*add-C
.ie \\n([T .ref*field C "" " "
.el .ref*field C . " "
.rr [T
..
\# %I Publisher (I stands for Issuer)
.de ref*add-I
.ie !'\\*([C'' .ref*field I :
.el \{\
.   ie \\n([T .ref*field I "" " "
.   el .ref*field I . " "
.\}
.rr [T
..
\# %D Date of publication
.de ref*add-D
.if \\n[ref*type]=1 \{\
.   ie !'\\*([V''.ref*field D "" "(" ")"
.   el .ref*field D
.\}
.if \\n[ref*type]=2 .ref*field D ,
.if \\n[ref*type]=3 \{\
.   ie '\\*([C'' \{\
.      ie '\\*([I'' .ref*field D . " "
.      el .ref*field D ,
.   \}
.   el .ref*field D ,
.\}
.if \\n[ref*type]=4 .ref*field D ,
..
\# %P Page number(s)
.de ref*add-P
.ie \\n[ref*type]=1 .ref*field P : 
.el .ref*field P . " "
..
\# %G Gov't. ordering number
.de ref*add-G
.ref*field G . " "
..
\# %O Other (usually goes at end of ref)
.de ref*add-O
.ref*field O . " "
.ie r [O .nr ref*suppress-period \\n([O
.el .nr ref*suppress-period 1
..
\#
.de ref*add-dflt
.ref*field \\$1 ,
..
\#
\# Book reprints
\# -------------
\# %d date of publication (the orignal date of publication)
.de ref*add-d
.ie \\n([T .ref*field d "" " "
.el .ref*field d . " "
.rr [T
..
\# %a additions (such as a new intro to reprints)
.de ref*add-a
.ie \\n([T .ref*field a "" " "
.el .ref*field a . " "
.rr [T
..
\# %t title, if different from original title (the T field, which s/b
\# the original title)
.de ref*add-t
.ie \\n([T .ref*field t "" " Rpt. as \E*[IT]" "" \E*[PREV]
.el .ref*field t . " Rpt. as \E*[IT]" "" \E*[PREV]
.rr [T
..
\#
\# Translated works
\# ----------------
\# %l Trans(l)ator
.de ref*add-l
.ie \\n([T .ref*field l "" " Trans. "
.el .ref*field l . " Trans. "
.rr [T
..
\# %r Translato(r) and edito(r)
.de ref*add-r
.ie \\n([T .ref*field r "" " Trans. and Ed. "
.el .ref*field r . " Trans. and Ed. " 
.rr [T
..
\#
\# Internet
\# --------
\# %s Site name
.de ref*add-s
.ie \\n([s .ref*field s "" ".\E*[IT]" "" \E*[PREV]
.el .ref*field s . " \E*[IT]" "" \E*[PREV]
.\" refer doesn't set reg [T to 1 for these book titles, so we do it here
.ds eval*[s \\*([s
.substring eval*[s -1
.rr [T
.if '\\*[eval*[s]'!' .nr [T 1
.if '\\*[eval*[s]'?' .nr [T 1
.rm eval*[s
..
\# %c content of site, if unclear (i.e. advertisement, cartoon,
\# interview, etc.)
.de ref*add-c
.ie \\n([T .ref*field c "" " "
.el .ref*field c . " "
.rr [T
..
\# %o organization, group or sponsor of site
.de ref*add-o
.ie \\n([T .ref*field o "" " "
.el .ref*field o . " "
.rr [T
..
\# %a access date, i.e. the date you read it
.de ref*add-a
.ie \\n([T .ref*field a "" " "
.el .ref*field a . " "
.rr [T
..
\# %u URL
.de ref*add-u
.ref*field u "" " <" ">"
.rr [T
..
\#
\# Build up reference string from ref*add-<x> macros.
\#
.de ref*field
.if d ref*string \{\
.   ie d ref*post-punct \{\
.      as ref*string "\\$2\\*[ref*post-punct] \"
.      rm ref*post-punct
.   \}
.   el .as ref*string "\\$2 \"
.\}
.as ref*string "\\$3\\*([\\$1\\$4
.if \\n[.$]>4 .ds ref*post-punct "\\$5
.nr ref*suppress-period 0
..
\#
\# MARGIN NOTES
\# ------------
\# This is a wrapper for MNinit.
\#
\# I could use a 'while' loop to assign args to strings, but too many
\# 'while' loops are slowing things down.
\#
.MAC MN_INIT END
.    if !'\\$1'rerun' \{\
.    ds $MN-arg1 \\$1
.    ds $MN-arg2 \\$2
.    ds $MN-arg3 \\$3
.    ds $MN-arg4 \\$4
.    ds $MN-arg5 \\$5
.    ds $MN-arg6 \\$6
.    ds $MN-arg7 \\$7
.    ds $MN-arg8 \\$8
.    ds $MN-arg9 \\$9
.    \}
.    ie \\n[#START_FOR_MNinit]=0 \{\
.       nr #MNinit_DEFERRED 1
.       nr #START_FOR_MNinit 1
.       return
.    \}
.    el \{\
.       MNinit \\*[$MN-arg1] \\*[$MN-arg2] \\*[$MN-arg3] \\*[$MN-arg4] \\*[$MN-arg5] \\*[$MN-arg6] \\*[$MN-arg7] \\*[$MN-arg8] \\*[$MN-arg9]
.    \}
.END
\#
.MAC MN_OVERFLOW_TRAP END
.    if \\n[#OVERFLOW_LEFT]=1  \{\
.       nr #no-repeat-MN-left 1
.       di MN_OVERFLOW_LEFT
.    \}
.    if \\n[#OVERFLOW_RIGHT]=1 \{\
.       nr #no-repeat-MN-right 1
.       di MN_OVERFLOW_RIGHT
.    \}
.    rr #OVERFLOW_LEFT
.    rr #OVERFLOW_RIGHT
.END
\#
.ig
The remainder of the margin notes macros and routines are adapted
from Werner Lemberg's MN.tmac.
..
\#
\# MNinit
\# ------
\# Usage:
\# MNinit [ragged|symmetric] \
\#        left-width right-width separation \
\#        font fontsize vertical-spacing \
\#        color hyphenation-flags
\#
\# Initialize margin notes.  Empty arguments (denoted with "") set
\# default values.  If the first argument is the string `ragged',
\# left and right margin notes are printed ragged-right.  If it is
\# `symmetric', left margin notes are printed ragged-left and right
\# margin notes ragged-right.  If omitted, margin notes are left
\# and right adjusted.
\#
\#
.de MNinit
.  nr #MNinit 1
.  ds MN-left-ad b\"
.  ds MN-right-ad b\"
.  if '\\$1'RAGGED' \{\
.    ds MN-left-ad l\"
.    ds MN-right-ad l\"
.    shift
.  \}
.  if '\\$1'SYMMETRIC' \{\
.    ds MN-left-ad r\"
.    ds MN-right-ad l\"
.    shift
.  \}
.  ie \B'\\$3' \
.    nr MN-sep (n;\\$3)
.  el \
.    nr MN-sep 1m
.  if ((\\n[.o] - \\n[MN-sep]) < 1n) \
.    ab MN: Left margin too small (<1n) for requested margin notes separation.
.  ie \B'\\$1' \{\
.    nr MN-left-width (n;\\$1)
.    nr MN-left-start (\\n[.o] - \\n[MN-sep] - \\n[MN-left-width])
.  \}
.  el \{\
.    nr MN-left-width (\\n[.o] - \\n[MN-sep])
.    nr MN-left-start 0
.  \}
.  if (\\n[MN-left-start] < 0) \
.    ab MN: Left margin too small for requested margin notes settings.
.  if (\\n[MN-left-width] < 1n) \
.    ab MN: Left margin notes width too small (<1n).
.
.  ie \B'\\$2' \{\
.    nr MN-right-width (n;\\$2)
.    nr MN-right-start (\\n[.o] + \\n[.l] + \\n[MN-sep])
.    if \\n[#COLUMNS]=1 \{\
.      if !\\n[#NUM_COLS]=1 \{\
.        nr MN-right-start (\\n[#COL_2_L_MARGIN] + \\n[#COL_L_LENGTH] + \\n[MN-sep])
.      \}
.    \}
.  \}
.  el \{\
.    nr MN-right-width \\n[MN-left-width]
.    nr MN-right-start (\\n[.o] + \\n[.l] + \\n[MN-sep])
.    if \\n[#COLUMNS]=1 \{\
.      if !\\n[#NUM_COLS]=1 \{\
.        nr MN-right-start (\\n[#COL_2_L_MARGIN] + \\n[#COL_L_LENGTH] + \\n[MN-sep])
.      \}
.    \}
.  \}
.  ie \A'\\$4' \{\
.    ds MN-font \\$4\"
.    if \\n[#PRINT_STYLE]=1 .ds MN-font CR
.  \}
.  el \{\
.    ds MN-font \\*[$PP_FT]
.    if \\n[#PRINT_STYLE]=1 .ds MN-font CR
.  \}
.  ie \B'\\$5' \{\
.    ps \\$5
.    nr MN-size \\n[.ps]
.    ps
.    if \\n[#PRINT_STYLE]=1 \{\
.       ps 12
.       nr MN-size \\n[.ps]
.       ps
.    \}
.  \}
.  el \{\
.    nr MN-size \\n[#DOC_PT_SIZE]
.  \}
.  ie \B'\\$6' \{\
'    vs \\$6
.    nr MN-spacing \\n(.v
'    vs
.    if '\\$6'DOC' \{ .nr MN-spacing \\n[#DOC_LEAD] \}
.    if \\n[#PRINT_STYLE]=1 \{\
.       nr MN-spacing \\n[#DOC_LEAD]
.    \}
.  \}
.  el \{\
.    nr MN-spacing \\n[#DOC_LEAD]
.  \}
.  ie \A'\\$7' \
.    if !\\n[#PRINT_STYLE]=1 .ds MN-color \\$7\"
.  el \
.    if !\\n[#PRINT_STYLE]=1 .ds MN-color
.  ie \B'\\$8' \
.    nr MN-hy \\$8
.  el \
.    nr MN-hy \\n[.hy]
.  ev MNbottom-left-env
.  if \A'\\*[MN-font]' \
.    ft \\*[MN-font]
.  if \\n[MN-size] \
.    ps \\n[MN-size]u
.  if \\n[MN-spacing] \
.    vs \\n[MN-spacing]u
.  ll \\n[MN-left-width]u
.  ad \\*[MN-left-ad]
.  hy \\n[MN-hy]
'  in 0
.  nop \m[\\*[MN-color]]\c
.  ev
.  ev MNbottom-right-env
.  if \A'\\*[MN-font]' \
.    ft \\*[MN-font]
.  if \\n[MN-size] \
.    ps \\n[MN-size]u
.  if \\n[MN-spacing] \
.    vs \\n[MN-spacing]u
.  ll \\n[MN-right-width]u
.  ad \\*[MN-right-ad]
.  hy \\n[MN-hy]
'  in 0
.  nop \m[\\*[MN-color]]\c
.  ev
.  nr MN-active 0
..
\# MN
\# --
\# Usage:
\# 
\#   MN LEFT|RIGHT
\#   margin note text
\#   MN
\#
\# With a parameter, start a margin note, otherwise end a margin note.
\# If the parameter is the string `left', define a left margin note,
\# otherwise define a right margin note.
\#
.de MN
.ds MN-dir \\$1
.if \\n[#COLUMNS]=1 \{\
.  if \\n[#NUM_COLS]>2 \{\
.    tm MN: More than two columns.  Ignoring margin notes.
.    return
.  \}
.  if !\\n[#NUM_COLS]=1 \{\
.    ie \\n[#COL_NUM]=1 .ds MN-dir LEFT
.    el .ds MN-dir RIGHT
.  \}
.\}
.  if !\\n[#MNinit]=1 \{\
.    tm MN: You must set parameters with MN_INIT before using MN. 
.    ab Aborting
.  \}
.  ie !'\\$1'' \{\
.    if \\n[MN-active] \{\
.      tm MN: Can't handle nested margin notes.
.      return
.    \}
.    nr MN-active 1
.    ev MN-env
.    ie '\\*[MN-dir]'LEFT' \{\
.      nr MN-left +1
.      ds MN-curr l-\\n[MN-left]\"
.      evc MNbottom-left-env
.    \}
.    el \{\
.      nr MN-right +1
.      ds MN-curr r-\\n[MN-right]\"
.      evc MNbottom-right-env
.    \}
.    mk MN-mk-\\*[MN-curr]
.    di MN-div-\\*[MN-curr]
.  \}
.  el \{\
.    if \\n[MN-active] \{\
.      br
.      di
.      nr MN-div-\\*[MN-curr]-depth \\n(dn
.      ev
.    \}
.    nr MN-active 0
.  \}
..
\#
\# MNtop
\# -----
\# Resets these registers (called in HEADER)
.de MNtop
.  nr MN-left 0
.  nr MN-right 0
.  nr MN-active 0
..
\#
\# MNbottom-left
\# -------------
\# The "left" half of Werner's original MNbottom.
\#
.de MNbottom-left
.  nr MN-curr 0
.  nr MN-last-pos 0
.  nr MN-lead-adj \\n[#DOC_LEAD]-\\n[MN-spacing]
.  vpt 0
.  mk MN-curr-pos
.  if \\n[MN-active] \{\
.    di
.    tm MN: Margin note finished by new page.  Ignored.
.  \}
.  po \\n[MN-left-start]u
.  ev MNbottom-left-env
.  nr #P \\n%+\\n[#PAGE_NUM_ADJ]
.  while (\\n[MN-curr] < \\n[MN-left]) \{\
.    nr MN-curr +1
.    ie (\\n[MN-last-pos] < \\n[MN-mk-l-\\n[MN-curr]]) \
.      sp |\\n[MN-mk-l-\\n[MN-curr]]u+\\n[MN-lead-adj]u
.    el \{\
.      nr MN-shifted 1
.      sp 1v
.      SHIM
.      if \\n[#SHIM]u>\\n[MN-spacing] .sp -(1v+\\n[MN-lead-adj]u)
.      tm MN: Warning: Left margin note #\\n[MN-curr] on page \\n[#P] shifted down.
.    \}
.\" If last margin note doesn't fit
.    if ( (\\n(nl+\\n[MN-div-l-\\n[MN-curr]-depth]) > (\\n(.p+\\n[#VARIABLE_FOOTER_POS]) ) \{\
.      if \\n[MN-shifted]=1 \{\
.        sp -(1v+\\n[#SHIM]u)
.        rm MN-div-l-\\n[MN-curr]
.        tm1 "[mom]: No room to start left margin note #\\n[MN-curr] on page \\n[#P] on page \\n[#P].
.        tm1 "       Ignoring margin note.
.        rr MN-shifted
.      \}
.      nr #no-repeat-MN-left 1
.      nr #OVERFLOW_LEFT 1
.      wh \\n[.p]u+\\n[#VARIABLE_FOOTER_POS]u-1u MN_OVERFLOW_TRAP
.      vpt 1
.    \}
.    MN-div-l-\\n[MN-curr]
.    br
.    nr MN-last-pos \\n[nl]
.\}
.  ev
.  po
.  if !\\n[#no-repeat-MN-left]=1 \{\
.     if \\n[MN-right]=0 .vpt 1
.  \}
..
\#
\# MNbottom-right
\# --------------
\# The "right" half of Werner's original MNbottom.
\#
.de MNbottom-right
.  nr MN-curr 0
.  nr MN-last-pos 0
.  nr MN-lead-adj \\n[#DOC_LEAD]-\\n[MN-spacing]
.  vpt 0
.  po \\n[MN-right-start]u
.  ev MNbottom-right-env
.  nr #P \\n%+\\n[#PAGE_NUM_ADJ]
.  while (\\n[MN-curr] < \\n[MN-right]) \{\
.    nr MN-curr +1
.    ie (\\n[MN-last-pos] < \\n[MN-mk-r-\\n[MN-curr]]) \
.      sp |\\n[MN-mk-r-\\n[MN-curr]]u+\\n[MN-lead-adj]u
.    el \{\
.      nr MN-shifted 1
.      sp 1v
.      SHIM
.      tm MN: Warning: Right margin note #\\n[MN-curr] on page \\n[#P] shifted down.
.    \}
.\" If last margin note doesn't fit
.    if ( (\\n(nl+\\n[MN-div-r-\\n[MN-curr]-depth]) > (\\n(.p+\\n[#VARIABLE_FOOTER_POS]) ) \{\
.      if \\n[MN-shifted]=1 \{\
.        sp -(1v+\\n[#SHIM]u)
.        rm MN-div-r-\\n[MN-curr]
.        tm1 "[mom]: No room to start right margin note #\\n[MN-curr] on page \\n[#P] on page \\n[#P].
.        tm1 "       Ignoring margin note.
.        rr MN-shifted
.      \}
.      nr #no-repeat-MN-right 1
.      nr #OVERFLOW_RIGHT 1
.      wh \\n[.p]u+\\n[#VARIABLE_FOOTER_POS]u-1u MN_OVERFLOW_TRAP
.      vpt 1
.    \}
.    MN-div-r-\\n[MN-curr]
.    br
.    nr MN-last-pos \\n[nl]
.\}
.  ev
.  po
'  sp |\\n[MN-curr-pos]u
.  if !\\n[#no-repeat-MN-right]=1 .vpt 1
..
