#	$NetBSD: Makefile.rump,v 1.68 2012/11/22 21:21:21 pooka Exp $
#

WARNS?=		3	# XXX: src/sys won't compile with -Wsign-compare yet
NOLINT=		# kernel code

.include <bsd.own.mk>

# If RUMPKMOD is _not_ set (only on capable archs, from bsd.own.mk),
# use rump ABI instead of the NetBSD kernel ABI.
.ifndef RUMPKMOD
CPPFLAGS:=	-I${RUMPTOP}/include ${CPPFLAGS}
CPPFLAGS+=	-D_RUMPKERNEL
.else
CPPFLAGS+=	-D_RUMP_NATIVE_ABI
.endif

CPPFLAGS+=	-DMAXUSERS=32
CPPFLAGS+=	-DCOMPAT_50=1

CPPFLAGS+=	-nostdinc
CFLAGS+=	-ffreestanding -fno-strict-aliasing

CWARNFLAGS+=	-Wno-format-zero-length -Wno-pointer-sign
CPPFLAGS+=	-D_KERNEL -DMULTIPROCESSOR -D_MODULE -DMODULAR
CPPFLAGS+=	-DDEBUGPRINT
CPPFLAGS+=	-I${.CURDIR} -I.
CPPFLAGS+=	-I${RUMPTOP}/../../common/include
CPPFLAGS+=	-I${RUMPTOP}/include
CPPFLAGS+=	-I${RUMPTOP}/librump/rumpkern/opt

.ifdef NEED_ISYSTEM
CPPFLAGS+=	-isystem ${RUMPTOP}/../arch
CPPFLAGS+=	-isystem ${RUMPTOP}/..
.else
CPPFLAGS+=	-I${RUMPTOP}/../arch
CPPFLAGS+=	-I${RUMPTOP}/..
.endif

LDFLAGS+=	-Wl,-T ${RUMPTOP}/ldscript.rump

RUMP_DIAGNOSTIC?=yes
.if ${RUMP_DIAGNOSTIC} == "yes"
CPPFLAGS+=	-DDIAGNOSTIC
.endif

.ifdef RUMP_DEBUG
CPPFLAGS+=	-DDEBUG
.endif

.ifdef RUMP_LOCKDEBUG
CPPFLAGS+=	-DLOCKDEBUG
.endif

# kernel libs should not get linked against libc
# XXX: actually, we would like to enable this but cannot, since it
# also leaves out libgcc, it causes problems on some platforms.
# revisit some day.
#LDFLAGS+=	-nodefaultlibs

# make sure __NetBSD__ gets defined (for builds on non-NetBSD)
# also, give those builds a way to undef the local compiler's macros
CPPFLAGS+=	-D__NetBSD__ ${RUMPKERN_UNDEF}

RUMPKERNEL=	This is NetBSD and I am the rump.  Good evening.

# workaround: evbppc is not a well-defined arch
.if (${MACHINE} == "evbppc")
CPPFLAGS+=	-DPPC_OEA
.endif

# If this file changes, we need a full rebuild
DPSRCS+=	${RUMPTOP}/Makefile.rump

#
# Rename library symbols before use.  If a symbol does not already belong
# to a rump namespace ("rump" or "RUMP"), prefix it with "rumpns".  This
# avoids accidentally linking any kernel symbol against host platform
# libraries.  The only non-renamed symbols are linkset delimiters and
# the GOT, which are more a property of the compiler than the kernel.
#
# Some toolchains generate unresolved symbols which are supposed to be
# satisfied by the toolchain itself when the program is linked.
# Unfortunately, we do not know which of the symbols are generated by
# the toolchain.  Worse, they vary from platform to platform and
# toolchain to toolchain.  The good news, however, is that this will
# be detected by a compile-time failure, so we can fairly easily manage
# a quirktable here.
#
# We also allow calling ourselves externally with e.g.:
# make -f /sys/rump/Makefile.rump RUMP_SYMREN=ffs.kobj
#
.if ${MACHINE_CPU} == "mips"
_SYMQUIRK='|_gp_disp'
.elif ${MACHINE_CPU} == "hppa"
_SYMQUIRK='|\$$\$$'
.elif ${MACHINE_ARCH} == "powerpc64"
_SYMQUIRK="|PF_funcs"
.endif

#
# Prefix quirks.  At least one toolchain generates global
# symbols with prefixes which really need to remain as prefixes
# (i.e. the '.' on the front of some ppc64 globals).  The
# way to know if you have the problem is if you get later
# complaints about symbols like 'rumpns_XrumpBLAH' or 'XrumpBLAH';
# the 'X' part was added by the toolchain and will need to
# be mentioned here.
# 
.if ${MACHINE_ARCH} == "powerpc64"
_PQ="\.?"
.else
_PQ=
.endif

rump_symren: __archivebuild
.if !defined(RUMP_SYMREN)
	@echo "Must supply RUMP_SYMREN for target rump_symren"
	@false
.endif

# if we are called from lib build (RUMP_SYMREN is not specified),
# build the arrrrchive.  otherwise just rename symbols.
__archivebuild: .USE
.if defined(RUMP_SYMREN) && defined(RUMPTOP)
	@echo "ERROR: RUMP_SYMREN can only be used standalone"
	@false
.endif
.if defined(RUMP_SYMREN)
	${_MKMSG} " symbol rename " ${RUMP_SYMREN}
.else
	${_MKTARGET_BUILD}
	rm -f ${.TARGET}
	${AR} ${_ARFL} ${.TARGET} `NM=${NM} ${LORDER} ${.ALLSRC:M*o} | ${TSORT}`
.endif
	${NM} -go ${RUMP_SYMREN:U${.TARGET}} | ${TOOL_AWK} '	\
	    $$NF!~/^'${_PQ}'(rump|RUMP|__|_GLOBAL_OFFSET_TABLE'${_SYMQUIRK}')/ \
	      {s = $$NF; sub(/^'${_PQ}'/, "&rumpns_", s); print $$NF, s}' \
	    | sort | uniq  > renametab.${.TARGET}
	${OBJCOPY} --preserve-dates --redefine-syms \
	    renametab.${.TARGET} ${RUMP_SYMREN:U${.TARGET}}
	rm -f renametab.${.TARGET}
.if !defined(RUMP_SYMREN)
	${AR} ${_ARRANFL} ${.TARGET}
.endif

_BSD_IOCONF_MK_USER_=1
.include <bsd.ioconf.mk>

.-include "${NETBSDSRCDIR}/sys/arch/${MACHINE_CPU}/include/Makefile.inc"
.-include "${NETBSDSRCDIR}/sys/arch/${MACHINE}/include/Makefile.inc"
