#	$NetBSD: Makefile.rump,v 1.46 2010/01/31 00:38:36 pooka Exp $
#

WARNS?=		3	# XXX: src/sys won't compile with -Wsign-compare yet
NOLINT=		# kernel code

.include <bsd.own.mk>

# use kernel ABI instead of rump ABI (needs md code)
.ifndef RUMPKMOD
CPPFLAGS:=	-I${RUMPTOP}/include ${CPPFLAGS}
.endif

CFLAGS+=	-ffreestanding -fno-strict-aliasing
CWARNFLAGS+=	-Wno-format-zero-length
CPPFLAGS+=	-D_RUMPKERNEL
CPPFLAGS+=	-D_KERNEL -DMULTIPROCESSOR -D_MODULE -DMODULAR
CPPFLAGS+=	-DMAXUSERS=32
CPPFLAGS+=	-DDIAGNOSTIC
CPPFLAGS+=	-DCOMPAT_50
CPPFLAGS+=	-DDEBUGPRINT
CPPFLAGS+=	-I${.CURDIR} -I.
CPPFLAGS+=	-I${RUMPTOP}/../../common/include -I${RUMPTOP}/../arch
CPPFLAGS+=	-I${RUMPTOP}/include
CPPFLAGS+=	-I${RUMPTOP}/librump/rumpkern/opt
CPPFLAGS+=	-nostdinc -I${RUMPTOP}/..
LDFLAGS+=	-T ${RUMPTOP}/ldscript.rump
#CPPFLAGS+=	-DDEBUG

# kernel libs should not get linked against libc
# XXX: actually, we would like to enable this but cannot, since it
# also leaves out libgcc, it causes problems on some platforms.
# revisit some day.
#LDFLAGS+=	-nodefaultlibs

# make sure __NetBSD__ gets defined (for builds on non-NetBSD)
CPPFLAGS+=	-D__NetBSD__

RUMPKERNEL=	This is NetBSD and I am the rump.  Good evening.

# workaround: evbppc is not a well-defined arch
.if (${MACHINE} == "evbppc")
CPPFLAGS+=	-DPPC_OEA
.endif

# If this file changes, we need a full rebuild
DPSRCS+=	${RUMPTOP}/Makefile.rump

#
# Rename library symbols before use.  If a symbol does not already belong
# to a rump namespace ("rump" or "RUMP"), prefix it with "rumpns".  This
# avoids accidentally linking any kernel symbol against host platform
# libraries.  The only non-renamed symbols are linkset delimiters and
# the GOT, which are more a property of the compiler than the kernel.
#
# Some toolchains generate unresolved symbols which are supposed to be
# satisfied by the toolchain itself when the program is linked.
# Unfortunately, we do not know which of the symbols are generated by
# the toolchain.  Worse, they vary from platform to platform and
# toolchain to toolchain.  The good news, however, is that this will
# be detected by a compile-time failure, so we can fairly easily manage
# a quirktable here.
#
# We also allow calling ourselves externally with e.g.:
# make -f /sys/rump/Makefile.rump RUMP_SYMREN=ffs.kobj
#
.if ${MACHINE_CPU} == "mips"
_SYMQUIRK='|_gp_disp'
.elif ${MACHINE_CPU} == "hppa"
_SYMQUIRK='|\$$\$$'
.endif

rump_symren: __archivebuild
.if !defined(RUMP_SYMREN)
	@echo "Must supply RUMP_SYMREN for target rump_symren"
	@false
.endif

# if we are called from lib build (RUMP_SYMREN is not specified),
# build the arrrrchive.  otherwise just rename symbols.
__archivebuild: .USE
.if defined(RUMP_SYMREN) && defined(RUMPTOP)
	@echo "ERROR: RUMP_SYMREN can only be used standalone"
	@false
.endif
.if defined(RUMP_SYMREN)
	${_MKMSG} " symbol rename " ${RUMP_SYMREN}
.else
	${_MKTARGET_BUILD}
	rm -f ${.TARGET}
	${AR} ${_ARFL} ${.TARGET} `NM=${NM} ${LORDER} ${.ALLSRC:M*o} | ${TSORT}`
.endif
	${NM} -go ${RUMP_SYMREN:U${.TARGET}} | ${TOOL_AWK} '	\
	    $$NF!~/^(rump|RUMP|__|_GLOBAL_OFFSET_TABLE'${_SYMQUIRK}')/ \
	      {printf "%s rumpns_%s\n", $$NF, $$NF}' \
	    | sort | uniq  > renametab.${.TARGET}
	${OBJCOPY} --preserve-dates --redefine-syms \
	    renametab.${.TARGET} ${RUMP_SYMREN:U${.TARGET}}
	rm -f renametab.${.TARGET}
.if !defined(RUMP_SYMREN)
	${AR} ${_ARRANFL} ${.TARGET}
.endif
	
.-include "${NETBSDSRCDIR}/sys/arch/${MACHINE_CPU}/include/Makefile.inc"
.-include "${NETBSDSRCDIR}/sys/arch/${MACHINE}/include/Makefile.inc"
