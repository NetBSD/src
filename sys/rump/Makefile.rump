#	$NetBSD: Makefile.rump,v 1.79 2013/04/27 12:51:45 pooka Exp $
#

WARNS?=		3	# XXX: src/sys won't compile with -Wsign-compare yet
NOLINT=		# kernel code

.include <bsd.own.mk>

# If RUMPKMOD is _not_ set (only on capable archs, from bsd.own.mk),
# use rump ABI instead of the NetBSD kernel ABI.
.ifndef RUMPKMOD
CPPFLAGS:=	-I${RUMPTOP}/include ${CPPFLAGS}
CPPFLAGS+=	-D_RUMPKERNEL
.else
CPPFLAGS+=	-D_RUMP_NATIVE_ABI
.endif

CPPFLAGS+=	-DMAXUSERS=32
CPPFLAGS+=	-DCOMPAT_50=1

CPPFLAGS+=	-nostdinc
CFLAGS+=	-ffreestanding -fno-strict-aliasing

CWARNFLAGS+=	-Wno-format-zero-length -Wno-pointer-sign
CPPFLAGS+=	-D_KERNEL -DMULTIPROCESSOR -D_MODULE -DMODULAR
CPPFLAGS+=	-DDEBUGPRINT
CPPFLAGS+=	-I${.CURDIR} -I.
CPPFLAGS+=	-I${RUMPTOP}/../../common/include
CPPFLAGS+=	-I${RUMPTOP}/include
CPPFLAGS+=	-I${RUMPTOP}/librump/rumpkern/opt

.ifdef NEED_ISYSTEM
CPPFLAGS+=	-isystem ${RUMPTOP}/../arch
CPPFLAGS+=	-isystem ${RUMPTOP}/..
.else
CPPFLAGS+=	-I${RUMPTOP}/../arch
CPPFLAGS+=	-I${RUMPTOP}/..
.endif

RUMP_LDSCRIPT?=yes
.if ${RUMP_LDSCRIPT} != "no"
# my ld or yours?
.ifdef HAVE_SUN_LD
LDFLAGS+=	-Wl,-M ${RUMPTOP}/ldscript_sun.rump
SRCS+=		linksyms_sun.c
.PATH:		${RUMPTOP}
.else
LDFLAGS+=	-Wl,-T ${RUMPTOP}/ldscript.rump
.endif
.endif

RUMP_DIAGNOSTIC?=yes
.if ${RUMP_DIAGNOSTIC} == "yes"
CPPFLAGS+=	-DDIAGNOSTIC
.endif

.ifdef RUMP_DEBUG
CPPFLAGS+=	-DDEBUG
.endif

.ifdef RUMP_LOCKDEBUG
CPPFLAGS+=	-DLOCKDEBUG
.endif

# kernel libs should not get linked against libc
# XXX: actually, we would like to enable this but cannot, since it
# also leaves out libgcc, it causes problems on some platforms.
# revisit some day.
#LDFLAGS+=	-nodefaultlibs

# make sure __NetBSD__ gets defined (for builds on non-NetBSD)
# also, give those builds a way to undef the local compiler's macros
CPPFLAGS+=	-D__NetBSD__ ${RUMPKERN_UNDEF}

RUMPKERNEL=	This is NetBSD and I am the rump.  Good evening.

# workaround: evbppc is not a well-defined arch
.if (${MACHINE} == "evbppc")
CPPFLAGS+=	-DPPC_OEA
.endif

# If this file changes, we need a full rebuild
DPSRCS+=	${RUMPTOP}/Makefile.rump

#
# Support for component-specific hypercalls
#


.ifdef RUMPCOMP_USER
.if empty(DESTDIR)
DESTDIR=/
.endif
BUILDRUMP_CPPFLAGS ?= -isysroot ${DESTDIR}
rumpcomp_user.d: rumpcomp_user.c
	${_MKTARGET_CREATE}
	${MKDEP} -f ${.TARGET} -- ${MKDEPFLAGS} ${BUILDRUMP_CPPFLAGS} ${RUMPCOMP_USER_CPPFLAGS} ${.ALLSRC:O:u:M*.c}

rumpcomp_user.o: rumpcomp_user.c
	${_MKTARGET_COMPILE}
	${CC} -o ${.TARGET} ${DBG} ${CWARNFLAGS} ${BUILDRUMP_CPPFLAGS} ${BUILDRUMP_CFLAGS} ${RUMPCOMP_USER_CPPFLAGS} ${RUMPCOMP_USER_CFLAGS} -c ${.ALLSRC:O:u:M*.c}

rumpcomp_user.pico: rumpcomp_user.c
	${_MKTARGET_COMPILE}
	${CC} -o ${.TARGET} -fPIC -DPIC ${DBG} ${CWARNFLAGS} ${BUILDRUMP_CPPFLAGS} ${BUILDRUMP_CFLAGS} ${RUMPCOMP_USER_CPPFLAGS} ${RUMPCOMP_USER_CFLAGS} -c ${.ALLSRC:O:u:M*.c}

rumpcomp_user.po: rumpcomp_user.c
	${_MKTARGET_COMPILE}
	${CC} -o ${.TARGET} ${PROFFLAGS} -pg ${DBG} ${CWARNFLAGS} ${BUILDRUMP_CPPFLAGS} ${BUILDRUMP_CPPFLAGS} ${RUMPCOMP_USER_CPPFLAGS} ${RUMPCOMP_USER_CFLAGS} -c ${.ALLSRC:O:u:M*.c}

RUMPCOMP_USEROBJ=rumpcomp_user.*o
SRCS+=rumpcomp_user.c
.endif

#
# Rename library symbols before use.  If a symbol does not already belong
# to a rump namespace ("rump" or "RUMP"), prefix it with "rumpns".  This
# avoids accidentally linking any kernel symbol against host platform
# libraries.  The only non-renamed symbols are linkset delimiters and
# the GOT, which are more a property of the compiler than the kernel.
#
# Some toolchains generate unresolved symbols which are supposed to be
# satisfied by the toolchain itself when the program is linked.
# Unfortunately, we do not know which of the symbols are generated by
# the toolchain.  Worse, they vary from platform to platform and
# toolchain to toolchain.  The good news, however, is that this will
# be detected by a compile-time failure, so we can fairly easily manage
# a quirktable here.
#
# We also allow calling ourselves externally with e.g.:
# make -f /sys/rump/Makefile.rump RUMP_SYMREN=ffs.kobj
#
.if ${MACHINE_CPU} == "mips"
_SYMQUIRK='|_gp_disp'
.elif ${MACHINE_CPU} == "hppa"
_SYMQUIRK='|\$$\$$'
.elif ${MACHINE_ARCH} == "powerpc64"
_SYMQUIRK="|PF_funcs"
.endif

#
# Prefix quirks.  At least one toolchain generates global
# symbols with prefixes which really need to remain as prefixes
# (i.e. the '.' on the front of some ppc64 globals).  The
# way to know if you have the problem is if you get later
# complaints about symbols like 'rumpns_XrumpBLAH' or 'XrumpBLAH';
# the 'X' part was added by the toolchain and will need to
# be mentioned here.
# 
.if ${MACHINE_ARCH} == "powerpc64"
_PQ="\.?"
.else
_PQ=
.endif

rump_symren: __archivebuild
.if !defined(RUMP_SYMREN)
	@echo "Must supply RUMP_SYMREN for target rump_symren"
	@false
.endif

# if we are called from lib build (RUMP_SYMREN is not specified),
# build the arrrrchive.  otherwise just rename symbols.
__archivebuild: .USE
.if defined(RUMP_SYMREN) && defined(RUMPTOP)
	@echo "ERROR: RUMP_SYMREN can only be used standalone"
	@false
.endif
.if defined(RUMP_SYMREN)
	${_MKMSG} " symbol rename " ${RUMP_SYMREN}
.else
	${_MKTARGET_BUILD}
	rm -f ${.TARGET}
.endif
	for obj in ${RUMP_SYMREN:U${.ALLSRC:N${RUMPCOMP_USEROBJ}}}; do \
		${NM} -go $${obj} | ${TOOL_AWK} ' \
		    $$NF!~/^'${_PQ}'(rump|RUMP|__|_GLOBAL_OFFSET_TABLE'${_SYMQUIRK}')/ \
		      {s=$$NF;sub(/^'${_PQ}'/, "&rumpns_", s); print $$NF, s}'\
		    | sort | uniq  > renametab.$${obj}; \
		${OBJCOPY} --preserve-dates --redefine-syms \
		    renametab.$${obj} $${obj}; \
		rm -f renametab.$${obj}; \
	done
.if !defined(RUMP_SYMREN)
	${AR} ${_ARFL} ${.TARGET} \
	    `NM=${NM} ${LORDER} ${.ALLSRC:M*o} | ${TSORT}`
.endif

_BSD_IOCONF_MK_USER_=1
.include <bsd.ioconf.mk>

.-include "${NETBSDSRCDIR}/sys/arch/${MACHINE_CPU}/include/Makefile.inc"
.-include "${NETBSDSRCDIR}/sys/arch/${MACHINE}/include/Makefile.inc"
