#	$NetBSD: Makefile.rumpkern,v 1.61 2009/11/04 19:17:53 pooka Exp $
#

.include "${RUMPTOP}/Makefile.rump"

LIB=		rump

.PATH:	${RUMPTOP}/librump/rumpkern				\
	${RUMPTOP}/../kern					\
	${RUMPTOP}/../uvm					\
	${RUMPTOP}/../conf					\
	${RUMPTOP}/../dev					\
	${RUMPTOP}/../secmodel/suser

#
# Source modules, first the ones specifically implemented for librump.
# 
SRCS=	rump.c rumpcopy.c emul.c intr.c locks.c ltsleep.c	\
	memalloc.c percpu.c scheduler.c sleepq.c		\
	sysproxy_socket.c threads.c vm.c

# stubs
#
SRCS+=	misc_stub.c pmap_stub.c

# autogenerated
#
SRCS+=	rump_syscalls.c rumpkern_if_wrappers.c

#
# Rest are from the std kernel sources.
#
# sys/kern
SRCS+=	init_sysctl_base.c kern_auth.c kern_descrip.c kern_event.c	\
	kern_ksyms.c kern_malloc_stdtype.c kern_module.c		\
	kern_mutex_obj.c kern_rate.c kern_stub.c kern_sysctl.c		\
	kern_timeout.c kern_uidinfo.c param.c				\
	sys_descrip.c sys_generic.c sys_select.c syscalls.c

# sys/kern subr (misc)
SRCS+=	subr_devsw.c subr_callback.c subr_copy.c subr_evcnt.c		\
	subr_extent.c subr_hash.c subr_humanize.c subr_iostat.c		\
	subr_kobj.c subr_log.c subr_once.c subr_prf.c			\
	subr_specificdata.c subr_time.c subr_workqueue.c

# sys/uvm
SRCS+=	uvm_readahead.c

# 4.4BSD secmodel.  selection is hardcoded for now
SRCS+=	secmodel_suser.c

# the funny bit.  this doesn't really belong here, but helps with the
# needs of kern_descrip.c.  And since it's a fully dynamic interface,
# it doesn't pull in other gunk.
SRCS+=	vnode_if.c

# sys/dev
SRCS+=	clock_subr.c

# Comment these if you want to use malloc(3) directly instead of
# the kernel allocators.  It's a few percent faster, but doesn't
# emulate all kernel corner cases as well.
#CPPFLAGS+=	-DRUMP_USE_REAL_ALLOCATORS
#SRCS+=		subr_kmem.c subr_pool.c subr_vmem.c

# no shlib_version because this is automatically in sync with lib/librump
SHLIB_MAJOR=    0
SHLIB_MINOR=    0

CPPFLAGS+=	-I${RUMPTOP}/librump/rumpkern -I${RUMPTOP}/librump/rumpvfs
CPPFLAGS+=	-I${RUMPTOP}/librump/rumpnet -I${RUMPTOP}/librump/rumpdev
CFLAGS+=	-Wno-pointer-sign
AFLAGS+=	-D_LOCORE -Wa,-fatal-warnings

#
# If archdir exists, it is required to provide:
# 1) kobj_reloc() and kobj_machdep()
# 2) rump_cpu_bootstrap()
# 3) ...?
# 4) PROFIT!
#

#
# Check if we are building compat.  In compat mode we need to provide
# the kernel of our compat target (amd64->i386 & sparc64->sparc), so
# take MD stuff from the right arch.
#
.ifdef LD32DIR
ARCHDIR=	${RUMPTOP}/librump/rumpkern/arch/${LD32DIR}
LIBKERN_ARCH=	${LD32DIR}
.else
ARCHDIR=	${RUMPTOP}/librump/rumpkern/arch/${MACHINE_ARCH}
.endif
.if exists(${ARCHDIR})
.include "${ARCHDIR}/Makefile.inc"
.PATH:	${ARCHDIR}
.else
SRCS+=	kobj_stubs.c rumpcpu_generic.c
.endif

# include libkern source files
KERNDIR=${RUMPTOP}/../lib/libkern
.include "${RUMPTOP}/../lib/libkern/Makefile.libkern"

# Some architectures require a little special massage with atomic
# compare-and-swap.  This is because the kernel version is using
# instructions or routines unavailable to us in userspace.  We
# use effectively the multiprocessor version of the userspace ops.
#
.if ${MACHINE_CPU} == "arm" || ${MACHINE_CPU} == "hppa" \
    || ${MACHINE_CPU} == "mips" || ${MACHINE_CPU} == "sh3" \
    || ${MACHINE_CPU} == "vax" || ${MACHINE_ARCH} == "m68000"
CPPFLAGS+=	-I${RUMPTOP}/../../common/lib/libc/atomic
SRCS+=		atomic_cas_generic.c
.endif

.include <bsd.lib.mk>
.include <bsd.klinks.mk>
