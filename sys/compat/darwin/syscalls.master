	$NetBSD: syscalls.master,v 1.38 2009/01/13 22:27:43 pooka Exp $

;	@(#)syscalls.master	8.2 (Berkeley) 1/13/94

; NetBSD system call name/number "master" file.
; (See syscalls.conf to see what it is processed into.)
;
; Fields: number type [type-dependent ...]
;	number	system call number, must be in order
;	type	one of STD, OBSOL, UNIMPL, NODEF, NOARGS, or one of
;		the compatibility options defined in syscalls.conf.
;
; types:
;	STD	always included
;	OBSOL	obsolete, not included in system
;	UNIMPL	unimplemented, not included in system
;	NODEF	included, but don't define the syscall number
;	NOARGS	included, but don't define the syscall args structure
;
; The compat options are defined in the syscalls.conf file, and the
; compat option name is prefixed to the syscall name.  Other than
; that, they're like NODEF (for 'compat' options), or STD (for
; 'libcompat' options).
;
; The type-dependent arguments are as follows:
; For STD, NODEF, NOARGS, and compat syscalls:
;	{ pseudo-proto } [alias]
; For other syscalls:
;	[comment]
;
; #ifdef's, etc. may be included, and are copied to the output files.
; #include's are copied to the syscall names and switch definition files only.
;
; NB: A lot of system calls are used from FreeBSD emulation, because theses
; system calls are just native NetBSD plus a check in /emul/<e_name>.

#include "opt_ktrace.h"
#include "opt_nfsserver.h"
#include "opt_ntp.h"
#include "opt_compat_netbsd.h"
#include "opt_sysv.h"
#include "opt_compat_43.h"

#include "fs_lfs.h"
#include "fs_nfs.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signal.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <compat/sys/signal.h>
#include <compat/sys/time.h>

#include <compat/mach/mach_types.h>
#include <compat/mach/mach_vm.h>

#include <compat/darwin/darwin_types.h>
#include <compat/darwin/darwin_signal.h>
#include <compat/darwin/darwin_audit.h>
#include <compat/darwin/darwin_syscallargs.h>

%%

0	NOARGS INDIR	{ int|sys||syscall(int code, \
			    ... register_t args[DARWIN_SYS_MAXSYSARGS]); }
1	NOARGS		{ void|sys||exit(int rval); }
2	STD		{ int|darwin_sys||fork(void); }
3	NOARGS		{ ssize_t|sys||read(int fd, void *buf, size_t nbyte); }
4	NOARGS		{ ssize_t|sys||write(int fd, const void *buf, \
			    size_t nbyte); }
5	NOARGS		{ int|sys||open(const char *path, \
			    int flags, ... mode_t mode); }
6	NOARGS		{ int|sys||close(int fd); }
7	NOARGS		{ int|compat_50_sys||wait4(int pid, int *status, \
			    int options, struct rusage50 *rusage); }
8	NOARGS		{ int|compat_43_sys||creat(const char *path, \
			    mode_t mode); } ocreat
9	NOARGS		{ int|sys||link(const char *path, \
			    const char *link); }
10	NOARGS		{ int|sys||unlink(const char *path); }
11	UNIMPL		execv
12	NOARGS		{ int|sys||chdir(const char *path); }
13	NOARGS		{ int|sys||fchdir(int fd); }
14	STD		{ int|darwin_sys||mknod(const char *path, \
			    mode_t mode, darwin_dev_t dev); }
15	NOARGS		{ int|sys||chmod(const char *path, mode_t mode); }
16	NOARGS		{ int|sys||chown(const char *path, uid_t uid, \
			    gid_t gid); }
17	NOARGS		{ int|sys||obreak(char *nsize); } break
18	STD		{ int|darwin_sys||getfsstat(struct darwin_statfs *buf, \
			    long bufsize, int flags); }
19	NOARGS		{ long|compat_43_sys||lseek(int fd, long offset, \
			    int whence); } olseek
20	STD		{ pid_t|darwin_sys||getpid(void); }
21	NOARGS		{ int|compat_40_sys||mount(const char *type, \
			    const char *path, int flags, void *data); }
22	NOARGS		{ int|sys||unmount(const char *path, int flags); }
23	NOARGS		{ int|sys||setuid(uid_t uid); }
#ifdef COMPAT_43
24	NOARGS		{ uid_t|sys||getuid_with_euid(void); } getuid
#else
24	NOARGS		{ uid_t|sys||getuid(void); }
#endif
25	NOARGS		{ uid_t|sys||geteuid(void); }
26	STD		{ int|darwin_sys||ptrace(int req, pid_t pid, \
			    void *addr, int data); }
27	NOARGS		{ ssize_t|sys||recvmsg(int s, struct msghdr *msg, \
			    int flags); }
28	NOARGS		{ ssize_t|sys||sendmsg(int s, \
			    const struct msghdr *msg, int flags); }
29	STD		{ ssize_t|darwin_sys||recvfrom(int s, void *buf, \
			    size_t len, int flags, struct sockaddr *from, \
			    unsigned int *fromlenaddr); }
30	STD		{ int|darwin_sys||accept(int s, struct sockaddr *name, \
			    unsigned int *anamelen); }
31	STD		{ int|darwin_sys||getpeername(int fdes, \
			    struct sockaddr *asa, unsigned int *alen); }
32	STD		{ int|darwin_sys||getsockname(int fdes, \
			    struct sockaddr *asa, unsigned int *alen); }
33	NOARGS		{ int|sys||access(const char *path, \
			    int flags); }
34	NOARGS		{ int|sys||chflags(const char *path, \
			    u_long flags); }
35	NOARGS		{ int|sys||fchflags(int fd, u_long flags); }
36	NOARGS		{ void|sys||sync(void); }
37	NOARGS		{ int|sys||kill(int pid, int signum); }
38	NOARGS		{ int|compat_43_sys||stat(const char *path, \
			    struct stat43 *ub); } stat43
39	NOARGS		{ pid_t|sys||getppid(void); }
40	NOARGS		{ int|compat_43_sys||lstat(const char *path, \
			    struct stat43 *ub); } lstat43
41	NOARGS		{ int|sys||dup(int fd); }
42	NOARGS		{ int|sys||pipe(void); }
43	NOARGS		{ gid_t|sys||getegid(void); }
44	NOARGS		{ int|sys||profil(void *samples, size_t size, \
			    u_long offset, u_int scale); }
#if defined(KTRACE) || !defined(_KERNEL)
45	NOARGS		{ int|sys||ktrace(const char *fname, int ops, \
			    int facs, int pid); }
#else
45	EXCL		ktrace
#endif
46	STD		{ int|darwin_sys||sigaction(int signum, \
			    struct darwin___sigaction *nsa, \
			    struct sigaction13 *osa); }
#ifdef COMPAT_43
47	NOARGS		{ gid_t|sys||getgid_with_egid(void); } getgid
#else
47	NOARGS		{ gid_t|sys||getgid(void); }
#endif
48	STD		{ int|darwin_sys||sigprocmask(int how, \
			    sigset13_t *set, sigset13_t *oset); }
49	NOARGS		{ int|sys||__getlogin(char *namebuf, size_t namelen); }
50	NOARGS		{ int|sys||__setlogin(const char *namebuf); }
51	NOARGS		{ int|sys||acct(const char *path); }
52	NOARGS    	{ int|compat_13_sys||sigpending(void); } sigpending13
53	NOARGS    	{ int|compat_13_sys||sigaltstack( \
			    const struct sigaltstack13 *nss, \
			    struct sigaltstack13 *oss); } sigaltstack13
54	STD		{ int|darwin_sys||ioctl(int fd, \
			    u_long com, ... void *data); }
55	NOARGS		{ int|sys||reboot(int opt); } oreboot
56	NOARGS		{ int|sys||revoke(const char *path); }
57	NOARGS		{ int|sys||symlink(const char *path, \
			    const char *link); }
58	NOARGS		{ int|sys||readlink(const char *path, \
			    char *buf, size_t count); }
59	NOARGS		{ int|sys||execve(const char *path, \
			    char * const *argp, char * const *envp); }
60	NOARGS		{ mode_t|sys||umask(mode_t newmask); }
61	NOARGS		{ int|sys||chroot(const char *path); }
62	NOARGS		{ int|compat_43_sys||fstat(int fd, \
			    struct stat43 *sb); } fstat43
63	UNIMPL
64	NOARGS    	{ int|compat_43_sys||getpagesize(void); } ogetpagesize
65	NOARGS    	{ int|compat_12_sys||msync(void *addr, size_t len); }
66	STD		{ int|darwin_sys||vfork(void); }
67	OBSOL		vread
68	OBSOL		vwrite
69	NOARGS		{ int|sys||sbrk(intptr_t incr); }
70	NOARGS		{ int|sys||sstk(int incr); }
71	NOARGS    	{ int|sys||mmap(void *addr, size_t len, int prot, \
			    int flags, int fd, long pos); } ommap
72	NOARGS		{ int|sys||ovadvise(int anom); } vadvise
73	NOARGS		{ int|sys||munmap(void *addr, size_t len); }
74	NOARGS		{ int|sys||mprotect(void *addr, size_t len, \
			    int prot); }
75	NOARGS		{ int|sys||madvise(void *addr, size_t len, \
			    int behav); }
76	UNIMPL
77	UNIMPL
78	NOARGS		{ int|sys||mincore(void *addr, size_t len, \
			    char *vec); }
79	NOARGS		{ int|sys||getgroups(int gidsetsize, \
			    gid_t *gidset); }
80	NOARGS		{ int|sys||setgroups(int gidsetsize, \
			    const gid_t *gidset); }
81	NOARGS		{ int|sys||getpgrp(void); }
82	NOARGS		{ int|sys||setpgid(int pid, int pgid); }
83	NOARGS		{ int|compat_50_sys||setitimer(int which, \
			    const struct itimerval50 *itv, \
			    struct itimerval50 *oitv); }
84	NOARGS    	{ int|compat_43_sys||wait(void); } owait
85	NOARGS    	{ int|compat_12_sys||swapon(const char *name); }
86	NOARGS		{ int|compat_50_sys||getitimer(int which, \
			    struct itimerval50 *itv); }
87	NOARGS    	{ int|compat_43_sys||gethostname(char *hostname, \
			    u_int len); } ogethostname
88	NOARGS    	{ int|compat_43_sys||sethostname(char *hostname, \
			    u_int len); } osethostname
89	NOARGS    	{ int|compat_43_sys||getdtablesize(void); } \
			    ogetdtablesize
90	NOARGS		{ int|sys||dup2(int from, int to); }
91	UNIMPL
92	NOARGS		{ int|sys||fcntl(int fd, int cmd, ... void *arg); }
93	NOARGS		{ int|compat_50_sys||select(int nd, fd_set *in, \
			    fd_set *ou, fd_set *ex, struct timeval50 *tv); }
94	UNIMPL
95	NOARGS		{ int|sys||fsync(int fd); }
96	NOARGS		{ int|sys||setpriority(int which, int who, int prio); }
97	STD		{ int|darwin_sys||socket(int domain, \
			    int type, int protocol); }
98	STD		{ int|darwin_sys||connect(int s, \
			    const struct sockaddr *name, \
			    unsigned int namelen); }
99	NOARGS    	{ int|compat_43_sys||accept(int s, void *name, \
			    int *anamelen); } oaccept
100	NOARGS		{ int|sys||getpriority(int which, int who); }
101	NOARGS    	{ int|compat_43_sys||send(int s, void *buf, int len, \
			    int flags); } osend
102	NOARGS    	{ int|compat_43_sys||recv(int s, void *buf, int len, \
			    int flags); } orecv
103	STD	    	{ int|darwin_sys||sigreturn_x2(struct \
			    darwin_ucontext *uctx); }
104	STD		{ int|darwin_sys||bind(int s, \
			     const struct sockaddr *name, \
			    unsigned int namelen); }
105	NOARGS		{ int|sys||setsockopt(int s, int level, int name, \
			    const void *val, unsigned int valsize); }
106	NOARGS		{ int|sys||listen(int s, int backlog); }
107	UNIMPL
108	NOARGS    	{ int|compat_43_sys||sigvec(int signum, \
			    struct sigvec *nsv, struct sigvec *osv); } osigvec
109	NOARGS    	{ int|compat_43_sys||sigblock(int mask); } osigblock
110	NOARGS    	{ int|compat_43_sys||sigsetmask(int mask); } osigsetmask
111	NOARGS    	{ int|compat_13_sys||sigsuspend(int mask); } \
			    sigsuspend13
112	NOARGS    	{ int|compat_43_sys||sigstack(struct sigstack *nss, \
			    struct sigstack *oss); } osigstack
113	NOARGS    	{ int|compat_43_sys||recvmsg(int s, \
			    struct omsghdr *msg, int flags); } orecvmsg
114	NOARGS    	{ int|compat_43_sys||sendmsg(int s, void *msg, \
			    int flags); } osendmsg
115	UNIMPL
116	NOARGS		{ int|compat_50_sys||gettimeofday(struct timeval50 *tp, \
			    struct timezone *tzp); }
117	NOARGS		{ int|compat_50_sys||getrusage(int who, \
			    struct rusage50 *rusage); }
118	NOARGS		{ int|sys||getsockopt(int s, int level, int name, \
			    void *val, unsigned int *avalsize); }
119	UNIMPL
120	NOARGS		{ ssize_t|sys||readv(int fd, \
			    const struct iovec *iovp, int iovcnt); }
121	NOARGS		{ ssize_t|sys||writev(int fd, \
			    const struct iovec *iovp, int iovcnt); }
122	NOARGS		{ int|compat_50_sys||settimeofday( \
			    const struct timeval50 *tv, \
			    const struct timezone *tzp); }
123	NOARGS		{ int|sys||fchown(int fd, uid_t uid, gid_t gid); }
124	NOARGS		{ int|sys||fchmod(int fd, mode_t mode); }
125	NOARGS    	{ int|compat_43_sys||recvfrom(int s, void *buf, \
			    size_t len, int flags, void *from, \
			    int *fromlenaddr); } orecvfrom
126	NOARGS		{ int|sys||setreuid(uid_t ruid, uid_t euid); }
127	NOARGS		{ int|sys||setregid(gid_t rgid, gid_t egid); }
128	NOARGS		{ int|sys||rename(const char *from, \
			    const char *to); }
129	NOARGS		{ int|compat_43_sys||truncate(const \
			    char *path, long length); } \
			    otruncate
130	NOARGS    	{ int|compat_43_sys||ftruncate(int fd, \
			    long length); } oftruncate
131	NOARGS		{ int|sys||flock(int fd, int how); }
132	NOARGS		{ int|sys||mkfifo(const char *path, \
			    mode_t mode); }
133	STD		{ ssize_t|darwin_sys||sendto(int s, const void *buf, \
			    size_t len, int flags, const struct sockaddr *to, \
			    unsigned int tolen); }
134	NOARGS		{ int|sys||shutdown(int s, int how); }
135	NOARGS		{ int|sys||socketpair(int domain, int type, \
			    int protocol, int *rsv); }
136	NOARGS		{ int|sys||mkdir(const char *path, mode_t mode); }
137	NOARGS		{ int|sys||rmdir(const char *path); }
138	NOARGS		{ int|compat_50_sys||utimes(const char *path, \
			    const struct timeval50 *tptr); }
139	UNIMPL		futimes
140	NOARGS		{ int|compat_50_sys||adjtime( \
			    const struct timeval50 *delta, \
			    struct timeval50 *olddelta); }
141	NOARGS    	{ int|compat_43_sys||getpeername(int fdes, \
			    void *asa, int *alen); } ogetpeername
142	NOARGS    	{ int32_t|compat_43_sys||gethostid(void); } ogethostid
143	UNIMPL
144	NOARGS    	{ int|compat_43_sys||getrlimit(int which, \
			    struct orlimit *rlp); } ogetrlimit
145	NOARGS    	{ int|compat_43_sys||setrlimit(int which, \
			    const struct orlimit *rlp); } osetrlimit
146	NOARGS    	{ int|compat_43_sys||killpg(int pgid, int signum); } \
			    okillpg
147	NOARGS		{ int|sys||setsid(void); }
148	UNIMPL
149	UNIMPL
150	NOARGS    	{ int|compat_43_sys||getsockname(int fdec, \
			    void *asa, int *alen); } ogetsockname
151	UNIMPL		getpgid
152	UNIMPL		setprivexec
153	UNIMPL		pread
154	UNIMPL		pwrite
#if defined(NFS) || defined(NFSSERVER) || !defined(_KERNEL)
155	NOARGS		{ int|sys||nfssvc(int flag, void *argp); }
#else
155	EXCL		nfssvc
#endif
156	NOARGS    	{ int|compat_43_sys||getdirentries(int fd, char *buf, \
			    u_int count, long *basep); } ogetdirentries
157	STD		{ int|darwin_sys||statfs(const char *path, \
			    struct darwin_statfs *buf); }
158	STD		{ int|darwin_sys||fstatfs(int fd, \
			    struct darwin_statfs *buf); }
159	UNIMPL		unmount
160	UNIMPL
#if defined(NFS) || defined(NFSSERVER) || !defined(_KERNEL)
161	NOARGS		{ int|compat_30_sys||getfh(const char *fname, \
			    fhandle_t *fhp); }
#else
161	EXCL		getfh
#endif
162	NOARGS		{ int|compat_09_sys||getdomainname(char *domainname, \
			    int len); } ogetdomainname
163	NOARGS    	{ int|compat_09_sys||setdomainname(char *domainname, \
			    int len); } osetdomainname
164	UNIMPL
165	UNIMPL		quotactl
166	UNIMPL
167	UNIMPL		mount
168	UNIMPL
169	UNIMPL
170	UNIMPL
171	UNIMPL		wait3
172	UNIMPL
173	UNIMPL
174	UNIMPL
175	UNIMPL
176	UNIMPL		add_profil
177	UNIMPL
178	UNIMPL
179	UNIMPL
180	STD		{ int|darwin_sys||kdebug_trace(int debugid, int arg1, \
			    int arg2, int arg3, int arg4, int arg5); }
181	NOARGS		{ int|sys||setgid(gid_t gid); }
182	NOARGS		{ int|sys||setegid(gid_t egid); }
183	NOARGS		{ int|sys||seteuid(uid_t euid); }
184	STD	    	{ int|darwin_sys||sigreturn(struct \
			    darwin_ucontext *uctx, int ucvers); }
185	UNIMPL
186	UNIMPL
187	UNIMPL
188	STD		{ int|darwin_sys||stat(const char *path, \
			    struct stat12 *ub); } stat12
189	STD		{ int|darwin_sys||fstat(int fd, \
			    struct stat12 *sb); }
190	STD		{ int|darwin_sys||lstat(const char *path, \
			    struct stat12 *ub); } lstat12
191	NOARGS		{ long|sys||pathconf(const char *path, \
			    int name); }
192	NOARGS		{ long|sys||fpathconf(int fd, int name); }
193	UNIMPL		getfsstat
194	NOARGS		{ int|sys||getrlimit(int which, \
			    struct rlimit *rlp); }
195	NOARGS		{ int|sys||setrlimit(int which, \
			    const struct rlimit *rlp); }
196	NOARGS		{ int|compat_12_sys||getdirentries(int fd, char *buf, \
			    u_int count, long *basep); }
197	NOARGS		{ void *|sys||mmap(void *addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }
198	UNIMPL
199	STD	    	{ off_t|darwin_sys||lseek(int fd, long off1, \
			    long off2, int whence); }
200	NOARGS		{ int|sys||truncate(const char *path, \
			    int pad, off_t length); }
201	NOARGS		{ int|sys||ftruncate(int fd, int pad, off_t length); }
202	STD		{ int|darwin_sys||__sysctl(int *name, u_int namelen, \
			    void *oldp, size_t *oldlenp, void *newp, \
			    size_t newlen); }
203	NOARGS		{ int|sys||mlock(const void *addr, size_t len); }
204	NOARGS		{ int|sys||munlock(const void *addr, size_t len); }
205	NOARGS		{ int|sys||undelete(const char *path); }
206	UNIMPL		atsocket
207	UNIMPL		atgetmsg
208	UNIMPL		atputmsg
209	UNIMPL		atpsndreq
210	UNIMPL		atpsndrsp
211	UNIMPL		atpgetreq
212	UNIMPL		atpgetrsp
213	UNIMPL
214	UNIMPL
215	UNIMPL
216	UNIMPL
217	UNIMPL
218	UNIMPL
219	UNIMPL
220	STD		{ int|darwin_sys||getattrlist(const char *path, \
			    struct darwin_attrlist *alist, void *attributes, \
			    size_t buflen, unsigned long options); }
221	UNIMPL		setattrlist
222	UNIMPL		getdirentriesattr
223	UNIMPL		exchangedata
224	UNIMPL		checkuseraccess
225	UNIMPL		searchfs
226	UNIMPL		delete
227	UNIMPL		copyfile
228	UNIMPL
229	UNIMPL
230	UNIMPL
231	UNIMPL		watchevent
232	UNIMPL		waitevent
233	UNIMPL		modwatch
234	UNIMPL
235	UNIMPL
236	UNIMPL
237	UNIMPL
238	UNIMPL
239	UNIMPL
240	UNIMPL
241	UNIMPL
242	UNIMPL		fsctl
243	UNIMPL
244	UNIMPL
245	UNIMPL
246	UNIMPL
247	UNIMPL
248	UNIMPL
249	UNIMPL
250	UNIMPL		minherit
251	UNIMPL		semsys
252	UNIMPL		msgsys
253	UNIMPL		semop
254	UNIMPL		semctl
255	UNIMPL		semget
256	UNIMPL		semop
257	UNIMPL		semconfig
258	UNIMPL		msgctl
259	UNIMPL		msgget
260	UNIMPL		msgsnd
261	UNIMPL		msgrcv
262	UNIMPL		shmat
263	UNIMPL		shmctl
264	UNIMPL		shmdt
265	UNIMPL		shmget
266	UNIMPL		shm_open
267	UNIMPL		shm_unlink
268	UNIMPL		sem_open
269	UNIMPL		sem_close
270	UNIMPL		sem_unlink
271	UNIMPL		sem_wait
272	UNIMPL		sem_trywait
273	UNIMPL		sem_post
274	UNIMPL		sem_getvalue
275	UNIMPL		sem_init
276	UNIMPL		sem_destroy
277	UNIMPL
278	UNIMPL
279	UNIMPL
280	UNIMPL
281	UNIMPL
282	UNIMPL
283	UNIMPL
284	UNIMPL
285	UNIMPL
286	UNIMPL
287	UNIMPL
288	UNIMPL
289	UNIMPL
290	UNIMPL
291	UNIMPL
292	UNIMPL
293	UNIMPL
294	UNIMPL
295	UNIMPL
296	STD		{ int|darwin_sys||load_shared_file(char *filename, \
			    void *addr, u_long len, void **base, \
			    int count, mach_sf_mapping_t *mappings, \
			    int *flags); }
297	UNIMPL		reset_shared_file
298	UNIMPL		new_system_shared_regions
299	UNIMPL
300	UNIMPL
301	UNIMPL
302	UNIMPL
303	UNIMPL
304	UNIMPL
305	UNIMPL
306	UNIMPL
307	UNIMPL
308	UNIMPL
309	UNIMPL
310	UNIMPL		getsid
311	UNIMPL
312	UNIMPL
313	UNIMPL
314	UNIMPL
315	UNIMPL
316	UNIMPL
317	UNIMPL
318	UNIMPL
319	UNIMPL
320	UNIMPL
321	UNIMPL
322	UNIMPL
323	UNIMPL
324	UNIMPL		mlockall
325	UNIMPL		munlockall
326	UNIMPL
327	UNIMPL		issetugid
328	UNIMPL		__pthread_kill
329	UNIMPL		pthread_sigmask
330	UNIMPL		sigwait
331	STD		{ void|darwin_sys||pthread_exit(void *value_ptr); }
332	UNIMPL
333	UNIMPL
334	UNIMPL
335	STD		{ int|darwin_sys||utrace(void *addr, size_t len); }
336	UNIMPL
337	UNIMPL
338	UNIMPL
339	UNIMPL
340	UNIMPL
341	UNIMPL
342	UNIMPL
343	UNIMPL
344	UNIMPL
345	UNIMPL
346	UNIMPL
347	UNIMPL
348	UNIMPL
349	UNIMPL
350	STD		{ int|darwin_sys||audit(void *record, int len); }
351	STD		{ int|darwin_sys||auditon(int cmd, \
			    void *data, int len); }
352	UNIMPL
353	STD		{ int|darwin_sys||getauid(darwin_au_id_t *auid); }
354	STD		{ int|darwin_sys||setauid(darwin_au_id_t *auid); }
355	STD		{ int|darwin_sys||getauditinfo(struct \
			    darwin_auditinfo *auditinfo); }
356	STD		{ int|darwin_sys||setauditinfo(struct \
			    darwin_auditinfo *auditinfo); }
357	STD		{ int|darwin_sys||getaudit_addr(struct \
			    darwin_auditinfo_addr *auditinfo_addr, int len); }
358	STD		{ int|darwin_sys||setaudit_addr(struct \
			    darwin_auditinfo_addr *auditinfo_addr, int len); }
359	STD		{ int|darwin_sys||auditctl(char *path); }
360	UNIMPL
361	UNIMPL
362	UNIMPL		kqueue
363	UNIMPL		kevent
