<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Introduction to the Kerberos 5 API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<p>
<a href="http://www.h5l.org/"><img src="http://www.h5l.org/keyhole-heimdal.png" alt="keyhole logo"/></a>
</p>
<!-- end of header marker -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction to the Kerberos 5 API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="api_overview"></a>
Kerberos 5 API Overview</h1>
<p>All functions are documented in manual pages. This section tries to give an overview of the major components used in Kerberos library, and point to where to look for a specific function.</p>
<h2><a class="anchor" id="intro_krb5_context"></a>
Kerberos context</h2>
<p>A kerberos context (krb5_context) holds all per thread state. All global variables that are context specific are stored in this structure, including default encryption types, credential cache (for example, a ticket file), and default realms.</p>
<p>The internals of the structure should never be accessed directly, functions exist for extracting information.</p>
<p>See the manual page for <a class="el" href="group__krb5.html#gabd94206e186c58a093975424a4a567a8">krb5_init_context()</a> how to create a context and module <a class="el" href="group__krb5.html">Heimdal Kerberos 5 library</a> for more information about the functions.</p>
<h2><a class="anchor" id="intro_krb5_auth_context"></a>
Kerberos authentication context</h2>
<p>Kerberos authentication context (krb5_auth_context) holds all context related to an authenticated connection, in a similar way to the kerberos context that holds the context for the thread or process.</p>
<p>The krb5_auth_context is used by various functions that are directly related to authentication between the server/client. Example of data that this structure contains are various flags, addresses of client and server, port numbers, keyblocks (and subkeys), sequence numbers, replay cache, and checksum types.</p>
<h2><a class="anchor" id="intro_krb5_principal"></a>
Kerberos principal</h2>
<p>The Kerberos principal is the structure that identifies a user or service in Kerberos. The structure that holds the principal is the krb5_principal. There are function to extract the realm and elements of the principal, but most applications have no reason to inspect the content of the structure.</p>
<p>The are several ways to create a principal (with different degree of portability), and one way to free it.</p>
<p>See also the page <a class="el" href="krb5_principal_intro.html">The principal handing functions.</a> for more information and also module <a class="el" href="group__krb5__principal.html">Heimdal Kerberos 5 principal functions</a>.</p>
<h2><a class="anchor" id="intro_krb5_ccache"></a>
Credential cache</h2>
<p>A credential cache holds the tickets for a user. A given user can have several credential caches, one for each realm where the user have the initial tickets (the first krbtgt).</p>
<p>The credential cache data can be stored internally in different way, each of them for different proposes. File credential (FILE) caches and processes based (KCM) caches are for permanent storage. While memory caches (MEMORY) are local caches to the local process.</p>
<p>Caches are opened with <a class="el" href="group__krb5__ccache.html#gae8ab9d6f4af5710dab860f2806a7d13b">krb5_cc_resolve()</a> or created with <a class="el" href="group__krb5__ccache.html#ga86c0f70d0c2b5de2d876edf4b693b5b9">krb5_cc_new_unique()</a>.</p>
<p>If the cache needs to be opened again (using <a class="el" href="group__krb5__ccache.html#gae8ab9d6f4af5710dab860f2806a7d13b">krb5_cc_resolve()</a>) <a class="el" href="group__krb5__ccache.html#gaebc0dd2a77529c05fb49e27235da7017">krb5_cc_close()</a> will close the handle, but not the remove the cache. <a class="el" href="group__krb5__ccache.html#ga3115bcccd71594374831caa9a07b1290">krb5_cc_destroy()</a> will zero out the cache, remove the cache so it can no longer be referenced.</p>
<p>See also <a class="el" href="krb5_ccache_intro.html">The credential cache functions</a> and <a class="el" href="group__krb5__ccache.html">Heimdal Kerberos 5 credential cache functions</a> .</p>
<h2><a class="anchor" id="intro_krb5_error_code"></a>
Kerberos errors</h2>
<p>Kerberos errors are based on the com_err library. All error codes are 32-bit signed numbers, the first 24 bits define what subsystem the error originates from, and last 8 bits are 255 error codes within the library. Each error code have fixed string associated with it. For example, the error-code -1765328383 have the symbolic name KRB5KDC_ERR_NAME_EXP, and associated error string `&lsquo;Client's entry in database has expired&rsquo;'.</p>
<p>This is a great improvement compared to just getting one of the unix error-codes back. However, Heimdal have an extention to pass back customised errors messages. Instead of getting <code>Key table entry not found'', the user might back</code>failed to find host/host.example.com@EXAMLE.COM(kvno 3) in keytab /etc/krb5.keytab (des-cbc-crc)''. This improves the chance that the user find the cause of the error so you should use the customised error message whenever it's available.</p>
<p>See also module <a class="el" href="group__krb5__error.html">Heimdal Kerberos 5 error reporting functions</a> .</p>
<h2><a class="anchor" id="intro_krb5_keytab"></a>
Keytab management</h2>
<p>A keytab is a storage for locally stored keys. Heimdal includes keytab support for Kerberos 5 keytabs, Kerberos 4 srvtab, AFS-KeyFile's, and for storing keys in memory.</p>
<p>Keytabs are used for servers and long-running services.</p>
<p>See also <a class="el" href="krb5_keytab_intro.html">The keytab handing functions</a> and <a class="el" href="group__krb5__keytab.html">Heimdal Kerberos 5 keytab handling functions</a> .</p>
<h2><a class="anchor" id="intro_krb5_crypto"></a>
Kerberos crypto</h2>
<p>Heimdal includes a implementation of the Kerberos crypto framework, all crypto operations. To create a crypto context call <a class="el" href="group__krb5__crypto.html#gad7003a8a81cef633cc0a2cc07c93dd32">krb5_crypto_init()</a>.</p>
<p>See also module <a class="el" href="group__krb5__crypto.html">Heimdal Kerberos 5 cryptography functions</a> .</p>
<h1><a class="anchor" id="kerberos5_client"></a>
Walkthrough of a sample Kerberos 5 client</h1>
<p>This example contains parts of a sample TCP Kerberos 5 clients, if you want a real working client, please look in appl/test directory in the Heimdal distribution.</p>
<p>All Kerberos error-codes that are returned from kerberos functions in this program are passed to krb5_err, that will print a descriptive text of the error code and exit. Graphical programs can convert error-code to a human readable error-string with the <a class="el" href="group__krb5__error.html#ga35cbf80e68f43a6d9503952886b85ed2">krb5_get_error_message()</a> function.</p>
<p>Note that you should not use any Kerberos function before <a class="el" href="group__krb5.html#gabd94206e186c58a093975424a4a567a8">krb5_init_context()</a> have completed successfully. That is the reason err() is used when <a class="el" href="group__krb5.html#gabd94206e186c58a093975424a4a567a8">krb5_init_context()</a> fails.</p>
<p>First the client needs to call krb5_init_context to initialise the Kerberos 5 library. This is only needed once per thread in the program. If the function returns a non-zero value it indicates that either the Kerberos implementation is failing or it's disabled on this host.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;krb5.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">        krb5_context context;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__krb5.html#gabd94206e186c58a093975424a4a567a8">krb5_init_context</a>(&amp;context))</div>
<div class="line">                errx (1, <span class="stringliteral">&quot;krb5_context&quot;</span>);</div>
<div class="ttc" id="agroup__krb5_html_gabd94206e186c58a093975424a4a567a8"><div class="ttname"><a href="group__krb5.html#gabd94206e186c58a093975424a4a567a8">krb5_init_context</a></div><div class="ttdeci">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_init_context(krb5_context *context)</div><div class="ttdef"><b>Definition:</b> context.c:417</div></div>
</div><!-- fragment --><p>Now the client wants to connect to the host at the other end. The preferred way of doing this is using getaddrinfo (for operating system that have this function implemented), since getaddrinfo is neutral to the address type and can use any protocol that is available.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>addrinfo *ai, *a;</div>
<div class="line"><span class="keyword">struct </span>addrinfo hints;</div>
<div class="line"><span class="keywordtype">int</span> error;</div>
<div class="line"> </div>
<div class="line">memset (&amp;hints, 0, <span class="keyword">sizeof</span>(hints));</div>
<div class="line">hints.ai_socktype = SOCK_STREAM;</div>
<div class="line">hints.ai_protocol = IPPROTO_TCP;</div>
<div class="line"> </div>
<div class="line">error = getaddrinfo (hostname, <span class="stringliteral">&quot;pop3&quot;</span>, &amp;hints, &amp;ai);</div>
<div class="line"><span class="keywordflow">if</span> (error)</div>
<div class="line">        errx (1, <span class="stringliteral">&quot;%s: %s&quot;</span>, hostname, gai_strerror(error));</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (a = ai; a != NULL; a = a-&gt;ai_next) {</div>
<div class="line">        <span class="keywordtype">int</span> s;</div>
<div class="line"> </div>
<div class="line">        s = socket (a-&gt;ai_family, a-&gt;ai_socktype, a-&gt;ai_protocol);</div>
<div class="line">        <span class="keywordflow">if</span> (s &lt; 0)</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (connect (s, a-&gt;ai_addr, a-&gt;ai_addrlen) &lt; 0) {</div>
<div class="line">                warn (<span class="stringliteral">&quot;connect(%s)&quot;</span>, hostname);</div>
<div class="line">                    close (s);</div>
<div class="line">                    <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line">        freeaddrinfo (ai);</div>
<div class="line">        ai = NULL;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (ai) {</div>
<div class="line">            freeaddrinfo (ai);</div>
<div class="line">            errx (<span class="stringliteral">&quot;failed to contact %s&quot;</span>, hostname);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Before authenticating, an authentication context needs to be created. This context keeps all information for one (to be) authenticated connection (see krb5_auth_context).</p>
<div class="fragment"><div class="line">status = krb5_auth_con_init (context, &amp;auth_context);</div>
<div class="line"><span class="keywordflow">if</span> (status)</div>
<div class="line">        <a class="code" href="group__krb5__error.html#gad75c268bcf26225ee8d4a39c178131a1">krb5_err</a> (context, 1, status, <span class="stringliteral">&quot;krb5_auth_con_init&quot;</span>);</div>
<div class="ttc" id="agroup__krb5__error_html_gad75c268bcf26225ee8d4a39c178131a1"><div class="ttname"><a href="group__krb5__error.html#gad75c268bcf26225ee8d4a39c178131a1">krb5_err</a></div><div class="ttdeci">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_err(krb5_context context, int eval, krb5_error_code code, const char *fmt,...) __attribute__((__noreturn__</div></div>
</div><!-- fragment --><p>For setting the address in the authentication there is a help function krb5_auth_con_setaddrs_from_fd() that does everything that is needed when given a connected file descriptor to the socket.</p>
<div class="fragment"><div class="line">status = krb5_auth_con_setaddrs_from_fd (context,</div>
<div class="line">                                         auth_context,</div>
<div class="line">                                         &amp;sock);</div>
<div class="line"><span class="keywordflow">if</span> (status)</div>
<div class="line">        <a class="code" href="group__krb5__error.html#gad75c268bcf26225ee8d4a39c178131a1">krb5_err</a> (context, 1, status,</div>
<div class="line">                  <span class="stringliteral">&quot;krb5_auth_con_setaddrs_from_fd&quot;</span>);</div>
</div><!-- fragment --><p>The next step is to build a server principal for the service we want to connect to. (See also <a class="el" href="group__krb5__principal.html#ga8be0f5000da6ee0d4bd5dcaf3cb01d08">krb5_sname_to_principal()</a>.)</p>
<div class="fragment"><div class="line">status = <a class="code" href="group__krb5__principal.html#ga8be0f5000da6ee0d4bd5dcaf3cb01d08">krb5_sname_to_principal</a> (context,</div>
<div class="line">                                  hostname,</div>
<div class="line">                                  service,</div>
<div class="line">                                  KRB5_NT_SRV_HST,</div>
<div class="line">                                  &amp;server);</div>
<div class="line"><span class="keywordflow">if</span> (status)</div>
<div class="line">        <a class="code" href="group__krb5__error.html#gad75c268bcf26225ee8d4a39c178131a1">krb5_err</a> (context, 1, status, <span class="stringliteral">&quot;krb5_sname_to_principal&quot;</span>);</div>
<div class="ttc" id="agroup__krb5__principal_html_ga8be0f5000da6ee0d4bd5dcaf3cb01d08"><div class="ttname"><a href="group__krb5__principal.html#ga8be0f5000da6ee0d4bd5dcaf3cb01d08">krb5_sname_to_principal</a></div><div class="ttdeci">KRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL krb5_sname_to_principal(krb5_context context, const char *hostname, const char *sname, int32_t type, krb5_principal *ret_princ)</div><div class="ttdef"><b>Definition:</b> principal.c:1364</div></div>
</div><!-- fragment --><p>The client principal is not passed to krb5_sendauth() function, this causes the krb5_sendauth() function to try to figure it out itself.</p>
<p>The server program is using the function krb5_recvauth() to receive the Kerberos 5 authenticator.</p>
<p>In this case, mutual authentication will be tried. That means that the server will authenticate to the client. Using mutual authentication is required to avoid man-in-the-middle attacks, since it enables the user to verify that they are talking to the right server (a server that knows the key).</p>
<p>If you are using a non-blocking socket you will need to do all work of krb5_sendauth() yourself. Basically you need to send over the authenticator from krb5_mk_req() and, in case of mutual authentication, verifying the result from the server with krb5_rd_rep().</p>
<div class="fragment"><div class="line">status = krb5_sendauth (context,</div>
<div class="line">                        &amp;auth_context,</div>
<div class="line">                        &amp;sock,</div>
<div class="line">                        VERSION,</div>
<div class="line">                        NULL,</div>
<div class="line">                        server,</div>
<div class="line">                        AP_OPTS_MUTUAL_REQUIRED,</div>
<div class="line">                        NULL,</div>
<div class="line">                        NULL,</div>
<div class="line">                        NULL,</div>
<div class="line">                        NULL,</div>
<div class="line">                        NULL,</div>
<div class="line">                        NULL);</div>
<div class="line"><span class="keywordflow">if</span> (status)</div>
<div class="line">        <a class="code" href="group__krb5__error.html#gad75c268bcf26225ee8d4a39c178131a1">krb5_err</a> (context, 1, status, <span class="stringliteral">&quot;krb5_sendauth&quot;</span>);</div>
</div><!-- fragment --><p>Once authentication has been performed, it is time to send some data. First we create a krb5_data structure, then we sign it with krb5_mk_safe() using the auth_context that contains the session-key that was exchanged in the krb5_sendauth()/krb5_recvauth() authentication sequence.</p>
<div class="fragment"><div class="line">data.data   = <span class="stringliteral">&quot;hej&quot;</span>;</div>
<div class="line">data.length = 3;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__krb5.html#gaa059e96dde4e0b8c082eb6f3d570b7bc">krb5_data_zero</a> (&amp;packet);</div>
<div class="line"> </div>
<div class="line">status = krb5_mk_safe (context,</div>
<div class="line">                       auth_context,</div>
<div class="line">                       &amp;data,</div>
<div class="line">                       &amp;packet,</div>
<div class="line">                       NULL);</div>
<div class="line"><span class="keywordflow">if</span> (status)</div>
<div class="line">        <a class="code" href="group__krb5__error.html#gad75c268bcf26225ee8d4a39c178131a1">krb5_err</a> (context, 1, status, <span class="stringliteral">&quot;krb5_mk_safe&quot;</span>);</div>
<div class="ttc" id="agroup__krb5_html_gaa059e96dde4e0b8c082eb6f3d570b7bc"><div class="ttname"><a href="group__krb5.html#gaa059e96dde4e0b8c082eb6f3d570b7bc">krb5_data_zero</a></div><div class="ttdeci">KRB5_LIB_FUNCTION void KRB5_LIB_CALL krb5_data_zero(krb5_data *p)</div><div class="ttdef"><b>Definition:</b> data.c:45</div></div>
</div><!-- fragment --><p>And send it over the network.</p>
<div class="fragment"><div class="line">len = packet.length;</div>
<div class="line">net_len = htonl(len);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (krb5_net_write (context, &amp;sock, &amp;net_len, 4) != 4)</div>
<div class="line">        err (1, <span class="stringliteral">&quot;krb5_net_write&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (krb5_net_write (context, &amp;sock, packet.data, len) != len)</div>
<div class="line">        err (1, <span class="stringliteral">&quot;krb5_net_write&quot;</span>);</div>
</div><!-- fragment --><p>To send encrypted (and signed) data krb5_mk_priv() should be used instead. krb5_mk_priv() works the same way as krb5_mk_safe(), with the exception that it encrypts the data in addition to signing it.</p>
<div class="fragment"><div class="line">data.data   = <span class="stringliteral">&quot;hemligt&quot;</span>;</div>
<div class="line">data.length = 7;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__krb5.html#gab4b80ac7a8bbab89fe947ae1c7828ea8">krb5_data_free</a> (&amp;packet);</div>
<div class="line"> </div>
<div class="line">status = krb5_mk_priv (context,</div>
<div class="line">                       auth_context,</div>
<div class="line">                       &amp;data,</div>
<div class="line">                       &amp;packet,</div>
<div class="line">                       NULL);</div>
<div class="line"><span class="keywordflow">if</span> (status)</div>
<div class="line">        <a class="code" href="group__krb5__error.html#gad75c268bcf26225ee8d4a39c178131a1">krb5_err</a> (context, 1, status, <span class="stringliteral">&quot;krb5_mk_priv&quot;</span>);</div>
<div class="ttc" id="agroup__krb5_html_gab4b80ac7a8bbab89fe947ae1c7828ea8"><div class="ttname"><a href="group__krb5.html#gab4b80ac7a8bbab89fe947ae1c7828ea8">krb5_data_free</a></div><div class="ttdeci">KRB5_LIB_FUNCTION void KRB5_LIB_CALL krb5_data_free(krb5_data *p)</div><div class="ttdef"><b>Definition:</b> data.c:63</div></div>
</div><!-- fragment --><p>And send it over the network.</p>
<div class="fragment"><div class="line">len = packet.length;</div>
<div class="line">net_len = htonl(len);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (krb5_net_write (context, &amp;sock, &amp;net_len, 4) != 4)</div>
<div class="line">        err (1, <span class="stringliteral">&quot;krb5_net_write&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (krb5_net_write (context, &amp;sock, packet.data, len) != len)</div>
<div class="line">        err (1, <span class="stringliteral">&quot;krb5_net_write&quot;</span>);</div>
</div><!-- fragment --><p>The server is using krb5_rd_safe() and krb5_rd_priv() to verify the signature and decrypt the packet.</p>
<h1><a class="anchor" id="intro_krb5_verify_user"></a>
Validating a password in an application</h1>
<p>See the manual page for krb5_verify_user().</p>
<h1><a class="anchor" id="mit_differences"></a>
API differences to MIT Kerberos</h1>
<p>This section is somewhat disorganised, but so far there is no overall structure to the differences, though some of the have their root in that Heimdal uses an ASN.1 compiler and MIT doesn't.</p>
<h2><a class="anchor" id="mit_krb5_principal"></a>
Principal and realms</h2>
<p>Heimdal stores the realm as a krb5_realm, that is a char *. MIT Kerberos uses a krb5_data to store a realm.</p>
<p>In Heimdal krb5_principal doesn't contain the component name_type; it's instead stored in component name.name_type. To get and set the nametype in Heimdal, use <a class="el" href="group__krb5__principal.html#gaf4a599c42592ff7485753e80b8de67b7">krb5_principal_get_type()</a> and <a class="el" href="group__krb5__principal.html#ga28b750b990452f02922bc74a6cac0313">krb5_principal_set_type()</a>.</p>
<p>For more information about principal and realms, see krb5_principal.</p>
<h2><a class="anchor" id="mit_krb5_error_code"></a>
Error messages</h2>
<p>To get the error string, Heimdal uses <a class="el" href="group__krb5__error.html#ga35cbf80e68f43a6d9503952886b85ed2">krb5_get_error_message()</a>. This is to return custom error messages (like <code>Can't find host/datan.example.com\@CODE.COM in /etc/krb5.conf.'' instead of a</code>Key table entry not found'' that error_message returns.</p>
<p>Heimdal uses a threadsafe(r) version of the com_err interface; the global com_err table isn't initialised. Then error_message returns quite a boring error string (just the error code itself). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<hr size="1"><address style="text-align: right;"><small>
Generated on Tue Nov 15 2022 14:04:26 for Heimdal Kerberos 5 library by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.9.1</small></address>
</body>
</html>
