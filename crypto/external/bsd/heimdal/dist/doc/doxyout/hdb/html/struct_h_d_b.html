<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>HDB Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<p>
<a href="http://www.h5l.org/"><img src="http://www.h5l.org/keyhole-heimdal.png" alt="keyhole logo"/></a>
</p>
<!-- end of header marker -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">HDB Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;hdb.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:acb4dd65f4c8add22c2150611944266e3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#acb4dd65f4c8add22c2150611944266e3">hdb_name</a></td></tr>
<tr class="separator:acb4dd65f4c8add22c2150611944266e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0195553be67d9fa3882ed141d1075cde"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a0195553be67d9fa3882ed141d1075cde">hdb_open</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, int, mode_t)</td></tr>
<tr class="separator:a0195553be67d9fa3882ed141d1075cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc1159194d397105074fd7af2147ef0"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#abcc1159194d397105074fd7af2147ef0">hdb_close</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *)</td></tr>
<tr class="separator:abcc1159194d397105074fd7af2147ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aaa1e953f3889416effecb330c31d5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#ad2aaa1e953f3889416effecb330c31d5">hdb_free</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *)</td></tr>
<tr class="separator:ad2aaa1e953f3889416effecb330c31d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221e8919e12c4d5cda20e4c4ea4bea57"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a221e8919e12c4d5cda20e4c4ea4bea57">hdb_fetch_kvno</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, krb5_const_principal, unsigned, krb5_kvno, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *)</td></tr>
<tr class="separator:a221e8919e12c4d5cda20e4c4ea4bea57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace37bcc785b39826a25043302aaad7d4"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#ace37bcc785b39826a25043302aaad7d4">hdb_store</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, unsigned, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *)</td></tr>
<tr class="separator:ace37bcc785b39826a25043302aaad7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40ae16bd6c089fc2224e416a418406d"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#ad40ae16bd6c089fc2224e416a418406d">hdb_remove</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, unsigned, krb5_const_principal)</td></tr>
<tr class="separator:ad40ae16bd6c089fc2224e416a418406d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b135e216639ec17963f0387952fc39"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#aa0b135e216639ec17963f0387952fc39">hdb_firstkey</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, unsigned, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *)</td></tr>
<tr class="separator:aa0b135e216639ec17963f0387952fc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619e68062182dac514dfe36a412781b0"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a619e68062182dac514dfe36a412781b0">hdb_nextkey</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, unsigned, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *)</td></tr>
<tr class="separator:a619e68062182dac514dfe36a412781b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882a4319a715245764833cded23c25f3"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a882a4319a715245764833cded23c25f3">hdb_lock</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, int)</td></tr>
<tr class="separator:a882a4319a715245764833cded23c25f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8c8e5f6ba731f25fc9a59b00606a83"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a7d8c8e5f6ba731f25fc9a59b00606a83">hdb_unlock</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *)</td></tr>
<tr class="separator:a7d8c8e5f6ba731f25fc9a59b00606a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6411230ae97787e3cab4d4ba493a3a"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a6a6411230ae97787e3cab4d4ba493a3a">hdb_rename</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, const char *)</td></tr>
<tr class="separator:a6a6411230ae97787e3cab4d4ba493a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7abb33606a55252a11a5ba67643b499"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#ac7abb33606a55252a11a5ba67643b499">hdb__get</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, krb5_data, krb5_data *)</td></tr>
<tr class="separator:ac7abb33606a55252a11a5ba67643b499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc7c8b10816ac9ff9dfac3693fb7d08"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#abcc7c8b10816ac9ff9dfac3693fb7d08">hdb__put</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, int, krb5_data, krb5_data)</td></tr>
<tr class="separator:abcc7c8b10816ac9ff9dfac3693fb7d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a23e6989e96466a728af17485131085"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a5a23e6989e96466a728af17485131085">hdb__del</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, krb5_data)</td></tr>
<tr class="separator:a5a23e6989e96466a728af17485131085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473e9785fb70e2f1bc4bdebcd1110112"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a473e9785fb70e2f1bc4bdebcd1110112">hdb_destroy</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *)</td></tr>
<tr class="separator:a473e9785fb70e2f1bc4bdebcd1110112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8433b5521e9fa51742cd35cc5214cec"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#ae8433b5521e9fa51742cd35cc5214cec">hdb_get_realms</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, krb5_realm **)</td></tr>
<tr class="separator:ae8433b5521e9fa51742cd35cc5214cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d5d0d2f801acedfc14ae3774b9d155"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a85d5d0d2f801acedfc14ae3774b9d155">hdb_password</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *, const char *, int)</td></tr>
<tr class="separator:a85d5d0d2f801acedfc14ae3774b9d155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9fe61b33b28bfee51ff02096f50504"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#abe9fe61b33b28bfee51ff02096f50504">hdb_auth_status</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *, int)</td></tr>
<tr class="separator:abe9fe61b33b28bfee51ff02096f50504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712341cb9b9a2770381a9605fcb09078"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a712341cb9b9a2770381a9605fcb09078">hdb_check_constrained_delegation</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *, krb5_const_principal)</td></tr>
<tr class="separator:a712341cb9b9a2770381a9605fcb09078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e50836e2b6032c53e079e24f37bd3b"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a74e50836e2b6032c53e079e24f37bd3b">hdb_check_pkinit_ms_upn_match</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *, krb5_const_principal)</td></tr>
<tr class="separator:a74e50836e2b6032c53e079e24f37bd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cc9eb48be2209ca7761764bdffb747"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a54cc9eb48be2209ca7761764bdffb747">hdb_check_s4u2self</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *, krb5_const_principal)</td></tr>
<tr class="separator:a54cc9eb48be2209ca7761764bdffb747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5095640648b5f15b030ee15318881422"><td class="memItemLeft" align="right" valign="top">krb5_error_code(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_d_b.html#a5095640648b5f15b030ee15318881422">hdb_set_sync</a> )(krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, int)</td></tr>
<tr class="separator:a5095640648b5f15b030ee15318881422"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="struct_h_d_b.html">HDB</a> backend function pointer structure</p>
<p>The <a class="el" href="struct_h_d_b.html">HDB</a> structure is what the KDC and kadmind framework uses to query the backend database when talking about principals. </p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a5a23e6989e96466a728af17485131085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a23e6989e96466a728af17485131085">&#9670;&nbsp;</a></span>hdb__del</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb__del) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, krb5_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete and hdb_entry from a classical DB backend</p>
<p>This function takes a principal key (krb5_data) naming the record to delete.</p>
<p>Same discussion as in <a class="el" href="struct_h_d_b.html#abcc7c8b10816ac9ff9dfac3693fb7d08">HDB::hdb__put</a> </p>

</div>
</div>
<a id="ac7abb33606a55252a11a5ba67643b499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7abb33606a55252a11a5ba67643b499">&#9670;&nbsp;</a></span>hdb__get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb__get) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, krb5_data, krb5_data *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an hdb_entry from a classical DB backend</p>
<p>This function takes a principal key (krb5_data) and returns all data related to principal in the return krb5_data. The returned encoded entry is of type hdb_entry or hdb_entry_alias. </p>

</div>
</div>
<a id="abcc7c8b10816ac9ff9dfac3693fb7d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc7c8b10816ac9ff9dfac3693fb7d08">&#9670;&nbsp;</a></span>hdb__put</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb__put) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, int, krb5_data, krb5_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store an hdb_entry from a classical DB backend</p>
<p>This function takes a principal key (krb5_data) and encoded hdb_entry or hdb_entry_alias as the data to store.</p>
<p>For a file-based DB, this must synchronize to disk when done. This is sub-optimal for kadm5_s_rename_principal(), and for kadm5_s_modify_principal() when using principal aliases; to improve this so that only one fsync() need be done per-transaction will require <a class="el" href="struct_h_d_b.html">HDB</a> API extensions. </p>

</div>
</div>
<a id="abe9fe61b33b28bfee51ff02096f50504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9fe61b33b28bfee51ff02096f50504">&#9670;&nbsp;</a></span>hdb_auth_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_auth_status) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *, int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auth feedback</p>
<p>This is a feedback call that allows backends that provides lockout functionality to register failure and/or successes.</p>
<p>In case the entry is locked out, the backend should set the hdb_entry.flags.locked-out flag. </p>

</div>
</div>
<a id="a712341cb9b9a2770381a9605fcb09078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712341cb9b9a2770381a9605fcb09078">&#9670;&nbsp;</a></span>hdb_check_constrained_delegation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_check_constrained_delegation) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *, krb5_const_principal)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if delegation is allowed. </p>

</div>
</div>
<a id="a74e50836e2b6032c53e079e24f37bd3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e50836e2b6032c53e079e24f37bd3b">&#9670;&nbsp;</a></span>hdb_check_pkinit_ms_upn_match</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_check_pkinit_ms_upn_match) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *, krb5_const_principal)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if this name is an alias for the supplied client for PKINIT userPrinicpalName logins </p>

</div>
</div>
<a id="a54cc9eb48be2209ca7761764bdffb747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54cc9eb48be2209ca7761764bdffb747">&#9670;&nbsp;</a></span>hdb_check_s4u2self</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_check_s4u2self) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *, krb5_const_principal)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if s4u2self is allowed from this client to this server </p>

</div>
</div>
<a id="abcc1159194d397105074fd7af2147ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc1159194d397105074fd7af2147ef0">&#9670;&nbsp;</a></span>hdb_close</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_close) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the database for transaction</p>
<p>Closes the database for further transactions, wont release any permanant resources. the database can be -&gt;hdb_open-ed again. </p>

</div>
</div>
<a id="a473e9785fb70e2f1bc4bdebcd1110112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473e9785fb70e2f1bc4bdebcd1110112">&#9670;&nbsp;</a></span>hdb_destroy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_destroy) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the handle to the database.</p>
<p>Destroy the handle to the database, deallocate all memory and related resources. Does not remove any permanent data. Its the logical reverse of hdb_create() function that is the entry point for the module. </p>

</div>
</div>
<a id="a221e8919e12c4d5cda20e4c4ea4bea57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221e8919e12c4d5cda20e4c4ea4bea57">&#9670;&nbsp;</a></span>hdb_fetch_kvno</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_fetch_kvno) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, krb5_const_principal, unsigned, krb5_kvno, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetch an entry from the backend</p>
<p>Fetch an entry from the backend, flags are what type of entry should be fetch: client, server, krbtgt. knvo (if specified and flags HDB_F_KVNO_SPECIFIED set) is the kvno to get </p>

</div>
</div>
<a id="aa0b135e216639ec17963f0387952fc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b135e216639ec17963f0387952fc39">&#9670;&nbsp;</a></span>hdb_firstkey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_firstkey) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, unsigned, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As part of iteration, fetch one entry </p>

</div>
</div>
<a id="ad2aaa1e953f3889416effecb330c31d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2aaa1e953f3889416effecb330c31d5">&#9670;&nbsp;</a></span>hdb_free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* HDB::hdb_free) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free an entry after use. </p>

</div>
</div>
<a id="ae8433b5521e9fa51742cd35cc5214cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8433b5521e9fa51742cd35cc5214cec">&#9670;&nbsp;</a></span>hdb_get_realms</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_get_realms) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, krb5_realm **)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the list of realms this backend handles. This call is optional to support. The returned realms are used for announcing the realms over bonjour. Free returned array with krb5_free_host_realm(). </p>

</div>
</div>
<a id="a882a4319a715245764833cded23c25f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882a4319a715245764833cded23c25f3">&#9670;&nbsp;</a></span>hdb_lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_lock) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock database</p>
<p>A lock can only be held by one consumers. Transaction can still happen on the database while the lock is held, so the entry is only useful for syncroning creation of the database and renaming of the database. </p>

</div>
</div>
<a id="acb4dd65f4c8add22c2150611944266e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4dd65f4c8add22c2150611944266e3">&#9670;&nbsp;</a></span>hdb_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* HDB::hdb_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>don't use, only for DB3 </p>

</div>
</div>
<a id="a619e68062182dac514dfe36a412781b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619e68062182dac514dfe36a412781b0">&#9670;&nbsp;</a></span>hdb_nextkey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_nextkey) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, unsigned, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As part of iteration, fetch next entry </p>

</div>
</div>
<a id="a0195553be67d9fa3882ed141d1075cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0195553be67d9fa3882ed141d1075cde">&#9670;&nbsp;</a></span>hdb_open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_open) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, int, mode_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open (or create) the a Kerberos database.</p>
<p>Open (or create) the a Kerberos database that was resolved with hdb_create(). The third and fourth flag to the function are the same as open(), thus passing O_CREAT will create the data base if it doesn't exists.</p>
<p>Then done the caller should call <a class="el" href="struct_h_d_b.html#abcc1159194d397105074fd7af2147ef0">hdb_close()</a>, and to release all resources <a class="el" href="struct_h_d_b.html#a473e9785fb70e2f1bc4bdebcd1110112">hdb_destroy()</a>. </p>

</div>
</div>
<a id="a85d5d0d2f801acedfc14ae3774b9d155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d5d0d2f801acedfc14ae3774b9d155">&#9670;&nbsp;</a></span>hdb_password</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_password) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *, const char *, int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change password.</p>
<p>Will update keys for the entry when given password. The new keys must be written into the entry and will then later be -&gt;<a class="el" href="struct_h_d_b.html#ace37bcc785b39826a25043302aaad7d4">hdb_store()</a> into the database. The backend will still perform all other operations, increasing the kvno, and update modification timestamp.</p>
<p>The backend needs to call _kadm5_set_keys() and perform password quality checks. </p>

</div>
</div>
<a id="ad40ae16bd6c089fc2224e416a418406d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40ae16bd6c089fc2224e416a418406d">&#9670;&nbsp;</a></span>hdb_remove</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_remove) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, unsigned, krb5_const_principal)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an entry from the database. </p>

</div>
</div>
<a id="a6a6411230ae97787e3cab4d4ba493a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6411230ae97787e3cab4d4ba493a3a">&#9670;&nbsp;</a></span>hdb_rename</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_rename) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rename the data base.</p>
<p>Assume that the database is not hdb_open'ed and not locked. </p>

</div>
</div>
<a id="a5095640648b5f15b030ee15318881422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5095640648b5f15b030ee15318881422">&#9670;&nbsp;</a></span>hdb_set_sync</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_set_sync) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable/disable synchronous updates</p>
<p>Calling this with 0 disables sync. Calling it with non-zero enables sync and does an fsync(). </p>

</div>
</div>
<a id="ace37bcc785b39826a25043302aaad7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace37bcc785b39826a25043302aaad7d4">&#9670;&nbsp;</a></span>hdb_store</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_store) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *, unsigned, <a class="el" href="structhdb__entry__ex.html">hdb_entry_ex</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store an entry to database </p>

</div>
</div>
<a id="a7d8c8e5f6ba731f25fc9a59b00606a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8c8e5f6ba731f25fc9a59b00606a83">&#9670;&nbsp;</a></span>hdb_unlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">krb5_error_code(* HDB::hdb_unlock) (krb5_context, struct <a class="el" href="struct_h_d_b.html">HDB</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlock database </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/jaltman/src/sourdough-waffles/lib/hdb/hdb.h</li>
</ul>
</div><!-- contents -->
<hr size="1"><address style="text-align: right;"><small>
Generated on Tue Nov 15 2022 14:04:25 for Heimdal hdb library by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.9.1</small></address>
</body>
</html>
