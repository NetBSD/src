=pod

=head1 NAME

SSL_shutdown - shut down a TLS/SSL connection

=head1 SYNOPSIS

 #include <openssl/ssl.h>

 int SSL_shutdown(SSL *ssl);

=head1 DESCRIPTION

SSL_shutdown() shuts down an active TLS/SSL connection. It sends the
"close notify" shutdown alert to the peer.

=head1 NOTES

SSL_shutdown() tries to send the "close notify" shutdown alert to the peer.
Whether the operation succeeds or not, the SSL_SENT_SHUTDOWN flag is set and
a currently open session is considered closed and good and will be kept in the
session cache for further reuse.

The shutdown procedure consists of 2 steps: the sending of the "close notify"
shutdown alert and the reception of the peer's "close notify" shutdown
alert. According to the TLS standard, it is acceptable for an application
to only send its shutdown alert and then close the underlying connection
without waiting for the peer's response (this way resources can be saved,
as the process can already terminate or serve another connection).
When the underlying connection shall be used for more communications, the
complete shutdown procedure (bidirectional "close notify" alerts) must be
performed, so that the peers stay synchronized.

SSL_shutdown() supports both uni- and bidirectional shutdown by its 2 step
behaviour.

SSL_shutdown() only closes the write direction.
It is not possible to call SSL_write() after calling SSL_shutdown().
The read direction is closed by the peer.

=head2 First to close the connection

When the application is the first party to send the "close notify"
alert, SSL_shutdown() will only send the alert and then set the
SSL_SENT_SHUTDOWN flag (so that the session is considered good and will
be kept in the cache).
SSL_shutdown() will then return with 0.
If a unidirectional shutdown is enough (the underlying connection shall be
closed anyway), this first call to SSL_shutdown() is sufficient.

In order to complete the bidirectional shutdown handshake, the peer needs
to send back a "close notify" alert.
The SSL_RECEIVED_SHUTDOWN flag will be set after receiving and processing
it.
SSL_shutdown() will return 1 when it has been received.

The peer is still allowed to send data after receiving the "close notify"
event.
If the peer did send data it needs to be processed by calling SSL_read()
before calling SSL_shutdown() a second time.
SSL_read() will indicate the end of the peer data by returning <= 0
and SSL_get_error() returning SSL_ERROR_ZERO_RETURN.
It is recommended to call SSL_read() between SSL_shutdown() calls.

=head2 Peer closes the connection

If the peer already sent the "close notify" alert B<and> it was
already processed implicitly inside another function
(L<SSL_read(3)>), the SSL_RECEIVED_SHUTDOWN flag is set.
SSL_read() will return <= 0 in that case, and SSL_get_error() will return
SSL_ERROR_ZERO_RETURN.
SSL_shutdown() will send the "close notify" alert, set the SSL_SENT_SHUTDOWN
flag and will immediately return with 1.
Whether SSL_RECEIVED_SHUTDOWN is already set can be checked using the
SSL_get_shutdown() (see also L<SSL_set_shutdown(3)> call.

=head1 NOTES

It is recommended to do a bidirectional shutdown by checking the return value
of SSL_shutdown() and call it again until it returns 1 or a fatal error.

The behaviour of SSL_shutdown() additionally depends on the underlying BIO.
If the underlying BIO is B<blocking>, SSL_shutdown() will only return once the
handshake step has been finished or an error occurred.

If the underlying BIO is B<non-blocking>, SSL_shutdown() will also return
when the underlying BIO could not satisfy the needs of SSL_shutdown()
to continue the handshake. In this case a call to SSL_get_error() with the
return value of SSL_shutdown() will yield B<SSL_ERROR_WANT_READ> or
B<SSL_ERROR_WANT_WRITE>. The calling process then must repeat the call after
taking appropriate action to satisfy the needs of SSL_shutdown().
The action depends on the underlying BIO. When using a non-blocking socket,
nothing is to be done, but select() can be used to check for the required
condition. When using a buffering BIO, like a BIO pair, data must be written
into or retrieved out of the BIO before being able to continue.

SSL_shutdown() can be modified to only set the connection to "shutdown"
state but not actually send the "close notify" alert messages,
see L<SSL_CTX_set_quiet_shutdown(3)>.
When "quiet shutdown" is enabled, SSL_shutdown() will always succeed
and return 1.

=head1 RETURN VALUES

The following return values can occur:

=over 4

=item Z<>0

The shutdown is not yet finished: the "close notify" was send but the peer
did not send it back yet.
Call SSL_shutdown() again to do a bidirectional shutdown.
The output of L<SSL_get_error(3)> may be misleading, as an
erroneous SSL_ERROR_SYSCALL may be flagged even though no error occurred.

=item Z<>1

The shutdown was successfully completed. The "close notify" alert was sent
and the peer's "close notify" alert was received.

=item E<lt>0

The shutdown was not successful.
Call L<SSL_get_error(3)> with the return value B<ret> to find out the reason.
It can occur if an action is needed to continue the operation for non-blocking
BIOs.

It can also occur when not all data was read using SSL_read().

=back

=head1 SEE ALSO

L<SSL_get_error(3)>, L<SSL_connect(3)>,
L<SSL_accept(3)>, L<SSL_set_shutdown(3)>,
L<SSL_CTX_set_quiet_shutdown(3)>,
L<SSL_clear(3)>, L<SSL_free(3)>,
L<ssl(7)>, L<bio(7)>

=head1 COPYRIGHT

Copyright 2000-2018 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the OpenSSL license (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
