#!/bin/sh -
#
# Copyright (c) 1990 The Regents of the University of California.
# All rights reserved.
#
# Written and contributed by W. Jolitz 12/90
#
# Redistribution and use in source and binary forms are permitted provided
# that: (1) source distributions retain this entire copyright notice and
# comment, and (2) distributions including binaries display the following
# acknowledgement:  ``This product includes software developed by the
# University of California, Berkeley and its contributors'' in the
# documentation or other materials provided with the distribution and in
# all advertising materials mentioning features or use of this software.
# Neither the name of the University nor the names of its contributors may
# be used to endorse or promote products derived from this software without
# specific prior written permission.
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
#	from: @(#)MAKEDEV	5.2 (Berkeley) 6/22/90
#	$NetBSD: MAKEDEV,v 1.75 2003/08/22 05:06:34 itojun Exp $
#
###########################################################################
#
#   PLEASE RUN "cd ../share/man/man8 ; make makedevs"
#   AFTER CHANGING THIS FILE, AND COMMIT THE UPDATED MANPAGE!
#
###########################################################################
#
# Device "make" file.  Valid arguments:
#	all	a smattering -- at least one of each except ch*
#
#	std	standard devices
#	fd	file descriptor device nodes
#	local	configuration specific devices
#	raminst	for RAM disk install
#
# Tapes:
#	st*	SCSI tapes
#
# Disks:
#	sd*	SCSI disks
#	cd*	SCSI compact discs
#	vnd*	"file" pseudo-disks
#	raid*	RAIDframe disk driver
#	ccd*	concatenated disk driver
#	cgd*	cryptographic disk driver
#	md*	memory pseudo-disk devices
#	fd*	floppy disk drives (3 1/2")
#	wd*	"winchester" disk drives (ST506,IDE,ESDI,RLL,...)
#
# Terminal ports:
#	ttye*	ITE consoles
#	tty*	standard built-in serial ports (2)
#	ttyE*	wscons
#
# Pointing devices:
#	wsmouse* wscons mouse events
#
# Keyboard devices:
#	wskbd*	wscons keyboard events
#
# Pseudo terminals:
#	pty*	set of 62 master and slave pseudo terminals
#	opty	first 16 ptys, to save inodes on install media
#
# Graphics devices:
#	grf*	Bitmapped graphics device
#
# Special purpose devices:
#	clockctl clock control for non root users
#	tun*	network tunnel driver
#	bpf*	packet filter
#	lkm	loadable kernel modules interface
#	ipl	IP Filter
#	pf	PF packet filter
#	crypto	hardware crypto access driver
#	random	Random number generator
#	scsibus* SCSI busses, see scsi(4), scsictl(8)
#	ss*	SCSI scanner
#	uk*	unknown SCSI device
#	ch*	SCSI media changer
#	adb	Apple Desktop Bus
#	asc*	Apple Sound Chip
#	cfs*	Venus cache driver, for Coda
#	systrace syscall tracer
#

dialin=0
dialout=524288		# high bit of the minor number

PATH=/sbin:/bin/:/usr/bin:/usr/sbin
umask 77

# Check if we have fdesc mounted
if [ -d fd ]; then
	case "`df fd`" in
	*fdesc*) nofdesc=false;;
	*) nofdesc=true;;
	esac
else
	nofdesc=true
fi

makedev()
{

for i
do
case $i in

init|all)
	makedev std wscons fd sd0 sd1 sd2 sd3 wd0 wd1 wd2 wd3 tty0 tty1 pty0
	makedev st0 st1 ch0 cd0 cd1 fd0 fd1 vnd0 vnd1 vnd2 vnd3
	makedev ccd0 ccd1 ccd2 ccd3 md0 ss0 uk0 uk1
	makedev cgd0 cgd1 cgd2 cgd3
	makedev raid0 raid1 raid2 raid3 raid4 raid5 raid6 raid7
	makedev ttye0 adb grf0 grf1 grf2 grf3
	makedev bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7
	makedev bpf8 bpf9 bpf10 bpf11 random
	makedev tun0 tun1 tun2 tun3 asc0 lkm ipl pf crypto local
	makedev scsibus0 scsibus1 scsibus2 scsibus3 cfs0
	makedev clockctl
	makedev systrace
	;;

std)
	rm -f console drum kmem mem reload zero null tty
	rm -f klog stdin stdout stderr ksyms
	mknod console		c 0 0
	mknod drum		c 3 0	; chmod 640 drum ; chgrp kmem drum
	mknod kmem		c 2 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 2 0	; chmod 640 mem ; chgrp kmem mem
	mknod reload		c 2 20	; chmod 640 reload ; chgrp kmem reload
	mknod zero		c 2 12	; chmod 666 zero
	mknod null		c 2 2	; chmod 666 null
	mknod tty		c 1 0	; chmod 666 tty
	mknod klog		c 6 0	; chmod 600 klog
	mknod stdin		c 21 0	; chmod 666 stdin
	mknod stdout		c 21 1	; chmod 666 stdout
	mknod stderr		c 21 2	; chmod 666 stderr
	mknod ksyms		c 52 0	; chmod 444 ksyms
	;;

raminst)
	makedev std
	makedev sd0 sd1 sd2 sd3 wd0 wd1 wd2 wd3 st0 st1 cd0 cd1 md0
	makedev adb grf0 grf1 ttye0
	makedev tty0 tty1 opty
	makedev bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7
	;;

ttye*)
	chr=11; unit=${i#ttye}
	rm -f ttye$unit ite*
	mknod ttye$unit	c $chr $unit
	;;

grf*)
	unit=${i#grf}
	rm -f grf$unit
	mknod grf$unit c 10 $unit
	chmod 666 grf$unit
	;;

adb)
	rm -f adb
	mknod adb c 23 0
	chmod 666 adb
	;;

wscons)
	makedev ttyE0 ttyE1 ttyE2 ttyE3 ttyE4 ttyE5 ttyE6 ttyE7
	makedev wsmouse0 wsmouse1 wsmouse2 wsmouse3
	makedev wskbd0 wskbd1 wskbd2 wskbd3
	makedev ttyEcfg
	;;

ttyEcfg)
	chr=46
	rm -f ttyEcfg
	mknod ttyEcfg c $chr 255
	chmod 600 ttyEcfg
	;;

ttyE*)
	chr=46; unit=${i#ttyE}
	rm -f ttyE$unit
	mknod ttyE$unit c $chr $unit
	;;

wsmouse*)
	unit=${i#wsmouse}
	wsmouse=wsmouse$unit
	major=41
	rm -f $wsmouse
	mknod $wsmouse c $major $unit
	chmod 600 $wsmouse
	;;

wskbd*)
	unit=${i#wskbd}
	wskbd=wskbd$unit
	major=40
	rm -f $wskbd
	mknod $wskbd c $major $unit
	chmod 600 $wskbd
	;;

fd)
	rm -f fd/*
	mkdir fd 2>/dev/null
	n=0
	while [ $n -lt 64 ]; do
		mknod fd/$n c 21 $n
		n=$(($n + 1))
	done
	chmod 755 fd
	chmod 666 fd/*
	;;

md*)
	unit=${i#md}; blk=13; chr=32
	rm -f md${unit}? rmd${unit}?
	mknod md${unit}a  b $blk $(($unit * 8 + 0))
	mknod md${unit}c  b $blk $(($unit * 8 + 2))
#	mknod rmd${unit}a c $chr $(($unit * 8 + 0))
#	mknod rmd${unit}c c $chr $(($unit * 8 + 2))
	chgrp operator md${unit}? #rmd${unit}?
	chmod 640 md${unit}? #rmd${unit}?
	;;

ss*)
	case $i in
	ss*) name=ss;	unit=${i#ss};	chr=33;;
	esac
	rm -f $name$unit n$name$unit en$name$unit
	mknod $name$unit	c $chr $(($unit * 16 + 0))
	mknod n$name$unit	c $chr $(($unit * 16 + 1))
	mknod en$name$unit	c $chr $(($unit * 16 + 3))
	chgrp operator $name$unit n$name$unit en$name$unit
	chmod 640 $name$unit n$name$unit en$name$unit
	;;

sd*|fd*|wd*|vnd*|ccd*|cgd*|raid*)
	case $i in
	ccd*) name=ccd;	unit=${i#ccd};	blk=9;	chr=20;;
	cgd*) name=cgd;	unit=${i#cgd};	blk=23;	chr=51;;
	fd*) name=fd;	unit=${i#fd};	blk=21;	chr=43;;
	raid*) name=raid; unit=${i#raid}; blk=20; chr=42;;
	sd*) name=sd;	unit=${i#sd};	blk=4;	chr=13;;
	wd*) name=wd;	unit=${i#wd};	blk=22;	chr=49;;
	vnd*) name=vnd;	unit=${i#vnd};	blk=8;	chr=19;;
	esac
	rm -f $name$unit? r$name$unit?
	mknod ${name}${unit}a	b $blk $(($unit * 8 + 0))
	mknod ${name}${unit}b	b $blk $(($unit * 8 + 1))
	mknod ${name}${unit}c	b $blk $(($unit * 8 + 2))
	mknod ${name}${unit}d	b $blk $(($unit * 8 + 3))
	mknod ${name}${unit}e	b $blk $(($unit * 8 + 4))
	mknod ${name}${unit}f	b $blk $(($unit * 8 + 5))
	mknod ${name}${unit}g	b $blk $(($unit * 8 + 6))
	mknod ${name}${unit}h	b $blk $(($unit * 8 + 7))
	mknod r${name}${unit}a	c $chr $(($unit * 8 + 0))
	mknod r${name}${unit}b	c $chr $(($unit * 8 + 1))
	mknod r${name}${unit}c	c $chr $(($unit * 8 + 2))
	mknod r${name}${unit}d	c $chr $(($unit * 8 + 3))
	mknod r${name}${unit}e	c $chr $(($unit * 8 + 4))
	mknod r${name}${unit}f	c $chr $(($unit * 8 + 5))
	mknod r${name}${unit}g	c $chr $(($unit * 8 + 6))
	mknod r${name}${unit}h	c $chr $(($unit * 8 + 7))
	chgrp operator $name$unit? r$name$unit?
	chmod 640 $name$unit? r$name$unit?
	;;

tty*)
	unit=${i#tty}
	rm -f ser$unit tty$unit tty0$unit dty0$unit
	mknod tty0$unit c 12 $(($unit + $dialin ))
	mknod dty0$unit c 12 $(($unit + $dialout))
	chown uucp tty0$unit dty0$unit
	;;

opty)
	rm -f ttyp[0-9a-f] ptyp[0-9a-f]
	for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f
	do
		case $j in
		[0-9])	jn=$j ;;
		a)	jn=10 ;;
		b)	jn=11 ;;
		c)	jn=12 ;;
		d)	jn=13 ;;
		e)	jn=14 ;;
		f)	jn=15 ;;
		esac
		mknod ttyp$j c 4 $jn
		mknod ptyp$j c 5 $jn
	done
	chmod 666 ttyp[0-9a-f] ptyp[0-9a-f]
	;;

pty*)
	class=${i#pty}
	name=`echo pqrstuvwxyzPQRST | dd bs=1 count=1 skip=$class 2>/dev/null`
	case $name in
	v)	echo "$0: $i: pty unit conflicts with console ttyv0 device."
		continue ;;
	?)	;;
	*)	echo "$0: $i: pty unit must be between 0 and 15"
		continue ;;
	esac
	rm -f tty$name[0-9a-zA-Z] pty$name[0-9a-zA-Z]
	jn=0
	while [ $jn -lt 62 ]
	do
		j=`echo 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ | dd bs=1 count=1 skip=$jn 2>/dev/null`
		skip=0
		if [ $jn -ge 16 ]; then
			skip=$(($class * 30 + 256 - 16))
		fi
		unit=$(($class * 16 + $jn + $skip))
		mknod tty$name$j c 4 $unit
		mknod pty$name$j c 5 $unit
		jn=$(($jn + 1))
	done
	chmod 666 tty$name[0-9a-zA-Z] pty$name[0-9a-zA-Z]
	;;

st*)
	case $i in
	st*) name=st;	unit=${i#st};	chr=14;	blk=5;;
	esac
	rm -f $name$unit n$name$unit e$name$unit en$name$unit \
		r$name$unit nr$name$unit er$name$unit enr$name$unit
	mknod $name$unit	b $blk $(($unit * 16 + 0))
	mknod n$name$unit	b $blk $(($unit * 16 + 1))
	mknod e$name$unit	b $blk $(($unit * 16 + 2))
	mknod en$name$unit	b $blk $(($unit * 16 + 3))
	mknod r$name$unit	c $chr $(($unit * 16 + 0))
	mknod nr$name$unit	c $chr $(($unit * 16 + 1))
	mknod er$name$unit	c $chr $(($unit * 16 + 2))
	mknod enr$name$unit	c $chr $(($unit * 16 + 3))
	chgrp operator $name$unit n$name$unit e$name$unit en$name$unit \
		r$name$unit nr$name$unit er$name$unit enr$name$unit
	chmod 660 $name$unit n$name$unit e$name$unit en$name$unit \
		r$name$unit nr$name$unit er$name$unit enr$name$unit
	;;

ch*|uk*)
	case $i in
	ch*) name=ch;	unit=${i#ch};	chr=17;;
	uk*) name=uk;	unit=${i#uk};	chr=34;;
	esac
	rm -f $name$unit
	mknod $name$unit	c $chr $unit
	chgrp operator $name$unit
	chmod 640 $name$unit
	;;

cd*)
	case $i in
	cd*) name=cd;	unit=${i#cd};	chr=15;	blk=6;;
	esac
	rm -f $name$unit? r$name$unit?
	mknod ${name}${unit}a	b $blk $(($unit * 8 + 0))
	mknod ${name}${unit}c	b $blk $(($unit * 8 + 2))
	mknod r${name}${unit}a	c $chr $(($unit * 8 + 0))
	mknod r${name}${unit}c	c $chr $(($unit * 8 + 2))
	chgrp operator $name$unit? r$name$unit?
	chmod 640 $name$unit? r$name$unit?
	;;

bpf*|tun*)
	case $i in
	bpf*) name=bpf;	unit=${i#bpf};	chr=22;;
	tun*) name=tun;	unit=${i#tun};	chr=24;;
	esac
	rm -f $name$unit
	mknod $name$unit	c $chr $unit
	;;

lkm)
	rm -f lkm
	mknod lkm c 25 0
	chgrp kmem lkm
	chmod 640 lkm
	;;

ipl)
	rm -f ipl ipnat ipstate ipauth
	mknod ipl c 35 0
	mknod ipnat c 35 1
	mknod ipstate c 35 2
	mknod ipauth c 35 3
	chmod 600 ipl ipnat ipstate ipauth
	;;

pf)
	rm -f pf
	mknod pf c 53 0
	chmod 600 pf
	;;

crypto)
	rm -f crypto
	mknod crypto c 54 0
	chmod 666 crypto
	;;

asc*)
	unit=${i#asc}
	rm -f asc$unit
	mknod asc$unit c 36 $unit
	chmod 666 asc$unit
	;;

random)
	rm -f random urandom
	mknod random c 38 0
	mknod urandom c 38 1
	chmod 444 random
	chmod 644 urandom
	;;

scsibus*)
	unit=${i#scsibus}
	rm -f scsibus$unit
	mknod scsibus$unit c 39 $unit
	chmod 644 scsibus$unit
	;;

cfs*)
	unit=${i#cfs}
	cfs=cfs$unit
	major=47
	rm -f $cfs
	mknod $cfs c $major $unit
	chmod 600 $cfs
	;;

clockctl)
	rm -f clockctl
	mknod clockctl c 48 0
	chgrp ntpd clockctl
	chmod 660 clockctl
	;;

systrace)
	rm -f systrace
	mknod systrace c 50 0
	chmod 644 systrace
	;;
local)
	if [ -f "$0.local" ]; then
		umask 0
		sh $0.local all
		umask 77
	fi
	;;

*)
	echo $i: unknown device
esac
done

}

makedev $*
