#!/bin/sh -
#
#	$NetBSD: MAKEDEV,v 1.22 2003/03/30 20:19:51 perry Exp $
#
# Copyright (c) 1990 The Regents of the University of California.
# All rights reserved.
#
# Redistribution and use in source and binary forms are permitted provided
# that: (1) source distributions retain this entire copyright notice and
# comment, and (2) distributions including binaries display the following
# acknowledgement:  ``This product includes software developed by the
# University of California, Berkeley and its contributors'' in the
# documentation or other materials provided with the distribution and in
# all advertising materials mentioning features or use of this software.
# Neither the name of the University nor the names of its contributors may
# be used to endorse or promote products derived from this software without
# specific prior written permission.
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
#	@(#)MAKEDEV	5.2 (Berkeley) 6/22/90
#
###########################################################################
#
#   PLEASE RUN "cd ../share/man/man8 ; make makedevs"
#   AFTER CHANGING THIS FILE, AND COMMIT THE UPDATED MANPAGE!
#
###########################################################################
#
# Device "make" file.  Valid arguments:
#	all	makes all known devices, including local devices.
#		Tries to make the 'standard' number of each type.
#	std	standard devices
#	ramdisk	devices to be put into INSTALL kernel ramdisks.
#	usbs	make USB devices
#
# Disks:
#	wd*	"winchester" disk drives (ST506,IDE,ESDI,RLL,...)
#	vnd*	"file" pseudo-disks
#	md*	memory pseudo-disk devices
#	ccd*	concatenated disk devices
#	cgd*	cryptographic disk devices
#	raid*	RAIDframe disk devices
#
# Console ports:
#	ttyE*	wscons
#
# Pointing devices:
#	wsmouse* wscons mouse events
#
# Keyboard devices:
#	wskbd*	wscons keyboard events
#
# Pseudo terminals:
#	pty*	set of 62 master and slave pseudo terminals
#	opty	first 16 ptys, to save inodes on install media
#
# USB devices:
#	usb*	USB control devices
#	uhid*	USB generic HID devices
#	ulpt*	USB printer devices
#	ugen*	USB generic devices
#	urio*	USB Diamond Rio 500 devices
#	uscanner*	USB scanners
#	ttyU*	USB modems
#
# Special purpose devices:
#	clockctl clock control for non root users
#	fd	file descriptors
#	bpf*	packet filter
#	ipl	IP filter
#	random	Random number generator
#	tun*	network tunnel driver
#	systrace syscall tracer
#

dialin=0
dialout=524288		# high bit of the minor number
callunit=262144

PATH=/sbin:/usr/sbin:/bin:/usr/bin
umask 77

# Check if we have fdesc mounted
if [ -d fd ]; then
	case "`df fd`" in
	*fdesc*) nofdesc=false;;
	*) nofdesc=true;;
	esac
else
	nofdesc=true
fi

makedev()
{

for i
do
case $i in

all)
	makedev std wscons fd wd0 wd1
	makedev pty0
	makedev bpf0 bpf1 bpf2 bpf3
	makedev vnd0 vnd1 vnd2 vnd3
	makedev local
	makedev random
	makedev ipl
	makedev tun0 tun1
	makedev md0
	makedev usbs
	makedev clockctl
	makedev systrace
	;;

std)
	rm -f console drum mem kmem null zero io klog
	mknod console		c 2 0
	mknod drum		c 1 0	; chmod 640 drum ; chgrp kmem drum
	mknod kmem		c 0 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 0 0	; chmod 640 mem	; chgrp kmem mem
	mknod null		c 0 2	; chmod 666 null
	mknod zero		c 0 12	; chmod 666 zero
	mknod io		c 0 14	; chmod 640 io ; chgrp kmem io
	mknod klog		c 5 0	; chmod 600 klog
	if $nofdesc; then
		rm -f tty stdin stdout stderr
		mknod tty	c 3 0	; chmod 666 tty
		mknod stdin	c 4 0	; chmod 666 stdin
		mknod stdout	c 4 1	; chmod 666 stdout
		mknod stderr	c 4 2	; chmod 666 stderr
	fi
	;;

ramdisk)
	makedev md0
	;;

wscons)
	makedev ttyE0 ttyE1 ttyE2 ttyE3 ttyE4 ttyE5 ttyE6 ttyE7
	makedev wsmouse0 wsmouse1 wsmouse2 wsmouse3
	makedev wskbd0 wskbd1 wskbd2 wskbd3
	makedev wsmux0 wsmux1 wsmux2 wsmux3
	makedev wsmouse wskbd
	makedev ttyEcfg
	;;

ttyEcfg)
	chr=27
	rm -f ttyEcfg
	mknod ttyEcfg c $chr 255
	chmod 600 ttyEcfg
	;;

ttyE*)
	chr=27; unit=${i#ttyE}
	rm -f ttyE$unit
	mknod ttyE$unit c $chr $unit
	;;

wsmouse)
	rm -f wsmouse
	mknod wsmouse c 30 0
	chmod 600 wsmouse
	;;

wskbd)
	rm -f wskbd
	mknod wskbd c 30 1
	chmod 600 wskbd
	;;

wsmux*)
	unit=${i#wsmux}
	unitctl=$(($unit + 128))
	wsmux=wsmux$unit
	wsmuxctl=wsmuxctl$unit
	major=30
	rm -f $wsmux $wsmuxctl
	mknod $wsmux c $major $unit
	chmod 600 $wsmux
	mknod $wsmuxctl c $major $unitctl
	chmod 200 $wsmuxctl
	;;

wsmouse*)
	unit=${i#wsmouse}
	wsmouse=wsmouse$unit
	major=29
	rm -f $wsmouse
	mknod $wsmouse c $major $unit
	chmod 600 $wsmouse
	;;

wskbd*)
	unit=${i#wskbd}
	wskbd=wskbd$unit
	major=28
	rm -f $wskbd
	mknod $wskbd c $major $unit
	chmod 600 $wskbd
	;;

fd)
	if $nofdesc; then
		rm -f fd/*
		mkdir fd 2>/dev/null
		n=0
		while [ $n -lt 64 ]; do
			mknod fd/$n c 4 $n
			n=$(($n + 1))
		done
		chmod 755 fd
		chmod 666 fd/*
	fi
	;;

md*)
	unit=${i#md}; blk=6; chr=12
	rm -f md${unit}? rmd${unit}?
	mknod md${unit}a  b $blk $(($unit * 8 + 0))
	mknod md${unit}d  b $blk $(($unit * 8 + 3))
	chgrp operator md${unit}? #rmd${unit}?
	chmod 640 md${unit}? #rmd${unit}?
	;;

ccd*|cgd*|vnd*|wd*|raid*)
	case $i in
	ccd*) name=ccd;	unit=${i#ccd};	blk=7;	chr=13;;
	cgd*) name=cgd;	unit=${i#cgd};	blk=10;	chr=40;;
	raid*) name=raid; unit=${i#raid}; blk=9; chr=15;;
	vnd*) name=vnd;	unit=${i#vnd};	blk=8;	chr=14;;
	wd*) name=wd;	unit=${i#wd};	blk=1;	chr=10;;
	esac
	rm -f $name$unit? r$name$unit?
	mknod ${name}${unit}a	b $blk $(($unit * 16 + 0))
	mknod ${name}${unit}b	b $blk $(($unit * 16 + 1))
	mknod ${name}${unit}c	b $blk $(($unit * 16 + 2))
	mknod ${name}${unit}d	b $blk $(($unit * 16 + 3))
	mknod ${name}${unit}e	b $blk $(($unit * 16 + 4))
	mknod ${name}${unit}f	b $blk $(($unit * 16 + 5))
	mknod ${name}${unit}g	b $blk $(($unit * 16 + 6))
	mknod ${name}${unit}h	b $blk $(($unit * 16 + 7))
	mknod ${name}${unit}i	b $blk $(($unit * 16 + 8))
	mknod ${name}${unit}j	b $blk $(($unit * 16 + 9))
	mknod ${name}${unit}k	b $blk $(($unit * 16 + 10))
	mknod ${name}${unit}l	b $blk $(($unit * 16 + 11))
	mknod ${name}${unit}m	b $blk $(($unit * 16 + 12))
	mknod ${name}${unit}n	b $blk $(($unit * 16 + 13))
	mknod ${name}${unit}o	b $blk $(($unit * 16 + 14))
	mknod ${name}${unit}p	b $blk $(($unit * 16 + 15))
	mknod r${name}${unit}a	c $chr $(($unit * 16 + 0))
	mknod r${name}${unit}b	c $chr $(($unit * 16 + 1))
	mknod r${name}${unit}c	c $chr $(($unit * 16 + 2))
	mknod r${name}${unit}d	c $chr $(($unit * 16 + 3))
	mknod r${name}${unit}e	c $chr $(($unit * 16 + 4))
	mknod r${name}${unit}f	c $chr $(($unit * 16 + 5))
	mknod r${name}${unit}g	c $chr $(($unit * 16 + 6))
	mknod r${name}${unit}h	c $chr $(($unit * 16 + 7))
	mknod r${name}${unit}i	c $chr $(($unit * 16 + 8))
	mknod r${name}${unit}j	c $chr $(($unit * 16 + 9))
	mknod r${name}${unit}k	c $chr $(($unit * 16 + 10))
	mknod r${name}${unit}l	c $chr $(($unit * 16 + 11))
	mknod r${name}${unit}m	c $chr $(($unit * 16 + 12))
	mknod r${name}${unit}n	c $chr $(($unit * 16 + 13))
	mknod r${name}${unit}o	c $chr $(($unit * 16 + 14))
	mknod r${name}${unit}p	c $chr $(($unit * 16 + 15))
	chgrp operator $name$unit? r$name$unit?
	chmod 640 $name$unit? r$name$unit?
	;;

opty)
	rm -f ttyp[0-9a-f] ptyp[0-9a-f]
	for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f
	do
		case $j in
		[0-9])	jn=$j ;;
		a)	jn=10 ;;
		b)	jn=11 ;;
		c)	jn=12 ;;
		d)	jn=13 ;;
		e)	jn=14 ;;
		f)	jn=15 ;;
		esac
		mknod ttyp$j c 7 $jn
		mknod ptyp$j c 6 $jn
	done
	chmod 666 ttyp[0-9a-f] ptyp[0-9a-f]
	;;

pty*)
	class=${i#pty}
	name=`echo pqrstuvwxyzPQRST | dd bs=1 count=1 skip=$class 2>/dev/null`
	case $name in
	v)	echo "$0: $i: pty unit conflicts with console ttyv0 device."
		continue ;;
	?)	;;
	*)	echo "$0: $i: pty unit must be between 0 and 15"
		continue ;;
	esac
	rm -f tty$name[0-9a-zA-Z] pty$name[0-9a-zA-Z]
	jn=0
	while [ $jn -lt 62 ]
	do
		j=`echo 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ | dd bs=1 count=1 skip=$jn 2>/dev/null`
		skip=0
		if [ $jn -ge 16 ]; then
			skip=$(($class * 30 + 256 - 16))
		fi
		unit=$(($class * 16 + $jn + $skip))
		mknod tty$name$j c 7 $unit
		mknod pty$name$j c 6 $unit
		jn=$(($jn + 1))
	done
	chmod 666 tty$name[0-9a-zA-Z] pty$name[0-9a-zA-Z]
	;;

bpf*|tun*)
	case $i in
	bpf*) name=bpf;	unit=${i#bpf};	chr=25;;
	tun*) name=tun;	unit=${i#tun};	chr=24;;
	esac
	rm -f $name$unit
	mknod $name$unit	c $chr $unit
	;;

ipl)
	rm -f ipl ipnat ipstate ipauth
	mknod ipl c 23 0
	mknod ipnat c 23 1
	mknod ipstate c 23 2
	mknod ipauth c 23 3
	chmod 600 ipl ipnat ipstate ipauth
	;;

random)
	rm -f random urandom
	mknod random c 26 0
	mknod urandom c 26 1
	chmod 444 random
	chmod 644 urandom
	;;

usbs)
	makedev usb usb0
	makedev uhid0 uhid1 uhid2 uhid3
	makedev ulpt0 ulpt1
	makedev ttyU0 ttyU1
	makedev urio0
	makedev uscanner0 uscanner1
	makedev ugen0
	;;

usb*)
	unit=${i#usb}
	if [ "$unit" = "" ]; then
	    unit=255
	    usb=usb
	else
	    usb=usb$unit
	fi
	major=31
	rm -f $usb
	mknod $usb c $major $unit
	chmod 600 $usb
	;;

uhid*)
	unit=${i#uhid}
	uhid=uhid$unit
	major=32
	rm -f $uhid
	mknod $uhid c $major $unit
	chmod 666 $uhid
	;;

ulpt*)
	unit=${i#ulpt}
	ulpt=ulpt$unit
	ulpn=ulpn$unit
	major=33
	rm -f $ulpt $ulpn
	mknod $ulpt c $major $unit
	mknod $ulpn c $major $(($unit + 64))
	chmod 600 $ulpt $ulpn
	;;

ugen*)
	unit=${i#ugen}
	ugen=ugen$unit
	major=34
	for j in 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
	do
		ugenj=$ugen.$j
		rm -f $ugenj
		mknod $ugenj c $major $(($unit * 16 + $j))
		chmod 600 $ugenj
	done
	;;


ttyU*)
	unit=${i#ttyU}
	ttyU=ttyU$unit
	dtyU=dtyU$unit
	ctyU=ctyU$unit
	major=35
	rm -f $ttyU $dtyU $ctyU
	mknod $ttyU c $major $(($unit + $dialin  ))
	mknod $dtyU c $major $(($unit + $dialout ))
	mknod $ctyU c $major $(($unit + $callunit))
	chown uucp $ttyU $dtyU $ctyU
	chmod 600 $ttyU $dtyU $ctyU
	;;

urio*)
	unit=${i#urio}
	urio=urio$unit
	major=36
	rm -f $urio
	mknod $urio c $major $unit
	chmod 600 $urio
	;;

uscanner*)
	unit=${i#uscanner}
	uscanner=uscanner$unit
	major=37
	rm -f $uscanner
	mknod $uscanner c $major $unit
	chmod 600 $uscanner
	;;

clockctl)
	rm -f clockctl
	mknod clockctl c 38 0
	chgrp ntpd clockctl
	chmod 660 clockctl
	;;

systrace)
	rm -f systrace
	mknod systrace c 39 0
	chmod 644 systrace
	;;

local)
	if [ -f "$0.local" ]; then
		umask 0
		sh $0.local all
		umask 77
	fi
	;;

*)
	echo $i: unknown device
	;;

esac
done

}

makedev $*
