#	$NetBSD: rc,v 1.66 1997/03/10 06:32:37 scottr Exp $
#	from: @(#)rc	8.2 (Berkeley) 3/17/94

# System startup script run by init on autoboot
# or after single-user.
# Output and error are redirected to console by init,
# and the console is the controlling terminal.

stty status '^T'

# Set shell to ignore SIGINT (2), but not children;
# shell catches SIGQUIT (3) and returns to single user after fsck.
trap : 2
trap : 3	# shouldn't be needed

HOME=/; export HOME
PATH=/sbin:/bin:/usr/sbin:/usr/bin
export PATH

# Configure ccd devices.
if [ -f /etc/ccd.conf ]; then
	ccdconfig -C
fi

if [ -e /fastboot ]; then
	echo "Fast boot: skipping disk checks."
elif [ $1x = autobootx ]; then
	echo "Automatic boot in progress: starting file system checks."
	fsck -p
	case $? in
	0)
		;;
	2)
		exit 1
		;;
	4)
		echo "Rebooting..."
		reboot
		echo "Reboot failed; help!"
		exit 1
		;;
	8)
		echo "Automatic file system check failed; help!"
		exit 1
		;;
	12)
		echo "Boot interrupted."
		exit 1
		;;
	130)
		# interrupt before catcher installed
		exit 1
		;;
	*)
		echo "Unknown error; help!"
		exit 1
		;;
	esac
fi

trap "echo 'Boot interrupted.'; exit 1" 3

swapon -a

umount -a >/dev/null 2>&1
mount -a -t nonfs
rm -f /fastboot		# XXX (root now writeable)

if [ -s /etc/rc.conf ]; then
	. /etc/rc.conf
fi

# set flags on ttys.  (do early, in case they use tty for SLIP in netstart)
echo 'setting tty flags'
ttyflags -a

# load any kernel modules specified in /etc/lkm.conf
if [ X"$lkm_init" != XNO -a -f /etc/rc.lkm ]; then
	. /etc/rc.lkm
fi

# set hostname, turn on network
echo 'starting network'
. /etc/netstart

mount /usr >/dev/null 2>&1
mount /var >/dev/null 2>&1

# clean up left-over files
rm -f /etc/nologin
rm -f /var/spool/lock/LCK.*
rm -f /var/spool/uucp/STST/*
(cd /var/run && { rm -rf -- *; install -c -m 664 -g utmp /dev/null utmp; })

# start the system logger first, so that all messages
# from daemons are logged, and the name server next.

if [ "X$syslogd_flags" != XNO ]; then
	echo 'starting system logger'
	rm -f /dev/log
	syslogd $syslogd_flags
fi

if [ "X$named_flags" != XNO ]; then
	echo 'starting name server';	named $named_flags
fi

# now start the rpc servers, for YP server/client, NFS.
echo -n 'starting rpc daemons:'

# note that portmap is generally required for all other rpc services.
if [ "X$portmap" != XNO ]; then
	echo -n ' portmap';             portmap
fi

if [ "X$ypserv_flags" != XNO ]; then
        echo -n ' ypserv';              ypserv $ypserv_flags
fi

if [ "X$ypbind_flags" != XNO ]; then
        echo -n ' ypbind';              ypbind $ypbind_flags
fi

if [ "X$yppasswdd_flags" != XNO ]; then
        echo -n ' rpc.yppasswdd';       rpc.yppasswdd $yppasswdd_flags
fi

if [ "X$bootparamd_flags" != XNO -a -r /etc/bootparams ]; then
        echo -n ' rpc.bootparamd';      rpc.bootparamd $bootparamd_flags
fi

if [ "X$nfs_server" = XYES -a -r /etc/exports ]; then
	if [ "X$nfsd_flags" = X ]; then
		nfsd_flags="-tun 4"
	fi
        rm -f /var/db/mountdtab
        echo -n > /var/db/mountdtab
        echo -n ' mountd';              mountd $mountd_flags
        echo -n ' nfsd';                nfsd $nfsd_flags
fi

if [ "X$nfs_client" = XYES ]; then
	if [ "X$nfsiod_flags" = X ]; then
		nfsiod_flags="-n 4"
	fi
        echo -n ' nfsiod';              nfsiod $nfsiod_flags
fi

if [ "X$nfs_server" = XYES -a -r /etc/exports -o "X$nfs_client" = XYES ]; then
	if [ "X$statd_flags" != XNO ]; then
		echo ' statd';		rpc.statd $statd_flags
	fi

	if [ "X$lockd_flags" != XNO ]; then
		echo ' lockd';		rpc.lockd $lockd_flags
	fi
fi

if [ "X$amd" = XYES -a -d "$amd_dir" -a -r "$amd_master" ]; then
        echo -n ' amd'
        amd $amd_flags -p -a $amd_dir `cat $amd_master` > /var/run/amd.pid
fi

echo '.'
mount -a -t nfs

if [ -f /sbin/ldconfig ]; then
	echo 'creating runtime link editor directory cache.'
	if [ -s /etc/ld.so.conf ]; then
		ldconfig `cat /etc/ld.so.conf`
	else
		ldconfig
	fi
fi 

# /var/crash should be a directory or a symbolic link
# to the crash directory if core dumps are to be saved.
if [ X"$savecore_flags" != XNO -a -d /var/crash ]; then
	echo checking for core dump...
	savecore $savecore_flags /var/crash
fi

				echo -n 'checking quotas:'
quotacheck -a
				echo ' done.'
quotaon -a

# build ps databases
echo 'building databases...'
kvm_mkdb /netbsd
dev_mkdb

chmod 666 /dev/tty[pqrs]*

# check the password temp/lock file
if [ -f /etc/ptmp ]
then
	logger -s -p auth.err \
	'password file may be incorrect -- /etc/ptmp exists'
fi

virecovery=/var/tmp/vi.recover/recover.*
if [ "$virecovery" != "/var/tmp/vi.recover/recover.*" ]; then
	echo preserving editor files
	for i in $virecovery; do
		sendmail -t < $i
	done
fi

echo clearing /tmp

# Prune quickly with one rm, then use find to clean up /tmp/[lq]* (this
# is not needed with mfs /tmp, but doesn't hurt anything).
(cd /tmp && rm -rf [a-km-pr-zA-Z]* &&
    find . ! -name . ! -name lost+found ! -name quota.user \
	! -name quota.group -exec rm -rf -- {} \; -type d -prune)

if [ -f /var/account/acct ]; then
	echo 'turning on accounting';	accton /var/account/acct
fi

echo -n standard daemons:
echo -n ' update';		update
echo -n ' cron';		cron
echo '.'

# now start all the other daemons
echo -n starting network daemons:

if [ X$gated_flags != XNO -a -r /etc/gated.conf ]; then
	echo -n ' gated';		gated $gated_flags
elif [ "X$routed_flags" != XNO ]; then
	echo -n ' routed';		routed $routed_flags
fi

if [ "X$mrouted_flags" != XNO ]; then
	echo -n ' mrouted';		mrouted $mrouted_flags
fi

if [ "X$timed_flags" != XNO ]; then
	echo -n ' time daemon'; 	timed $timed_flags
fi

if [ "X$xntpd_flags" != XNO ]; then
	echo -n ' ntp daemon';		xntpd $xntpd_flags
fi

if [ "X$dhcpd_flags" != XNO -a -r /etc/dhcpd.conf ]; then
	echo -n ' dhcpd';		dhcpd $dhcpd_flags
fi

if [ X$rwhod = XYES ]; then
	echo -n ' rwhod';		rwhod
fi

if [ "X$lpd_flags" != XNO ]; then
	echo -n ' printer';		lpd $lpd_flags
fi

# We call sendmail with a full path so that SIGHUP works.
if [ "X$sendmail_flags" != XNO -a -r /etc/sendmail.cf ]; then
	echo -n ' sendmail';		/usr/sbin/sendmail $sendmail_flags
fi

if [ "X$rarpd_flags" != XNO -a -r /etc/ethers ]; then
	echo -n ' rarpd';		rarpd $rarpd_flags
fi

if [ "X$rbootd_flags" != XNO -a -r /etc/rbootd.conf ]; then
	echo -n ' rbootd';		rbootd $rbootd_flags
fi

if [ "X$inetd_flags" != XNO -a -r /etc/inetd.conf ]; then
	echo -n ' inetd';		inetd $inetd_flags
fi

echo '.'

. /etc/rc.local

date
exit 0
