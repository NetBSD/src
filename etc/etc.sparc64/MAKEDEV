#!/bin/sh -
#
#	$NetBSD: MAKEDEV,v 1.47 2003/02/20 13:37:33 martin Exp $
#
# Copyright (c) 1990 The Regents of the University of California.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#	This product includes software developed by the University of
#	California, Berkeley and its contributors.
# 4. Neither the name of the University nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
#	@(#)MAKEDEV	5.5 (Berkeley) 5/28/91
#
###########################################################################
#
#   PLEASE RUN "cd ../share/man/man8 ; make makedevs"
#   AFTER CHANGING THIS FILE, AND COMMIT THE UPDATED MANPAGE!
#
###########################################################################
#
# Device "make" file.  Valid arguments:
#	std	standard devices
#	local	configuration specific devices
#	isdns	make ISDN devices
#	usbs	make USB devices
# Tapes:
#	st*	SCSI tape
# Disks:
#	sd*	SCSI disks
#	wd*	IDE disks
#	cd*	SCSI cdrom drives
#	ch*	SCSI media changer
#	fd*	Floppies
#	vnd*	"file" pseudo-disks
#	ccd*	concatenated disk devices
#	cgd*	cryptographic disk devices
#	raid*	RAIDframe disk driver
#	md*	memory pseudo-disk devices
# Console ports:
#	console	standard console
#	ttyE*	wscons
# Pointing devices:
#	mouse	standard sun mouse events
#	wsmouse* wscons mouse events
# Keyboard devices:
#	kbd	standard sun keyboard events
#	wskbd*	wscons keyboard events
# Terminals:
#	tty*	Z88530 serial controllers
#	ttyC*	NS16550 serial controllers
#	ttyh*	SAB82532 serial controllers
# Pseudo terminals:
#	pty*	set of 62 master and slave pseudo terminals
#	opty	first 16 ptys, to save inodes on install media
# USB devices:
#	usb*	Bus control devices used by usbd for attach/detach
#	uhid*	Generic HID devices
#	ulpt*	Printer devices
#	ugen*	Generic device
#	urio*	Diamond Rio 500
#	uscanner*	Scanners
#	ttyU*	Modem
# Printers:
#	bpp	parallel printer port on sbus machines
#	lpt*	stock lp on PCI machines
#	lpa*	interruptless lp
# ISDN devices:
#	isdn	communication between userland isdnd and kernel
#	isdnctl	control device
#	isdnbchan* raw b-channel access
#	isdntel*	telephony device
#	isdntrc*	trace device
# Special purpose devices:
#	clockctl clock control for non root users
#	audio*	audio devices.
#	openprom	OPENPROM and EEPROM interface
#	bwtwo*	monochromatic frame buffer
#	cgtwo*	8-bit color frame buffer
#	cgthree*	8-bit color frame buffer
#	cgfour*	8-bit color frame buffer
#	cgsix*	accelerated 8-bit color frame buffer
#	cgeight*	24-bit color frame buffer
#	tcx*	accelerated 8/24-bit color frame buffer
#	bpf*	packet filter
#	lkm	loadable kernel modules interface
#	tun*	network tunnel driver
#	ipl	IP filter
#	random	Random number generator
#	scsibus* SCSI busses, see scsi(4), scsictl(8)
#	ses* SES/SAF-TE SCSI Devices
#	ss*	SCSI scanner
#	uk*	unknown SCSI device
#	pci*	PCI bus access devices
#	systrace syscall tracer
#	wsmux*	wscons event multiplexor
#	wsfont*	console font control
#	dpt*	DPT/Adaptec EATA RAID management interface
#	nsmb*	SMB requester
#	kttcp	kernel ttcp helper device
#	dmoverio hardware-assisted data movers
#	veriexec verified executable fingerprint loader
#	twe	3ware Escalade control interface
#

dialin=0
dialout=524288		# high bit of the minor number
callunit=262144

PATH=/sbin:/bin/:/usr/bin:/usr/sbin:/usr/etc
umask 77

# Check if we have fdesc mounted
if [ -d fd ]; then
	case "`df fd`" in
	*fdesc*) nofdesc=false;;
	*) nofdesc=true;;
	esac
else
	nofdesc=true
fi

makedev()
{

for i
do
case $i in

all)
	makedev std ttya ttyb ttyc ttyd ttyC00 ttyC01 ttyh0 ttyh1
	makedev fd sd0 sd1 sd2 sd3 sd4 ss0 ch0 uk0 uk1
	makedev wd0 wd1 wd2 wd3 cd0 st0 st1 fd0 md0 md1
	makedev audio0 audio1 audio2 audio3
	makedev pty0 vnd0 vnd1 vnd2 vnd3 audio
	makedev tun0 tun1 tun2 tun3
	makedev bpp lpt0 lpt1 lpt2
	makedev ccd0 ccd1 ccd2 ccd3
	makedev cgd0 cgd1 cgd2 cgd3
	makedev raid0 raid1 raid2 raid3 raid4 raid5 raid6 raid7
	makedev bpf0 bpf1 bpf2 bpf3 bpf4 bpf5 bpf6 bpf7
	makedev bwtwo0 cgtwo0 cgthree0 cgfour0 cgsix0
	makedev cgeight0 tcx0
	makedev scsibus0 scsibus1 scsibus2 scsibus3
	makedev ipl lkm random local
	makedev usbs
	makedev isdns
	makedev pci0 pci1 pci2 pci3 pci4 pci5 pci6 pci7
	makedev clockctl
	makedev systrace
	makedev wscons
	;;
floppy|ramdisk)
	makedev std ttya ttyb ttyc ttyd opty
	makedev sd0 sd1 sd2 sd3 sd4 sd5 md0
	makedev wd0 wd1 cd0 cd1 st0 st1 fd0
	makedev random
	;;
isdns)
	makedev isdn isdnctl isdnbchan0 isdnbchan1 isdntel0 isdntel1 isdntrc0 isdntrc1
	;;
std)
	rm -f console kmem mem null zero eeprom openprom drum klog \
		ttya ttyb fb mouse kbd bpp
	mknod console		c 0 0
	mknod kmem		c 3 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 3 0	; chmod 640 mem ; chgrp kmem mem
	mknod null		c 3 2	; chmod 666 null
	mknod zero		c 3 12	; chmod 666 zero
	mknod eeprom		c 3 11  ; chmod 640 eeprom ; chgrp kmem eeprom
	mknod openprom		c 70 0  ; chmod 640 openprom;chgrp kmem openprom
	mknod drum		c 7 0	; chmod 640 drum ; chgrp kmem drum
	mknod klog		c 16 0	; chmod 600 klog
	if $nofdesc; then
		rm -f tty stdin stdout stderr
		mknod tty	c 2 0	; chmod 666 tty
		mknod stdin	c 24 0	; chmod 666 stdin
		mknod stdout	c 24 1	; chmod 666 stdout
		mknod stderr	c 24 2	; chmod 666 stderr
	fi
	mknod fb		c 22 0 ; chmod 666 fb
	mknod mouse		c 13 0 ; chmod 666 mouse
	mknod kbd		c 29 0 ; chmod 666 kbd
	makedev bpp
	;;

tty[abcd])
	unit=${i#???}
	case $unit in
	a)	index=0;;
	b)	index=1;;
	c)	index=4;;
	d)	index=5;;
	esac
	rm -f tty$unit dty$unit
	mknod tty$unit c 12 $(($index + $dialin ))
	mknod dty$unit c 12 $(($index + $dialout))
	chown uucp tty$unit dty$unit
	;;

ttyC*)
	unit=${i#ttyC}
	rm -f ttyC$unit dtyC$unit
	mknod ttyC$unit c 36 $(($unit + $dialin ))
	mknod dtyC$unit c 36 $(($unit + $dialout))
	chown uucp ttyC$unit dtyC$unit
	;;

ttyh*)
	unit=${i#ttyh}
	rm -f ttyh$unit dtyh$unit
	mknod ttyh$unit c 77 $(($unit + $dialin ))
	mknod dtyh$unit c 77 $(($unit + $dialout))
	chown uucp ttyh$unit dtyh$unit
	;;

fd)
	if $nofdesc; then
		rm -f fd/*
		mkdir fd 2>/dev/null
		n=0
		while [ $n -lt 64 ]; do
			mknod fd/$n c 24 $n
			n=$(($n + 1))
		done
		chmod 755 fd
		chmod 666 fd/*
	fi
	;;

bwtwo*)
	unit=${i#bwtwo}
	rm -f bwtwo$unit
	mknod bwtwo$unit	c 27 $unit; chmod 666 bwtwo$unit
	;;

cgtwo*)
	unit=${i#cgtwo}
	rm -f cgtwo$unit
	mknod cgtwo$unit	c 31 $unit; chmod 666 cgtwo$unit
	;;

cgthree*)
	unit=${i#cgthree}
	rm -f cgthree$unit
	mknod cgthree$unit	c 55 $unit; chmod 666 cgthree$unit
	;;

cgfour*)
	unit=${i#cgfour}
	rm -f cgfour$unit
	mknod cgfour$unit	c 39 $unit; chmod 666 cgfour$unit
	;;

cgsix*)
	unit=${i#cgsix}
	rm -f cgsix$unit
	mknod cgsix$unit	c 67 $unit; chmod 666 cgsix$unit
	;;

cgeight*)
	unit=${i#cgeight}
	rm -f cgeight$unit
	mknod cgeight$unit	c 64 $unit; chmod 666 cgeight$unit
	;;

tcx*)
	unit=${i#tcx}
	rm -f tcx$unit
	mknod tcx$unit		c 109 $unit; chmod 666 tcx$unit
	;;

wscons)
	makedev ttyE0 ttyE1 ttyE2 ttyE3 ttyE4 ttyE5 ttyE6 ttyE7
	makedev wsmouse0 wsmouse1 wsmouse2 wsmouse3
	makedev wskbd0 wskbd1 wskbd2 wskbd3
	makedev wsmux0 wsmux1 wsmux2 wsmux3
	makedev wsmouse wskbd
	makedev ttyEcfg ttyEstat
	makedev wsfont
	;;

ttyEstat)
	chr=90
	rm -f ttyEstat
	mknod ttyEstat c $chr 254
	chmod 600 ttyEstat
	;;

ttyEcfg)
	chr=90
	rm -f ttyEcfg
	mknod ttyEcfg c $chr 255
	chmod 600 ttyEcfg
	;;

ttyE*)
	chr=90; unit=${i#ttyE}
	rm -f ttyE$unit
	mknod ttyE$unit c $chr $unit
	;;

wsmux*)
	unit=${i#wsmux}
	unitctl=$(($unit + 128))
	wsmux=wsmux$unit
	wsmuxctl=wsmuxctl$unit
	major=93
	rm -f $wsmux $wsmuxctl
	mknod $wsmux c $major $unit
	chmod 600 $wsmux
	mknod $wsmuxctl c $major $unitctl
	chmod 200 $wsmuxctl
	;;

wsmouse)
	rm -f wsmouse
	mknod wsmouse c 93 0
	chmod 600 wsmouse
	;;

wskbd)
	rm -f wskbd
	mknod wskbd c 93 1
	chmod 600 wskbd
	;;

wskbd*)
	unit=${i#wskbd}
	wskbd=wskbd$unit
	major=91
	rm -f $wskbd
	mknod $wskbd c $major $unit
	chmod 600 $wskbd
	;;

wsmouse*)
	unit=${i#wsmouse}
	wsmouse=wsmouse$unit
	major=92
	rm -f $wsmouse
	mknod $wsmouse c $major $unit
	chmod 600 $wsmouse
	;;

wsfont)
	rm -f wsfont
	mknod wsfont c 94 0
	chmod 600 wsfont
	;;

audio*)
	unit=${i#audio}
	audio=audio$unit
	sound=sound$unit
	mixer=mixer$unit
	major=69
	audioctl=audioctl$unit
	if [ "$unit" = "" ]; then unit=0; fi
	rm -f $audio $sound $mixer $audioctl
	mknod $sound    c $major $(($unit + 0))
	mknod $audio    c $major $(($unit + 128))
	mknod $mixer    c $major $(($unit + 16))
	mknod $audioctl c $major $(($unit + 192))
	chmod 666 $audio $sound $mixer $audioctl
	;;

bpf*)
	unit=${i#bpf}
	rm -f bpf$unit
	mknod bpf$unit c 105 $unit
	chmod 600 bpf$unit
	;;

tun*)
	unit=${i#tun}
	rm -f tun$unit
	mknod tun$unit c 111 $unit
	chmod 600 tun$unit
	;;

md*)
	unit=${i#md}; blk=5; chr=61
	rm -f md${unit}? rmd${unit}?
	mknod md${unit}a  b $blk $(($unit * 8 + 0))
	mknod md${unit}c  b $blk $(($unit * 8 + 2))
#	mknod rmd${unit}a c $chr $(($unit * 8 + 0))
#	mknod rmd${unit}c c $chr $(($unit * 8 + 2))
	chgrp operator md${unit}? #rmd${unit}?
	chmod 640 md${unit}? #rmd${unit}?
	;;

ccd*|cgd*|fd*|wd*|sd*|cd*|vnd*|raid*)
	case $i in
	ccd*)	name=ccd;	unit=${i#ccd};	blk=9;	chr=23;;
	cgd*)	name=cgd;	unit=${i#cgd};	blk=26; chr=127;;
	fd*)	name=fd;	unit=${i#fd};	blk=16;	chr=54;;
	wd*)	name=wd;	unit=${i#wd};	blk=12;	chr=26;;
	sd*)	name=sd;	unit=${i#sd};	blk=7;	chr=17;;
	cd*)	name=cd;	unit=${i#cd};	blk=18;	chr=58;;
	raid*)	name=raid;	unit=${i#raid};	blk=25;	chr=121;;
	vnd*)	name=vnd;	unit=${i#vnd};	blk=8;	chr=110;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|\
	17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)
		rm -f ${name}${unit}[a-h] r${name}${unit}[a-h]
		mknod ${name}${unit}c	b $blk $(($unit * 8 + 2))
		mknod ${name}${unit}a	b $blk $(($unit * 8 + 0))
		mknod ${name}${unit}b	b $blk $(($unit * 8 + 1))
		mknod ${name}${unit}d	b $blk $(($unit * 8 + 3))
		mknod ${name}${unit}e	b $blk $(($unit * 8 + 4))
		mknod ${name}${unit}f	b $blk $(($unit * 8 + 5))
		mknod ${name}${unit}g	b $blk $(($unit * 8 + 6))
		mknod ${name}${unit}h	b $blk $(($unit * 8 + 7))
		mknod r${name}${unit}a	c $chr $(($unit * 8 + 0))
		mknod r${name}${unit}b	c $chr $(($unit * 8 + 1))
		mknod r${name}${unit}c	c $chr $(($unit * 8 + 2))
		mknod r${name}${unit}d	c $chr $(($unit * 8 + 3))
		mknod r${name}${unit}e	c $chr $(($unit * 8 + 4))
		mknod r${name}${unit}f	c $chr $(($unit * 8 + 5))
		mknod r${name}${unit}g	c $chr $(($unit * 8 + 6))
		mknod r${name}${unit}h	c $chr $(($unit * 8 + 7))
		chgrp operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		chmod 640 ${name}${unit}[a-h] r${name}${unit}[a-h]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	;;

st*)
	case $i in
	st*) name=st; unit=${i#st}; blk=11; chr=18;;
	esac
	rm -f $name$unit n$name$unit e$name$unit en$name$unit \
		r$name$unit nr$name$unit er$name$unit enr$name$unit
	mknod ${name}${unit}	b $blk $(($unit * 16 + 0))
	mknod n${name}${unit}	b $blk $(($unit * 16 + 1))
	mknod e${name}${unit}	b $blk $(($unit * 16 + 2))
	mknod en${name}${unit}	b $blk $(($unit * 16 + 3))
	mknod r${name}${unit}	c $chr $(($unit * 16 + 0))
	mknod nr${name}${unit}	c $chr $(($unit * 16 + 1))
	mknod er${name}${unit}	c $chr $(($unit * 16 + 2))
	mknod enr${name}${unit}	c $chr $(($unit * 16 + 3))
	chgrp operator ${name}${unit} n${name}${unit} \
		e$name$unit en$name$unit \
		r${name}${unit} nr${name}${unit} \
		er${name}${unit} enr${name}${unit}
	chmod 660 ${name}${unit} n${name}${unit} \
		e$name$unit en$name$unit \
		r${name}${unit} nr${name}${unit} \
		er${name}${unit} enr${name}${unit}
	;;

ss*)
	case $i in
	ss*) name=ss;	unit=${i#ss};	chr=59;;
	esac
	rm -f $name$unit n$name$unit en$name$unit
	mknod $name$unit	c $chr $(($unit * 16 + 0))
	mknod n$name$unit	c $chr $(($unit * 16 + 1))
	mknod en$name$unit	c $chr $(($unit * 16 + 3))
	chgrp operator $name$unit n$name$unit en$name$unit
	chmod 640 $name$unit n$name$unit en$name$unit
	;;

ses*|ch*|uk*)
	case $i in
	ch*) name=ch;  unit=${i#ch}; chr=19;;
	uk*) name=uk;  unit=${i#uk}; chr=60;;
	ses*) name=ses;  unit=${i#ses}; chr=4;;
	esac
	rm -f $name$unit
	mknod ${name}${unit}	c $chr $(($unit + 0))
	chgrp operator ${name}${unit}
	chmod 640 ${name}${unit}
	;;

lkm)
	rm -f lkm
	mknod lkm c 112 0
	chgrp kmem lkm
	chmod 640 lkm
	;;

ipl)
	rm -f ipl ipnat ipstate ipauth
	mknod ipl c 25 0
	mknod ipnat c 25 1
	mknod ipstate c 25 2
	mknod ipauth c 25 3
	chmod 600 ipl ipnat ipstate ipauth
	;;

opty)
	rm -f ttyp[0-9a-f] ptyp[0-9a-f]
	for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f
	do
		case $j in
		[0-9])	jn=$j ;;
		a)	jn=10 ;;
		b)	jn=11 ;;
		c)	jn=12 ;;
		d)	jn=13 ;;
		e)	jn=14 ;;
		f)	jn=15 ;;
		esac
		mknod ttyp$j c 20 $jn
		mknod ptyp$j c 21 $jn
	done
	chmod 666 ttyp[0-9a-f] ptyp[0-9a-f]
	;;

pty*)
	class=${i#pty}
	name=`echo pqrstuvwxyzPQRST | dd bs=1 count=1 skip=$class 2>/dev/null`
	case $name in
	v)	echo "$0: $i: pty unit conflicts with console ttyv0 device."
		continue ;;
	?)	;;
	*)	echo "$0: $i: pty unit must be between 0 and 15"
		continue ;;
	esac
	rm -f tty$name[0-9a-zA-Z] pty$name[0-9a-zA-Z]
	jn=0
	while [ $jn -lt 62 ]
	do
		j=`echo 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ | dd bs=1 count=1 skip=$jn 2>/dev/null`
		skip=0
		if [ $jn -ge 16 ]; then
			skip=$(($class * 30 + 256 - 16))
		fi
		unit=$(($class * 16 + $jn + $skip))
		mknod tty$name$j c 20 $unit
		mknod pty$name$j c 21 $unit
		jn=$(($jn + 1))
	done
	chmod 666 tty$name[0-9a-zA-Z] pty$name[0-9a-zA-Z]
	;;

random)
	rm -f random urandom
	mknod random c 119 0
	mknod urandom c 119 1
	chmod 444 random
	chmod 644 urandom
	;;

magma*)
	unit=${i#magma}
	if [ 0$unit -gt 3 ]
	then
		echo "bad unit for $i: $unit"
		break
	fi

	rm -f tty$unit[0-9a-f] bpp$unit[01]
	for j in 0 1 2 3 4 5 6 7 8 9 a b c d e f
	do
		case $j in
		[0-9])  jn=$j ;;
		a)	jn=10 ;;
		b)	jn=11 ;;
		c)	jn=12 ;;
		d)	jn=13 ;;
		e)	jn=14 ;;
		f)	jn=15 ;;
		esac
		mknod tty$unit$j c 100 $(($unit * 64 + $jn))
	done

	mknod bpp${unit}0 c 101 $(($unit * 64 + 0))
	mknod bpp${unit}1 c 101 $(($unit * 64 + 1))
	;;

bpp*)
	unit=${i#bpp}
	rm -f bpp$unit
	mknod bpp$unit c 107 $(($unit + 0))
	chmod 600 bpp$unit
	;;

lpt*|lpa*)
	case $i in
	lpt*) name=lpt;	unit=${i#lpt};	chr=37;	flags=0;;
	lpa*) name=lpa;	unit=${i#lpa};	chr=37;	flags=128;;
	esac
	rm -f $name$unit
	mknod $name$unit	c $chr $(($unit + $flags))
	;;

scsibus*)
	unit=${i#scsibus}
	rm -f scsibus$unit
	mknod scsibus$unit c 120 $unit
	chmod 644 scsibus$unit
	;;

isdn)
	rm -f isdn
	mknod isdn c 72 0
	chmod 600 isdn
	;;

isdnctl)
	rm -f isdnctl
	mknod isdnctl c 73 0
	chmod 600 isdnctl
	;;

isdnbchan*)
	unit=${i#isdnbchan}
	rm -f isdnbchan$unit
	mknod isdnbchan$unit c 74 $unit
	chmod 600 isdnbchan$unit
	;;

isdntel*)
	unit=${i#isdntel}
	rm -f isdntel$unit
	mknod isdntel$unit c 76 $unit
	chmod 600 isdntel$unit
	;;

isdntrc*)
	unit=${i#isdntrc}
	rm -f isdntrc$unit
	mknod isdntrc$unit c 75 $unit
	chmod 600 isdntrc$unit
	;;

usbs)
	makedev usb usb0 usb1 usb2 usb3 usb4 usb5 usb6 usb7
	makedev uhid0 uhid1 uhid2 uhid3
	makedev ulpt0 ulpt1
	makedev ttyU0 ttyU1
	makedev urio0
	makedev uscanner0 uscanner1
	;;

usb*)
	unit=${i#usb}
	if [ "$unit" = "" ]; then
	    unit=255
	    usb=usb
	else
	    usb=usb$unit
	fi
	major=78
	rm -f $usb
	mknod $usb c $major $unit
	chmod 600 $usb
	;;

uhid*)
	unit=${i#uhid}
	uhid=uhid$unit
	major=79
	rm -f $uhid
	mknod $uhid c $major $unit
	chmod 666 $uhid
	;;

ulpt*)
	unit=${i#ulpt}
	ulpt=ulpt$unit
	ulpn=ulpn$unit
	major=80
	rm -f $ulpt $ulpn
	mknod $ulpt c $major $unit
	mknod $ulpn c $major $(($unit + 64))
	chmod 600 $ulpt $ulpn
	;;

ugen*)
	unit=${i#ugen}
	ugen=ugen$unit
	major=81
	for j in 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15
	do
		ugenj=$ugen.$j
		rm -f $ugenj
		mknod $ugenj c $major $(($unit * 16 + $j))
		chmod 600 $ugenj
	done
	;;

ttyU*)
	unit=${i#ttyU}
	ttyU=ttyU$unit
	dtyU=dtyU$unit
	ctyU=ctyU$unit
	major=82
	rm -f $ttyU $dtyU $ctyU
	mknod $ttyU c $major $(($unit + $dialin  ))
	mknod $dtyU c $major $(($unit + $dialout ))
	mknod $ctyU c $major $(($unit + $callunit))
	chown uucp $ttyU $dtyU $ctyU
	chmod 600 $ttyU $dtyU $ctyU
	;;

urio*)
	unit=${i#urio}
	urio=urio$unit
	major=83
	rm -f $urio
	mknod $urio c $major $unit
	chmod 600 $urio
	;;

uscanner*)
	unit=${i#uscanner}
	uscanner=uscanner$unit
	major=84
	rm -f $uscanner
	mknod $uscanner c $major $unit
	chmod 600 $uscanner
	;;

pci*)
	unit=${i#pci}
	rm -f pci$unit
	mknod pci$unit c 123 $unit
	chmod 644 pci$unit
	;;

clockctl)
	rm -f clockctl
	mknod clockctl c 125 0
	chgrp ntpd clockctl
	chmod 660 clockctl
	;;

systrace)
	rm -f systrace
	mknod systrace c 126 0
	chmod 644 systrace
	;;


dpt*)
	unit=${i#dpt}
	rm -f dpt$unit
	mknod dpt$unit c 132 $unit
	chmod 600 dpt$unit
	;;

nsmb)
	makedev nsmb0 nsmb1 nsmb2 nsmb3
	;;

nsmb*)
	unit=${i#nsmb}
	nsmb=nsmb$unit
	major=134
	rm -f $nsmb
	mknod $nsmb c $major $unit
	chmod 644 $nsmb
	;;


kttcp)
	rm -f kttcp
	mknod kttcp c 128 0
	chmod 600 kttcp
	;;

dmoverio)
	rm -f dmoverio
	mknod dmoverio c 129 0
	chmod 644 dmoverio
	;;

veriexec)
	rm -f veriexec
	mknod veriexec c 130 0
	chmod 644 veriexec
	;;

twe*)
	unit=${i#twe}
	rm -f twe$unit
	mknod twe$unit c 133 $unit
	chmod 600 twe$unit
	;;

local)
	if [ -f "$0.local" ]; then
		umask 0
		sh $0.local all
		umask 77
	fi
	;;

*)
	echo $i: unknown device
	;;
esac
done

}

makedev $*
