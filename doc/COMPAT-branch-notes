DONE
----
1. Removed linking of the kernel compat object library into all kernels;
   using the .o library caused some build breakage, and resulted in the
   bulk of the compat code being included in every kernel, but without
   any module linkage.  In turn, this caused failure when loading some
   modules due to symbols already being defined in the kernel.

2. Reverted some intentional breakage for loading the sysv_ipc module;
   the breakage was introduced as the fix for the above-mentioned build
   breakage.  

3. Split the sysv_ipc compat routines into their own compat_sysv module.

4. Resolved some inter-module dependencies.

5. Extracted some net/if.c compat routines into the compat module, and
   replaced the originals with indirect (vectored) function calls.

6. Implemented a mechanism for modules to include "aliases", allowing
   a single module file to declare multiple names.  For example, a
   single "compat" module could declare compat_80, compat_70, etc, and
   other modules could depend on specific compat levels rather than on
   the entirety of compat.

7. Reconfirmed all compat-module dependencies, and update the files *
   def lines as needed, to insure that built-in dependencies get
   resolved.


TODO
----
1. Audit the entire code base for any remaining embedded #ifdef's for
   COMPAT_xx.  When found, move the actual compat code into the compat
   hierarchy and replace originals with indirect (vectored) calls.

   (There are several instances of this in the net routing table code.)

2. Using the alias mechanism, split compat (and perhaps compat_sysv)
   into multiple version-specific modules.  Note that in addition to
   updating the module code, this would also require changes to
   syscalls.master files to change the names of the modules associated
   with module-provided syscalls.

