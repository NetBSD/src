# $NetBSD: tzdata2netbsd,v 1.2 2014/05/18 16:53:56 apb Exp $
#
# For use by NetBSD developers when updating to new versions of tzdata.
#

OLDVER=2013i
NEWVER=2014c

# Uppercase variants of OLDVER and NEWVER
OLDVER_UC="$( echo "${OLDVER}" | tr '[a-z]' '[A-Z]' )"
NEWVER_UC="$( echo "${NEWVER}" | tr '[a-z]' '[A-Z]' )"

# Tags for use with version control systems
CVSOLDTAG="TZDATA${OLDVER_UC}"
CVSNEWTAG="TZDATA${NEWVER_UC}"
CVSBRANCHTAG="TZDATA"
GITHUBTAG="${NEWVER}"

# URLs for fetching distribution files, etc.
DISTURL="ftp://ftp.iana.org/tz/releases/tzdata${NEWVER}.tar.gz"
SIGURL="${DISTURL}.asc"
NEWSURL="https://github.com/eggert/tz/raw/${GITHUBTAG}/NEWS"

# Directories
REPODIR="src/share/zoneinfo"	# relative to the NetSBD CVS repository
WORKDIR="$(pwd)/update-work"
EXTRACTDIR="${WORKDIR}/extract/${NEWVER}"

# Files in the work directory
DISTFILE="${WORKDIR}/${DISTURL##*/}"
SIGFILE="${DISTFILE}.sig"
NEWSFILE="${WORKDIR}/NEWS"
NEWSTRIMFILE="${WORKDIR}/NEWS.trimmed"
IMPORTMSGFILE="${WORKDIR}/import.msg"
MERGSMSGFILE="${WORKDIR}/merge.msg"
PGPVERIFYLOG="${WORKDIR}/pgpverify.log"

DOIT()
{
	local really_do_it=false
	local reply

	echo "ABOUT TO DO:" "$(shell_quote "$@")"
	read -p "Really do it? [yes/no/quit] " reply
	case "${reply}" in
	[yY]*)	really_do_it=true ;;
	[nN]*)	really_do_it=false ;;
	[qQ]*)
		echo "Aborting"
		return 1
		;;
	esac
	if $really_do_it; then
		echo "REALLY DOING IT NOW..."
		"$@"
	else
		echo "NOT REALLY DOING:" "$@"
	fi
}

# Quote args to make them safe in the shell.
# Usage: quotedlist="$(shell_quote args...)"
#
# After building up a quoted list, use it by evaling it inside
# double quotes, like this:
#    eval "set -- $quotedlist"
# or like this:
#    eval "\$command $quotedlist \$filename"
shell_quote()
{
	local result=''
	local arg qarg
	for arg in "$@" ; do
		case "${arg}" in
		''|*[!-./a-zA-Z0-9]*)
			# Convert each embedded ' to '\'',
			# then insert ' at the beginning of the first line,
			# and append ' at the end of the last line.
			qarg="$(printf "%s\n" "$arg" | \
			    sed -e "s/'/'\\\\''/g" -e "1s/^/'/" -e "\$s/\$/'/")"
			;;
		*)
			# Arg is not the empty string, and does not contain
			# any unsafe characters.
			qarg="${arg}"
			;;
		esac
		result="${result}${result:+ }${qarg}"
	done
	printf "%s\n" "$result"
}

findcvsroot()
{
	[ -n "${CVSROOT}" ] && return 0
	CVSROOT="$( cat ./CVS/Root )"
	[ -n "${CVSROOT}" ] && return 0
	echo >&2 "Failed to set CVSROOT value"
	return 1
}

mkworkdir()
{
	mkdir -p "${WORKDIR}"
}

fetch()
{
	[ -f "${DISTFILE}" ] || ftp -o "${DISTFILE}" "${DISTURL}"
	[ -f "${SIGFILE}" ] || ftp -o "${SIGFILE}" "${SIGURL}"
	[ -f "${NEWSFILE}" ] || ftp -o "${NEWSFILE}" "${NEWSURL}"
}

checksig()
{
	{ gpg --verify "${SIGFILE}" "${DISTFILE}"
	  echo gpg exit status $?
	} 2>&1 | tee "${PGPVERIFYLOG}"

	# The output should contain lines that match all the following regexps
	#
	while read line; do
		if ! grep -q -e "^${line}\$" "${PGPVERIFYLOG}"; then
			echo >&2 "Failed to verify signature: ${line}"
			return 1
		fi
	done <<'EOF'
gpg: Signature made .* using RSA key ID 62AA7E34
gpg: Good signature from "Paul Eggert <eggert@cs.ucla.edu>"
Primary key fingerprint: 7E37 92A9 D8AC F7D6 33BC  1588 ED97 E90E 62AA 7E34
gpg exit status 0
EOF
}

extract()
{
	mkdir -p "${EXTRACTDIR}"
	tar -z -xf "${DISTFILE}" -C "${EXTRACTDIR}"
}

# Find the relevant part of the NEWS file for all releases between
# OLDVER and NEWVER, and save them to NEWSTRIMFILE.
#
trimnews()
{
	awk -v oldver="${OLDVER}" -v newver="${NEWVER}" \
	    '
		BEGIN {inrange = 0}
		/^Release [0-9]+[a-z]+ - .*/ {
			# "Release <version> - <date>"
			inrange = ($2 > oldver && $2 <= newver)
		}
		// { if (inrange) print; }
		' \
		<"${NEWSFILE}" >"${NEWSTRIMFILE}"
}

# Create IMPORTMSGFILE from NEWSTRIMFILE, by ignoring some sections,
# keeping only the first sentence from paragraphs in other sections,
# and changing the format.
#
# The result should be edited by hand before performing a cvs commit.
# A message to that effect is inserted at the beginning of the file.
#
mkimportmsg()
{
	[ -s "${IMPORTMSGFILE}" ] && return
	{ cat <<EOF
EDIT ME: Edit this file and then delete the lines marked "EDIT ME".
EDIT ME: This file will be used as a log message for the "cvs commit" that
EDIT ME: imports tzdata${NEWVER}.  The initial contents of this file were
EDIT ME: generated from ${NEWSFILE}.
EDIT ME: 
EOF
	awk -v oldver="${OLDVER}" -v newver="${NEWVER}" \
	    -v disturl="${DISTURL}" \
	    '
		BEGIN {
			bullet = "  * ";
			indent = "    ";
			blankline = 0;
			goodsection = 0;
			havesentence = 0;
			print "Import tzdata"newver" from "disturl;
		}
		/^Release/ {
			# "Release <version> - <date>"
			ver = $2;
			date = gensub(".* - ", "", 1, $0);
			print "";
			print "Summary of changes in tzdata"ver \
				" ("date"):";
		}
		/^$/ { blankline = 1; havesentence = 0; }
		/^  Changes affecting/ { goodsection = 0; }
		/^  Changes affecting.*time/ { goodsection = 1; }
		/^  Changes affecting.*documentation/ || \
		/^  Changes affecting.*commentary/ {
			t = gensub("^ *", "", 1, $0);
			t = gensub("\\.*$", ".", 1, t);
			print bullet t;
			goodsection = 0;
		}
		/^    .*/ && goodsection {
			# In a paragraph in a "good" section.
			# Ignore leading spaces, and ignore anything
			# after the first sentence.
			# First line of paragraph gets a bullet.
			t = gensub("^ *", "", 1, $0);
			t = gensub("\\. .*", ".", 1, t);
			if (blankline) print bullet t;
			else if (! havesentence) print indent t;
			havesentence = (havesentence || (t ~ "\\.$"));
		}
		/./ { blankline = 0; }
		' \
		<"${NEWSTRIMFILE}"
	} >"${IMPORTMSGFILE}"
}

editimportmsg()
{
	if [ -s "${IMPORTMSGFILE}" ] \
	&& ! grep -q '^EDIT' "${IMPORTMSGFILE}"
	then
		return 0 # file has already been edited
	fi
	# Pass both IMPORTMSGFILE and NEWSFILE to the editor, so that the
	# user can easily consult NEWSFILE while editing IMPORTMSGFILE.
	vi "${IMPORTMSGFILE}" "${NEWSFILE}"
}

cvsimport()
{
	if ! [ -s "${IMPORTMSGFILE}" ] \
	|| grep -q '^EDIT' "${IMPORTMSGFILE}"
	then
		cat >&2 <<EOF
The message file ${IMPORTMSGFILE}
has not been properly edited.
Not performing cvs import.
EOF
		return 1
	fi
	( cd "${EXTRACTDIR}" &&
	  DOIT cvs -d "${CVSROOT}" import -m "$(cat "${IMPORTMSGFILE}")" \
		"${REPODIR}" "${CVSBRANCHTAG}" "${CVSNEWTAG}"
	)
}

cvsmerge()
{
	DOIT cvs -d "${CVSROOT}" update -j"${CVSOLDTAG}" -j"${CVSNEWTAG}"
}

resolveconflicts()
{
	cat <<EOF
Resolve conflicts resulting from the cvs merge.
exit 0 when done.  exit 1 to abort.
EOF
	nl='
'
	PS1="[inside ${0##*/}]${nl}${PS1}" sh -i
}

cvscommitmerge()
{
	if grep -l '^[<=>][<=>][<=>]' *
	then
		cat >&2 <<EOF
There still appear to be conflicts in the files listed above.
Not performing cvs commit.
EOF
		return 1
	fi
	DOIT cvs -d "${CVSROOT}" commit -m "Merge tzdata${NEWVER}"
}

extra()
{
	cat <<EOF
Also do the following:
 * Edit src/doc/3RDPARTY
 * Edit src/doc/CHANGES
 * Edit src/distrib/sets/base/mi if the set of installed files has changed.
 * Submit pullup requests for all active release branches.
 * rm -rf ${WORKDIR}
EOF
}

main()
{
	set -e
	findcvsroot
	mkworkdir
	fetch
	checksig
	extract
	trimnews
	mkimportmsg
	editimportmsg
	cvsimport
	cvsmerge
	resolveconflicts
	cvscommitmerge
	extra
}

main "$@"
