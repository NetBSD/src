#! /bin/sh

# $NetBSD: mkoptions.sh,v 1.1 2017/05/28 00:38:01 kre Exp $

#
# It would be more sensible to generate 2 .h files, one which
# is for everyone to use, defines the "variables" and (perhaps) generates
# the externs (though they could just be explicit in options.h)
# and one just for options.c which generates the initialisation.
#
# But then I'd have to deal with making the Makefile handle that properly...
# (this is simpler there, and it just means a bit more sh compile time.)

set -f
IFS=' 	'	# blank, tab (no newline)

IF="$1"
OF="${3+$3/}$2"

{
	printf '/*\n * File automatically generated by %s.\n' "$0"
	printf ' * Do not edit, do not add to cvs.\n'
	printf ' */\n\n'

	printf '#ifdef DEFINE_OPTIONS\n'
	printf '#define DEF_OPT(a,b,c,d,e) { a, b, c, d, e },\n'
	printf 'struct optent optlist[] = {\n'
	printf '#else\n'
	printf '#define DEF_OPT(a,b,c,d,e)\n'
	printf '#endif\n\n'
} >"${OF}"

FIRST=true
I=0

while read line
do
	# Look for comments in various styles, and ignore them
	# preprocessor statements are simply output verbatim
	# but use them only first or last. one #ifdef/#endif at end is OK

	case "${line}" in
	'')	continue;;
	/*)	continue;;
	\**)	continue;;
	\;*)	continue;;
	\#*)	printf '%s\n\n' "${line}" >&4; continue;;
	esac

	set -- ${line%%[ 	]#*}

	var="$1" name="$2"

	case "${var}" in
	('' | [!A-Za-z_]* | *[!A-Za-z0-9_]*)
		printf >&2 "Bad var name: '%s'\\n" "${var}"
		# exit 1
		continue	# just ignore it for now
	esac

	case "${name}" in
#	=)	name=${var};;		# probably not a good idea
	?) 	set -- ${var} '' $name $3 $4; name= ;;
	esac

	chr="$3" set="$4" dflt="$5"

	case "${chr}" in
	-)	chr= set= dflt="$4";;
	''|?)	;;
	*)	printf >&2 'flag "%s": Not a character\n' "${chr}"; continue;;
	esac

	# options must have some kind of name, or they are useless...
	test -z "${name}${chr}" && continue

	case "${set}" in
	-)	set= ;;
	[01])	dflt="${set}"; set= ;;
	''|?)	;;
	*)	printf >&2 'set "%s": Not a character\n' "${set}"; continue;;
	esac


	if [ -n "${name}" ]
	then
		printf '    DEF_OPT("%s", ' "${name}" >&4
	else
		printf '    DEF_OPT(0, ' >&4
	fi

	if [ -n "${chr}" ]
	then
		printf "'%s', " "${chr}" >&4
	else
		printf '0, ' >&4
	fi

	if [ -n "${set}" ]
	then
		printf "'%s', 0, " "${set}" >&4
	else
		printf '0, 0, ' >&4
	fi

	if [ -n "${dflt}" ]
	then
		printf '%s )\n' "${dflt}" >&4
	else
		printf '0 )\n' >&4
	fi

	printf '#define	%s	optlist[%d].val\n\n' "${var}" "${I}" >&4
	I=$((I + 1))

	test -z "${chr}" && continue

	printf '%s %d\n' "${chr}" $((I - 1))

done < "$IF" 4>>"${OF}" | sort -t' ' -k1,1f -k1,1r | while read chr index
do
	if $FIRST
	then
		printf '#ifdef DEFINE_OPTIONS\n'
		printf '    { 0, 0, 0, 0, 0 }\n};\n\n'
		printf 'const unsigned char optorder[] = {\n'
		FIRST=false
	fi
	printf '\t%s,\n' "${index}"

done >>"${OF}"

{
	printf '};\n\n'
	printf '#define NOPTS (sizeof optlist / sizeof optlist[0] - 1)\n'
	printf 'int sizeof_optlist = sizeof optlist;\n\n'
	printf	\
	   'const int option_flags = (sizeof optorder / sizeof optorder[0]);\n'
	printf '\n#else\n\n'
	printf 'extern struct optent optlist[];\n'
	printf 'extern int sizeof_optlist;\n'
	printf 'extern const unsigned char optorder[];\n'
	printf 'extern const int option_flags;\n'
	printf '\n#endif\n'
} >> "${OF}"

exit 0
